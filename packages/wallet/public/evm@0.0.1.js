(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.evm = factory());
})(this, (function () { 'use strict';

  var global$c = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  var lookup$2 = [];
  var revLookup$1 = [];
  var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init$1 () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup$2[i] = code[i];
      revLookup$1[code.charCodeAt(i)] = i;
    }

    revLookup$1['-'.charCodeAt(0)] = 62;
    revLookup$1['_'.charCodeAt(0)] = 63;
  }

  function toByteArray$1 (b64) {
    if (!inited) {
      init$1();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr$1(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64$1 (num) {
    return lookup$2[num >> 18 & 0x3F] + lookup$2[num >> 12 & 0x3F] + lookup$2[num >> 6 & 0x3F] + lookup$2[num & 0x3F]
  }

  function encodeChunk$1 (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64$1(tmp));
    }
    return output.join('')
  }

  function fromByteArray$1 (uint8) {
    if (!inited) {
      init$1();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup$2[tmp >> 2];
      output += lookup$2[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup$2[tmp >> 10];
      output += lookup$2[(tmp >> 4) & 0x3F];
      output += lookup$2[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read$1 (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$6 = {}.toString;

  var isArray$4 = Array.isArray || function (arr) {
    return toString$6.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer$8.TYPED_ARRAY_SUPPORT = global$c.TYPED_ARRAY_SUPPORT !== undefined
    ? global$c.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer$8.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer$8.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer$8(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer$8 (arg, encodingOrOffset, length) {
    if (!Buffer$8.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$8)) {
      return new Buffer$8(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from$3(this, arg, encodingOrOffset, length)
  }

  Buffer$8.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer$8._augment = function (arr) {
    arr.__proto__ = Buffer$8.prototype;
    return arr
  };

  function from$3 (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer$8.from = function (value, encodingOrOffset, length) {
    return from$3(null, value, encodingOrOffset, length)
  };

  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
    Buffer$8.prototype.__proto__ = Uint8Array.prototype;
    Buffer$8.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer$8.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer$8.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer$8.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer$8.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer$8.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength$1(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer$8.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$4(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer$8.isBuffer = isBuffer$3;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer$8.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer$8.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer$8.concat = function concat (list, length) {
    if (!isArray$4(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer$8.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer$8.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength$1 (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes$1(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes$1(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$8.byteLength = byteLength$1;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer$8.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer$8.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer$8.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer$8.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer$8.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer$8.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer$8.compare(this, b) === 0
  };

  Buffer$8.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer$8.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer$8.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer$8.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer$8.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer$8.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer$8.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer$8.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer$8.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray$1(buf)
    } else {
      return fromByteArray$1(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer$8.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$8.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$8(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer$8.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer$8.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer$8.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer$8.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer$8.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer$8.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer$8.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer$8.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$8.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$8.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer$8.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$8.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$8.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer$8.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer$8.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read$1(this, offset, true, 23, 4)
  };

  Buffer$8.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read$1(this, offset, false, 23, 4)
  };

  Buffer$8.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read$1(this, offset, true, 52, 8)
  };

  Buffer$8.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read$1(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer$8.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$8.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$8.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer$8.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer$8.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$8.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer$8.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$8.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer$8.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$8.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$8.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer$8.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer$8.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$8.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer$8.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$8.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer$8.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer$8.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer$8.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer$8.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer$8.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer$8.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer$8.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer$8.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes$1(new Buffer$8(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes$1 (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray$1(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer$3(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function commonjsRequire (path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$c.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$c.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick$3(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser$1 = true;
  var env = {};
  var argv = [];
  var version$1 = ''; // empty string to avoid regexp issues
  var versions$1 = {};
  var release = {};
  var config = {};

  function noop$6() {}

  var on = noop$6;
  var addListener = noop$6;
  var once$4 = noop$6;
  var off = noop$6;
  var removeListener = noop$6;
  var removeAllListeners = noop$6;
  var emit = noop$6;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance$1 = global$c.performance || {};
  var performanceNow =
    performance$1.now        ||
    performance$1.mozNow     ||
    performance$1.msNow      ||
    performance$1.oNow       ||
    performance$1.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance$1)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var browser$1$1 = {
    nextTick: nextTick$3,
    title: title,
    browser: browser$1,
    env: env,
    argv: argv,
    version: version$1,
    versions: versions$1,
    on: on,
    addListener: addListener,
    once: once$4,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var inherits$1 = {exports: {}};

  var inherits_browser$1 = {exports: {}};

  if (false) {
    // implementation from standard node.js 'util' module
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    inherits_browser$1.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }

  try {
    var util$7 = require('util');
    /* istanbul ignore next */
    if (typeof util$7.inherits !== 'function') throw '';
    inherits$1.exports = util$7.inherits;
  } catch (e) {
    /* istanbul ignore next */
    inherits$1.exports = inherits_browser$1.exports;
  }

  var dist$b = {};

  var bloom = {};

  var dist$a = {};

  var constants$1 = {};

  var buffer = {};

  var base64Js = {};

  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;

  var lookup$1 = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
    lookup$1[i$1] = code[i$1];
    revLookup[code.charCodeAt(i$1)] = i$1;
  }

  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens (b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;

    var placeHoldersLen = validLen === len
      ? 0
      : 4 - (validLen % 4);

    return [validLen, placeHoldersLen]
  }

  // base64 is 4/3 + up to two characters of the original data
  function byteLength (b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function _byteLength (b64, validLen, placeHoldersLen) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function toByteArray (b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];

    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

    var curByte = 0;

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
      ? validLen - 4
      : validLen;

    var i;
    for (i = 0; i < len; i += 4) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 18) |
        (revLookup[b64.charCodeAt(i + 1)] << 12) |
        (revLookup[b64.charCodeAt(i + 2)] << 6) |
        revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = (tmp >> 16) & 0xFF;
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 2) |
        (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 10) |
        (revLookup[b64.charCodeAt(i + 1)] << 4) |
        (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup$1[num >> 18 & 0x3F] +
      lookup$1[num >> 12 & 0x3F] +
      lookup$1[num >> 6 & 0x3F] +
      lookup$1[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp =
        ((uint8[i] << 16) & 0xFF0000) +
        ((uint8[i + 1] << 8) & 0xFF00) +
        (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(
        lookup$1[tmp >> 2] +
        lookup$1[(tmp << 4) & 0x3F] +
        '=='
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup$1[tmp >> 10] +
        lookup$1[(tmp >> 4) & 0x3F] +
        lookup$1[(tmp << 2) & 0x3F] +
        '='
      );
    }

    return parts.join('')
  }

  var ieee754 = {};

  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

  ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  };

  ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = ((value * c) - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  (function (exports) {

  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol =
    (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
      ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
      : null;

  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;

  const K_MAX_LENGTH = 0x7fffffff;
  exports.kMaxLength = K_MAX_LENGTH;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
      typeof console.error === 'function') {
    console.error(
      'This browser lacks typed array (Uint8Array) support which is required by ' +
      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    );
  }

  function typedArraySupport () {
    // Can typed array instances can be augmented?
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function () { return 42 } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42
    } catch (e) {
      return false
    }
  }

  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined
      return this.buffer
    }
  });

  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined
      return this.byteOffset
    }
  });

  function createBuffer (length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"')
    }
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  function from (value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset)
    }

    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value)
    }

    if (value == null) {
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }

    if (isInstance(value, ArrayBuffer) ||
        (value && isInstance(value.buffer, ArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }

    if (typeof SharedArrayBuffer !== 'undefined' &&
        (isInstance(value, SharedArrayBuffer) ||
        (value && isInstance(value.buffer, SharedArrayBuffer)))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }

    if (typeof value === 'number') {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      )
    }

    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length)
    }

    const b = fromObject(value);
    if (b) return b

    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
        typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
    }

    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length)
  };

  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
  }

  function alloc (size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpreted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(size).fill(fill, encoding)
        : createBuffer(size).fill(fill)
    }
    return createBuffer(size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding)
  };

  function allocUnsafe (size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size)
  };

  function fromString (string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }

    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);

    const actual = buf.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual);
    }

    return buf
  }

  function fromArrayLike (array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf
  }

  function fromArrayView (arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
    }
    return fromArrayLike(arrayView)
  }

  function fromArrayBuffer (array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds')
    }

    let buf;
    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }

    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);

    return buf
  }

  function fromObject (obj) {
    if (Buffer.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);

      if (buf.length === 0) {
        return buf
      }

      obj.copy(buf, 0, 0, len);
      return buf
    }

    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  function checked (length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    }
    return length | 0
  }

  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer.alloc(+length)
  }

  Buffer.isBuffer = function isBuffer (b) {
    return b != null && b._isBuffer === true &&
      b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
  };

  Buffer.compare = function compare (a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      )
    }

    if (a === b) return 0

    let x = a.length;
    let y = b.length;

    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    let i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
          buf.copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer,
            buf,
            pos
          );
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
        'Received type ' + typeof string
      )
    }

    const len = string.length;
    const mustMatch = (arguments.length > 2 && arguments[2] === true);
    if (!mustMatch && len === 0) return 0

    // Use a for loop to avoid recursion
    let loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
          }
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    let loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    const length = this.length;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.toLocaleString = Buffer.prototype.toString;

  Buffer.prototype.equals = function equals (b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>'
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. ' +
        'Received type ' + (typeof target)
      )
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);

    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);

    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    const strLen = string.length;

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    let loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
        case 'latin1':
        case 'binary':
          return asciiWrite(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf)
    } else {
      return base64.fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];

    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = (firstByte > 0xEF)
        ? 4
        : (firstByte > 0xDF)
            ? 3
            : (firstByte > 0xBF)
                ? 2
                : 1;

      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  const MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);

    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);

    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    const len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    let out = '';
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUintLE =
  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUintBE =
  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    let val = this[offset + --byteLength];
    let mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUint8 =
  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUint16LE =
  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUint16BE =
  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUint32LE =
  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUint32BE =
  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    const lo = first +
      this[++offset] * 2 ** 8 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 24;

    const hi = this[++offset] +
      this[++offset] * 2 ** 8 +
      this[++offset] * 2 ** 16 +
      last * 2 ** 24;

    return BigInt(lo) + (BigInt(hi) << BigInt(32))
  });

  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    const hi = first * 2 ** 24 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      this[++offset];

    const lo = this[++offset] * 2 ** 24 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      last;

    return (BigInt(hi) << BigInt(32)) + BigInt(lo)
  });

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    const val = this[offset + 4] +
      this[offset + 5] * 2 ** 8 +
      this[offset + 6] * 2 ** 16 +
      (last << 24); // Overflow

    return (BigInt(val) << BigInt(32)) +
      BigInt(first +
      this[++offset] * 2 ** 8 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 24)
  });

  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }

    const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      this[++offset];

    return (BigInt(val) << BigInt(32)) +
      BigInt(this[++offset] * 2 ** 24 +
      this[++offset] * 2 ** 16 +
      this[++offset] * 2 ** 8 +
      last)
  });

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUintLE =
  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUintBE =
  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUint8 =
  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeUint16LE =
  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    return offset + 2
  };

  Buffer.prototype.writeUint16BE =
  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
    return offset + 2
  };

  Buffer.prototype.writeUint32LE =
  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
    return offset + 4
  };

  Buffer.prototype.writeUint32BE =
  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
    return offset + 4
  };

  function wrtBigUInt64LE (buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);

    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset
  }

  function wrtBigUInt64BE (buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);

    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8
  }

  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  });

  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  });

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, (8 * byteLength) - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, (8 * byteLength) - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
    return offset + 4
  };

  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  });

  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  });

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    const len = end - start;

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if ((encoding === 'utf8' && code < 128) ||
            encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } else if (typeof val === 'boolean') {
      val = Number(val);
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    let i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer.isBuffer(val)
        ? val
        : Buffer.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val +
          '" is invalid for argument "value"')
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // CUSTOM ERRORS
  // =============

  // Simplified versions from Node, changed for Buffer-only usage
  const errors = {};
  function E (sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor () {
        super();

        Object.defineProperty(this, 'message', {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });

        // Add the error code to the name to include it in the stack trace.
        this.name = `${this.name} [${sym}]`;
        // Access the stack to generate the error message including the error code
        // from the name.
        this.stack; // eslint-disable-line no-unused-expressions
        // Reset the name to the actual name.
        delete this.name;
      }

      get code () {
        return sym
      }

      set code (value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }

      toString () {
        return `${this.name} [${sym}]: ${this.message}`
      }
    };
  }

  E('ERR_BUFFER_OUT_OF_BOUNDS',
    function (name) {
      if (name) {
        return `${name} is outside of buffer bounds`
      }

      return 'Attempt to access memory outside buffer bounds'
    }, RangeError);
  E('ERR_INVALID_ARG_TYPE',
    function (name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`
    }, TypeError);
  E('ERR_OUT_OF_RANGE',
    function (str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += 'n';
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg
    }, RangeError);

  function addNumericalSeparator (val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`
  }

  // CHECK FUNCTIONS
  // ===============

  function checkBounds (buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
      boundsError(offset, buf.length - (byteLength + 1));
    }
  }

  function checkIntBI (value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
      const n = typeof min === 'bigint' ? 'n' : '';
      let range;
      if (byteLength > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                  `${(byteLength + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE('value', range, value)
    }
    checkBounds(buf, offset, byteLength);
  }

  function validateNumber (value, name) {
    if (typeof value !== 'number') {
      throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
    }
  }

  function boundsError (value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
    }

    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
    }

    throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                      `>= ${type ? 1 : 0} and <= ${length}`,
                                      value)
  }

  // HELPER FUNCTIONS
  // ================

  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];

    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }

  function base64ToBytes (str) {
    return base64.toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166
  function isInstance (obj, type) {
    return obj instanceof type ||
      (obj != null && obj.constructor != null && obj.constructor.name != null &&
        obj.constructor.name === type.name)
  }
  function numberIsNaN (obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
  }

  // Create lookup table for `toString('hex')`
  // See: https://github.com/feross/buffer/issues/219
  const hexSliceLookupTable = (function () {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table
  })();

  // Return not function with Error if BigInt not supported
  function defineBigIntMethod (fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
  }

  function BufferBigIntNotDefined () {
    throw new Error('BigInt not supported')
  }
  }(buffer));

  var secp256k1 = {};

  var hmac = {};

  var _assert = {};

  Object.defineProperty(_assert, "__esModule", { value: true });
  _assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
  function number$h(n) {
      if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
  }
  _assert.number = number$h;
  function bool(b) {
      if (typeof b !== 'boolean')
          throw new Error(`Expected boolean, not ${b}`);
  }
  _assert.bool = bool;
  function bytes$1(b, ...lengths) {
      if (!(b instanceof Uint8Array))
          throw new TypeError('Expected Uint8Array');
      if (lengths.length > 0 && !lengths.includes(b.length))
          throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  _assert.bytes = bytes$1;
  function hash(hash) {
      if (typeof hash !== 'function' || typeof hash.create !== 'function')
          throw new Error('Hash should be wrapped by utils.wrapConstructor');
      number$h(hash.outputLen);
      number$h(hash.blockLen);
  }
  _assert.hash = hash;
  function exists(instance, checkFinished = true) {
      if (instance.destroyed)
          throw new Error('Hash instance has been destroyed');
      if (checkFinished && instance.finished)
          throw new Error('Hash#digest() has already been called');
  }
  _assert.exists = exists;
  function output(out, instance) {
      bytes$1(out);
      const min = instance.outputLen;
      if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
  }
  _assert.output = output;
  const assert = {
      number: number$h,
      bool,
      bytes: bytes$1,
      hash,
      exists,
      output,
  };
  _assert.default = assert;

  var utils$1 = {};

  var crypto$2 = {};

  var _polyfillNode_crypto = {};

  var _polyfillNode_crypto$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _polyfillNode_crypto
  });

  var require$$2$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_crypto$1);

  Object.defineProperty(crypto$2, "__esModule", { value: true });
  crypto$2.crypto = void 0;
  const nodeCrypto = require$$2$2;
  crypto$2.crypto = {
      node: nodeCrypto,
      web: undefined,
  };

  (function (exports) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
  // The import here is via the package name. This is to ensure
  // that exports mapping/resolution does fall into place.
  const crypto_1 = crypto$2;
  // Cast array to different type
  const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u32;
  // Cast array to view
  const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView;
  // The rotate right (circular right shift) operation for uint32
  const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
  exports.rotr = rotr;
  exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
  // There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
  // So, just to be sure not to corrupt anything.
  if (!exports.isLE)
      throw new Error('Non little-endian hardware is not supported');
  const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
  /**
   * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
   */
  function bytesToHex(uint8a) {
      // pre-caching improves the speed 6x
      if (!(uint8a instanceof Uint8Array))
          throw new Error('Uint8Array expected');
      let hex = '';
      for (let i = 0; i < uint8a.length; i++) {
          hex += hexes[uint8a[i]];
      }
      return hex;
  }
  exports.bytesToHex = bytesToHex;
  /**
   * @example hexToBytes('deadbeef')
   */
  function hexToBytes(hex) {
      if (typeof hex !== 'string') {
          throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
      }
      if (hex.length % 2)
          throw new Error('hexToBytes: received invalid unpadded hex');
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
              throw new Error('Invalid byte sequence');
          array[i] = byte;
      }
      return array;
  }
  exports.hexToBytes = hexToBytes;
  // There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
  // which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
  const nextTick = async () => { };
  exports.nextTick = nextTick;
  // Returns control to thread each 'tick' ms to avoid blocking
  async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
          cb(i);
          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
              continue;
          await (0, exports.nextTick)();
          ts += diff;
      }
  }
  exports.asyncLoop = asyncLoop;
  function utf8ToBytes(str) {
      if (typeof str !== 'string') {
          throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
  }
  exports.utf8ToBytes = utf8ToBytes;
  function toBytes(data) {
      if (typeof data === 'string')
          data = utf8ToBytes(data);
      if (!(data instanceof Uint8Array))
          throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
  }
  exports.toBytes = toBytes;
  /**
   * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
   * @example concatBytes(buf1, buf2)
   */
  function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
          throw new Error('Uint8Array list expected');
      if (arrays.length === 1)
          return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
      }
      return result;
  }
  exports.concatBytes = concatBytes;
  // For runtime check if class implements interface
  class Hash {
      // Safe version that clones internal state
      clone() {
          return this._cloneInto();
      }
  }
  exports.Hash = Hash;
  // Check if object doens't have custom constructor (like Uint8Array/Array)
  const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
  function checkOpts(defaults, opts) {
      if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
          throw new TypeError('Options should be object or undefined');
      const merged = Object.assign(defaults, opts);
      return merged;
  }
  exports.checkOpts = checkOpts;
  function wrapConstructor(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
  }
  exports.wrapConstructor = wrapConstructor;
  function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
  }
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  /**
   * Secure PRNG
   */
  function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto.web) {
          return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
      }
      else if (crypto_1.crypto.node) {
          return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
      }
      else {
          throw new Error("The environment doesn't have randomBytes function");
      }
  }
  exports.randomBytes = randomBytes;
  }(utils$1));

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = void 0;
  const _assert_js_1 = _assert;
  const utils_js_1 = utils$1;
  // HMAC (RFC 2104)
  class HMAC extends utils_js_1.Hash {
      constructor(hash, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          _assert_js_1.default.hash(hash);
          const key = (0, utils_js_1.toBytes)(_key);
          this.iHash = hash.create();
          if (!(this.iHash instanceof utils_js_1.Hash))
              throw new TypeError('Expected instance of class which extends utils.Hash');
          const blockLen = (this.blockLen = this.iHash.blockLen);
          this.outputLen = this.iHash.outputLen;
          const pad = new Uint8Array(blockLen);
          // blockLen can be bigger than outputLen
          pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
              pad[i] ^= 0x36;
          this.iHash.update(pad);
          // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
          this.oHash = hash.create();
          // Undo internal XOR && apply outer XOR
          for (let i = 0; i < pad.length; i++)
              pad[i] ^= 0x36 ^ 0x5c;
          this.oHash.update(pad);
          pad.fill(0);
      }
      update(buf) {
          _assert_js_1.default.exists(this);
          this.iHash.update(buf);
          return this;
      }
      digestInto(out) {
          _assert_js_1.default.exists(this);
          _assert_js_1.default.bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
      }
      digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
      }
      _cloneInto(to) {
          // Create new instance without calling constructor since key already in state and we don't know it.
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
      }
      destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
      }
  }
  /**
   * HMAC: RFC2104 message authentication code.
   * @param hash - function that would be used e.g. sha256
   * @param key - message key
   * @param message - message data
   */
  const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
  exports.hmac = hmac;
  exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }(hmac));

  var sha256$1 = {};

  var _sha2 = {};

  Object.defineProperty(_sha2, "__esModule", { value: true });
  _sha2.SHA2 = void 0;
  const _assert_js_1$1 = _assert;
  const utils_js_1$3 = utils$1;
  // Polyfill for Safari 14
  function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === 'function')
          return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(0xffffffff);
      const wh = Number((value >> _32n) & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
  }
  // Base SHA2 class (RFC 6234)
  class SHA2 extends utils_js_1$3.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1$3.createView)(this.buffer);
      }
      update(data) {
          _assert_js_1$1.default.exists(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1$3.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len;) {
              const take = Math.min(blockLen - this.pos, len - pos);
              // Fast path: we have at least one block in input, cast it to view and process
              if (take === blockLen) {
                  const dataView = (0, utils_js_1$3.createView)(data);
                  for (; blockLen <= len - pos; pos += blockLen)
                      this.process(dataView, pos);
                  continue;
              }
              buffer.set(data.subarray(pos, pos + take), this.pos);
              this.pos += take;
              pos += take;
              if (this.pos === blockLen) {
                  this.process(view, 0);
                  this.pos = 0;
              }
          }
          this.length += data.length;
          this.roundClean();
          return this;
      }
      digestInto(out) {
          _assert_js_1$1.default.exists(this);
          _assert_js_1$1.default.output(out, this);
          this.finished = true;
          // Padding
          // We can avoid allocation of buffer for padding completely if it
          // was previously not allocated here. But it won't change performance.
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          // append the bit '1' to the message
          buffer[pos++] = 0b10000000;
          this.buffer.subarray(pos).fill(0);
          // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
          if (this.padOffset > blockLen - pos) {
              this.process(view, 0);
              pos = 0;
          }
          // Pad until full block byte with zeros
          for (let i = pos; i < blockLen; i++)
              buffer[i] = 0;
          // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
          // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
          // So we just write lowest 64 bits of that value.
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_js_1$3.createView)(out);
          this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
      }
      digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
      }
      _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
              to.buffer.set(buffer);
          return to;
      }
  }
  _sha2.SHA2 = SHA2;

  Object.defineProperty(sha256$1, "__esModule", { value: true });
  sha256$1.sha256 = void 0;
  const _sha2_js_1$1 = _sha2;
  const utils_js_1$2 = utils$1;
  // Choice: a ? b : c
  const Chi = (a, b, c) => (a & b) ^ (~a & c);
  // Majority function, true if any two inpust is true
  const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
  // Round constants:
  // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
  // prettier-ignore
  const SHA256_K = new Uint32Array([
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ]);
  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
  // prettier-ignore
  const IV = new Uint32Array([
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ]);
  // Temporary buffer, not used to store anything between runs
  // Named this way because it matches specification.
  const SHA256_W = new Uint32Array(64);
  class SHA256 extends _sha2_js_1$1.SHA2 {
      constructor() {
          super(64, 32, 8, false);
          // We cannot use array here since array allows indexing by variable
          // which means optimizer/compiler cannot use registers.
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
      }
      get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
      }
      process(view, offset) {
          // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
          for (let i = 0; i < 16; i++, offset += 4)
              SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
              const W15 = SHA256_W[i - 15];
              const W2 = SHA256_W[i - 2];
              const s0 = (0, utils_js_1$2.rotr)(W15, 7) ^ (0, utils_js_1$2.rotr)(W15, 18) ^ (W15 >>> 3);
              const s1 = (0, utils_js_1$2.rotr)(W2, 17) ^ (0, utils_js_1$2.rotr)(W2, 19) ^ (W2 >>> 10);
              SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
          }
          // Compression function main loop, 64 rounds
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
              const sigma1 = (0, utils_js_1$2.rotr)(E, 6) ^ (0, utils_js_1$2.rotr)(E, 11) ^ (0, utils_js_1$2.rotr)(E, 25);
              const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
              const sigma0 = (0, utils_js_1$2.rotr)(A, 2) ^ (0, utils_js_1$2.rotr)(A, 13) ^ (0, utils_js_1$2.rotr)(A, 22);
              const T2 = (sigma0 + Maj(A, B, C)) | 0;
              H = G;
              G = F;
              F = E;
              E = (D + T1) | 0;
              D = C;
              C = B;
              B = A;
              A = (T1 + T2) | 0;
          }
          // Add the compressed chunk to the current hash value
          A = (A + this.A) | 0;
          B = (B + this.B) | 0;
          C = (C + this.C) | 0;
          D = (D + this.D) | 0;
          E = (E + this.E) | 0;
          F = (F + this.F) | 0;
          G = (G + this.G) | 0;
          H = (H + this.H) | 0;
          this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
          SHA256_W.fill(0);
      }
      destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
      }
  }
  /**
   * SHA2-256 hash function
   * @param message - data that would be hashed
   */
  sha256$1.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());

  var lib = {};

  (function (exports) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
  const nodeCrypto = require$$2$2;
  const _0n = BigInt(0);
  const _1n = BigInt(1);
  const _2n = BigInt(2);
  const _3n = BigInt(3);
  const _8n = BigInt(8);
  const POW_2_256 = _2n ** BigInt(256);
  const CURVE = {
      a: _0n,
      b: BigInt(7),
      P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),
      n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),
      h: _1n,
      Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
      Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
  };
  exports.CURVE = CURVE;
  function weistrass(x) {
      const { a, b } = CURVE;
      const x2 = mod(x * x);
      const x3 = mod(x2 * x);
      return mod(x3 + a * x + b);
  }
  const USE_ENDOMORPHISM = CURVE.a === _0n;
  class JacobianPoint {
      constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
      }
      static fromAffine(p) {
          if (!(p instanceof Point)) {
              throw new TypeError('JacobianPoint#fromAffine: expected Point');
          }
          return new JacobianPoint(p.x, p.y, _1n);
      }
      static toAffineBatch(points) {
          const toInv = invertBatch(points.map((p) => p.z));
          return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
          return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
      }
      equals(other) {
          if (!(other instanceof JacobianPoint))
              throw new TypeError('JacobianPoint expected');
          const { x: X1, y: Y1, z: Z1 } = this;
          const { x: X2, y: Y2, z: Z2 } = other;
          const Z1Z1 = mod(Z1 ** _2n);
          const Z2Z2 = mod(Z2 ** _2n);
          const U1 = mod(X1 * Z2Z2);
          const U2 = mod(X2 * Z1Z1);
          const S1 = mod(mod(Y1 * Z2) * Z2Z2);
          const S2 = mod(mod(Y2 * Z1) * Z1Z1);
          return U1 === U2 && S1 === S2;
      }
      negate() {
          return new JacobianPoint(this.x, mod(-this.y), this.z);
      }
      double() {
          const { x: X1, y: Y1, z: Z1 } = this;
          const A = mod(X1 ** _2n);
          const B = mod(Y1 ** _2n);
          const C = mod(B ** _2n);
          const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));
          const E = mod(_3n * A);
          const F = mod(E ** _2n);
          const X3 = mod(F - _2n * D);
          const Y3 = mod(E * (D - X3) - _8n * C);
          const Z3 = mod(_2n * Y1 * Z1);
          return new JacobianPoint(X3, Y3, Z3);
      }
      add(other) {
          if (!(other instanceof JacobianPoint))
              throw new TypeError('JacobianPoint expected');
          const { x: X1, y: Y1, z: Z1 } = this;
          const { x: X2, y: Y2, z: Z2 } = other;
          if (X2 === _0n || Y2 === _0n)
              return this;
          if (X1 === _0n || Y1 === _0n)
              return other;
          const Z1Z1 = mod(Z1 ** _2n);
          const Z2Z2 = mod(Z2 ** _2n);
          const U1 = mod(X1 * Z2Z2);
          const U2 = mod(X2 * Z1Z1);
          const S1 = mod(mod(Y1 * Z2) * Z2Z2);
          const S2 = mod(mod(Y2 * Z1) * Z1Z1);
          const H = mod(U2 - U1);
          const r = mod(S2 - S1);
          if (H === _0n) {
              if (r === _0n) {
                  return this.double();
              }
              else {
                  return JacobianPoint.ZERO;
              }
          }
          const HH = mod(H ** _2n);
          const HHH = mod(H * HH);
          const V = mod(U1 * HH);
          const X3 = mod(r ** _2n - HHH - _2n * V);
          const Y3 = mod(r * (V - X3) - S1 * HHH);
          const Z3 = mod(Z1 * Z2 * H);
          return new JacobianPoint(X3, Y3, Z3);
      }
      subtract(other) {
          return this.add(other.negate());
      }
      multiplyUnsafe(scalar) {
          const P0 = JacobianPoint.ZERO;
          if (typeof scalar === 'bigint' && scalar === _0n)
              return P0;
          let n = normalizeScalar(scalar);
          if (n === _1n)
              return this;
          if (!USE_ENDOMORPHISM) {
              let p = P0;
              let d = this;
              while (n > _0n) {
                  if (n & _1n)
                      p = p.add(d);
                  d = d.double();
                  n >>= _1n;
              }
              return p;
          }
          let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
          let k1p = P0;
          let k2p = P0;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
              if (k1 & _1n)
                  k1p = k1p.add(d);
              if (k2 & _1n)
                  k2p = k2p.add(d);
              d = d.double();
              k1 >>= _1n;
              k2 >>= _1n;
          }
          if (k1neg)
              k1p = k1p.negate();
          if (k2neg)
              k2p = k2p.negate();
          k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
          return k1p.add(k2p);
      }
      precomputeWindow(W) {
          const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
          const points = [];
          let p = this;
          let base = p;
          for (let window = 0; window < windows; window++) {
              base = p;
              points.push(base);
              for (let i = 1; i < 2 ** (W - 1); i++) {
                  base = base.add(p);
                  points.push(base);
              }
              p = base.double();
          }
          return points;
      }
      wNAF(n, affinePoint) {
          if (!affinePoint && this.equals(JacobianPoint.BASE))
              affinePoint = Point.BASE;
          const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
          if (256 % W) {
              throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
          }
          let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
          if (!precomputes) {
              precomputes = this.precomputeWindow(W);
              if (affinePoint && W !== 1) {
                  precomputes = JacobianPoint.normalizeZ(precomputes);
                  pointPrecomputes.set(affinePoint, precomputes);
              }
          }
          let p = JacobianPoint.ZERO;
          let f = JacobianPoint.ZERO;
          const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
          const windowSize = 2 ** (W - 1);
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window = 0; window < windows; window++) {
              const offset = window * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                  wbits -= maxNumber;
                  n += _1n;
              }
              if (wbits === 0) {
                  let pr = precomputes[offset];
                  if (window % 2)
                      pr = pr.negate();
                  f = f.add(pr);
              }
              else {
                  let cached = precomputes[offset + Math.abs(wbits) - 1];
                  if (wbits < 0)
                      cached = cached.negate();
                  p = p.add(cached);
              }
          }
          return { p, f };
      }
      multiply(scalar, affinePoint) {
          let n = normalizeScalar(scalar);
          let point;
          let fake;
          if (USE_ENDOMORPHISM) {
              const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
              let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
              let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
              if (k1neg)
                  k1p = k1p.negate();
              if (k2neg)
                  k2p = k2p.negate();
              k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
              point = k1p.add(k2p);
              fake = f1p.add(f2p);
          }
          else {
              const { p, f } = this.wNAF(n, affinePoint);
              point = p;
              fake = f;
          }
          return JacobianPoint.normalizeZ([point, fake])[0];
      }
      toAffine(invZ = invert(this.z)) {
          const { x, y, z } = this;
          const iz1 = invZ;
          const iz2 = mod(iz1 * iz1);
          const iz3 = mod(iz2 * iz1);
          const ax = mod(x * iz2);
          const ay = mod(y * iz3);
          const zz = mod(z * iz1);
          if (zz !== _1n)
              throw new Error('invZ was invalid');
          return new Point(ax, ay);
      }
  }
  JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
  JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
  const pointPrecomputes = new WeakMap();
  class Point {
      constructor(x, y) {
          this.x = x;
          this.y = y;
      }
      _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
      }
      static fromCompressedHex(bytes) {
          const isShort = bytes.length === 32;
          const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
          if (!isValidFieldElement(x))
              throw new Error('Point is not on curve');
          const y2 = weistrass(x);
          let y = sqrtMod(y2);
          const isYOdd = (y & _1n) === _1n;
          if (isShort) {
              if (isYOdd)
                  y = mod(-y);
          }
          else {
              const isFirstByteOdd = (bytes[0] & 1) === 1;
              if (isFirstByteOdd !== isYOdd)
                  y = mod(-y);
          }
          const point = new Point(x, y);
          point.assertValidity();
          return point;
      }
      static fromUncompressedHex(bytes) {
          const x = bytesToNumber(bytes.subarray(1, 33));
          const y = bytesToNumber(bytes.subarray(33, 65));
          const point = new Point(x, y);
          point.assertValidity();
          return point;
      }
      static fromHex(hex) {
          const bytes = ensureBytes(hex);
          const len = bytes.length;
          const header = bytes[0];
          if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {
              return this.fromCompressedHex(bytes);
          }
          if (len === 65 && header === 0x04)
              return this.fromUncompressedHex(bytes);
          throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
      }
      static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normalizePrivateKey(privateKey));
      }
      static fromSignature(msgHash, signature, recovery) {
          msgHash = ensureBytes(msgHash);
          const h = truncateHash(msgHash);
          const { r, s } = normalizeSignature(signature);
          if (recovery !== 0 && recovery !== 1) {
              throw new Error('Cannot recover signature: invalid recovery bit');
          }
          const prefix = recovery & 1 ? '03' : '02';
          const R = Point.fromHex(prefix + numTo32bStr(r));
          const { n } = CURVE;
          const rinv = invert(r, n);
          const u1 = mod(-h * rinv, n);
          const u2 = mod(s * rinv, n);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
              throw new Error('Cannot recover signature: point at infinify');
          Q.assertValidity();
          return Q;
      }
      toRawBytes(isCompressed = false) {
          return hexToBytes(this.toHex(isCompressed));
      }
      toHex(isCompressed = false) {
          const x = numTo32bStr(this.x);
          if (isCompressed) {
              const prefix = this.y & _1n ? '03' : '02';
              return `${prefix}${x}`;
          }
          else {
              return `04${x}${numTo32bStr(this.y)}`;
          }
      }
      toHexX() {
          return this.toHex(true).slice(2);
      }
      toRawX() {
          return this.toRawBytes(true).slice(1);
      }
      assertValidity() {
          const msg = 'Point is not on elliptic curve';
          const { x, y } = this;
          if (!isValidFieldElement(x) || !isValidFieldElement(y))
              throw new Error(msg);
          const left = mod(y * y);
          const right = weistrass(x);
          if (mod(left - right) !== _0n)
              throw new Error(msg);
      }
      equals(other) {
          return this.x === other.x && this.y === other.y;
      }
      negate() {
          return new Point(this.x, mod(-this.y));
      }
      double() {
          return JacobianPoint.fromAffine(this).double().toAffine();
      }
      add(other) {
          return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
          return this.add(other.negate());
      }
      multiply(scalar) {
          return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
      multiplyAndAddUnsafe(Q, a, b) {
          const P = JacobianPoint.fromAffine(this);
          const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
          const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
          const sum = aP.add(bQ);
          return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
      }
  }
  exports.Point = Point;
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
  Point.ZERO = new Point(_0n, _0n);
  function sliceDER(s) {
      return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
  }
  function parseDERInt(data) {
      if (data.length < 2 || data[0] !== 0x02) {
          throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
      }
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len) {
          throw new Error(`Invalid signature integer: wrong length`);
      }
      if (res[0] === 0x00 && res[1] <= 0x7f) {
          throw new Error('Invalid signature integer: trailing length');
      }
      return { data: bytesToNumber(res), left: data.subarray(len + 2) };
  }
  function parseDERSignature(data) {
      if (data.length < 2 || data[0] != 0x30) {
          throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
      }
      if (data[1] !== data.length - 2) {
          throw new Error('Invalid signature: incorrect length');
      }
      const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
      const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
      if (rBytesLeft.length) {
          throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
      }
      return { r, s };
  }
  class Signature {
      constructor(r, s) {
          this.r = r;
          this.s = s;
          this.assertValidity();
      }
      static fromCompact(hex) {
          const arr = isUint8a(hex);
          const name = 'Signature.fromCompact';
          if (typeof hex !== 'string' && !arr)
              throw new TypeError(`${name}: Expected string or Uint8Array`);
          const str = arr ? bytesToHex(hex) : hex;
          if (str.length !== 128)
              throw new Error(`${name}: Expected 64-byte hex`);
          return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
      }
      static fromDER(hex) {
          const arr = isUint8a(hex);
          if (typeof hex !== 'string' && !arr)
              throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
          const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
          return new Signature(r, s);
      }
      static fromHex(hex) {
          return this.fromDER(hex);
      }
      assertValidity() {
          const { r, s } = this;
          if (!isWithinCurveOrder(r))
              throw new Error('Invalid Signature: r must be 0 < r < n');
          if (!isWithinCurveOrder(s))
              throw new Error('Invalid Signature: s must be 0 < s < n');
      }
      hasHighS() {
          const HALF = CURVE.n >> _1n;
          return this.s > HALF;
      }
      normalizeS() {
          return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
      }
      toDERRawBytes(isCompressed = false) {
          return hexToBytes(this.toDERHex(isCompressed));
      }
      toDERHex(isCompressed = false) {
          const sHex = sliceDER(numberToHexUnpadded(this.s));
          if (isCompressed)
              return sHex;
          const rHex = sliceDER(numberToHexUnpadded(this.r));
          const rLen = numberToHexUnpadded(rHex.length / 2);
          const sLen = numberToHexUnpadded(sHex.length / 2);
          const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
          return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
      }
      toRawBytes() {
          return this.toDERRawBytes();
      }
      toHex() {
          return this.toDERHex();
      }
      toCompactRawBytes() {
          return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
          return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
  }
  exports.Signature = Signature;
  function concatBytes(...arrays) {
      if (!arrays.every(isUint8a))
          throw new Error('Uint8Array list expected');
      if (arrays.length === 1)
          return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
      }
      return result;
  }
  function isUint8a(bytes) {
      return bytes instanceof Uint8Array;
  }
  const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
  function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
          throw new Error('Expected Uint8Array');
      let hex = '';
      for (let i = 0; i < uint8a.length; i++) {
          hex += hexes[uint8a[i]];
      }
      return hex;
  }
  function numTo32bStr(num) {
      if (num > POW_2_256)
          throw new Error('Expected number < 2^256');
      return num.toString(16).padStart(64, '0');
  }
  function numTo32b(num) {
      return hexToBytes(numTo32bStr(num));
  }
  function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber(hex) {
      if (typeof hex !== 'string') {
          throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
      }
      return BigInt(`0x${hex}`);
  }
  function hexToBytes(hex) {
      if (typeof hex !== 'string') {
          throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
      }
      if (hex.length % 2)
          throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
              throw new Error('Invalid byte sequence');
          array[i] = byte;
      }
      return array;
  }
  function bytesToNumber(bytes) {
      return hexToNumber(bytesToHex(bytes));
  }
  function ensureBytes(hex) {
      return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  }
  function normalizeScalar(num) {
      if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)
          return BigInt(num);
      if (typeof num === 'bigint' && isWithinCurveOrder(num))
          return num;
      throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
  }
  function mod(a, b = CURVE.P) {
      const result = a % b;
      return result >= _0n ? result : b + result;
  }
  function pow2(x, power) {
      const { P } = CURVE;
      let res = x;
      while (power-- > _0n) {
          res *= res;
          res %= P;
      }
      return res;
  }
  function sqrtMod(x) {
      const { P } = CURVE;
      const _6n = BigInt(6);
      const _11n = BigInt(11);
      const _22n = BigInt(22);
      const _23n = BigInt(23);
      const _44n = BigInt(44);
      const _88n = BigInt(88);
      const b2 = (x * x * x) % P;
      const b3 = (b2 * b2 * x) % P;
      const b6 = (pow2(b3, _3n) * b3) % P;
      const b9 = (pow2(b6, _3n) * b3) % P;
      const b11 = (pow2(b9, _2n) * b2) % P;
      const b22 = (pow2(b11, _11n) * b11) % P;
      const b44 = (pow2(b22, _22n) * b22) % P;
      const b88 = (pow2(b44, _44n) * b44) % P;
      const b176 = (pow2(b88, _88n) * b88) % P;
      const b220 = (pow2(b176, _44n) * b44) % P;
      const b223 = (pow2(b220, _3n) * b3) % P;
      const t1 = (pow2(b223, _23n) * b22) % P;
      const t2 = (pow2(t1, _6n) * b2) % P;
      return pow2(t2, _2n);
  }
  function invert(number, modulo = CURVE.P) {
      if (number === _0n || modulo <= _0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, u = _1n;
      while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          b = a, a = r, x = u, u = m;
      }
      const gcd = b;
      if (gcd !== _1n)
          throw new Error('invert: does not exist');
      return mod(x, modulo);
  }
  function invertBatch(nums, p = CURVE.P) {
      const scratch = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
          if (num === _0n)
              return acc;
          scratch[i] = acc;
          return mod(acc * num, p);
      }, _1n);
      const inverted = invert(lastMultiplied, p);
      nums.reduceRight((acc, num, i) => {
          if (num === _0n)
              return acc;
          scratch[i] = mod(acc * scratch[i], p);
          return mod(acc * num, p);
      }, inverted);
      return scratch;
  }
  const divNearest = (a, b) => (a + b / _2n) / b;
  const POW_2_128 = _2n ** BigInt(128);
  function splitScalarEndo(k) {
      const { n } = CURVE;
      const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
      const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
      const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
      const b2 = a1;
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
          k1 = n - k1;
      if (k2neg)
          k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
      }
      return { k1neg, k1, k2neg, k2 };
  }
  function truncateHash(hash) {
      const { n } = CURVE;
      const byteLength = hash.length;
      const delta = byteLength * 8 - 256;
      let h = bytesToNumber(hash);
      if (delta > 0)
          h = h >> BigInt(delta);
      if (h >= n)
          h -= n;
      return h;
  }
  class HmacDrbg {
      constructor() {
          this.v = new Uint8Array(32).fill(1);
          this.k = new Uint8Array(32).fill(0);
          this.counter = 0;
      }
      hmac(...values) {
          return exports.utils.hmacSha256(this.k, ...values);
      }
      hmacSync(...values) {
          if (typeof exports.utils.hmacSha256Sync !== 'function')
              throw new Error('utils.hmacSha256Sync is undefined, you need to set it');
          const res = exports.utils.hmacSha256Sync(this.k, ...values);
          if (res instanceof Promise)
              throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');
          return res;
      }
      incr() {
          if (this.counter >= 1000) {
              throw new Error('Tried 1,000 k values for sign(), all were invalid');
          }
          this.counter += 1;
      }
      async reseed(seed = new Uint8Array()) {
          this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);
          this.v = await this.hmac(this.v);
          if (seed.length === 0)
              return;
          this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);
          this.v = await this.hmac(this.v);
      }
      reseedSync(seed = new Uint8Array()) {
          this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
          this.v = this.hmacSync(this.v);
          if (seed.length === 0)
              return;
          this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
          this.v = this.hmacSync(this.v);
      }
      async generate() {
          this.incr();
          this.v = await this.hmac(this.v);
          return this.v;
      }
      generateSync() {
          this.incr();
          this.v = this.hmacSync(this.v);
          return this.v;
      }
  }
  function isWithinCurveOrder(num) {
      return _0n < num && num < CURVE.n;
  }
  function isValidFieldElement(num) {
      return _0n < num && num < CURVE.P;
  }
  function kmdToSig(kBytes, m, d) {
      const k = bytesToNumber(kBytes);
      if (!isWithinCurveOrder(k))
          return;
      const { n } = CURVE;
      const q = Point.BASE.multiply(k);
      const r = mod(q.x, n);
      if (r === _0n)
          return;
      const s = mod(invert(k, n) * mod(m + d * r, n), n);
      if (s === _0n)
          return;
      const sig = new Signature(r, s);
      const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
      return { sig, recovery };
  }
  function normalizePrivateKey(key) {
      let num;
      if (typeof key === 'bigint') {
          num = key;
      }
      else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
          num = BigInt(key);
      }
      else if (typeof key === 'string') {
          if (key.length !== 64)
              throw new Error('Expected 32 bytes of private key');
          num = hexToNumber(key);
      }
      else if (isUint8a(key)) {
          if (key.length !== 32)
              throw new Error('Expected 32 bytes of private key');
          num = bytesToNumber(key);
      }
      else {
          throw new TypeError('Expected valid private key');
      }
      if (!isWithinCurveOrder(num))
          throw new Error('Expected private key: 0 < key < n');
      return num;
  }
  function normalizePublicKey(publicKey) {
      if (publicKey instanceof Point) {
          publicKey.assertValidity();
          return publicKey;
      }
      else {
          return Point.fromHex(publicKey);
      }
  }
  function normalizeSignature(signature) {
      if (signature instanceof Signature) {
          signature.assertValidity();
          return signature;
      }
      try {
          return Signature.fromDER(signature);
      }
      catch (error) {
          return Signature.fromCompact(signature);
      }
  }
  function getPublicKey(privateKey, isCompressed = false) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  exports.getPublicKey = getPublicKey;
  function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
      return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
  }
  exports.recoverPublicKey = recoverPublicKey;
  function isPub(item) {
      const arr = isUint8a(item);
      const str = typeof item === 'string';
      const len = (arr || str) && item.length;
      if (arr)
          return len === 33 || len === 65;
      if (str)
          return len === 66 || len === 130;
      if (item instanceof Point)
          return true;
      return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = false) {
      if (isPub(privateA))
          throw new TypeError('getSharedSecret: first arg must be private key');
      if (!isPub(publicB))
          throw new TypeError('getSharedSecret: second arg must be public key');
      const b = normalizePublicKey(publicB);
      b.assertValidity();
      return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
  }
  exports.getSharedSecret = getSharedSecret;
  function bits2int(bytes) {
      const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;
      return bytesToNumber(slice);
  }
  function bits2octets(bytes) {
      const z1 = bits2int(bytes);
      const z2 = mod(z1, CURVE.n);
      return int2octets(z2 < _0n ? z1 : z2);
  }
  function int2octets(num) {
      if (typeof num !== 'bigint')
          throw new Error('Expected bigint');
      const hex = numTo32bStr(num);
      return hexToBytes(hex);
  }
  function initSigArgs(msgHash, privateKey, extraEntropy) {
      if (msgHash == null)
          throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
      const h1 = ensureBytes(msgHash);
      const d = normalizePrivateKey(privateKey);
      const seedArgs = [int2octets(d), bits2octets(h1)];
      if (extraEntropy != null) {
          if (extraEntropy === true)
              extraEntropy = exports.utils.randomBytes(32);
          const e = ensureBytes(extraEntropy);
          if (e.length !== 32)
              throw new Error('sign: Expected 32 bytes of extra data');
          seedArgs.push(e);
      }
      const seed = concatBytes(...seedArgs);
      const m = bits2int(h1);
      return { seed, m, d };
  }
  function finalizeSig(recSig, opts) {
      let { sig, recovery } = recSig;
      const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
      if (canonical && sig.hasHighS()) {
          sig = sig.normalizeS();
          recovery ^= 1;
      }
      const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
      return recovered ? [hashed, recovery] : hashed;
  }
  async function sign(msgHash, privKey, opts = {}) {
      const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      let sig;
      const drbg = new HmacDrbg();
      await drbg.reseed(seed);
      while (!(sig = kmdToSig(await drbg.generate(), m, d)))
          await drbg.reseed();
      return finalizeSig(sig, opts);
  }
  exports.sign = sign;
  function signSync(msgHash, privKey, opts = {}) {
      const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      let sig;
      const drbg = new HmacDrbg();
      drbg.reseedSync(seed);
      while (!(sig = kmdToSig(drbg.generateSync(), m, d)))
          drbg.reseedSync();
      return finalizeSig(sig, opts);
  }
  exports.signSync = signSync;
  const vopts = { strict: true };
  function verify(signature, msgHash, publicKey, opts = vopts) {
      let sig;
      try {
          sig = normalizeSignature(signature);
          msgHash = ensureBytes(msgHash);
      }
      catch (error) {
          return false;
      }
      const { r, s } = sig;
      if (opts.strict && sig.hasHighS())
          return false;
      const h = truncateHash(msgHash);
      let P;
      try {
          P = normalizePublicKey(publicKey);
      }
      catch (error) {
          return false;
      }
      const { n } = CURVE;
      const sinv = invert(s, n);
      const u1 = mod(h * sinv, n);
      const u2 = mod(r * sinv, n);
      const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
      if (!R)
          return false;
      const v = mod(R.x, n);
      return v === r;
  }
  exports.verify = verify;
  function finalizeSchnorrChallenge(ch) {
      return mod(bytesToNumber(ch), CURVE.n);
  }
  function hasEvenY(point) {
      return (point.y & _1n) === _0n;
  }
  class SchnorrSignature {
      constructor(r, s) {
          this.r = r;
          this.s = s;
          this.assertValidity();
      }
      static fromHex(hex) {
          const bytes = ensureBytes(hex);
          if (bytes.length !== 64)
              throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
          const r = bytesToNumber(bytes.subarray(0, 32));
          const s = bytesToNumber(bytes.subarray(32, 64));
          return new SchnorrSignature(r, s);
      }
      assertValidity() {
          const { r, s } = this;
          if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
              throw new Error('Invalid signature');
      }
      toHex() {
          return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
      toRawBytes() {
          return hexToBytes(this.toHex());
      }
  }
  function schnorrGetPublicKey(privateKey) {
      return Point.fromPrivateKey(privateKey).toRawX();
  }
  function initSchnorrSigArgs(message, privateKey, auxRand) {
      if (message == null)
          throw new TypeError(`sign: Expected valid message, not "${message}"`);
      const m = ensureBytes(message);
      const d0 = normalizePrivateKey(privateKey);
      const rand = ensureBytes(auxRand);
      if (rand.length !== 32)
          throw new TypeError('sign: Expected 32 bytes of aux randomness');
      const P = Point.fromPrivateKey(d0);
      const px = P.toRawX();
      const d = hasEvenY(P) ? d0 : CURVE.n - d0;
      return { m, P, px, d, rand };
  }
  function initSchnorrNonce(d, t0h) {
      return numTo32b(d ^ bytesToNumber(t0h));
  }
  function finalizeSchnorrNonce(k0h) {
      const k0 = mod(bytesToNumber(k0h), CURVE.n);
      if (k0 === _0n)
          throw new Error('sign: Creation of signature failed. k is zero');
      const R = Point.fromPrivateKey(k0);
      const rx = R.toRawX();
      const k = hasEvenY(R) ? k0 : CURVE.n - k0;
      return { R, rx, k };
  }
  function finalizeSchnorrSig(R, k, e, d) {
      return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
  }
  async function schnorrSign(message, privateKey, auxRand = exports.utils.randomBytes()) {
      const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);
      const t = initSchnorrNonce(d, await exports.utils.taggedHash(TAGS.aux, rand));
      const { R, rx, k } = finalizeSchnorrNonce(await exports.utils.taggedHash(TAGS.nonce, t, px, m));
      const e = finalizeSchnorrChallenge(await exports.utils.taggedHash(TAGS.challenge, rx, px, m));
      const sig = finalizeSchnorrSig(R, k, e, d);
      const isValid = await schnorrVerify(sig, m, px);
      if (!isValid)
          throw new Error('sign: Invalid signature produced');
      return sig;
  }
  function schnorrSignSync(message, privateKey, auxRand = exports.utils.randomBytes()) {
      const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);
      const t = initSchnorrNonce(d, exports.utils.taggedHashSync(TAGS.aux, rand));
      const { R, rx, k } = finalizeSchnorrNonce(exports.utils.taggedHashSync(TAGS.nonce, t, px, m));
      const e = finalizeSchnorrChallenge(exports.utils.taggedHashSync(TAGS.challenge, rx, px, m));
      const sig = finalizeSchnorrSig(R, k, e, d);
      const isValid = schnorrVerifySync(sig, m, px);
      if (!isValid)
          throw new Error('sign: Invalid signature produced');
      return sig;
  }
  function initSchnorrVerify(signature, message, publicKey) {
      const raw = signature instanceof SchnorrSignature;
      const sig = raw ? signature : SchnorrSignature.fromHex(signature);
      if (raw)
          sig.assertValidity();
      return {
          ...sig,
          m: ensureBytes(message),
          P: normalizePublicKey(publicKey),
      };
  }
  function finalizeSchnorrVerify(r, P, s, e) {
      const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
      if (!R || !hasEvenY(R) || R.x !== r)
          return false;
      return true;
  }
  async function schnorrVerify(signature, message, publicKey) {
      try {
          const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
          const e = finalizeSchnorrChallenge(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
          return finalizeSchnorrVerify(r, P, s, e);
      }
      catch (error) {
          return false;
      }
  }
  function schnorrVerifySync(signature, message, publicKey) {
      try {
          const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
          const e = finalizeSchnorrChallenge(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
          return finalizeSchnorrVerify(r, P, s, e);
      }
      catch (error) {
          return false;
      }
  }
  exports.schnorr = {
      Signature: SchnorrSignature,
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      signSync: schnorrSignSync,
      verifySync: schnorrVerifySync,
  };
  Point.BASE._setWindowSize(8);
  const crypto = {
      node: nodeCrypto,
      web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
  };
  const TAGS = {
      challenge: 'BIP0340/challenge',
      aux: 'BIP0340/aux',
      nonce: 'BIP0340/nonce',
  };
  const TAGGED_HASH_PREFIXES = {};
  exports.utils = {
      isValidPrivateKey(privateKey) {
          try {
              normalizePrivateKey(privateKey);
              return true;
          }
          catch (error) {
              return false;
          }
      },
      privateAdd: (privateKey, tweak) => {
          const p = normalizePrivateKey(privateKey);
          const t = normalizePrivateKey(tweak);
          return numTo32b(mod(p + t, CURVE.n));
      },
      privateNegate: (privateKey) => {
          const p = normalizePrivateKey(privateKey);
          return numTo32b(CURVE.n - p);
      },
      pointAddScalar: (p, tweak, isCompressed) => {
          const P = Point.fromHex(p);
          const t = normalizePrivateKey(tweak);
          const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);
          if (!Q)
              throw new Error('Tweaked point at infinity');
          return Q.toRawBytes(isCompressed);
      },
      pointMultiply: (p, tweak, isCompressed) => {
          const P = Point.fromHex(p);
          const t = bytesToNumber(ensureBytes(tweak));
          return P.multiply(t).toRawBytes(isCompressed);
      },
      hashToPrivateKey: (hash) => {
          hash = ensureBytes(hash);
          if (hash.length < 40 || hash.length > 1024)
              throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
          const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
          return numTo32b(num);
      },
      randomBytes: (bytesLength = 32) => {
          if (crypto.web) {
              return crypto.web.getRandomValues(new Uint8Array(bytesLength));
          }
          else if (crypto.node) {
              const { randomBytes } = crypto.node;
              return Uint8Array.from(randomBytes(bytesLength));
          }
          else {
              throw new Error("The environment doesn't have randomBytes function");
          }
      },
      randomPrivateKey: () => {
          return exports.utils.hashToPrivateKey(exports.utils.randomBytes(40));
      },
      bytesToHex,
      hexToBytes,
      concatBytes,
      mod,
      invert,
      sha256: async (...messages) => {
          if (crypto.web) {
              const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));
              return new Uint8Array(buffer);
          }
          else if (crypto.node) {
              const { createHash } = crypto.node;
              const hash = createHash('sha256');
              messages.forEach((m) => hash.update(m));
              return Uint8Array.from(hash.digest());
          }
          else {
              throw new Error("The environment doesn't have sha256 function");
          }
      },
      hmacSha256: async (key, ...messages) => {
          if (crypto.web) {
              const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);
              const message = concatBytes(...messages);
              const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);
              return new Uint8Array(buffer);
          }
          else if (crypto.node) {
              const { createHmac } = crypto.node;
              const hash = createHmac('sha256', key);
              messages.forEach((m) => hash.update(m));
              return Uint8Array.from(hash.digest());
          }
          else {
              throw new Error("The environment doesn't have hmac-sha256 function");
          }
      },
      sha256Sync: undefined,
      hmacSha256Sync: undefined,
      taggedHash: async (tag, ...messages) => {
          let tagP = TAGGED_HASH_PREFIXES[tag];
          if (tagP === undefined) {
              const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
              tagP = concatBytes(tagH, tagH);
              TAGGED_HASH_PREFIXES[tag] = tagP;
          }
          return exports.utils.sha256(tagP, ...messages);
      },
      taggedHashSync: (tag, ...messages) => {
          if (typeof exports.utils.sha256Sync !== 'function')
              throw new Error('utils.sha256Sync is undefined, you need to set it');
          let tagP = TAGGED_HASH_PREFIXES[tag];
          if (tagP === undefined) {
              const tagH = exports.utils.sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
              tagP = concatBytes(tagH, tagH);
              TAGGED_HASH_PREFIXES[tag] = tagP;
          }
          return exports.utils.sha256Sync(tagP, ...messages);
      },
      precompute(windowSize = 8, point = Point.BASE) {
          const cached = point === Point.BASE ? point : new Point(point.x, point.y);
          cached._setWindowSize(windowSize);
          cached.multiply(_3n);
          return cached;
      },
  };
  }(lib));

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schnorr = exports.Signature = exports.Point = exports.CURVE = exports.utils = exports.getSharedSecret = exports.recoverPublicKey = exports.verify = exports.signSync = exports.sign = exports.getPublicKey = void 0;
  const hmac_1 = hmac;
  const sha256_1 = sha256$1;
  const secp256k1_1 = lib;
  var secp256k1_2 = lib;
  Object.defineProperty(exports, "getPublicKey", { enumerable: true, get: function () { return secp256k1_2.getPublicKey; } });
  Object.defineProperty(exports, "sign", { enumerable: true, get: function () { return secp256k1_2.sign; } });
  Object.defineProperty(exports, "signSync", { enumerable: true, get: function () { return secp256k1_2.signSync; } });
  Object.defineProperty(exports, "verify", { enumerable: true, get: function () { return secp256k1_2.verify; } });
  Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function () { return secp256k1_2.recoverPublicKey; } });
  Object.defineProperty(exports, "getSharedSecret", { enumerable: true, get: function () { return secp256k1_2.getSharedSecret; } });
  Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return secp256k1_2.utils; } });
  Object.defineProperty(exports, "CURVE", { enumerable: true, get: function () { return secp256k1_2.CURVE; } });
  Object.defineProperty(exports, "Point", { enumerable: true, get: function () { return secp256k1_2.Point; } });
  Object.defineProperty(exports, "Signature", { enumerable: true, get: function () { return secp256k1_2.Signature; } });
  Object.defineProperty(exports, "schnorr", { enumerable: true, get: function () { return secp256k1_2.schnorr; } });
  // Enable sync API for noble-secp256k1
  secp256k1_1.utils.hmacSha256Sync = (key, ...messages) => {
      const h = hmac_1.hmac.create(sha256_1.sha256, key);
      messages.forEach(msg => h.update(msg));
      return h.digest();
  };
  }(secp256k1));

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
  const buffer_1 = buffer;
  const secp256k1_1 = secp256k1;
  /**
   * 2^64-1
   */
  exports.MAX_UINT64 = BigInt('0xffffffffffffffff');
  /**
   * The max integer that the evm can handle (2^256-1)
   */
  exports.MAX_INTEGER = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
  /**
   * The max integer that the evm can handle (2^256-1) as a bigint
   */
  exports.MAX_INTEGER_BIGINT = BigInt(2) ** BigInt(256) - BigInt(1);
  exports.SECP256K1_ORDER = secp256k1_1.CURVE.n;
  exports.SECP256K1_ORDER_DIV_2 = secp256k1_1.CURVE.n / BigInt(2);
  /**
   * 2^256
   */
  exports.TWO_POW256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
  /**
   * Keccak-256 hash of null
   */
  exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
  /**
   * Keccak-256 hash of null
   */
  exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');
  /**
   * Keccak-256 of an RLP of an empty array
   */
  exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
  /**
   * Keccak-256 of an RLP of an empty array
   */
  exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
  /**
   * Keccak-256 hash of the RLP of null
   */
  exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
  /**
   * Keccak-256 hash of the RLP of null
   */
  exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');
  /**
   *  RLP encoded empty string
   */
  exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([0x80]);

  }(constants$1));

  var account = {};

  var dist$9 = {};

  Object.defineProperty(dist$9, "__esModule", { value: true });
  dist$9.RLP = dist$9.utils = dist$9.decode = dist$9.encode = void 0;
  /**
   * RLP Encoding based on https://eth.wiki/en/fundamentals/rlp
   * This function takes in data, converts it to Uint8Array if not,
   * and adds a length for recursion.
   * @param input Will be converted to Uint8Array
   * @returns Uint8Array of encoded data
   **/
  function encode(input) {
      if (Array.isArray(input)) {
          const output = [];
          for (let i = 0; i < input.length; i++) {
              output.push(encode(input[i]));
          }
          const buf = concatBytes(...output);
          return concatBytes(encodeLength(buf.length, 192), buf);
      }
      const inputBuf = toBytes(input);
      if (inputBuf.length === 1 && inputBuf[0] < 128) {
          return inputBuf;
      }
      return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
  }
  dist$9.encode = encode;
  /**
   * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
   * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
   * @param input
   * @param start
   * @param end
   */
  function safeSlice(input, start, end) {
      if (end > input.length) {
          throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
      }
      return input.slice(start, end);
  }
  /**
   * Parse integers. Check if there is no leading zeros
   * @param v The value to parse
   */
  function decodeLength(v) {
      if (v[0] === 0) {
          throw new Error('invalid RLP: extra zeros');
      }
      return parseHexByte(bytesToHex(v));
  }
  function encodeLength(len, offset) {
      if (len < 56) {
          return Uint8Array.from([len + offset]);
      }
      const hexLength = numberToHex(len);
      const lLength = hexLength.length / 2;
      const firstByte = numberToHex(offset + 55 + lLength);
      return Uint8Array.from(hexToBytes(firstByte + hexLength));
  }
  function decode(input, stream = false) {
      if (typeof input === 'undefined' || input === null || input.length === 0) {
          return Uint8Array.from([]);
      }
      const inputBytes = toBytes(input);
      const decoded = _decode(inputBytes);
      if (stream) {
          return decoded;
      }
      if (decoded.remainder.length !== 0) {
          throw new Error('invalid RLP: remainder must be zero');
      }
      return decoded.data;
  }
  dist$9.decode = decode;
  /** Decode an input with RLP */
  function _decode(input) {
      let length, llength, data, innerRemainder, d;
      const decoded = [];
      const firstByte = input[0];
      if (firstByte <= 0x7f) {
          // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
          return {
              data: input.slice(0, 1),
              remainder: input.slice(1),
          };
      }
      else if (firstByte <= 0xb7) {
          // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
          // The range of the first byte is [0x80, 0xb7]
          length = firstByte - 0x7f;
          // set 0x80 null to 0
          if (firstByte === 0x80) {
              data = Uint8Array.from([]);
          }
          else {
              data = safeSlice(input, 1, length);
          }
          if (length === 2 && data[0] < 0x80) {
              throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
          }
          return {
              data: data,
              remainder: input.slice(length),
          };
      }
      else if (firstByte <= 0xbf) {
          // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
          // followed by the length, followed by the string
          llength = firstByte - 0xb6;
          if (input.length - 1 < llength) {
              throw new Error('invalid RLP: not enough bytes for string length');
          }
          length = decodeLength(safeSlice(input, 1, llength));
          if (length <= 55) {
              throw new Error('invalid RLP: expected string length to be greater than 55');
          }
          data = safeSlice(input, llength, length + llength);
          return {
              data: data,
              remainder: input.slice(length + llength),
          };
      }
      else if (firstByte <= 0xf7) {
          // a list between 0-55 bytes long
          length = firstByte - 0xbf;
          innerRemainder = safeSlice(input, 1, length);
          while (innerRemainder.length) {
              d = _decode(innerRemainder);
              decoded.push(d.data);
              innerRemainder = d.remainder;
          }
          return {
              data: decoded,
              remainder: input.slice(length),
          };
      }
      else {
          // a list over 55 bytes long
          llength = firstByte - 0xf6;
          length = decodeLength(safeSlice(input, 1, llength));
          if (length < 56) {
              throw new Error('invalid RLP: encoded list too short');
          }
          const totalLength = llength + length;
          if (totalLength > input.length) {
              throw new Error('invalid RLP: total length is larger than the data');
          }
          innerRemainder = safeSlice(input, llength, totalLength);
          while (innerRemainder.length) {
              d = _decode(innerRemainder);
              decoded.push(d.data);
              innerRemainder = d.remainder;
          }
          return {
              data: decoded,
              remainder: input.slice(totalLength),
          };
      }
  }
  const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
  function bytesToHex(uint8a) {
      // Pre-caching chars with `cachedHexes` speeds this up 6x
      let hex = '';
      for (let i = 0; i < uint8a.length; i++) {
          hex += cachedHexes[uint8a[i]];
      }
      return hex;
  }
  function parseHexByte(hexByte) {
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte))
          throw new Error('Invalid byte sequence');
      return byte;
  }
  // Caching slows it down 2-3x
  function hexToBytes(hex) {
      if (typeof hex !== 'string') {
          throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
      }
      if (hex.length % 2)
          throw new Error('hexToBytes: received invalid unpadded hex');
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          array[i] = parseHexByte(hex.slice(j, j + 2));
      }
      return array;
  }
  /** Concatenates two Uint8Arrays into one. */
  function concatBytes(...arrays) {
      if (arrays.length === 1)
          return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
      }
      return result;
  }
  function utf8ToBytes(utf) {
      return new TextEncoder().encode(utf);
  }
  /** Transform an integer into its hexadecimal value */
  function numberToHex(integer) {
      if (integer < 0) {
          throw new Error('Invalid integer as argument, must be unsigned!');
      }
      const hex = integer.toString(16);
      return hex.length % 2 ? `0${hex}` : hex;
  }
  /** Pad a string to be even */
  function padToEven$1(a) {
      return a.length % 2 ? `0${a}` : a;
  }
  /** Check if a string is prefixed by 0x */
  function isHexPrefixed$1(str) {
      return str.length >= 2 && str[0] === '0' && str[1] === 'x';
  }
  /** Removes 0x from a given String */
  function stripHexPrefix$1(str) {
      if (typeof str !== 'string') {
          return str;
      }
      return isHexPrefixed$1(str) ? str.slice(2) : str;
  }
  /** Transform anything into a Uint8Array */
  function toBytes(v) {
      if (v instanceof Uint8Array) {
          return v;
      }
      if (typeof v === 'string') {
          if (isHexPrefixed$1(v)) {
              return hexToBytes(padToEven$1(stripHexPrefix$1(v)));
          }
          return utf8ToBytes(v);
      }
      if (typeof v === 'number' || typeof v === 'bigint') {
          if (!v) {
              return Uint8Array.from([]);
          }
          return hexToBytes(numberToHex(v));
      }
      if (v === null || v === undefined) {
          return Uint8Array.from([]);
      }
      throw new Error('toBytes: received unsupported type ' + typeof v);
  }
  dist$9.utils = {
      bytesToHex,
      concatBytes,
      hexToBytes,
      utf8ToBytes,
  };
  dist$9.RLP = { encode, decode };

  var keccak = {};

  var sha3 = {};

  var _u64 = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
  const U32_MASK64 = BigInt(2 ** 32 - 1);
  const _32n = BigInt(32);
  // We are not using BigUint64Array, because they are extremely slow as per 2022
  function fromBig(n, le = false) {
      if (le)
          return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
      return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  exports.fromBig = fromBig;
  function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
  }
  exports.split = split;
  const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
  exports.toBig = toBig;
  // for Shift in [0, 32)
  const shrSH = (h, l, s) => h >>> s;
  const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
  // Right rotate for Shift in [1, 32)
  const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
  const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
  // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
  const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
  const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
  // Right rotate for shift===32 (just swaps l&h)
  const rotr32H = (h, l) => l;
  const rotr32L = (h, l) => h;
  // Left rotate for Shift in [1, 32)
  const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
  const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
  // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
  const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
  const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
  // JS uses 32-bit signed integers for bitwise operations which means we cannot
  // simple take carry out of low bit sum by shift, we need to use division.
  // Removing "export" has 5% perf penalty -_-
  function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
  }
  exports.add = add;
  // Addition with more than 2 elements
  const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
  const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
  const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
  // prettier-ignore
  const u64 = {
      fromBig, split, toBig: exports.toBig,
      shrSH, shrSL,
      rotrSH, rotrSL, rotrBH, rotrBL,
      rotr32H, rotr32L,
      rotlSH, rotlSL, rotlBH, rotlBL,
      add, add3L, add3H, add4L, add4H, add5H, add5L,
  };
  exports.default = u64;
  }(_u64));

  Object.defineProperty(sha3, "__esModule", { value: true });
  sha3.shake256 = sha3.shake128 = sha3.keccak_512 = sha3.keccak_384 = sha3.keccak_256 = sha3.keccak_224 = sha3.sha3_512 = sha3.sha3_384 = sha3.sha3_256 = sha3.sha3_224 = sha3.Keccak = sha3.keccakP = void 0;
  const _assert_js_1 = _assert;
  const _u64_js_1 = _u64;
  const utils_js_1$1 = utils$1;
  // Various per round constants calculations
  const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  const _0n = BigInt(0);
  const _1n = BigInt(1);
  const _2n = BigInt(2);
  const _7n = BigInt(7);
  const _256n = BigInt(256);
  const _0x71n = BigInt(0x71);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      // Pi
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      // Rotational
      SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
      // Iota
      let t = _0n;
      for (let j = 0; j < 7; j++) {
          R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
          if (R & _2n)
              t ^= _1n << ((_1n << BigInt(j)) - _1n);
      }
      _SHA3_IOTA.push(t);
  }
  const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
  // Left rotation (without 0, 32, 64)
  const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
  const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
  // Same as keccakf1600, but allows to skip some rounds
  function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
      for (let round = 24 - rounds; round < 24; round++) {
          // Theta θ
          for (let x = 0; x < 10; x++)
              B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
          for (let x = 0; x < 10; x += 2) {
              const idx1 = (x + 8) % 10;
              const idx0 = (x + 2) % 10;
              const B0 = B[idx0];
              const B1 = B[idx0 + 1];
              const Th = rotlH(B0, B1, 1) ^ B[idx1];
              const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
              for (let y = 0; y < 50; y += 10) {
                  s[x + y] ^= Th;
                  s[x + y + 1] ^= Tl;
              }
          }
          // Rho (ρ) and Pi (π)
          let curH = s[2];
          let curL = s[3];
          for (let t = 0; t < 24; t++) {
              const shift = SHA3_ROTL[t];
              const Th = rotlH(curH, curL, shift);
              const Tl = rotlL(curH, curL, shift);
              const PI = SHA3_PI[t];
              curH = s[PI];
              curL = s[PI + 1];
              s[PI] = Th;
              s[PI + 1] = Tl;
          }
          // Chi (χ)
          for (let y = 0; y < 50; y += 10) {
              for (let x = 0; x < 10; x++)
                  B[x] = s[y + x];
              for (let x = 0; x < 10; x++)
                  s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
          }
          // Iota (ι)
          s[0] ^= SHA3_IOTA_H[round];
          s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
  }
  sha3.keccakP = keccakP;
  class Keccak extends utils_js_1$1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          // Can be passed from user as dkLen
          _assert_js_1.default.number(outputLen);
          // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
          if (0 >= this.blockLen || this.blockLen >= 200)
              throw new Error('Sha3 supports only keccak-f1600 function');
          this.state = new Uint8Array(200);
          this.state32 = (0, utils_js_1$1.u32)(this.state);
      }
      keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
      }
      update(data) {
          _assert_js_1.default.exists(this);
          const { blockLen, state } = this;
          data = (0, utils_js_1$1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len;) {
              const take = Math.min(blockLen - this.pos, len - pos);
              for (let i = 0; i < take; i++)
                  state[this.pos++] ^= data[pos++];
              if (this.pos === blockLen)
                  this.keccak();
          }
          return this;
      }
      finish() {
          if (this.finished)
              return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          // Do the padding
          state[pos] ^= suffix;
          if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
              this.keccak();
          state[blockLen - 1] ^= 0x80;
          this.keccak();
      }
      writeInto(out) {
          _assert_js_1.default.exists(this, false);
          _assert_js_1.default.bytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len;) {
              if (this.posOut >= blockLen)
                  this.keccak();
              const take = Math.min(blockLen - this.posOut, len - pos);
              out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
              this.posOut += take;
              pos += take;
          }
          return out;
      }
      xofInto(out) {
          // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
          if (!this.enableXOF)
              throw new Error('XOF is not possible for this instance');
          return this.writeInto(out);
      }
      xof(bytes) {
          _assert_js_1.default.number(bytes);
          return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
          _assert_js_1.default.output(out, this);
          if (this.finished)
              throw new Error('digest() was already called');
          this.writeInto(out);
          this.destroy();
          return out;
      }
      digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
          this.destroyed = true;
          this.state.fill(0);
      }
      _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          // Suffix can change in cSHAKE
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
      }
  }
  sha3.Keccak = Keccak;
  const gen = (suffix, blockLen, outputLen) => (0, utils_js_1$1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
  sha3.sha3_224 = gen(0x06, 144, 224 / 8);
  /**
   * SHA3-256 hash function
   * @param message - that would be hashed
   */
  sha3.sha3_256 = gen(0x06, 136, 256 / 8);
  sha3.sha3_384 = gen(0x06, 104, 384 / 8);
  sha3.sha3_512 = gen(0x06, 72, 512 / 8);
  sha3.keccak_224 = gen(0x01, 144, 224 / 8);
  /**
   * keccak-256 hash function. Different from SHA3-256.
   * @param message - that would be hashed
   */
  sha3.keccak_256 = gen(0x01, 136, 256 / 8);
  sha3.keccak_384 = gen(0x01, 104, 384 / 8);
  sha3.keccak_512 = gen(0x01, 72, 512 / 8);
  const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1$1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  sha3.shake128 = genShake(0x1f, 168, 128 / 8);
  sha3.shake256 = genShake(0x1f, 136, 256 / 8);

  var utils = {exports: {}};

  (function (module, exports) {
  var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
  // buf.toString('hex') -> toHex(buf)
  const _assert_1 = __importDefault(_assert);
  const utils_1 = utils$1;
  const assertBool = _assert_1.default.bool;
  exports.assertBool = assertBool;
  const assertBytes = _assert_1.default.bytes;
  exports.assertBytes = assertBytes;
  var utils_2 = utils$1;
  Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
  Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
  Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
  Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
  Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
  // buf.toString('utf8') -> bytesToUtf8(buf)
  function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
          throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
  }
  exports.bytesToUtf8 = bytesToUtf8;
  function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
  }
  exports.hexToBytes = hexToBytes;
  // buf.equals(buf2) -> equalsBytes(buf, buf2)
  function equalsBytes(a, b) {
      if (a.length !== b.length) {
          return false;
      }
      for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
              return false;
          }
      }
      return true;
  }
  exports.equalsBytes = equalsBytes;
  // Internal utils
  function wrapHash(hash) {
      return (msg) => {
          _assert_1.default.bytes(msg);
          return hash(msg);
      };
  }
  exports.wrapHash = wrapHash;
  exports.crypto = (() => {
      const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : undefined;
      const nodeRequire = typeof commonjsRequire === "function" &&
          commonjsRequire.bind(module);
      return {
          node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
          web: webCrypto
      };
  })();
  }(utils, utils.exports));

  Object.defineProperty(keccak, "__esModule", { value: true });
  keccak.keccak512 = keccak.keccak384 = keccak.keccak256 = keccak.keccak224 = void 0;
  const sha3_1 = sha3;
  const utils_1$3 = utils.exports;
  keccak.keccak224 = (0, utils_1$3.wrapHash)(sha3_1.keccak_224);
  keccak.keccak256 = (() => {
      const k = (0, utils_1$3.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
  })();
  keccak.keccak384 = (0, utils_1$3.wrapHash)(sha3_1.keccak_384);
  keccak.keccak512 = (0, utils_1$3.wrapHash)(sha3_1.keccak_512);

  var bytes = {};

  var helpers$1 = {};

  var internal = {};

  /*
  The MIT License

  Copyright (c) 2016 Nick Dodson. nickdodson.com

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE
   */
  Object.defineProperty(internal, "__esModule", { value: true });
  internal.isHexString = internal.getKeys = internal.fromAscii = internal.fromUtf8 = internal.toAscii = internal.arrayContainsArray = internal.getBinarySize = internal.padToEven = internal.stripHexPrefix = internal.isHexPrefixed = void 0;
  /**
   * Returns a `Boolean` on whether or not the a `String` starts with '0x'
   * @param str the string input value
   * @return a boolean if it is or is not hex prefixed
   * @throws if the str input is not a string
   */
  function isHexPrefixed(str) {
      if (typeof str !== 'string') {
          throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
      }
      return str[0] === '0' && str[1] === 'x';
  }
  internal.isHexPrefixed = isHexPrefixed;
  /**
   * Removes '0x' from a given `String` if present
   * @param str the string value
   * @returns the string without 0x prefix
   */
  const stripHexPrefix = (str) => {
      if (typeof str !== 'string')
          throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
      return isHexPrefixed(str) ? str.slice(2) : str;
  };
  internal.stripHexPrefix = stripHexPrefix;
  /**
   * Pads a `String` to have an even length
   * @param value
   * @return output
   */
  function padToEven(value) {
      let a = value;
      if (typeof a !== 'string') {
          throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
      }
      if (a.length % 2)
          a = `0${a}`;
      return a;
  }
  internal.padToEven = padToEven;
  /**
   * Get the binary size of a string
   * @param str
   * @returns the number of bytes contained within the string
   */
  function getBinarySize(str) {
      if (typeof str !== 'string') {
          throw new Error(`[getBinarySize] method requires input type 'string', recieved ${typeof str}`);
      }
      return Buffer$8.byteLength(str, 'utf8');
  }
  internal.getBinarySize = getBinarySize;
  /**
   * Returns TRUE if the first specified array contains all elements
   * from the second one. FALSE otherwise.
   *
   * @param superset
   * @param subset
   *
   */
  function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
          throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
      }
      if (Array.isArray(subset) !== true) {
          throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
      }
      return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0);
  }
  internal.arrayContainsArray = arrayContainsArray;
  /**
   * Should be called to get ascii from its hex representation
   *
   * @param string in hex
   * @returns ascii string representation of hex value
   */
  function toAscii(hex) {
      let str = '';
      let i = 0;
      const l = hex.length;
      if (hex.substring(0, 2) === '0x')
          i = 2;
      for (; i < l; i += 2) {
          const code = parseInt(hex.substr(i, 2), 16);
          str += String.fromCharCode(code);
      }
      return str;
  }
  internal.toAscii = toAscii;
  /**
   * Should be called to get hex representation (prefixed by 0x) of utf8 string
   *
   * @param string
   * @param optional padding
   * @returns hex representation of input string
   */
  function fromUtf8(stringValue) {
      const str = Buffer$8.from(stringValue, 'utf8');
      return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;
  }
  internal.fromUtf8 = fromUtf8;
  /**
   * Should be called to get hex representation (prefixed by 0x) of ascii string
   *
   * @param  string
   * @param  optional padding
   * @returns  hex representation of input string
   */
  function fromAscii(stringValue) {
      let hex = '';
      for (let i = 0; i < stringValue.length; i++) {
          const code = stringValue.charCodeAt(i);
          const n = code.toString(16);
          hex += n.length < 2 ? `0${n}` : n;
      }
      return `0x${hex}`;
  }
  internal.fromAscii = fromAscii;
  /**
   * Returns the keys from an array of objects.
   * @example
   * ```js
   * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']
   *````
   * @param  params
   * @param  key
   * @param  allowEmpty
   * @returns output just a simple array of output keys
   */
  function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
          throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
      }
      if (typeof key !== 'string') {
          throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
      }
      const result = [];
      for (let i = 0; i < params.length; i++) {
          let value = params[i][key];
          if (allowEmpty === true && !value) {
              value = '';
          }
          else if (typeof value !== 'string') {
              throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
          }
          result.push(value);
      }
      return result;
  }
  internal.getKeys = getKeys;
  /**
   * Is the string a hex string.
   *
   * @param  value
   * @param  length
   * @returns  output the string is a hex string
   */
  function isHexString(value, length) {
      if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))
          return false;
      if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)
          return false;
      return true;
  }
  internal.isHexString = isHexString;

  Object.defineProperty(helpers$1, "__esModule", { value: true });
  helpers$1.assertIsString = helpers$1.assertIsArray = helpers$1.assertIsBuffer = helpers$1.assertIsHexString = void 0;
  const internal_1 = internal;
  /**
   * Throws if a string is not hex prefixed
   * @param {string} input string to check hex prefix of
   */
  const assertIsHexString = function (input) {
      if (!(0, internal_1.isHexString)(input)) {
          const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
          throw new Error(msg);
      }
  };
  helpers$1.assertIsHexString = assertIsHexString;
  /**
   * Throws if input is not a buffer
   * @param {Buffer} input value to check
   */
  const assertIsBuffer = function (input) {
      if (!Buffer$8.isBuffer(input)) {
          const msg = `This method only supports Buffer but input was: ${input}`;
          throw new Error(msg);
      }
  };
  helpers$1.assertIsBuffer = assertIsBuffer;
  /**
   * Throws if input is not an array
   * @param {number[]} input value to check
   */
  const assertIsArray = function (input) {
      if (!Array.isArray(input)) {
          const msg = `This method only supports number arrays but input was: ${input}`;
          throw new Error(msg);
      }
  };
  helpers$1.assertIsArray = assertIsArray;
  /**
   * Throws if input is not a string
   * @param {string} input value to check
   */
  const assertIsString = function (input) {
      if (typeof input !== 'string') {
          const msg = `This method only supports strings but input was: ${input}`;
          throw new Error(msg);
      }
  };
  helpers$1.assertIsString = assertIsString;

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
  const helpers_1 = helpers$1;
  const internal_1 = internal;
  /**
   * Converts a `Number` into a hex `String`
   * @param {Number} i
   * @return {String}
   */
  const intToHex = function (i) {
      if (!Number.isSafeInteger(i) || i < 0) {
          throw new Error(`Received an invalid integer type: ${i}`);
      }
      return `0x${i.toString(16)}`;
  };
  exports.intToHex = intToHex;
  /**
   * Converts an `Number` to a `Buffer`
   * @param {Number} i
   * @return {Buffer}
   */
  const intToBuffer = function (i) {
      const hex = (0, exports.intToHex)(i);
      return Buffer$8.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');
  };
  exports.intToBuffer = intToBuffer;
  /**
   * Returns a buffer filled with 0s.
   * @param bytes the number of bytes the buffer should be
   */
  const zeros = function (bytes) {
      return Buffer$8.allocUnsafe(bytes).fill(0);
  };
  exports.zeros = zeros;
  /**
   * Pads a `Buffer` with zeros till it has `length` bytes.
   * Truncates the beginning or end of input if its length exceeds `length`.
   * @param msg the value to pad (Buffer)
   * @param length the number of bytes the output should be
   * @param right whether to start padding form the left or right
   * @return (Buffer)
   */
  const setLength = function (msg, length, right) {
      const buf = (0, exports.zeros)(length);
      if (right) {
          if (msg.length < length) {
              msg.copy(buf);
              return buf;
          }
          return msg.slice(0, length);
      }
      else {
          if (msg.length < length) {
              msg.copy(buf, length - msg.length);
              return buf;
          }
          return msg.slice(-length);
      }
  };
  /**
   * Left Pads a `Buffer` with leading zeros till it has `length` bytes.
   * Or it truncates the beginning if it exceeds.
   * @param msg the value to pad (Buffer)
   * @param length the number of bytes the output should be
   * @return (Buffer)
   */
  const setLengthLeft = function (msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
  };
  exports.setLengthLeft = setLengthLeft;
  /**
   * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.
   * it truncates the end if it exceeds.
   * @param msg the value to pad (Buffer)
   * @param length the number of bytes the output should be
   * @return (Buffer)
   */
  const setLengthRight = function (msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
  };
  exports.setLengthRight = setLengthRight;
  /**
   * Trims leading zeros from a `Buffer`, `String` or `Number[]`.
   * @param a (Buffer|Array|String)
   * @return (Buffer|Array|String)
   */
  const stripZeros = function (a) {
      let first = a[0];
      while (a.length > 0 && first.toString() === '0') {
          a = a.slice(1);
          first = a[0];
      }
      return a;
  };
  /**
   * Trims leading zeros from a `Buffer`.
   * @param a (Buffer)
   * @return (Buffer)
   */
  const unpadBuffer = function (a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
  };
  exports.unpadBuffer = unpadBuffer;
  /**
   * Trims leading zeros from an `Array` (of numbers).
   * @param a (number[])
   * @return (number[])
   */
  const unpadArray = function (a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
  };
  exports.unpadArray = unpadArray;
  /**
   * Trims leading zeros from a hex-prefixed `String`.
   * @param a (String)
   * @return (String)
   */
  const unpadHexString = function (a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return ('0x' + stripZeros(a));
  };
  exports.unpadHexString = unpadHexString;
  /**
   * Attempts to turn a value into a `Buffer`.
   * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects
   * with a `toArray()` or `toBuffer()` method.
   * @param v the value
   */
  const toBuffer = function (v) {
      if (v === null || v === undefined) {
          return Buffer$8.allocUnsafe(0);
      }
      if (Buffer$8.isBuffer(v)) {
          return Buffer$8.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
          return Buffer$8.from(v);
      }
      if (typeof v === 'string') {
          if (!(0, internal_1.isHexString)(v)) {
              throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
          }
          return Buffer$8.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');
      }
      if (typeof v === 'number') {
          return (0, exports.intToBuffer)(v);
      }
      if (typeof v === 'bigint') {
          if (v < BigInt(0)) {
              throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);
          }
          let n = v.toString(16);
          if (n.length % 2)
              n = '0' + n;
          return Buffer$8.from(n, 'hex');
      }
      if (v.toArray) {
          // converts a BN to a Buffer
          return Buffer$8.from(v.toArray());
      }
      if (v.toBuffer) {
          return Buffer$8.from(v.toBuffer());
      }
      throw new Error('invalid type');
  };
  exports.toBuffer = toBuffer;
  /**
   * Converts a `Buffer` into a `0x`-prefixed hex `String`.
   * @param buf `Buffer` object to convert
   */
  const bufferToHex = function (buf) {
      buf = (0, exports.toBuffer)(buf);
      return '0x' + buf.toString('hex');
  };
  exports.bufferToHex = bufferToHex;
  /**
   * Converts a {@link Buffer} to a {@link bigint}
   */
  function bufferToBigInt(buf) {
      const hex = (0, exports.bufferToHex)(buf);
      if (hex === '0x') {
          return BigInt(0);
      }
      return BigInt(hex);
  }
  exports.bufferToBigInt = bufferToBigInt;
  /**
   * Converts a {@link bigint} to a {@link Buffer}
   */
  function bigIntToBuffer(num) {
      return (0, exports.toBuffer)('0x' + num.toString(16));
  }
  exports.bigIntToBuffer = bigIntToBuffer;
  /**
   * Converts a `Buffer` to a `Number`.
   * @param buf `Buffer` object to convert
   * @throws If the input number exceeds 53 bits.
   */
  const bufferToInt = function (buf) {
      const res = Number(bufferToBigInt(buf));
      if (!Number.isSafeInteger(res))
          throw new Error('Number exceeds 53 bits');
      return res;
  };
  exports.bufferToInt = bufferToInt;
  /**
   * Interprets a `Buffer` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.
   * @param num Signed integer value
   */
  const fromSigned = function (num) {
      return BigInt.asIntN(256, bufferToBigInt(num));
  };
  exports.fromSigned = fromSigned;
  /**
   * Converts a `BigInt` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
   * @param num
   */
  const toUnsigned = function (num) {
      return bigIntToBuffer(BigInt.asUintN(256, num));
  };
  exports.toUnsigned = toUnsigned;
  /**
   * Adds "0x" to a given `String` if it does not already start with "0x".
   */
  const addHexPrefix = function (str) {
      if (typeof str !== 'string') {
          return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;
  };
  exports.addHexPrefix = addHexPrefix;
  /**
   * Shortens a string  or buffer's hex string representation to maxLength (default 50).
   *
   * Examples:
   *
   * Input:  '657468657265756d000000000000000000000000000000000000000000000000'
   * Output: '657468657265756d0000000000000000000000000000000000…'
   */
  function short(buffer, maxLength = 50) {
      const bufferStr = Buffer$8.isBuffer(buffer) ? buffer.toString('hex') : buffer;
      if (bufferStr.length <= maxLength) {
          return bufferStr;
      }
      return bufferStr.slice(0, maxLength) + '…';
  }
  exports.short = short;
  /**
   * Returns the utf8 string representation from a hex string.
   *
   * Examples:
   *
   * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'
   * Input 2: '657468657265756d'
   * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'
   *
   * Output (all 3 input variants): 'ethereum'
   *
   * Note that this method is not intended to be used with hex strings
   * representing quantities in both big endian or little endian notation.
   *
   * @param string Hex string, should be `0x` prefixed
   * @return Utf8 string
   */
  const toUtf8 = function (hex) {
      const zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
          throw new Error('Invalid non-even hex string input for toUtf8() provided');
      }
      const bufferVal = Buffer$8.from(hex.replace(zerosRegexp, ''), 'hex');
      return bufferVal.toString('utf8');
  };
  exports.toUtf8 = toUtf8;
  /**
   * Converts a `Buffer` or `Array` to JSON.
   * @param ba (Buffer|Array)
   * @return (Array|String|null)
   */
  const baToJSON = function (ba) {
      if (Buffer$8.isBuffer(ba)) {
          return `0x${ba.toString('hex')}`;
      }
      else if (ba instanceof Array) {
          const array = [];
          for (let i = 0; i < ba.length; i++) {
              array.push((0, exports.baToJSON)(ba[i]));
          }
          return array;
      }
  };
  exports.baToJSON = baToJSON;
  /**
   * Checks provided Buffers for leading zeroes and throws if found.
   *
   * Examples:
   *
   * Valid values: 0x1, 0x, 0x01, 0x1234
   * Invalid values: 0x0, 0x00, 0x001, 0x0001
   *
   * Note: This method is useful for validating that RLP encoded integers comply with the rule that all
   * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes
   * @param values An object containing string keys and Buffer values
   * @throws if any provided value is found to have leading zero bytes
   */
  const validateNoLeadingZeroes = function (values) {
      for (const [k, v] of Object.entries(values)) {
          if (v !== undefined && v.length > 0 && v[0] === 0) {
              throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);
          }
      }
  };
  exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
  function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
          return Buffer$8.from(arr);
      }
      return arr.map((a) => arrToBufArr(a));
  }
  exports.arrToBufArr = arrToBufArr;
  function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
          return Uint8Array.from(arr ?? []);
      }
      return arr.map((a) => bufArrToArr(a));
  }
  exports.bufArrToArr = bufArrToArr;
  /**
   * Converts a {@link bigint} to a `0x` prefixed hex string
   */
  const bigIntToHex = (num) => {
      return '0x' + num.toString(16);
  };
  exports.bigIntToHex = bigIntToHex;
  /**
   * Convert value from bigint to an unpadded Buffer
   * (useful for RLP transport)
   * @param value value to convert
   */
  function bigIntToUnpaddedBuffer(value) {
      return (0, exports.unpadBuffer)(bigIntToBuffer(value));
  }
  exports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;

  }(bytes));

  var types$5 = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTruthy = exports.isFalsy = exports.toType = exports.TypeOutput = void 0;
  const bytes_1 = bytes;
  const internal_1 = internal;
  /**
   * Type output options
   */
  var TypeOutput;
  (function (TypeOutput) {
      TypeOutput[TypeOutput["Number"] = 0] = "Number";
      TypeOutput[TypeOutput["BigInt"] = 1] = "BigInt";
      TypeOutput[TypeOutput["Buffer"] = 2] = "Buffer";
      TypeOutput[TypeOutput["PrefixedHexString"] = 3] = "PrefixedHexString";
  })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
  function toType(input, outputType) {
      if (input === null) {
          return null;
      }
      if (input === undefined) {
          return undefined;
      }
      if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {
          throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
      }
      else if (typeof input === 'number' && !Number.isSafeInteger(input)) {
          throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
      }
      const output = (0, bytes_1.toBuffer)(input);
      switch (outputType) {
          case TypeOutput.Buffer:
              return output;
          case TypeOutput.BigInt:
              return (0, bytes_1.bufferToBigInt)(output);
          case TypeOutput.Number: {
              const bigInt = (0, bytes_1.bufferToBigInt)(output);
              if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
                  throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');
              }
              return Number(bigInt);
          }
          case TypeOutput.PrefixedHexString:
              return (0, bytes_1.bufferToHex)(output);
          default:
              throw new Error('unknown outputType');
      }
  }
  exports.toType = toType;
  /**
   * Returns true if a value is falsy
   *
   * @param value - Value to check for falseness
   *
   * @deprecated This helper function should only be used temporarily until the monorepo types are explicit enough
   */
  function isFalsy(value) {
      return !!(value === false ||
          value === '' ||
          value === 0 ||
          Number.isNaN(value) ||
          value === null ||
          typeof value === 'undefined' ||
          value === BigInt(0));
  }
  exports.isFalsy = isFalsy;
  /**
   * Returns true if a value is truthy
   *
   * @param value - Value to check for truthiness
   *
   * @deprecated This helper function should only be used temporarily until the monorepo types are explicit enough
   */
  function isTruthy(value) {
      return !isFalsy(value);
  }
  exports.isTruthy = isTruthy;

  }(types$5));

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
  const rlp_1 = dist$9;
  const keccak_1 = keccak;
  const secp256k1_1 = secp256k1;
  const utils_1 = utils.exports;
  const bytes_1 = bytes;
  const constants_1 = constants$1;
  const helpers_1 = helpers$1;
  const internal_1 = internal;
  const types_1 = types$5;
  const _0n = BigInt(0);
  class Account {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating an Account from varying data types.
       */
      constructor(nonce = _0n, balance = _0n, stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
          this.nonce = nonce;
          this.balance = balance;
          this.stateRoot = stateRoot;
          this.codeHash = codeHash;
          this._validate();
      }
      static fromAccountData(accountData) {
          const { nonce, balance, stateRoot, codeHash } = accountData;
          return new Account((0, types_1.isTruthy)(nonce) ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, (0, types_1.isTruthy)(balance) ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, (0, types_1.isTruthy)(stateRoot) ? (0, bytes_1.toBuffer)(stateRoot) : undefined, (0, types_1.isTruthy)(codeHash) ? (0, bytes_1.toBuffer)(codeHash) : undefined);
      }
      static fromRlpSerializedAccount(serialized) {
          const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
          if (!Array.isArray(values)) {
              throw new Error('Invalid serialized account input. Must be array');
          }
          return this.fromValuesArray(values);
      }
      static fromValuesArray(values) {
          const [nonce, balance, stateRoot, codeHash] = values;
          return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), stateRoot, codeHash);
      }
      _validate() {
          if (this.nonce < _0n) {
              throw new Error('nonce must be greater than zero');
          }
          if (this.balance < _0n) {
              throw new Error('balance must be greater than zero');
          }
          if (this.stateRoot.length !== 32) {
              throw new Error('stateRoot must have a length of 32');
          }
          if (this.codeHash.length !== 32) {
              throw new Error('codeHash must have a length of 32');
          }
      }
      /**
       * Returns a Buffer Array of the raw Buffers for the account, in order.
       */
      raw() {
          return [
              (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),
              (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),
              this.stateRoot,
              this.codeHash,
          ];
      }
      /**
       * Returns the RLP serialization of the account as a `Buffer`.
       */
      serialize() {
          return Buffer$8.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));
      }
      /**
       * Returns a `Boolean` determining if the account is a contract.
       */
      isContract() {
          return !this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
      /**
       * Returns a `Boolean` determining if the account is empty complying to the definition of
       * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
       * "An account is considered empty when it has no code and zero nonce and zero balance."
       */
      isEmpty() {
          return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
  }
  exports.Account = Account;
  /**
   * Checks if the address is a valid. Accepts checksummed addresses too.
   */
  const isValidAddress = function (hexAddress) {
      try {
          (0, helpers_1.assertIsString)(hexAddress);
      }
      catch (e) {
          return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
  };
  exports.isValidAddress = isValidAddress;
  /**
   * Returns a checksummed address.
   *
   * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
   * has the effect of checksummed addresses for one chain having invalid checksums for others.
   * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).
   *
   * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not
   * backwards compatible to the original widely adopted checksum format standard introduced in
   * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.
   * Usage of this EIP is therefore discouraged unless you have a very targeted use case.
   */
  const toChecksumAddress = function (hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      let prefix = '';
      if ((0, types_1.isTruthy)(eip1191ChainId)) {
          const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));
          prefix = chainId.toString() + '0x';
      }
      const buf = Buffer$8.from(prefix + address, 'utf8');
      const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));
      let ret = '0x';
      for (let i = 0; i < address.length; i++) {
          if (parseInt(hash[i], 16) >= 8) {
              ret += address[i].toUpperCase();
          }
          else {
              ret += address[i];
          }
      }
      return ret;
  };
  exports.toChecksumAddress = toChecksumAddress;
  /**
   * Checks if the address is a valid checksummed address.
   *
   * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
   */
  const isValidChecksumAddress = function (hexAddress, eip1191ChainId) {
      return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
  };
  exports.isValidChecksumAddress = isValidChecksumAddress;
  /**
   * Generates an address of a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  const generateAddress = function (from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {
          // in RLP we want to encode null in the case of zero nonce
          // read the RLP documentation for an answer if you dare
          return Buffer$8.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);
      }
      // Only take the lower 160bits of the hash
      return Buffer$8.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);
  };
  exports.generateAddress = generateAddress;
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  const generateAddress2 = function (from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      if (from.length !== 20) {
          throw new Error('Expected from to be of length 20');
      }
      if (salt.length !== 32) {
          throw new Error('Expected salt to be of length 32');
      }
      const address = (0, keccak_1.keccak256)(Buffer$8.concat([Buffer$8.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));
      return (0, bytes_1.toBuffer)(address).slice(-20);
  };
  exports.generateAddress2 = generateAddress2;
  /**
   * Checks if the private key satisfies the rules of the curve secp256k1.
   */
  const isValidPrivate = function (privateKey) {
      return secp256k1_1.utils.isValidPrivateKey(privateKey);
  };
  exports.isValidPrivate = isValidPrivate;
  /**
   * Checks if the public key satisfies the rules of the curve secp256k1
   * and the requirements of Ethereum.
   * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
   * @param sanitize Accept public keys in other formats
   */
  const isValidPublic = function (publicKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
          // Convert to SEC1 for secp256k1
          // Automatically checks whether point is on curve
          try {
              secp256k1_1.Point.fromHex(Buffer$8.concat([Buffer$8.from([4]), publicKey]));
              return true;
          }
          catch (e) {
              return false;
          }
      }
      if (!sanitize) {
          return false;
      }
      try {
          secp256k1_1.Point.fromHex(publicKey);
          return true;
      }
      catch (e) {
          return false;
      }
  };
  exports.isValidPublic = isValidPublic;
  /**
   * Returns the ethereum address of a given public key.
   * Accepts "Ethereum public keys" and SEC1 encoded keys.
   * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
   * @param sanitize Accept public keys in other formats
   */
  const pubToAddress = function (pubKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
          pubKey = Buffer$8.from(secp256k1_1.Point.fromHex(pubKey).toRawBytes(false).slice(1));
      }
      if (pubKey.length !== 64) {
          throw new Error('Expected pubKey to be of length 64');
      }
      // Only take the lower 160bits of the hash
      return Buffer$8.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
  };
  exports.pubToAddress = pubToAddress;
  exports.publicToAddress = exports.pubToAddress;
  /**
   * Returns the ethereum public key of a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  const privateToPublic = function (privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      // skip the type flag and use the X, Y points
      return Buffer$8.from(secp256k1_1.Point.fromPrivateKey(privateKey).toRawBytes(false).slice(1));
  };
  exports.privateToPublic = privateToPublic;
  /**
   * Returns the ethereum address of a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  const privateToAddress = function (privateKey) {
      return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
  };
  exports.privateToAddress = privateToAddress;
  /**
   * Converts a public key to the Ethereum format.
   */
  const importPublic = function (publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
          publicKey = Buffer$8.from(secp256k1_1.Point.fromHex(publicKey).toRawBytes(false).slice(1));
      }
      return publicKey;
  };
  exports.importPublic = importPublic;
  /**
   * Returns the zero address.
   */
  const zeroAddress = function () {
      const addressLength = 20;
      const addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
  };
  exports.zeroAddress = zeroAddress;
  /**
   * Checks if a given address is the zero address.
   */
  const isZeroAddress = function (hexAddress) {
      try {
          (0, helpers_1.assertIsString)(hexAddress);
      }
      catch (e) {
          return false;
      }
      const zeroAddr = (0, exports.zeroAddress)();
      return zeroAddr === hexAddress;
  };
  exports.isZeroAddress = isZeroAddress;

  }(account));

  var address = {};

  Object.defineProperty(address, "__esModule", { value: true });
  address.Address = void 0;
  const account_1 = account;
  const bytes_1$1 = bytes;
  class Address {
      constructor(buf) {
          if (buf.length !== 20) {
              throw new Error('Invalid address length');
          }
          this.buf = buf;
      }
      /**
       * Returns the zero address.
       */
      static zero() {
          return new Address((0, bytes_1$1.zeros)(20));
      }
      /**
       * Returns an Address object from a hex-encoded string.
       * @param str - Hex-encoded address
       */
      static fromString(str) {
          if (!(0, account_1.isValidAddress)(str)) {
              throw new Error('Invalid address');
          }
          return new Address((0, bytes_1$1.toBuffer)(str));
      }
      /**
       * Returns an address for a given public key.
       * @param pubKey The two points of an uncompressed key
       */
      static fromPublicKey(pubKey) {
          if (!Buffer$8.isBuffer(pubKey)) {
              throw new Error('Public key should be Buffer');
          }
          const buf = (0, account_1.pubToAddress)(pubKey);
          return new Address(buf);
      }
      /**
       * Returns an address for a given private key.
       * @param privateKey A private key must be 256 bits wide
       */
      static fromPrivateKey(privateKey) {
          if (!Buffer$8.isBuffer(privateKey)) {
              throw new Error('Private key should be Buffer');
          }
          const buf = (0, account_1.privateToAddress)(privateKey);
          return new Address(buf);
      }
      /**
       * Generates an address for a newly created contract.
       * @param from The address which is creating this new address
       * @param nonce The nonce of the from account
       */
      static generate(from, nonce) {
          if (typeof nonce !== 'bigint') {
              throw new Error('Expected nonce to be a bigint');
          }
          return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1$1.bigIntToBuffer)(nonce)));
      }
      /**
       * Generates an address for a contract created using CREATE2.
       * @param from The address which is creating this new address
       * @param salt A salt
       * @param initCode The init code of the contract being created
       */
      static generate2(from, salt, initCode) {
          if (!Buffer$8.isBuffer(salt)) {
              throw new Error('Expected salt to be a Buffer');
          }
          if (!Buffer$8.isBuffer(initCode)) {
              throw new Error('Expected initCode to be a Buffer');
          }
          return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
      }
      /**
       * Is address equal to another.
       */
      equals(address) {
          return this.buf.equals(address.buf);
      }
      /**
       * Is address zero.
       */
      isZero() {
          return this.equals(Address.zero());
      }
      /**
       * True if address is in the address range defined
       * by EIP-1352
       */
      isPrecompileOrSystemAddress() {
          const address = (0, bytes_1$1.bufferToBigInt)(this.buf);
          const rangeMin = BigInt(0);
          const rangeMax = BigInt('0xffff');
          return address >= rangeMin && address <= rangeMax;
      }
      /**
       * Returns hex encoding of address.
       */
      toString() {
          return '0x' + this.buf.toString('hex');
      }
      /**
       * Returns Buffer representation of address.
       */
      toBuffer() {
          return Buffer$8.from(this.buf);
      }
  }
  address.Address = Address;

  var signature = {};

  Object.defineProperty(signature, "__esModule", { value: true });
  signature.hashPersonalMessage = signature.isValidSignature = signature.fromRpcSig = signature.toCompactSig = signature.toRpcSig = signature.ecrecover = signature.ecsign = void 0;
  const keccak_1$b = keccak;
  const secp256k1_1 = secp256k1;
  const bytes_1 = bytes;
  const constants_1 = constants$1;
  const helpers_1$1 = helpers$1;
  /**
   * Returns the ECDSA signature of a message hash.
   *
   * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value
   * accordingly, otherwise return a "static" `v` just derived from the `recovery` bit
   */
  function ecsign(msgHash, privateKey, chainId) {
      const [signature, recovery] = (0, secp256k1_1.signSync)(msgHash, privateKey, { recovered: true, der: false });
      const r = Buffer$8.from(signature.slice(0, 32));
      const s = Buffer$8.from(signature.slice(32, 64));
      const v = chainId === undefined
          ? BigInt(recovery + 27)
          : BigInt(recovery + 35) + BigInt(chainId) * BigInt(2);
      return { r, s, v };
  }
  signature.ecsign = ecsign;
  function calculateSigRecovery(v, chainId) {
      if (v === BigInt(0) || v === BigInt(1))
          return v;
      if (chainId === undefined) {
          return v - BigInt(27);
      }
      return v - (chainId * BigInt(2) + BigInt(35));
  }
  function isValidSigRecovery(recovery) {
      return recovery === BigInt(0) || recovery === BigInt(1);
  }
  /**
   * ECDSA public key recovery from signature.
   * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
   * @returns Recovered public key
   */
  const ecrecover = function (msgHash, v, r, s, chainId) {
      const signature = Buffer$8.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
          throw new Error('Invalid signature v value');
      }
      const senderPubKey = (0, secp256k1_1.recoverPublicKey)(msgHash, signature, Number(recovery));
      return Buffer$8.from(senderPubKey.slice(1));
  };
  signature.ecrecover = ecrecover;
  /**
   * Convert signature parameters into the format of `eth_sign` RPC method.
   * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
   * @returns Signature
   */
  const toRpcSig = function (v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
          throw new Error('Invalid signature v value');
      }
      // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
      return (0, bytes_1.bufferToHex)(Buffer$8.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
  };
  signature.toRpcSig = toRpcSig;
  /**
   * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).
   * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
   * @returns Signature
   */
  const toCompactSig = function (v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
          throw new Error('Invalid signature v value');
      }
      let ss = s;
      if ((v > BigInt(28) && v % BigInt(2) === BigInt(1)) || v === BigInt(1) || v === BigInt(28)) {
          ss = Buffer$8.from(s);
          ss[0] |= 0x80;
      }
      return (0, bytes_1.bufferToHex)(Buffer$8.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
  };
  signature.toCompactSig = toCompactSig;
  /**
   * Convert signature format of the `eth_sign` RPC method to signature parameters
   *
   * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)
   * `v + 27` is returned for the `v` value
   * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes
   * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.
   */
  const fromRpcSig = function (sig) {
      const buf = (0, bytes_1.toBuffer)(sig);
      let r;
      let s;
      let v;
      if (buf.length >= 65) {
          r = buf.slice(0, 32);
          s = buf.slice(32, 64);
          v = (0, bytes_1.bufferToBigInt)(buf.slice(64));
      }
      else if (buf.length === 64) {
          // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)
          r = buf.slice(0, 32);
          s = buf.slice(32, 64);
          v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);
          s[0] &= 0x7f;
      }
      else {
          throw new Error('Invalid signature length');
      }
      // support both versions of `eth_sign` responses
      if (v < 27) {
          v = v + BigInt(27);
      }
      return {
          v,
          r,
          s,
      };
  };
  signature.fromRpcSig = fromRpcSig;
  /**
   * Validate a ECDSA signature.
   * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions
   * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
   */
  const isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {
      if (r.length !== 32 || s.length !== 32) {
          return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
          return false;
      }
      const rBigInt = (0, bytes_1.bufferToBigInt)(r);
      const sBigInt = (0, bytes_1.bufferToBigInt)(s);
      if (rBigInt === BigInt(0) ||
          rBigInt >= constants_1.SECP256K1_ORDER ||
          sBigInt === BigInt(0) ||
          sBigInt >= constants_1.SECP256K1_ORDER) {
          return false;
      }
      if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {
          return false;
      }
      return true;
  };
  signature.isValidSignature = isValidSignature;
  /**
   * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
   * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
   * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
   * used to produce the signature.
   */
  const hashPersonalMessage = function (message) {
      (0, helpers_1$1.assertIsBuffer)(message);
      const prefix = Buffer$8.from(`\u0019Ethereum Signed Message:\n${message.length}`, 'utf-8');
      return Buffer$8.from((0, keccak_1$b.keccak256)(Buffer$8.concat([prefix, message])));
  };
  signature.hashPersonalMessage = hashPersonalMessage;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;
  /**
   * Constants
   */
  __exportStar(constants$1, exports);
  /**
   * Account class and helper functions
   */
  __exportStar(account, exports);
  /**
   * Address type
   */
  __exportStar(address, exports);
  /**
   * ECDSA signature
   */
  __exportStar(signature, exports);
  /**
   * Utilities for manipulating Buffers, byte arrays, etc.
   */
  __exportStar(bytes, exports);
  /**
   * Helpful TypeScript types
   */
  __exportStar(types$5, exports);
  /**
   * Export ethjs-util methods
   */
  var internal_1 = internal;
  Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function () { return internal_1.arrayContainsArray; } });
  Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function () { return internal_1.fromAscii; } });
  Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function () { return internal_1.fromUtf8; } });
  Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function () { return internal_1.getBinarySize; } });
  Object.defineProperty(exports, "getKeys", { enumerable: true, get: function () { return internal_1.getKeys; } });
  Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function () { return internal_1.isHexPrefixed; } });
  Object.defineProperty(exports, "isHexString", { enumerable: true, get: function () { return internal_1.isHexString; } });
  Object.defineProperty(exports, "padToEven", { enumerable: true, get: function () { return internal_1.padToEven; } });
  Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function () { return internal_1.stripHexPrefix; } });
  Object.defineProperty(exports, "toAscii", { enumerable: true, get: function () { return internal_1.toAscii; } });

  }(dist$a));

  Object.defineProperty(bloom, "__esModule", { value: true });
  bloom.Bloom = void 0;
  const util_1$T = dist$a;
  const keccak_1$a = keccak;
  const BYTE_SIZE = 256;
  class Bloom {
      /**
       * Represents a Bloom filter.
       */
      constructor(bitvector) {
          if (!bitvector) {
              this.bitvector = (0, util_1$T.zeros)(BYTE_SIZE);
          }
          else {
              if (bitvector.length !== BYTE_SIZE)
                  throw new Error('bitvectors must be 2048 bits long');
              this.bitvector = bitvector;
          }
      }
      /**
       * Adds an element to a bit vector of a 64 byte bloom filter.
       * @param e - The element to add
       */
      add(e) {
          e = Buffer$8.from((0, keccak_1$a.keccak256)(e));
          const mask = 2047; // binary 11111111111
          for (let i = 0; i < 3; i++) {
              const first2bytes = e.readUInt16BE(i * 2);
              const loc = mask & first2bytes;
              const byteLoc = loc >> 3;
              const bitLoc = 1 << loc % 8;
              this.bitvector[BYTE_SIZE - byteLoc - 1] |= bitLoc;
          }
      }
      /**
       * Checks if an element is in the bloom.
       * @param e - The element to check
       */
      check(e) {
          e = Buffer$8.from((0, keccak_1$a.keccak256)(e));
          const mask = 2047; // binary 11111111111
          let match = true;
          for (let i = 0; i < 3 && match; i++) {
              const first2bytes = e.readUInt16BE(i * 2);
              const loc = mask & first2bytes;
              const byteLoc = loc >> 3;
              const bitLoc = 1 << loc % 8;
              match = (this.bitvector[BYTE_SIZE - byteLoc - 1] & bitLoc) !== 0;
          }
          return Boolean(match);
      }
      /**
       * Checks if multiple topics are in a bloom.
       * @returns `true` if every topic is in the bloom
       */
      multiCheck(topics) {
          return topics.every((t) => this.check(t));
      }
      /**
       * Bitwise or blooms together.
       */
      or(bloom) {
          if ((0, util_1$T.isTruthy)(bloom)) {
              for (let i = 0; i <= BYTE_SIZE; i++) {
                  this.bitvector[i] = this.bitvector[i] | bloom.bitvector[i];
              }
          }
      }
  }
  bloom.Bloom = Bloom;

  var eei = {};

  var vmState = {};

  var dist$8 = {};

  var common$2 = {};

  var events = {exports: {}};

  var R = typeof Reflect === 'object' ? Reflect : null;
  var ReflectApply = R && typeof R.apply === 'function'
    ? R.apply
    : function ReflectApply(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };

  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target)
        .concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target);
    };
  }

  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }

  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
  };

  function EventEmitter$1() {
    EventEmitter$1.init.call(this);
  }
  events.exports = EventEmitter$1;
  events.exports.once = once$3;

  // Backwards-compat with node 0.10.x
  EventEmitter$1.EventEmitter = EventEmitter$1;

  EventEmitter$1.prototype._events = undefined;
  EventEmitter$1.prototype._eventsCount = 0;
  EventEmitter$1.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  var defaultMaxListeners = 10;

  function checkListener(listener) {
    if (typeof listener !== 'function') {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }

  Object.defineProperty(EventEmitter$1, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
      }
      defaultMaxListeners = arg;
    }
  });

  EventEmitter$1.init = function() {

    if (this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
  };

  function _getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter$1.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };

  EventEmitter$1.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = (type === 'error');

    var events = this._events;
    if (events !== undefined)
      doError = (doError && events.error === undefined);
    else if (!doError)
      return false;

    // If there is no 'error' event listener then throw.
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
      }
      // At least give some kind of context to the user
      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
      err.context = er;
      throw err; // Unhandled 'error' event
    }

    var handler = events[type];

    if (handler === undefined)
      return false;

    if (typeof handler === 'function') {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    checkListener(listener);

    events = target._events;
    if (events === undefined) {
      events = target._events = Object.create(null);
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener !== undefined) {
        target.emit('newListener', type,
                    listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (existing === undefined) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
        // If we've already got an array, just append.
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }

      // Check for listener leak
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        // No error code for this since it is a Warning
        // eslint-disable-next-line no-restricted-syntax
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + String(type) + ' listeners ' +
                            'added. Use emitter.setMaxListeners() to ' +
                            'increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }

    return target;
  }

  EventEmitter$1.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;

  EventEmitter$1.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }

  function _onceWrap(target, type, listener) {
    var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }

  EventEmitter$1.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter$1.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

  // Emits a 'removeListener' event if and only if the listener was removed.
  EventEmitter$1.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        checkListener(listener);

        events = this._events;
        if (events === undefined)
          return this;

        list = events[type];
        if (list === undefined)
          return this;

        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            return this;

          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }

          if (list.length === 1)
            events[type] = list[0];

          if (events.removeListener !== undefined)
            this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };

  EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;

  EventEmitter$1.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events, i;

        events = this._events;
        if (events === undefined)
          return this;

        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else
              delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }

        return this;
      };

  function _listeners(target, type, unwrap) {
    var events = target._events;

    if (events === undefined)
      return [];

    var evlistener = events[type];
    if (evlistener === undefined)
      return [];

    if (typeof evlistener === 'function')
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];

    return unwrap ?
      unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }

  EventEmitter$1.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };

  EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };

  EventEmitter$1.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount$1.call(emitter, type);
    }
  };

  EventEmitter$1.prototype.listenerCount = listenerCount$1;
  function listenerCount$1(type) {
    var events = this._events;

    if (events !== undefined) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener !== undefined) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter$1.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };

  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }

  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  function once$3(emitter, name) {
    return new Promise(function (resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }

      function resolver() {
        if (typeof emitter.removeListener === 'function') {
          emitter.removeListener('error', errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== 'error') {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }

  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
  }

  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === 'function') {
      // EventTarget does not have `error` event semantics like Node
      // EventEmitters, we do not listen for `error` events here.
      emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }

  var EE = events.exports;

  var crc32 = {};

  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */

  (function (exports) {
  (function (factory) {
  	/*jshint ignore:start */
  	/*eslint-disable */
  	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
  		{
  			factory(exports);
  		}
  	} else {
  		factory({});
  	}
  	/*eslint-enable */
  	/*jshint ignore:end */
  }(function(CRC32) {
  CRC32.version = '1.2.2';
  /*global Int32Array */
  function signed_crc_table() {
  	var c = 0, table = new Array(256);

  	for(var n =0; n != 256; ++n){
  		c = n;
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		table[n] = c;
  	}

  	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
  }

  var T0 = signed_crc_table();
  function slice_by_16_tables(T) {
  	var c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;

  	for(n = 0; n != 256; ++n) table[n] = T[n];
  	for(n = 0; n != 256; ++n) {
  		v = T[n];
  		for(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];
  	}
  	var out = [];
  	for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
  	return out;
  }
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];
  var T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];
  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
  function crc32_bstr(bstr, seed) {
  	var C = seed ^ -1;
  	for(var i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];
  	return ~C;
  }

  function crc32_buf(B, seed) {
  	var C = seed ^ -1, L = B.length - 15, i = 0;
  	for(; i < L;) C =
  		Tf[B[i++] ^ (C & 255)] ^
  		Te[B[i++] ^ ((C >> 8) & 255)] ^
  		Td[B[i++] ^ ((C >> 16) & 255)] ^
  		Tc[B[i++] ^ (C >>> 24)] ^
  		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^
  		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^
  		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
  	L += 15;
  	while(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];
  	return ~C;
  }

  function crc32_str(str, seed) {
  	var C = seed ^ -1;
  	for(var i = 0, L = str.length, c = 0, d = 0; i < L;) {
  		c = str.charCodeAt(i++);
  		if(c < 0x80) {
  			C = (C>>>8) ^ T0[(C^c)&0xFF];
  		} else if(c < 0x800) {
  			C = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
  		} else if(c >= 0xD800 && c < 0xE000) {
  			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
  			C = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];
  		} else {
  			C = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
  		}
  	}
  	return ~C;
  }
  CRC32.table = T0;
  // $FlowIgnore
  CRC32.bstr = crc32_bstr;
  // $FlowIgnore
  CRC32.buf = crc32_buf;
  // $FlowIgnore
  CRC32.str = crc32_str;
  }));
  }(crc32));

  var name$J = "goerli";
  var chainId$5 = 5;
  var networkId$5 = 5;
  var defaultHardfork$5 = "merge";
  var consensus$7 = {
  	type: "poa",
  	algorithm: "clique",
  	clique: {
  		period: 15,
  		epoch: 30000
  	}
  };
  var comment$J = "Cross-client PoA test network";
  var url$J = "https://github.com/goerli/testnet";
  var genesis$5 = {
  	timestamp: "0x5c51a607",
  	gasLimit: 10485760,
  	difficulty: 1,
  	nonce: "0x0000000000000000",
  	extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  };
  var hardforks$6 = [
  	{
  		name: "chainstart",
  		block: 0,
  		forkHash: "0xa3f5ab08"
  	},
  	{
  		name: "homestead",
  		block: 0,
  		forkHash: "0xa3f5ab08"
  	},
  	{
  		name: "tangerineWhistle",
  		block: 0,
  		forkHash: "0xa3f5ab08"
  	},
  	{
  		name: "spuriousDragon",
  		block: 0,
  		forkHash: "0xa3f5ab08"
  	},
  	{
  		name: "byzantium",
  		block: 0,
  		forkHash: "0xa3f5ab08"
  	},
  	{
  		name: "constantinople",
  		block: 0,
  		forkHash: "0xa3f5ab08"
  	},
  	{
  		name: "petersburg",
  		block: 0,
  		forkHash: "0xa3f5ab08"
  	},
  	{
  		name: "istanbul",
  		block: 1561651,
  		forkHash: "0xc25efa5c"
  	},
  	{
  		name: "berlin",
  		block: 4460644,
  		forkHash: "0x757a1c47"
  	},
  	{
  		name: "london",
  		block: 5062605,
  		forkHash: "0xb8c6299d"
  	},
  	{
  		"//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
  		name: "merge",
  		ttd: "10790000",
  		block: null,
  		forkHash: "0xb8c6299d"
  	},
  	{
  		name: "mergeForkIdTransition",
  		block: null,
  		forkHash: null
  	},
  	{
  		name: "shanghai",
  		block: null,
  		forkHash: null
  	}
  ];
  var bootstrapNodes$5 = [
  	{
  		ip: "51.141.78.53",
  		port: 30303,
  		id: "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
  		location: "",
  		comment: "Upstream bootnode 1"
  	},
  	{
  		ip: "13.93.54.137",
  		port: 30303,
  		id: "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
  		location: "",
  		comment: "Upstream bootnode 2"
  	},
  	{
  		ip: "94.237.54.114",
  		port: 30313,
  		id: "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
  		location: "",
  		comment: "Upstream bootnode 3"
  	},
  	{
  		ip: "18.218.250.66",
  		port: 30313,
  		id: "b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",
  		location: "",
  		comment: "Upstream bootnode 4"
  	},
  	{
  		ip: "3.11.147.67",
  		port: 30303,
  		id: "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
  		location: "",
  		comment: "Ethereum Foundation bootnode"
  	},
  	{
  		ip: "51.15.116.226",
  		port: 30303,
  		id: "a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",
  		location: "",
  		comment: "Goerli Initiative bootnode"
  	},
  	{
  		ip: "51.15.119.157",
  		port: 30303,
  		id: "807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",
  		location: "",
  		comment: "Goerli Initiative bootnode"
  	},
  	{
  		ip: "51.15.119.157",
  		port: 40303,
  		id: "a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",
  		location: "",
  		comment: "Goerli Initiative bootnode"
  	}
  ];
  var dnsNetworks$4 = [
  	"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
  ];
  var require$$3$2 = {
  	name: name$J,
  	chainId: chainId$5,
  	networkId: networkId$5,
  	defaultHardfork: defaultHardfork$5,
  	consensus: consensus$7,
  	comment: comment$J,
  	url: url$J,
  	genesis: genesis$5,
  	hardforks: hardforks$6,
  	bootstrapNodes: bootstrapNodes$5,
  	dnsNetworks: dnsNetworks$4
  };

  var name$I = "kovan";
  var chainId$4 = 42;
  var networkId$4 = 42;
  var defaultHardfork$4 = "london";
  var consensus$6 = {
  	type: "poa",
  	algorithm: "clique",
  	clique: {
  		period: 15,
  		epoch: 30000
  	}
  };
  var comment$I = "Parity PoA test network";
  var url$I = "https://kovan-testnet.github.io/website/";
  var genesis$4 = {
  	gasLimit: 6000000,
  	difficulty: 131072,
  	nonce: "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  	extraData: "0x"
  };
  var hardforks$5 = [
  	{
  		name: "chainstart",
  		block: 0,
  		forkHash: "0x010ffe56"
  	},
  	{
  		name: "homestead",
  		block: 0,
  		forkHash: "0x010ffe56"
  	},
  	{
  		name: "tangerineWhistle",
  		block: 0,
  		forkHash: "0x010ffe56"
  	},
  	{
  		name: "spuriousDragon",
  		block: 0,
  		forkHash: "0x010ffe56"
  	},
  	{
  		name: "byzantium",
  		block: 5067000,
  		forkHash: "0x7f83c620"
  	},
  	{
  		name: "constantinople",
  		block: 9200000,
  		forkHash: "0xa94e3dc4"
  	},
  	{
  		name: "petersburg",
  		block: 10255201,
  		forkHash: "0x186874aa"
  	},
  	{
  		name: "istanbul",
  		block: 14111141,
  		forkHash: "0x7f6599a6"
  	},
  	{
  		name: "berlin",
  		block: 24770900,
  		forkHash: "0x1a0f10d9"
  	},
  	{
  		name: "london",
  		block: 26741100,
  		forkHash: "0x1ed20b71"
  	},
  	{
  		name: "merge",
  		block: null,
  		forkHash: null
  	},
  	{
  		name: "shanghai",
  		block: null,
  		forkHash: null
  	}
  ];
  var bootstrapNodes$4 = [
  	{
  		ip: "116.203.116.241",
  		port: 30303,
  		id: "16898006ba2cd4fa8bf9a3dfe32684c178fa861df144bfc21fe800dc4838a03e342056951fa9fd533dcb0be1219e306106442ff2cf1f7e9f8faa5f2fc1a3aa45",
  		location: "",
  		comment: "1"
  	},
  	{
  		ip: "3.217.96.11",
  		port: 30303,
  		id: "2909846f78c37510cc0e306f185323b83bb2209e5ff4fdd279d93c60e3f365e3c6e62ad1d2133ff11f9fd6d23ad9c3dad73bb974d53a22f7d1ac5b7dea79d0b0",
  		location: "",
  		comment: "2"
  	},
  	{
  		ip: "108.61.170.124",
  		port: 30303,
  		id: "740e1c8ea64e71762c71a463a04e2046070a0c9394fcab5891d41301dc473c0cff00ebab5a9bc87fbcb610ab98ac18225ff897bc8b7b38def5975d5ceb0a7d7c",
  		location: "",
  		comment: "3"
  	},
  	{
  		ip: "157.230.31.163",
  		port: 30303,
  		id: "2909846f78c37510cc0e306f185323b83bb2209e5ff4fdd279d93c60e3f365e3c6e62ad1d2133ff11f9fd6d23ad9c3dad73bb974d53a22f7d1ac5b7dea79d0b0",
  		location: "",
  		comment: "4"
  	}
  ];
  var require$$4$2 = {
  	name: name$I,
  	chainId: chainId$4,
  	networkId: networkId$4,
  	defaultHardfork: defaultHardfork$4,
  	consensus: consensus$6,
  	comment: comment$I,
  	url: url$I,
  	genesis: genesis$4,
  	hardforks: hardforks$5,
  	bootstrapNodes: bootstrapNodes$4
  };

  var name$H = "mainnet";
  var chainId$3 = 1;
  var networkId$3 = 1;
  var defaultHardfork$3 = "london";
  var consensus$5 = {
  	type: "pow",
  	algorithm: "ethash",
  	ethash: {
  	}
  };
  var comment$H = "The Ethereum main chain";
  var url$H = "https://ethstats.net/";
  var genesis$3 = {
  	gasLimit: 5000,
  	difficulty: 17179869184,
  	nonce: "0x0000000000000042",
  	extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
  };
  var hardforks$4 = [
  	{
  		name: "chainstart",
  		block: 0,
  		forkHash: "0xfc64ec04"
  	},
  	{
  		name: "homestead",
  		block: 1150000,
  		forkHash: "0x97c2c34c"
  	},
  	{
  		name: "dao",
  		block: 1920000,
  		forkHash: "0x91d1f948"
  	},
  	{
  		name: "tangerineWhistle",
  		block: 2463000,
  		forkHash: "0x7a64da13"
  	},
  	{
  		name: "spuriousDragon",
  		block: 2675000,
  		forkHash: "0x3edd5b10"
  	},
  	{
  		name: "byzantium",
  		block: 4370000,
  		forkHash: "0xa00bc324"
  	},
  	{
  		name: "constantinople",
  		block: 7280000,
  		forkHash: "0x668db0af"
  	},
  	{
  		name: "petersburg",
  		block: 7280000,
  		forkHash: "0x668db0af"
  	},
  	{
  		name: "istanbul",
  		block: 9069000,
  		forkHash: "0x879d6e30"
  	},
  	{
  		name: "muirGlacier",
  		block: 9200000,
  		forkHash: "0xe029e991"
  	},
  	{
  		name: "berlin",
  		block: 12244000,
  		forkHash: "0x0eb440f6"
  	},
  	{
  		name: "london",
  		block: 12965000,
  		forkHash: "0xb715077d"
  	},
  	{
  		name: "arrowGlacier",
  		block: 13773000,
  		forkHash: "0x20c327fc"
  	},
  	{
  		name: "grayGlacier",
  		block: 15050000,
  		forkHash: "0xf0afd0e3"
  	},
  	{
  		name: "mergeForkIdTransition",
  		block: null,
  		forkHash: null
  	},
  	{
  		name: "merge",
  		block: null,
  		forkHash: null
  	},
  	{
  		name: "shanghai",
  		block: null,
  		forkHash: null
  	}
  ];
  var bootstrapNodes$3 = [
  	{
  		ip: "18.138.108.67",
  		port: 30303,
  		id: "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
  		location: "ap-southeast-1-001",
  		comment: "bootnode-aws-ap-southeast-1-001"
  	},
  	{
  		ip: "3.209.45.79",
  		port: 30303,
  		id: "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
  		location: "us-east-1-001",
  		comment: "bootnode-aws-us-east-1-001"
  	},
  	{
  		ip: "34.255.23.113",
  		port: 30303,
  		id: "ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758",
  		location: "eu-west-1-001",
  		comment: "bootnode-aws-eu-west-1-001"
  	},
  	{
  		ip: "35.158.244.151",
  		port: 30303,
  		id: "279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8",
  		location: "eu-central-1-001",
  		comment: "bootnode-aws-eu-central-1-001"
  	},
  	{
  		ip: "52.187.207.27",
  		port: 30303,
  		id: "8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a",
  		location: "australiaeast-001",
  		comment: "bootnode-azure-australiaeast-001"
  	},
  	{
  		ip: "191.234.162.198",
  		port: 30303,
  		id: "103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1",
  		location: "brazilsouth-001",
  		comment: "bootnode-azure-brazilsouth-001"
  	},
  	{
  		ip: "52.231.165.108",
  		port: 30303,
  		id: "715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8",
  		location: "koreasouth-001",
  		comment: "bootnode-azure-koreasouth-001"
  	},
  	{
  		ip: "104.42.217.25",
  		port: 30303,
  		id: "5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f",
  		location: "westus-001",
  		comment: "bootnode-azure-westus-001"
  	}
  ];
  var dnsNetworks$3 = [
  	"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
  ];
  var require$$5$2 = {
  	name: name$H,
  	chainId: chainId$3,
  	networkId: networkId$3,
  	defaultHardfork: defaultHardfork$3,
  	consensus: consensus$5,
  	comment: comment$H,
  	url: url$H,
  	genesis: genesis$3,
  	hardforks: hardforks$4,
  	bootstrapNodes: bootstrapNodes$3,
  	dnsNetworks: dnsNetworks$3
  };

  var name$G = "rinkeby";
  var chainId$2 = 4;
  var networkId$2 = 4;
  var defaultHardfork$2 = "london";
  var consensus$4 = {
  	type: "poa",
  	algorithm: "clique",
  	clique: {
  		period: 15,
  		epoch: 30000
  	}
  };
  var comment$G = "PoA test network";
  var url$G = "https://www.rinkeby.io";
  var genesis$2 = {
  	timestamp: "0x58ee40ba",
  	gasLimit: 4700000,
  	difficulty: 1,
  	nonce: "0x0000000000000000",
  	extraData: "0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  };
  var hardforks$3 = [
  	{
  		name: "chainstart",
  		block: 0,
  		forkHash: "0x3b8e0691"
  	},
  	{
  		name: "homestead",
  		block: 1,
  		forkHash: "0x60949295"
  	},
  	{
  		name: "tangerineWhistle",
  		block: 2,
  		forkHash: "0x8bde40dd"
  	},
  	{
  		name: "spuriousDragon",
  		block: 3,
  		forkHash: "0xcb3a64bb"
  	},
  	{
  		name: "byzantium",
  		block: 1035301,
  		forkHash: "0x8d748b57"
  	},
  	{
  		name: "constantinople",
  		block: 3660663,
  		forkHash: "0xe49cab14"
  	},
  	{
  		name: "petersburg",
  		block: 4321234,
  		forkHash: "0xafec6b27"
  	},
  	{
  		name: "istanbul",
  		block: 5435345,
  		forkHash: "0xcbdb8838"
  	},
  	{
  		name: "berlin",
  		block: 8290928,
  		forkHash: "0x6910c8bd"
  	},
  	{
  		name: "london",
  		block: 8897988,
  		forkHash: "0x8e29f2f3"
  	},
  	{
  		name: "merge",
  		block: null,
  		forkHash: null
  	},
  	{
  		name: "shanghai",
  		block: null,
  		forkHash: null
  	}
  ];
  var bootstrapNodes$2 = [
  	{
  		ip: "52.169.42.101",
  		port: 30303,
  		id: "a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",
  		location: "",
  		comment: "IE"
  	},
  	{
  		ip: "52.3.158.184",
  		port: 30303,
  		id: "343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",
  		location: "",
  		comment: "INFURA"
  	},
  	{
  		ip: "159.89.28.211",
  		port: 30303,
  		id: "b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",
  		location: "",
  		comment: "AKASHA"
  	}
  ];
  var dnsNetworks$2 = [
  	"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"
  ];
  var require$$6$2 = {
  	name: name$G,
  	chainId: chainId$2,
  	networkId: networkId$2,
  	defaultHardfork: defaultHardfork$2,
  	consensus: consensus$4,
  	comment: comment$G,
  	url: url$G,
  	genesis: genesis$2,
  	hardforks: hardforks$3,
  	bootstrapNodes: bootstrapNodes$2,
  	dnsNetworks: dnsNetworks$2
  };

  var name$F = "ropsten";
  var chainId$1 = 3;
  var networkId$1 = 3;
  var defaultHardfork$1 = "merge";
  var consensus$3 = {
  	type: "pow",
  	algorithm: "ethash",
  	ethash: {
  	}
  };
  var comment$F = "PoW test network";
  var url$F = "https://github.com/ethereum/ropsten";
  var genesis$1 = {
  	gasLimit: 16777216,
  	difficulty: 1048576,
  	nonce: "0x0000000000000042",
  	extraData: "0x3535353535353535353535353535353535353535353535353535353535353535"
  };
  var hardforks$2 = [
  	{
  		name: "chainstart",
  		block: 0,
  		forkHash: "0x30c7ddbc"
  	},
  	{
  		name: "homestead",
  		block: 0,
  		forkHash: "0x30c7ddbc"
  	},
  	{
  		name: "tangerineWhistle",
  		block: 0,
  		forkHash: "0x30c7ddbc"
  	},
  	{
  		name: "spuriousDragon",
  		block: 10,
  		forkHash: "0x63760190"
  	},
  	{
  		name: "byzantium",
  		block: 1700000,
  		forkHash: "0x3ea159c7"
  	},
  	{
  		name: "constantinople",
  		block: 4230000,
  		forkHash: "0x97b544f3"
  	},
  	{
  		name: "petersburg",
  		block: 4939394,
  		forkHash: "0xd6e2149b"
  	},
  	{
  		name: "istanbul",
  		block: 6485846,
  		forkHash: "0x4bc66396"
  	},
  	{
  		name: "muirGlacier",
  		block: 7117117,
  		forkHash: "0x6727ef90"
  	},
  	{
  		name: "berlin",
  		block: 9812189,
  		forkHash: "0xa157d377"
  	},
  	{
  		name: "london",
  		block: 10499401,
  		forkHash: "0x7119b6b3"
  	},
  	{
  		"//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
  		name: "merge",
  		ttd: "50000000000000000",
  		block: null,
  		forkHash: "0x7119b6b3"
  	},
  	{
  		name: "mergeForkIdTransition",
  		block: null,
  		forkHash: null
  	},
  	{
  		name: "shanghai",
  		block: null,
  		forkHash: null
  	}
  ];
  var bootstrapNodes$1 = [
  	{
  		ip: "52.176.7.10",
  		port: 30303,
  		id: "30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",
  		location: "",
  		comment: "US-Azure geth"
  	},
  	{
  		ip: "52.176.100.77",
  		port: 30303,
  		id: "865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",
  		location: "",
  		comment: "US-Azure parity"
  	},
  	{
  		ip: "52.232.243.152",
  		port: 30303,
  		id: "6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",
  		location: "",
  		comment: "Parity"
  	},
  	{
  		ip: "192.81.208.223",
  		port: 30303,
  		id: "94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",
  		location: "",
  		comment: "@gpip"
  	}
  ];
  var dnsNetworks$1 = [
  	"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"
  ];
  var require$$7$3 = {
  	name: name$F,
  	chainId: chainId$1,
  	networkId: networkId$1,
  	defaultHardfork: defaultHardfork$1,
  	consensus: consensus$3,
  	comment: comment$F,
  	url: url$F,
  	genesis: genesis$1,
  	hardforks: hardforks$2,
  	bootstrapNodes: bootstrapNodes$1,
  	dnsNetworks: dnsNetworks$1
  };

  var name$E = "sepolia";
  var chainId = 11155111;
  var networkId = 11155111;
  var defaultHardfork = "merge";
  var consensus$2 = {
  	type: "pow",
  	algorithm: "ethash",
  	ethash: {
  	}
  };
  var comment$E = "PoW test network to replace Ropsten";
  var url$E = "https://github.com/ethereum/go-ethereum/pull/23730";
  var genesis = {
  	timestamp: "0x6159af19",
  	gasLimit: 30000000,
  	difficulty: 131072,
  	nonce: "0x0000000000000000",
  	extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
  };
  var hardforks$1 = [
  	{
  		name: "chainstart",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "homestead",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "tangerineWhistle",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "spuriousDragon",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "byzantium",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "constantinople",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "petersburg",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "istanbul",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "muirGlacier",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "berlin",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "london",
  		block: 0,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		"//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
  		name: "merge",
  		ttd: "17000000000000000",
  		block: null,
  		forkHash: "0xfe3366e7"
  	},
  	{
  		name: "mergeForkIdTransition",
  		block: 1735371,
  		forkHash: "0xb96cbd13"
  	},
  	{
  		name: "shanghai",
  		block: null,
  		forkHash: null
  	}
  ];
  var bootstrapNodes = [
  	{
  		ip: "18.168.182.86",
  		port: 30303,
  		id: "9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",
  		location: "",
  		comment: "geth"
  	},
  	{
  		ip: "52.14.151.177",
  		port: 30303,
  		id: "ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",
  		location: "",
  		comment: "besu"
  	},
  	{
  		ip: "165.22.196.173",
  		port: 30303,
  		id: "ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",
  		location: "",
  		comment: "EF"
  	},
  	{
  		ip: "65.108.95.67",
  		port: 30303,
  		id: "075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",
  		location: "",
  		comment: "lodestar"
  	}
  ];
  var dnsNetworks = [
  	"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
  ];
  var require$$8$2 = {
  	name: name$E,
  	chainId: chainId,
  	networkId: networkId,
  	defaultHardfork: defaultHardfork,
  	consensus: consensus$2,
  	comment: comment$E,
  	url: url$E,
  	genesis: genesis,
  	hardforks: hardforks$1,
  	bootstrapNodes: bootstrapNodes,
  	dnsNetworks: dnsNetworks
  };

  var eips$7 = {};

  var name$D = "EIP-1153";
  var number$g = 1153;
  var comment$D = "Transient Storage";
  var url$D = "https://eips.ethereum.org/EIPS/eip-1153";
  var status$D = "Review";
  var minimumHardfork$m = "chainstart";
  var requiredEIPs$d = [
  ];
  var gasConfig$y = {
  };
  var gasPrices$y = {
  	tstore: {
  		v: 100,
  		d: "Base fee of the TSTORE opcode"
  	},
  	tload: {
  		v: 100,
  		d: "Base fee of the TLOAD opcode"
  	}
  };
  var vm$z = {
  };
  var pow$y = {
  };
  var require$$0$5 = {
  	name: name$D,
  	number: number$g,
  	comment: comment$D,
  	url: url$D,
  	status: status$D,
  	minimumHardfork: minimumHardfork$m,
  	requiredEIPs: requiredEIPs$d,
  	gasConfig: gasConfig$y,
  	gasPrices: gasPrices$y,
  	vm: vm$z,
  	pow: pow$y
  };

  var name$C = "EIP-1559";
  var number$f = 1559;
  var comment$C = "Fee market change for ETH 1.0 chain";
  var url$C = "https://eips.ethereum.org/EIPS/eip-1559";
  var status$C = "Final";
  var minimumHardfork$l = "berlin";
  var requiredEIPs$c = [
  	2930
  ];
  var gasConfig$x = {
  	baseFeeMaxChangeDenominator: {
  		v: 8,
  		d: "Maximum base fee change denominator"
  	},
  	elasticityMultiplier: {
  		v: 2,
  		d: "Maximum block gas target elasticity"
  	},
  	initialBaseFee: {
  		v: 1000000000,
  		d: "Initial base fee on first EIP1559 block"
  	}
  };
  var gasPrices$x = {
  };
  var vm$y = {
  };
  var pow$x = {
  };
  var require$$1$2 = {
  	name: name$C,
  	number: number$f,
  	comment: comment$C,
  	url: url$C,
  	status: status$C,
  	minimumHardfork: minimumHardfork$l,
  	requiredEIPs: requiredEIPs$c,
  	gasConfig: gasConfig$x,
  	gasPrices: gasPrices$x,
  	vm: vm$y,
  	pow: pow$x
  };

  var name$B = "EIP-2315";
  var number$e = 2315;
  var comment$B = "Simple subroutines for the EVM";
  var url$B = "https://eips.ethereum.org/EIPS/eip-2315";
  var status$B = "Draft";
  var minimumHardfork$k = "istanbul";
  var gasConfig$w = {
  };
  var gasPrices$w = {
  	beginsub: {
  		v: 2,
  		d: "Base fee of the BEGINSUB opcode"
  	},
  	returnsub: {
  		v: 5,
  		d: "Base fee of the RETURNSUB opcode"
  	},
  	jumpsub: {
  		v: 10,
  		d: "Base fee of the JUMPSUB opcode"
  	}
  };
  var vm$x = {
  };
  var pow$w = {
  };
  var require$$2$1 = {
  	name: name$B,
  	number: number$e,
  	comment: comment$B,
  	url: url$B,
  	status: status$B,
  	minimumHardfork: minimumHardfork$k,
  	gasConfig: gasConfig$w,
  	gasPrices: gasPrices$w,
  	vm: vm$x,
  	pow: pow$w
  };

  var name$A = "EIP-2537";
  var number$d = 2537;
  var comment$A = "BLS12-381 precompiles";
  var url$A = "https://eips.ethereum.org/EIPS/eip-2537";
  var status$A = "Draft";
  var minimumHardfork$j = "chainstart";
  var gasConfig$v = {
  };
  var gasPrices$v = {
  	Bls12381G1AddGas: {
  		v: 600,
  		d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
  	},
  	Bls12381G1MulGas: {
  		v: 12000,
  		d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
  	},
  	Bls12381G2AddGas: {
  		v: 4500,
  		d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
  	},
  	Bls12381G2MulGas: {
  		v: 55000,
  		d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
  	},
  	Bls12381PairingBaseGas: {
  		v: 115000,
  		d: "Base gas cost of BLS12-381 pairing check"
  	},
  	Bls12381PairingPerPairGas: {
  		v: 23000,
  		d: "Per-pair gas cost of BLS12-381 pairing check"
  	},
  	Bls12381MapG1Gas: {
  		v: 5500,
  		d: "Gas cost of BLS12-381 map field element to G1"
  	},
  	Bls12381MapG2Gas: {
  		v: 110000,
  		d: "Gas cost of BLS12-381 map field element to G2"
  	},
  	Bls12381MultiExpGasDiscount: {
  		v: [
  			[
  				1,
  				1200
  			],
  			[
  				2,
  				888
  			],
  			[
  				3,
  				764
  			],
  			[
  				4,
  				641
  			],
  			[
  				5,
  				594
  			],
  			[
  				6,
  				547
  			],
  			[
  				7,
  				500
  			],
  			[
  				8,
  				453
  			],
  			[
  				9,
  				438
  			],
  			[
  				10,
  				423
  			],
  			[
  				11,
  				408
  			],
  			[
  				12,
  				394
  			],
  			[
  				13,
  				379
  			],
  			[
  				14,
  				364
  			],
  			[
  				15,
  				349
  			],
  			[
  				16,
  				334
  			],
  			[
  				17,
  				330
  			],
  			[
  				18,
  				326
  			],
  			[
  				19,
  				322
  			],
  			[
  				20,
  				318
  			],
  			[
  				21,
  				314
  			],
  			[
  				22,
  				310
  			],
  			[
  				23,
  				306
  			],
  			[
  				24,
  				302
  			],
  			[
  				25,
  				298
  			],
  			[
  				26,
  				294
  			],
  			[
  				27,
  				289
  			],
  			[
  				28,
  				285
  			],
  			[
  				29,
  				281
  			],
  			[
  				30,
  				277
  			],
  			[
  				31,
  				273
  			],
  			[
  				32,
  				269
  			],
  			[
  				33,
  				268
  			],
  			[
  				34,
  				266
  			],
  			[
  				35,
  				265
  			],
  			[
  				36,
  				263
  			],
  			[
  				37,
  				262
  			],
  			[
  				38,
  				260
  			],
  			[
  				39,
  				259
  			],
  			[
  				40,
  				257
  			],
  			[
  				41,
  				256
  			],
  			[
  				42,
  				254
  			],
  			[
  				43,
  				253
  			],
  			[
  				44,
  				251
  			],
  			[
  				45,
  				250
  			],
  			[
  				46,
  				248
  			],
  			[
  				47,
  				247
  			],
  			[
  				48,
  				245
  			],
  			[
  				49,
  				244
  			],
  			[
  				50,
  				242
  			],
  			[
  				51,
  				241
  			],
  			[
  				52,
  				239
  			],
  			[
  				53,
  				238
  			],
  			[
  				54,
  				236
  			],
  			[
  				55,
  				235
  			],
  			[
  				56,
  				233
  			],
  			[
  				57,
  				232
  			],
  			[
  				58,
  				231
  			],
  			[
  				59,
  				229
  			],
  			[
  				60,
  				228
  			],
  			[
  				61,
  				226
  			],
  			[
  				62,
  				225
  			],
  			[
  				63,
  				223
  			],
  			[
  				64,
  				222
  			],
  			[
  				65,
  				221
  			],
  			[
  				66,
  				220
  			],
  			[
  				67,
  				219
  			],
  			[
  				68,
  				219
  			],
  			[
  				69,
  				218
  			],
  			[
  				70,
  				217
  			],
  			[
  				71,
  				216
  			],
  			[
  				72,
  				216
  			],
  			[
  				73,
  				215
  			],
  			[
  				74,
  				214
  			],
  			[
  				75,
  				213
  			],
  			[
  				76,
  				213
  			],
  			[
  				77,
  				212
  			],
  			[
  				78,
  				211
  			],
  			[
  				79,
  				211
  			],
  			[
  				80,
  				210
  			],
  			[
  				81,
  				209
  			],
  			[
  				82,
  				208
  			],
  			[
  				83,
  				208
  			],
  			[
  				84,
  				207
  			],
  			[
  				85,
  				206
  			],
  			[
  				86,
  				205
  			],
  			[
  				87,
  				205
  			],
  			[
  				88,
  				204
  			],
  			[
  				89,
  				203
  			],
  			[
  				90,
  				202
  			],
  			[
  				91,
  				202
  			],
  			[
  				92,
  				201
  			],
  			[
  				93,
  				200
  			],
  			[
  				94,
  				199
  			],
  			[
  				95,
  				199
  			],
  			[
  				96,
  				198
  			],
  			[
  				97,
  				197
  			],
  			[
  				98,
  				196
  			],
  			[
  				99,
  				196
  			],
  			[
  				100,
  				195
  			],
  			[
  				101,
  				194
  			],
  			[
  				102,
  				193
  			],
  			[
  				103,
  				193
  			],
  			[
  				104,
  				192
  			],
  			[
  				105,
  				191
  			],
  			[
  				106,
  				191
  			],
  			[
  				107,
  				190
  			],
  			[
  				108,
  				189
  			],
  			[
  				109,
  				188
  			],
  			[
  				110,
  				188
  			],
  			[
  				111,
  				187
  			],
  			[
  				112,
  				186
  			],
  			[
  				113,
  				185
  			],
  			[
  				114,
  				185
  			],
  			[
  				115,
  				184
  			],
  			[
  				116,
  				183
  			],
  			[
  				117,
  				182
  			],
  			[
  				118,
  				182
  			],
  			[
  				119,
  				181
  			],
  			[
  				120,
  				180
  			],
  			[
  				121,
  				179
  			],
  			[
  				122,
  				179
  			],
  			[
  				123,
  				178
  			],
  			[
  				124,
  				177
  			],
  			[
  				125,
  				176
  			],
  			[
  				126,
  				176
  			],
  			[
  				127,
  				175
  			],
  			[
  				128,
  				174
  			]
  		],
  		d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
  	}
  };
  var vm$w = {
  };
  var pow$v = {
  };
  var require$$3$1 = {
  	name: name$A,
  	number: number$d,
  	comment: comment$A,
  	url: url$A,
  	status: status$A,
  	minimumHardfork: minimumHardfork$j,
  	gasConfig: gasConfig$v,
  	gasPrices: gasPrices$v,
  	vm: vm$w,
  	pow: pow$v
  };

  var name$z = "EIP-2565";
  var number$c = 2565;
  var comment$z = "ModExp gas cost";
  var url$z = "https://eips.ethereum.org/EIPS/eip-2565";
  var status$z = "Final";
  var minimumHardfork$i = "byzantium";
  var gasConfig$u = {
  };
  var gasPrices$u = {
  	modexpGquaddivisor: {
  		v: 3,
  		d: "Gquaddivisor from modexp precompile for gas calculation"
  	}
  };
  var vm$v = {
  };
  var pow$u = {
  };
  var require$$4$1 = {
  	name: name$z,
  	number: number$c,
  	comment: comment$z,
  	url: url$z,
  	status: status$z,
  	minimumHardfork: minimumHardfork$i,
  	gasConfig: gasConfig$u,
  	gasPrices: gasPrices$u,
  	vm: vm$v,
  	pow: pow$u
  };

  var name$y = "EIP-2718";
  var comment$y = "Typed Transaction Envelope";
  var url$y = "https://eips.ethereum.org/EIPS/eip-2718";
  var status$y = "Final";
  var minimumHardfork$h = "chainstart";
  var gasConfig$t = {
  };
  var gasPrices$t = {
  };
  var vm$u = {
  };
  var pow$t = {
  };
  var require$$5$1 = {
  	name: name$y,
  	comment: comment$y,
  	url: url$y,
  	status: status$y,
  	minimumHardfork: minimumHardfork$h,
  	gasConfig: gasConfig$t,
  	gasPrices: gasPrices$t,
  	vm: vm$u,
  	pow: pow$t
  };

  var name$x = "EIP-2929";
  var comment$x = "Gas cost increases for state access opcodes";
  var url$x = "https://eips.ethereum.org/EIPS/eip-2929";
  var status$x = "Final";
  var minimumHardfork$g = "chainstart";
  var gasConfig$s = {
  };
  var gasPrices$s = {
  	coldsload: {
  		v: 2100,
  		d: "Gas cost of the first read of storage from a given location (per transaction)"
  	},
  	coldaccountaccess: {
  		v: 2600,
  		d: "Gas cost of the first read of a given address (per transaction)"
  	},
  	warmstorageread: {
  		v: 100,
  		d: "Gas cost of reading storage locations which have already loaded 'cold'"
  	},
  	sstoreCleanGasEIP2200: {
  		v: 2900,
  		d: "Once per SSTORE operation from clean non-zero to something else"
  	},
  	sstoreNoopGasEIP2200: {
  		v: 100,
  		d: "Once per SSTORE operation if the value doesn't change"
  	},
  	sstoreDirtyGasEIP2200: {
  		v: 100,
  		d: "Once per SSTORE operation if a dirty value is changed"
  	},
  	sstoreInitRefundEIP2200: {
  		v: 19900,
  		d: "Once per SSTORE operation for resetting to the original zero value"
  	},
  	sstoreCleanRefundEIP2200: {
  		v: 4900,
  		d: "Once per SSTORE operation for resetting to the original non-zero value"
  	},
  	call: {
  		v: 0,
  		d: "Base fee of the CALL opcode"
  	},
  	callcode: {
  		v: 0,
  		d: "Base fee of the CALLCODE opcode"
  	},
  	delegatecall: {
  		v: 0,
  		d: "Base fee of the DELEGATECALL opcode"
  	},
  	staticcall: {
  		v: 0,
  		d: "Base fee of the STATICCALL opcode"
  	},
  	balance: {
  		v: 0,
  		d: "Base fee of the BALANCE opcode"
  	},
  	extcodesize: {
  		v: 0,
  		d: "Base fee of the EXTCODESIZE opcode"
  	},
  	extcodecopy: {
  		v: 0,
  		d: "Base fee of the EXTCODECOPY opcode"
  	},
  	extcodehash: {
  		v: 0,
  		d: "Base fee of the EXTCODEHASH opcode"
  	},
  	sload: {
  		v: 0,
  		d: "Base fee of the SLOAD opcode"
  	},
  	sstore: {
  		v: 0,
  		d: "Base fee of the SSTORE opcode"
  	}
  };
  var vm$t = {
  };
  var pow$s = {
  };
  var require$$6$1 = {
  	name: name$x,
  	comment: comment$x,
  	url: url$x,
  	status: status$x,
  	minimumHardfork: minimumHardfork$g,
  	gasConfig: gasConfig$s,
  	gasPrices: gasPrices$s,
  	vm: vm$t,
  	pow: pow$s
  };

  var name$w = "EIP-2930";
  var comment$w = "Optional access lists";
  var url$w = "https://eips.ethereum.org/EIPS/eip-2930";
  var status$w = "Final";
  var minimumHardfork$f = "istanbul";
  var requiredEIPs$b = [
  	2718,
  	2929
  ];
  var gasConfig$r = {
  };
  var gasPrices$r = {
  	accessListStorageKeyCost: {
  		v: 1900,
  		d: "Gas cost per storage key in an Access List transaction"
  	},
  	accessListAddressCost: {
  		v: 2400,
  		d: "Gas cost per storage key in an Access List transaction"
  	}
  };
  var vm$s = {
  };
  var pow$r = {
  };
  var require$$7$2 = {
  	name: name$w,
  	comment: comment$w,
  	url: url$w,
  	status: status$w,
  	minimumHardfork: minimumHardfork$f,
  	requiredEIPs: requiredEIPs$b,
  	gasConfig: gasConfig$r,
  	gasPrices: gasPrices$r,
  	vm: vm$s,
  	pow: pow$r
  };

  var name$v = "EIP-3074";
  var number$b = 3074;
  var comment$v = "AUTH and AUTHCALL opcodes";
  var url$v = "https://eips.ethereum.org/EIPS/eip-3074";
  var status$v = "Review";
  var minimumHardfork$e = "london";
  var gasConfig$q = {
  };
  var gasPrices$q = {
  	auth: {
  		v: 3100,
  		d: "Gas cost of the AUTH opcode"
  	},
  	authcall: {
  		v: 0,
  		d: "Gas cost of the AUTHCALL opcode"
  	},
  	authcallValueTransfer: {
  		v: 6700,
  		d: "Paid for CALL when the value transfer is non-zero"
  	}
  };
  var vm$r = {
  };
  var pow$q = {
  };
  var require$$8$1 = {
  	name: name$v,
  	number: number$b,
  	comment: comment$v,
  	url: url$v,
  	status: status$v,
  	minimumHardfork: minimumHardfork$e,
  	gasConfig: gasConfig$q,
  	gasPrices: gasPrices$q,
  	vm: vm$r,
  	pow: pow$q
  };

  var name$u = "EIP-3198";
  var number$a = 3198;
  var comment$u = "BASEFEE opcode";
  var url$u = "https://eips.ethereum.org/EIPS/eip-3198";
  var status$u = "Final";
  var minimumHardfork$d = "london";
  var gasConfig$p = {
  };
  var gasPrices$p = {
  	basefee: {
  		v: 2,
  		d: "Gas cost of the BASEFEE opcode"
  	}
  };
  var vm$q = {
  };
  var pow$p = {
  };
  var require$$9$1 = {
  	name: name$u,
  	number: number$a,
  	comment: comment$u,
  	url: url$u,
  	status: status$u,
  	minimumHardfork: minimumHardfork$d,
  	gasConfig: gasConfig$p,
  	gasPrices: gasPrices$p,
  	vm: vm$q,
  	pow: pow$p
  };

  var name$t = "EIP-3529";
  var comment$t = "Reduction in refunds";
  var url$t = "https://eips.ethereum.org/EIPS/eip-3529";
  var status$t = "Final";
  var minimumHardfork$c = "berlin";
  var requiredEIPs$a = [
  	2929
  ];
  var gasConfig$o = {
  	maxRefundQuotient: {
  		v: 5,
  		d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
  	}
  };
  var gasPrices$o = {
  	selfdestructRefund: {
  		v: 0,
  		d: "Refunded following a selfdestruct operation"
  	},
  	sstoreClearRefundEIP2200: {
  		v: 4800,
  		d: "Once per SSTORE operation for clearing an originally existing storage slot"
  	}
  };
  var vm$p = {
  };
  var pow$o = {
  };
  var require$$10$2 = {
  	name: name$t,
  	comment: comment$t,
  	url: url$t,
  	status: status$t,
  	minimumHardfork: minimumHardfork$c,
  	requiredEIPs: requiredEIPs$a,
  	gasConfig: gasConfig$o,
  	gasPrices: gasPrices$o,
  	vm: vm$p,
  	pow: pow$o
  };

  var name$s = "EIP-3540";
  var number$9 = 3540;
  var comment$s = "EVM Object Format (EOF) v1";
  var url$s = "https://eips.ethereum.org/EIPS/eip-3540";
  var status$s = "Review";
  var minimumHardfork$b = "london";
  var requiredEIPs$9 = [
  	3541
  ];
  var gasConfig$n = {
  };
  var gasPrices$n = {
  };
  var vm$o = {
  };
  var pow$n = {
  };
  var require$$11$2 = {
  	name: name$s,
  	number: number$9,
  	comment: comment$s,
  	url: url$s,
  	status: status$s,
  	minimumHardfork: minimumHardfork$b,
  	requiredEIPs: requiredEIPs$9,
  	gasConfig: gasConfig$n,
  	gasPrices: gasPrices$n,
  	vm: vm$o,
  	pow: pow$n
  };

  var name$r = "EIP-3541";
  var comment$r = "Reject new contracts starting with the 0xEF byte";
  var url$r = "https://eips.ethereum.org/EIPS/eip-3541";
  var status$r = "Final";
  var minimumHardfork$a = "berlin";
  var requiredEIPs$8 = [
  ];
  var gasConfig$m = {
  };
  var gasPrices$m = {
  };
  var vm$n = {
  };
  var pow$m = {
  };
  var require$$12$2 = {
  	name: name$r,
  	comment: comment$r,
  	url: url$r,
  	status: status$r,
  	minimumHardfork: minimumHardfork$a,
  	requiredEIPs: requiredEIPs$8,
  	gasConfig: gasConfig$m,
  	gasPrices: gasPrices$m,
  	vm: vm$n,
  	pow: pow$m
  };

  var name$q = "EIP-3554";
  var comment$q = "Reduction in refunds";
  var url$q = "Difficulty Bomb Delay to December 1st 2021";
  var status$q = "Final";
  var minimumHardfork$9 = "muirGlacier";
  var requiredEIPs$7 = [
  ];
  var gasConfig$l = {
  };
  var gasPrices$l = {
  };
  var vm$m = {
  };
  var pow$l = {
  	difficultyBombDelay: {
  		v: 9500000,
  		d: "the amount of blocks to delay the difficulty bomb with"
  	}
  };
  var require$$13$2 = {
  	name: name$q,
  	comment: comment$q,
  	url: url$q,
  	status: status$q,
  	minimumHardfork: minimumHardfork$9,
  	requiredEIPs: requiredEIPs$7,
  	gasConfig: gasConfig$l,
  	gasPrices: gasPrices$l,
  	vm: vm$m,
  	pow: pow$l
  };

  var name$p = "EIP-3607";
  var number$8 = 3607;
  var comment$p = "Reject transactions from senders with deployed code";
  var url$p = "https://eips.ethereum.org/EIPS/eip-3607";
  var status$p = "Final";
  var minimumHardfork$8 = "chainstart";
  var requiredEIPs$6 = [
  ];
  var gasConfig$k = {
  };
  var gasPrices$k = {
  };
  var vm$l = {
  };
  var pow$k = {
  };
  var require$$14$2 = {
  	name: name$p,
  	number: number$8,
  	comment: comment$p,
  	url: url$p,
  	status: status$p,
  	minimumHardfork: minimumHardfork$8,
  	requiredEIPs: requiredEIPs$6,
  	gasConfig: gasConfig$k,
  	gasPrices: gasPrices$k,
  	vm: vm$l,
  	pow: pow$k
  };

  var name$o = "EIP-3651";
  var number$7 = 3198;
  var comment$o = "Warm COINBASE";
  var url$o = "https://eips.ethereum.org/EIPS/eip-3651";
  var status$o = "Review";
  var minimumHardfork$7 = "london";
  var requiredEIPs$5 = [
  	2929
  ];
  var gasConfig$j = {
  };
  var gasPrices$j = {
  };
  var vm$k = {
  };
  var pow$j = {
  };
  var require$$15$2 = {
  	name: name$o,
  	number: number$7,
  	comment: comment$o,
  	url: url$o,
  	status: status$o,
  	minimumHardfork: minimumHardfork$7,
  	requiredEIPs: requiredEIPs$5,
  	gasConfig: gasConfig$j,
  	gasPrices: gasPrices$j,
  	vm: vm$k,
  	pow: pow$j
  };

  var name$n = "EIP-3670";
  var number$6 = 3670;
  var comment$n = "EOF - Code Validation";
  var url$n = "https://eips.ethereum.org/EIPS/eip-3670";
  var status$n = "Review";
  var minimumHardfork$6 = "london";
  var requiredEIPs$4 = [
  	3540
  ];
  var gasConfig$i = {
  };
  var gasPrices$i = {
  };
  var vm$j = {
  };
  var pow$i = {
  };
  var require$$16$1 = {
  	name: name$n,
  	number: number$6,
  	comment: comment$n,
  	url: url$n,
  	status: status$n,
  	minimumHardfork: minimumHardfork$6,
  	requiredEIPs: requiredEIPs$4,
  	gasConfig: gasConfig$i,
  	gasPrices: gasPrices$i,
  	vm: vm$j,
  	pow: pow$i
  };

  var name$m = "EIP-3675";
  var number$5 = 3675;
  var comment$m = "Upgrade consensus to Proof-of-Stake";
  var url$m = "https://eips.ethereum.org/EIPS/eip-3675";
  var status$m = "Review";
  var minimumHardfork$5 = "london";
  var requiredEIPs$3 = [
  ];
  var gasConfig$h = {
  };
  var gasPrices$h = {
  };
  var vm$i = {
  };
  var pow$h = {
  };
  var require$$17 = {
  	name: name$m,
  	number: number$5,
  	comment: comment$m,
  	url: url$m,
  	status: status$m,
  	minimumHardfork: minimumHardfork$5,
  	requiredEIPs: requiredEIPs$3,
  	gasConfig: gasConfig$h,
  	gasPrices: gasPrices$h,
  	vm: vm$i,
  	pow: pow$h
  };

  var name$l = "EIP-3855";
  var number$4 = 3855;
  var comment$l = "PUSH0 instruction";
  var url$l = "https://eips.ethereum.org/EIPS/eip-3855";
  var status$l = "Review";
  var minimumHardfork$4 = "chainstart";
  var requiredEIPs$2 = [
  ];
  var gasConfig$g = {
  };
  var gasPrices$g = {
  	push0: {
  		v: 2,
  		d: "Base fee of the PUSH0 opcode"
  	}
  };
  var vm$h = {
  };
  var pow$g = {
  };
  var require$$18 = {
  	name: name$l,
  	number: number$4,
  	comment: comment$l,
  	url: url$l,
  	status: status$l,
  	minimumHardfork: minimumHardfork$4,
  	requiredEIPs: requiredEIPs$2,
  	gasConfig: gasConfig$g,
  	gasPrices: gasPrices$g,
  	vm: vm$h,
  	pow: pow$g
  };

  var name$k = "EIP-3860";
  var number$3 = 3860;
  var comment$k = "Limit and meter initcode";
  var url$k = "https://eips.ethereum.org/EIPS/eip-3860";
  var status$k = "Review";
  var minimumHardfork$3 = "spuriousDragon";
  var requiredEIPs$1 = [
  ];
  var gasConfig$f = {
  };
  var gasPrices$f = {
  	initCodeWordCost: {
  		v: 2,
  		d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
  	}
  };
  var vm$g = {
  	maxInitCodeSize: {
  		v: 49152,
  		d: "Maximum length of initialization code when creating a contract"
  	}
  };
  var pow$f = {
  };
  var require$$19 = {
  	name: name$k,
  	number: number$3,
  	comment: comment$k,
  	url: url$k,
  	status: status$k,
  	minimumHardfork: minimumHardfork$3,
  	requiredEIPs: requiredEIPs$1,
  	gasConfig: gasConfig$f,
  	gasPrices: gasPrices$f,
  	vm: vm$g,
  	pow: pow$f
  };

  var name$j = "EIP-4345";
  var number$2 = 4345;
  var comment$j = "Difficulty Bomb Delay to June 2022";
  var url$j = "https://eips.ethereum.org/EIPS/eip-4345";
  var status$j = "Final";
  var minimumHardfork$2 = "london";
  var gasConfig$e = {
  };
  var gasPrices$e = {
  };
  var vm$f = {
  };
  var pow$e = {
  	difficultyBombDelay: {
  		v: 10700000,
  		d: "the amount of blocks to delay the difficulty bomb with"
  	}
  };
  var require$$20 = {
  	name: name$j,
  	number: number$2,
  	comment: comment$j,
  	url: url$j,
  	status: status$j,
  	minimumHardfork: minimumHardfork$2,
  	gasConfig: gasConfig$e,
  	gasPrices: gasPrices$e,
  	vm: vm$f,
  	pow: pow$e
  };

  var name$i = "EIP-4399";
  var number$1 = 4399;
  var comment$i = "Supplant DIFFICULTY opcode with PREVRANDAO";
  var url$i = "https://eips.ethereum.org/EIPS/eip-4399";
  var status$i = "Review";
  var minimumHardfork$1 = "london";
  var requiredEIPs = [
  ];
  var gasConfig$d = {
  };
  var gasPrices$d = {
  };
  var vm$e = {
  };
  var pow$d = {
  };
  var require$$21 = {
  	name: name$i,
  	number: number$1,
  	comment: comment$i,
  	url: url$i,
  	status: status$i,
  	minimumHardfork: minimumHardfork$1,
  	requiredEIPs: requiredEIPs,
  	gasConfig: gasConfig$d,
  	gasPrices: gasPrices$d,
  	vm: vm$e,
  	pow: pow$d
  };

  var name$h = "EIP-5133";
  var number = 5133;
  var comment$h = "Delaying Difficulty Bomb to mid-September 2022";
  var url$h = "https://eips.ethereum.org/EIPS/eip-5133";
  var status$h = "Draft";
  var minimumHardfork = "grayGlacier";
  var gasConfig$c = {
  };
  var gasPrices$c = {
  };
  var vm$d = {
  };
  var pow$c = {
  	difficultyBombDelay: {
  		v: 11400000,
  		d: "the amount of blocks to delay the difficulty bomb with"
  	}
  };
  var require$$22 = {
  	name: name$h,
  	number: number,
  	comment: comment$h,
  	url: url$h,
  	status: status$h,
  	minimumHardfork: minimumHardfork,
  	gasConfig: gasConfig$c,
  	gasPrices: gasPrices$c,
  	vm: vm$d,
  	pow: pow$c
  };

  Object.defineProperty(eips$7, "__esModule", { value: true });
  eips$7.EIPs = void 0;
  eips$7.EIPs = {
      1153: require$$0$5,
      1559: require$$1$2,
      2315: require$$2$1,
      2537: require$$3$1,
      2565: require$$4$1,
      2718: require$$5$1,
      2929: require$$6$1,
      2930: require$$7$2,
      3074: require$$8$1,
      3198: require$$9$1,
      3529: require$$10$2,
      3540: require$$11$2,
      3541: require$$12$2,
      3554: require$$13$2,
      3607: require$$14$2,
      3651: require$$15$2,
      3670: require$$16$1,
      3675: require$$17,
      3855: require$$18,
      3860: require$$19,
      4345: require$$20,
      4399: require$$21,
      5133: require$$22,
  };

  var enums = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CustomChain = exports.ConsensusAlgorithm = exports.ConsensusType = exports.Hardfork = exports.Chain = void 0;
  (function (Chain) {
      Chain[Chain["Mainnet"] = 1] = "Mainnet";
      Chain[Chain["Ropsten"] = 3] = "Ropsten";
      Chain[Chain["Rinkeby"] = 4] = "Rinkeby";
      Chain[Chain["Kovan"] = 42] = "Kovan";
      Chain[Chain["Goerli"] = 5] = "Goerli";
      Chain[Chain["Sepolia"] = 11155111] = "Sepolia";
  })(exports.Chain || (exports.Chain = {}));
  (function (Hardfork) {
      Hardfork["Chainstart"] = "chainstart";
      Hardfork["Homestead"] = "homestead";
      Hardfork["Dao"] = "dao";
      Hardfork["TangerineWhistle"] = "tangerineWhistle";
      Hardfork["SpuriousDragon"] = "spuriousDragon";
      Hardfork["Byzantium"] = "byzantium";
      Hardfork["Constantinople"] = "constantinople";
      Hardfork["Petersburg"] = "petersburg";
      Hardfork["Istanbul"] = "istanbul";
      Hardfork["MuirGlacier"] = "muirGlacier";
      Hardfork["Berlin"] = "berlin";
      Hardfork["London"] = "london";
      Hardfork["ArrowGlacier"] = "arrowGlacier";
      Hardfork["GrayGlacier"] = "grayGlacier";
      Hardfork["MergeForkIdTransition"] = "mergeForkIdTransition";
      Hardfork["Merge"] = "merge";
      Hardfork["Shanghai"] = "shanghai";
  })(exports.Hardfork || (exports.Hardfork = {}));
  (function (ConsensusType) {
      ConsensusType["ProofOfStake"] = "pos";
      ConsensusType["ProofOfWork"] = "pow";
      ConsensusType["ProofOfAuthority"] = "poa";
  })(exports.ConsensusType || (exports.ConsensusType = {}));
  (function (ConsensusAlgorithm) {
      ConsensusAlgorithm["Ethash"] = "ethash";
      ConsensusAlgorithm["Clique"] = "clique";
      ConsensusAlgorithm["Casper"] = "casper";
  })(exports.ConsensusAlgorithm || (exports.ConsensusAlgorithm = {}));
  (function (CustomChain) {
      /**
       * Polygon (Matic) Mainnet
       *
       * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
       */
      CustomChain["PolygonMainnet"] = "polygon-mainnet";
      /**
       * Polygon (Matic) Mumbai Testnet
       *
       * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
       */
      CustomChain["PolygonMumbai"] = "polygon-mumbai";
      /**
       * Arbitrum Rinkeby Testnet
       *
       * - [Documentation](https://developer.offchainlabs.com/docs/public_testnet)
       */
      CustomChain["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
      /**
       * xDai EVM sidechain with a native stable token
       *
       * - [Documentation](https://www.xdaichain.com/)
       */
      CustomChain["xDaiChain"] = "x-dai-chain";
      /**
       * Optimistic Kovan - testnet for Optimism roll-up
       *
       * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)
       */
      CustomChain["OptimisticKovan"] = "optimistic-kovan";
      /**
       * Optimistic Ethereum - mainnet for Optimism roll-up
       *
       * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)
       */
      CustomChain["OptimisticEthereum"] = "optimistic-ethereum";
  })(exports.CustomChain || (exports.CustomChain = {}));

  }(enums));

  var hardforks = {};

  var name$g = "chainstart";
  var comment$g = "Start of the Ethereum main chain";
  var url$g = "";
  var status$g = "";
  var gasConfig$b = {
  	minGasLimit: {
  		v: 5000,
  		d: "Minimum the gas limit may ever be"
  	},
  	gasLimitBoundDivisor: {
  		v: 1024,
  		d: "The bound divisor of the gas limit, used in update calculations"
  	},
  	maxRefundQuotient: {
  		v: 2,
  		d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
  	}
  };
  var gasPrices$b = {
  	base: {
  		v: 2,
  		d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
  	},
  	tierStep: {
  		v: [
  			0,
  			2,
  			3,
  			5,
  			8,
  			10,
  			20
  		],
  		d: "Once per operation, for a selection of them"
  	},
  	exp: {
  		v: 10,
  		d: "Base fee of the EXP opcode"
  	},
  	expByte: {
  		v: 10,
  		d: "Times ceil(log256(exponent)) for the EXP instruction"
  	},
  	sha3: {
  		v: 30,
  		d: "Base fee of the SHA3 opcode"
  	},
  	sha3Word: {
  		v: 6,
  		d: "Once per word of the SHA3 operation's data"
  	},
  	sload: {
  		v: 50,
  		d: "Base fee of the SLOAD opcode"
  	},
  	sstoreSet: {
  		v: 20000,
  		d: "Once per SSTORE operation if the zeroness changes from zero"
  	},
  	sstoreReset: {
  		v: 5000,
  		d: "Once per SSTORE operation if the zeroness does not change from zero"
  	},
  	sstoreRefund: {
  		v: 15000,
  		d: "Once per SSTORE operation if the zeroness changes to zero"
  	},
  	jumpdest: {
  		v: 1,
  		d: "Base fee of the JUMPDEST opcode"
  	},
  	log: {
  		v: 375,
  		d: "Base fee of the LOG opcode"
  	},
  	logData: {
  		v: 8,
  		d: "Per byte in a LOG* operation's data"
  	},
  	logTopic: {
  		v: 375,
  		d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
  	},
  	create: {
  		v: 32000,
  		d: "Base fee of the CREATE opcode"
  	},
  	call: {
  		v: 40,
  		d: "Base fee of the CALL opcode"
  	},
  	callStipend: {
  		v: 2300,
  		d: "Free gas given at beginning of call"
  	},
  	callValueTransfer: {
  		v: 9000,
  		d: "Paid for CALL when the value transfor is non-zero"
  	},
  	callNewAccount: {
  		v: 25000,
  		d: "Paid for CALL when the destination address didn't exist prior"
  	},
  	selfdestructRefund: {
  		v: 24000,
  		d: "Refunded following a selfdestruct operation"
  	},
  	memory: {
  		v: 3,
  		d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
  	},
  	quadCoeffDiv: {
  		v: 512,
  		d: "Divisor for the quadratic particle of the memory cost equation"
  	},
  	createData: {
  		v: 200,
  		d: ""
  	},
  	tx: {
  		v: 21000,
  		d: "Per transaction. NOTE: Not payable on data of calls between transactions"
  	},
  	txCreation: {
  		v: 32000,
  		d: "The cost of creating a contract via tx"
  	},
  	txDataZero: {
  		v: 4,
  		d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
  	},
  	txDataNonZero: {
  		v: 68,
  		d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
  	},
  	copy: {
  		v: 3,
  		d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
  	},
  	ecRecover: {
  		v: 3000,
  		d: ""
  	},
  	sha256: {
  		v: 60,
  		d: ""
  	},
  	sha256Word: {
  		v: 12,
  		d: ""
  	},
  	ripemd160: {
  		v: 600,
  		d: ""
  	},
  	ripemd160Word: {
  		v: 120,
  		d: ""
  	},
  	identity: {
  		v: 15,
  		d: ""
  	},
  	identityWord: {
  		v: 3,
  		d: ""
  	},
  	stop: {
  		v: 0,
  		d: "Base fee of the STOP opcode"
  	},
  	add: {
  		v: 3,
  		d: "Base fee of the ADD opcode"
  	},
  	mul: {
  		v: 5,
  		d: "Base fee of the MUL opcode"
  	},
  	sub: {
  		v: 3,
  		d: "Base fee of the SUB opcode"
  	},
  	div: {
  		v: 5,
  		d: "Base fee of the DIV opcode"
  	},
  	sdiv: {
  		v: 5,
  		d: "Base fee of the SDIV opcode"
  	},
  	mod: {
  		v: 5,
  		d: "Base fee of the MOD opcode"
  	},
  	smod: {
  		v: 5,
  		d: "Base fee of the SMOD opcode"
  	},
  	addmod: {
  		v: 8,
  		d: "Base fee of the ADDMOD opcode"
  	},
  	mulmod: {
  		v: 8,
  		d: "Base fee of the MULMOD opcode"
  	},
  	signextend: {
  		v: 5,
  		d: "Base fee of the SIGNEXTEND opcode"
  	},
  	lt: {
  		v: 3,
  		d: "Base fee of the LT opcode"
  	},
  	gt: {
  		v: 3,
  		d: "Base fee of the GT opcode"
  	},
  	slt: {
  		v: 3,
  		d: "Base fee of the SLT opcode"
  	},
  	sgt: {
  		v: 3,
  		d: "Base fee of the SGT opcode"
  	},
  	eq: {
  		v: 3,
  		d: "Base fee of the EQ opcode"
  	},
  	iszero: {
  		v: 3,
  		d: "Base fee of the ISZERO opcode"
  	},
  	and: {
  		v: 3,
  		d: "Base fee of the AND opcode"
  	},
  	or: {
  		v: 3,
  		d: "Base fee of the OR opcode"
  	},
  	xor: {
  		v: 3,
  		d: "Base fee of the XOR opcode"
  	},
  	not: {
  		v: 3,
  		d: "Base fee of the NOT opcode"
  	},
  	byte: {
  		v: 3,
  		d: "Base fee of the BYTE opcode"
  	},
  	address: {
  		v: 2,
  		d: "Base fee of the ADDRESS opcode"
  	},
  	balance: {
  		v: 20,
  		d: "Base fee of the BALANCE opcode"
  	},
  	origin: {
  		v: 2,
  		d: "Base fee of the ORIGIN opcode"
  	},
  	caller: {
  		v: 2,
  		d: "Base fee of the CALLER opcode"
  	},
  	callvalue: {
  		v: 2,
  		d: "Base fee of the CALLVALUE opcode"
  	},
  	calldataload: {
  		v: 3,
  		d: "Base fee of the CALLDATALOAD opcode"
  	},
  	calldatasize: {
  		v: 2,
  		d: "Base fee of the CALLDATASIZE opcode"
  	},
  	calldatacopy: {
  		v: 3,
  		d: "Base fee of the CALLDATACOPY opcode"
  	},
  	codesize: {
  		v: 2,
  		d: "Base fee of the CODESIZE opcode"
  	},
  	codecopy: {
  		v: 3,
  		d: "Base fee of the CODECOPY opcode"
  	},
  	gasprice: {
  		v: 2,
  		d: "Base fee of the GASPRICE opcode"
  	},
  	extcodesize: {
  		v: 20,
  		d: "Base fee of the EXTCODESIZE opcode"
  	},
  	extcodecopy: {
  		v: 20,
  		d: "Base fee of the EXTCODECOPY opcode"
  	},
  	blockhash: {
  		v: 20,
  		d: "Base fee of the BLOCKHASH opcode"
  	},
  	coinbase: {
  		v: 2,
  		d: "Base fee of the COINBASE opcode"
  	},
  	timestamp: {
  		v: 2,
  		d: "Base fee of the TIMESTAMP opcode"
  	},
  	number: {
  		v: 2,
  		d: "Base fee of the NUMBER opcode"
  	},
  	difficulty: {
  		v: 2,
  		d: "Base fee of the DIFFICULTY opcode"
  	},
  	gaslimit: {
  		v: 2,
  		d: "Base fee of the GASLIMIT opcode"
  	},
  	pop: {
  		v: 2,
  		d: "Base fee of the POP opcode"
  	},
  	mload: {
  		v: 3,
  		d: "Base fee of the MLOAD opcode"
  	},
  	mstore: {
  		v: 3,
  		d: "Base fee of the MSTORE opcode"
  	},
  	mstore8: {
  		v: 3,
  		d: "Base fee of the MSTORE8 opcode"
  	},
  	sstore: {
  		v: 0,
  		d: "Base fee of the SSTORE opcode"
  	},
  	jump: {
  		v: 8,
  		d: "Base fee of the JUMP opcode"
  	},
  	jumpi: {
  		v: 10,
  		d: "Base fee of the JUMPI opcode"
  	},
  	pc: {
  		v: 2,
  		d: "Base fee of the PC opcode"
  	},
  	msize: {
  		v: 2,
  		d: "Base fee of the MSIZE opcode"
  	},
  	gas: {
  		v: 2,
  		d: "Base fee of the GAS opcode"
  	},
  	push: {
  		v: 3,
  		d: "Base fee of the PUSH opcode"
  	},
  	dup: {
  		v: 3,
  		d: "Base fee of the DUP opcode"
  	},
  	swap: {
  		v: 3,
  		d: "Base fee of the SWAP opcode"
  	},
  	callcode: {
  		v: 40,
  		d: "Base fee of the CALLCODE opcode"
  	},
  	"return": {
  		v: 0,
  		d: "Base fee of the RETURN opcode"
  	},
  	invalid: {
  		v: 0,
  		d: "Base fee of the INVALID opcode"
  	},
  	selfdestruct: {
  		v: 0,
  		d: "Base fee of the SELFDESTRUCT opcode"
  	}
  };
  var vm$c = {
  	stackLimit: {
  		v: 1024,
  		d: "Maximum size of VM stack allowed"
  	},
  	callCreateDepth: {
  		v: 1024,
  		d: "Maximum depth of call/create stack"
  	},
  	maxExtraDataSize: {
  		v: 32,
  		d: "Maximum size extra data may be after Genesis"
  	}
  };
  var pow$b = {
  	minimumDifficulty: {
  		v: 131072,
  		d: "The minimum that the difficulty may ever be"
  	},
  	difficultyBoundDivisor: {
  		v: 2048,
  		d: "The bound divisor of the difficulty, used in the update calculations"
  	},
  	durationLimit: {
  		v: 13,
  		d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
  	},
  	epochDuration: {
  		v: 30000,
  		d: "Duration between proof-of-work epochs"
  	},
  	timebombPeriod: {
  		v: 100000,
  		d: "Exponential difficulty timebomb period"
  	},
  	minerReward: {
  		v: "5000000000000000000",
  		d: "the amount a miner get rewarded for mining a block"
  	},
  	difficultyBombDelay: {
  		v: 0,
  		d: "the amount of blocks to delay the difficulty bomb with"
  	}
  };
  var require$$0$4 = {
  	name: name$g,
  	comment: comment$g,
  	url: url$g,
  	status: status$g,
  	gasConfig: gasConfig$b,
  	gasPrices: gasPrices$b,
  	vm: vm$c,
  	pow: pow$b
  };

  var name$f = "homestead";
  var comment$f = "Homestead hardfork with protocol and network changes";
  var url$f = "https://eips.ethereum.org/EIPS/eip-606";
  var status$f = "Final";
  var gasConfig$a = {
  };
  var gasPrices$a = {
  	delegatecall: {
  		v: 40,
  		d: "Base fee of the DELEGATECALL opcode"
  	}
  };
  var vm$b = {
  };
  var pow$a = {
  };
  var require$$1$1 = {
  	name: name$f,
  	comment: comment$f,
  	url: url$f,
  	status: status$f,
  	gasConfig: gasConfig$a,
  	gasPrices: gasPrices$a,
  	vm: vm$b,
  	pow: pow$a
  };

  var name$e = "dao";
  var comment$e = "DAO rescue hardfork";
  var url$e = "https://eips.ethereum.org/EIPS/eip-779";
  var status$e = "Final";
  var gasConfig$9 = {
  };
  var gasPrices$9 = {
  };
  var vm$a = {
  };
  var pow$9 = {
  };
  var require$$2 = {
  	name: name$e,
  	comment: comment$e,
  	url: url$e,
  	status: status$e,
  	gasConfig: gasConfig$9,
  	gasPrices: gasPrices$9,
  	vm: vm$a,
  	pow: pow$9
  };

  var name$d = "tangerineWhistle";
  var comment$d = "Hardfork with gas cost changes for IO-heavy operations";
  var url$d = "https://eips.ethereum.org/EIPS/eip-608";
  var status$d = "Final";
  var gasConfig$8 = {
  };
  var gasPrices$8 = {
  	sload: {
  		v: 200,
  		d: "Once per SLOAD operation"
  	},
  	call: {
  		v: 700,
  		d: "Once per CALL operation & message call transaction"
  	},
  	extcodesize: {
  		v: 700,
  		d: "Base fee of the EXTCODESIZE opcode"
  	},
  	extcodecopy: {
  		v: 700,
  		d: "Base fee of the EXTCODECOPY opcode"
  	},
  	balance: {
  		v: 400,
  		d: "Base fee of the BALANCE opcode"
  	},
  	delegatecall: {
  		v: 700,
  		d: "Base fee of the DELEGATECALL opcode"
  	},
  	callcode: {
  		v: 700,
  		d: "Base fee of the CALLCODE opcode"
  	},
  	selfdestruct: {
  		v: 5000,
  		d: "Base fee of the SELFDESTRUCT opcode"
  	}
  };
  var vm$9 = {
  };
  var pow$8 = {
  };
  var require$$3 = {
  	name: name$d,
  	comment: comment$d,
  	url: url$d,
  	status: status$d,
  	gasConfig: gasConfig$8,
  	gasPrices: gasPrices$8,
  	vm: vm$9,
  	pow: pow$8
  };

  var name$c = "spuriousDragon";
  var comment$c = "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit";
  var url$c = "https://eips.ethereum.org/EIPS/eip-607";
  var status$c = "Final";
  var gasConfig$7 = {
  };
  var gasPrices$7 = {
  	expByte: {
  		v: 50,
  		d: "Times ceil(log256(exponent)) for the EXP instruction"
  	}
  };
  var vm$8 = {
  	maxCodeSize: {
  		v: 24576,
  		d: "Maximum length of contract code"
  	}
  };
  var pow$7 = {
  };
  var require$$4 = {
  	name: name$c,
  	comment: comment$c,
  	url: url$c,
  	status: status$c,
  	gasConfig: gasConfig$7,
  	gasPrices: gasPrices$7,
  	vm: vm$8,
  	pow: pow$7
  };

  var name$b = "byzantium";
  var comment$b = "Hardfork with new precompiles, instructions and other protocol changes";
  var url$b = "https://eips.ethereum.org/EIPS/eip-609";
  var status$b = "Final";
  var gasConfig$6 = {
  };
  var gasPrices$6 = {
  	modexpGquaddivisor: {
  		v: 20,
  		d: "Gquaddivisor from modexp precompile for gas calculation"
  	},
  	ecAdd: {
  		v: 500,
  		d: "Gas costs for curve addition precompile"
  	},
  	ecMul: {
  		v: 40000,
  		d: "Gas costs for curve multiplication precompile"
  	},
  	ecPairing: {
  		v: 100000,
  		d: "Base gas costs for curve pairing precompile"
  	},
  	ecPairingWord: {
  		v: 80000,
  		d: "Gas costs regarding curve pairing precompile input length"
  	},
  	revert: {
  		v: 0,
  		d: "Base fee of the REVERT opcode"
  	},
  	staticcall: {
  		v: 700,
  		d: "Base fee of the STATICCALL opcode"
  	},
  	returndatasize: {
  		v: 2,
  		d: "Base fee of the RETURNDATASIZE opcode"
  	},
  	returndatacopy: {
  		v: 3,
  		d: "Base fee of the RETURNDATACOPY opcode"
  	}
  };
  var vm$7 = {
  };
  var pow$6 = {
  	minerReward: {
  		v: "3000000000000000000",
  		d: "the amount a miner get rewarded for mining a block"
  	},
  	difficultyBombDelay: {
  		v: 3000000,
  		d: "the amount of blocks to delay the difficulty bomb with"
  	}
  };
  var require$$5 = {
  	name: name$b,
  	comment: comment$b,
  	url: url$b,
  	status: status$b,
  	gasConfig: gasConfig$6,
  	gasPrices: gasPrices$6,
  	vm: vm$7,
  	pow: pow$6
  };

  var name$a = "constantinople";
  var comment$a = "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)";
  var url$a = "https://eips.ethereum.org/EIPS/eip-1013";
  var status$a = "Final";
  var gasConfig$5 = {
  };
  var gasPrices$5 = {
  	netSstoreNoopGas: {
  		v: 200,
  		d: "Once per SSTORE operation if the value doesn't change"
  	},
  	netSstoreInitGas: {
  		v: 20000,
  		d: "Once per SSTORE operation from clean zero"
  	},
  	netSstoreCleanGas: {
  		v: 5000,
  		d: "Once per SSTORE operation from clean non-zero"
  	},
  	netSstoreDirtyGas: {
  		v: 200,
  		d: "Once per SSTORE operation from dirty"
  	},
  	netSstoreClearRefund: {
  		v: 15000,
  		d: "Once per SSTORE operation for clearing an originally existing storage slot"
  	},
  	netSstoreResetRefund: {
  		v: 4800,
  		d: "Once per SSTORE operation for resetting to the original non-zero value"
  	},
  	netSstoreResetClearRefund: {
  		v: 19800,
  		d: "Once per SSTORE operation for resetting to the original zero value"
  	},
  	shl: {
  		v: 3,
  		d: "Base fee of the SHL opcode"
  	},
  	shr: {
  		v: 3,
  		d: "Base fee of the SHR opcode"
  	},
  	sar: {
  		v: 3,
  		d: "Base fee of the SAR opcode"
  	},
  	extcodehash: {
  		v: 400,
  		d: "Base fee of the EXTCODEHASH opcode"
  	},
  	create2: {
  		v: 32000,
  		d: "Base fee of the CREATE2 opcode"
  	}
  };
  var vm$6 = {
  };
  var pow$5 = {
  	minerReward: {
  		v: "2000000000000000000",
  		d: "The amount a miner gets rewarded for mining a block"
  	},
  	difficultyBombDelay: {
  		v: 5000000,
  		d: "the amount of blocks to delay the difficulty bomb with"
  	}
  };
  var require$$6 = {
  	name: name$a,
  	comment: comment$a,
  	url: url$a,
  	status: status$a,
  	gasConfig: gasConfig$5,
  	gasPrices: gasPrices$5,
  	vm: vm$6,
  	pow: pow$5
  };

  var name$9 = "petersburg";
  var comment$9 = "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople";
  var url$9 = "https://eips.ethereum.org/EIPS/eip-1716";
  var status$9 = "Final";
  var gasConfig$4 = {
  };
  var gasPrices$4 = {
  	netSstoreNoopGas: {
  		v: null,
  		d: "Removed along EIP-1283"
  	},
  	netSstoreInitGas: {
  		v: null,
  		d: "Removed along EIP-1283"
  	},
  	netSstoreCleanGas: {
  		v: null,
  		d: "Removed along EIP-1283"
  	},
  	netSstoreDirtyGas: {
  		v: null,
  		d: "Removed along EIP-1283"
  	},
  	netSstoreClearRefund: {
  		v: null,
  		d: "Removed along EIP-1283"
  	},
  	netSstoreResetRefund: {
  		v: null,
  		d: "Removed along EIP-1283"
  	},
  	netSstoreResetClearRefund: {
  		v: null,
  		d: "Removed along EIP-1283"
  	}
  };
  var vm$5 = {
  };
  var pow$4 = {
  };
  var require$$7$1 = {
  	name: name$9,
  	comment: comment$9,
  	url: url$9,
  	status: status$9,
  	gasConfig: gasConfig$4,
  	gasPrices: gasPrices$4,
  	vm: vm$5,
  	pow: pow$4
  };

  var name$8 = "istanbul";
  var comment$8 = "HF targeted for December 2019 following the Constantinople/Petersburg HF";
  var url$8 = "https://eips.ethereum.org/EIPS/eip-1679";
  var status$8 = "Final";
  var gasConfig$3 = {
  };
  var gasPrices$3 = {
  	blake2Round: {
  		v: 1,
  		d: "Gas cost per round for the Blake2 F precompile"
  	},
  	ecAdd: {
  		v: 150,
  		d: "Gas costs for curve addition precompile"
  	},
  	ecMul: {
  		v: 6000,
  		d: "Gas costs for curve multiplication precompile"
  	},
  	ecPairing: {
  		v: 45000,
  		d: "Base gas costs for curve pairing precompile"
  	},
  	ecPairingWord: {
  		v: 34000,
  		d: "Gas costs regarding curve pairing precompile input length"
  	},
  	txDataNonZero: {
  		v: 16,
  		d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
  	},
  	sstoreSentryGasEIP2200: {
  		v: 2300,
  		d: "Minimum gas required to be present for an SSTORE call, not consumed"
  	},
  	sstoreNoopGasEIP2200: {
  		v: 800,
  		d: "Once per SSTORE operation if the value doesn't change"
  	},
  	sstoreDirtyGasEIP2200: {
  		v: 800,
  		d: "Once per SSTORE operation if a dirty value is changed"
  	},
  	sstoreInitGasEIP2200: {
  		v: 20000,
  		d: "Once per SSTORE operation from clean zero to non-zero"
  	},
  	sstoreInitRefundEIP2200: {
  		v: 19200,
  		d: "Once per SSTORE operation for resetting to the original zero value"
  	},
  	sstoreCleanGasEIP2200: {
  		v: 5000,
  		d: "Once per SSTORE operation from clean non-zero to something else"
  	},
  	sstoreCleanRefundEIP2200: {
  		v: 4200,
  		d: "Once per SSTORE operation for resetting to the original non-zero value"
  	},
  	sstoreClearRefundEIP2200: {
  		v: 15000,
  		d: "Once per SSTORE operation for clearing an originally existing storage slot"
  	},
  	balance: {
  		v: 700,
  		d: "Base fee of the BALANCE opcode"
  	},
  	extcodehash: {
  		v: 700,
  		d: "Base fee of the EXTCODEHASH opcode"
  	},
  	chainid: {
  		v: 2,
  		d: "Base fee of the CHAINID opcode"
  	},
  	selfbalance: {
  		v: 5,
  		d: "Base fee of the SELFBALANCE opcode"
  	},
  	sload: {
  		v: 800,
  		d: "Base fee of the SLOAD opcode"
  	}
  };
  var vm$4 = {
  };
  var pow$3 = {
  };
  var require$$8 = {
  	name: name$8,
  	comment: comment$8,
  	url: url$8,
  	status: status$8,
  	gasConfig: gasConfig$3,
  	gasPrices: gasPrices$3,
  	vm: vm$4,
  	pow: pow$3
  };

  var name$7 = "muirGlacier";
  var comment$7 = "HF to delay the difficulty bomb";
  var url$7 = "https://eips.ethereum.org/EIPS/eip-2384";
  var status$7 = "Final";
  var gasConfig$2 = {
  };
  var gasPrices$2 = {
  };
  var vm$3 = {
  };
  var pow$2 = {
  	difficultyBombDelay: {
  		v: 9000000,
  		d: "the amount of blocks to delay the difficulty bomb with"
  	}
  };
  var require$$9 = {
  	name: name$7,
  	comment: comment$7,
  	url: url$7,
  	status: status$7,
  	gasConfig: gasConfig$2,
  	gasPrices: gasPrices$2,
  	vm: vm$3,
  	pow: pow$2
  };

  var name$6 = "berlin";
  var comment$6 = "HF targeted for July 2020 following the Muir Glacier HF";
  var url$6 = "https://eips.ethereum.org/EIPS/eip-2070";
  var status$6 = "Final";
  var eips$6 = [
  	2565,
  	2929,
  	2718,
  	2930
  ];
  var require$$10$1 = {
  	name: name$6,
  	comment: comment$6,
  	url: url$6,
  	status: status$6,
  	eips: eips$6
  };

  var name$5 = "london";
  var comment$5 = "HF targeted for July 2021 following the Berlin fork";
  var url$5 = "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md";
  var status$5 = "Final";
  var eips$5 = [
  	1559,
  	3198,
  	3529,
  	3541
  ];
  var require$$11$1 = {
  	name: name$5,
  	comment: comment$5,
  	url: url$5,
  	status: status$5,
  	eips: eips$5
  };

  var name$4 = "shanghai";
  var comment$4 = "Next feature hardfork after the merge hardfork";
  var url$4 = "https://github.com/ethereum/pm/issues/356";
  var status$4 = "Pre-Draft";
  var eips$4 = [
  ];
  var require$$12$1 = {
  	name: name$4,
  	comment: comment$4,
  	url: url$4,
  	status: status$4,
  	eips: eips$4
  };

  var name$3 = "arrowGlacier";
  var comment$3 = "HF to delay the difficulty bomb";
  var url$3 = "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md";
  var status$3 = "Final";
  var eips$3 = [
  	4345
  ];
  var gasConfig$1 = {
  };
  var gasPrices$1 = {
  };
  var vm$2 = {
  };
  var pow$1 = {
  };
  var require$$13$1 = {
  	name: name$3,
  	comment: comment$3,
  	url: url$3,
  	status: status$3,
  	eips: eips$3,
  	gasConfig: gasConfig$1,
  	gasPrices: gasPrices$1,
  	vm: vm$2,
  	pow: pow$1
  };

  var name$2 = "grayGlacier";
  var comment$2 = "Delaying the difficulty bomb to Mid September 2022";
  var url$2 = "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md";
  var status$2 = "Draft";
  var eips$2 = [
  	5133
  ];
  var gasConfig = {
  };
  var gasPrices = {
  };
  var vm$1 = {
  };
  var pow = {
  };
  var require$$14$1 = {
  	name: name$2,
  	comment: comment$2,
  	url: url$2,
  	status: status$2,
  	eips: eips$2,
  	gasConfig: gasConfig,
  	gasPrices: gasPrices,
  	vm: vm$1,
  	pow: pow
  };

  var name$1 = "mergeForkIdTransition";
  var comment$1 = "Pre-merge hardfork to fork off non-upgraded clients";
  var url$1 = "https://eips.ethereum.org/EIPS/eip-3675";
  var status$1 = "Draft";
  var eips$1 = [
  ];
  var require$$15$1 = {
  	name: name$1,
  	comment: comment$1,
  	url: url$1,
  	status: status$1,
  	eips: eips$1
  };

  var name = "merge";
  var comment = "Hardfork to upgrade the consensus mechanism to Proof-of-Stake";
  var url = "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md";
  var status = "Draft";
  var consensus$1 = {
  	type: "pos",
  	algorithm: "casper",
  	casper: {
  	}
  };
  var eips = [
  	3675,
  	4399
  ];
  var require$$16 = {
  	name: name,
  	comment: comment,
  	url: url,
  	status: status,
  	consensus: consensus$1,
  	eips: eips
  };

  Object.defineProperty(hardforks, "__esModule", { value: true });
  hardforks.hardforks = void 0;
  hardforks.hardforks = [
      ['chainstart', require$$0$4],
      ['homestead', require$$1$1],
      ['dao', require$$2],
      ['tangerineWhistle', require$$3],
      ['spuriousDragon', require$$4],
      ['byzantium', require$$5],
      ['constantinople', require$$6],
      ['petersburg', require$$7$1],
      ['istanbul', require$$8],
      ['muirGlacier', require$$9],
      ['berlin', require$$10$1],
      ['london', require$$11$1],
      ['shanghai', require$$12$1],
      ['arrowGlacier', require$$13$1],
      ['grayGlacier', require$$14$1],
      ['mergeForkIdTransition', require$$15$1],
      ['merge', require$$16],
  ];

  Object.defineProperty(common$2, "__esModule", { value: true });
  common$2.Common = void 0;
  const events_1 = events.exports;
  const util_1$S = dist$a;
  const crc_32_1 = crc32;
  const goerli = require$$3$2;
  const kovan = require$$4$2;
  const mainnet = require$$5$2;
  const rinkeby = require$$6$2;
  const ropsten = require$$7$3;
  const sepolia = require$$8$2;
  const eips_1 = eips$7;
  const enums_1 = enums;
  const hardforks_1 = hardforks;
  /**
   * Common class to access chain and hardfork parameters and to provide
   * a unified and shared view on the network and hardfork state.
   *
   * Use the {@link Common.custom} static constructor for creating simple
   * custom chain {@link Common} objects (more complete custom chain setups
   * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).
   */
  class Common extends events_1.EventEmitter {
      constructor(opts) {
          super();
          this._eips = [];
          this._customChains = opts.customChains ?? [];
          this._chainParams = this.setChain(opts.chain);
          this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;
          this._hardfork = this.DEFAULT_HARDFORK;
          if ((0, util_1$S.isTruthy)(opts.hardfork)) {
              this.setHardfork(opts.hardfork);
          }
          if (opts.eips) {
              this.setEIPs(opts.eips);
          }
      }
      /**
       * Creates a {@link Common} object for a custom chain, based on a standard one.
       *
       * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden
       * in a provided {@link chainParamsOrName} dictionary. Some usage example:
       *
       * ```javascript
       * Common.custom({chainId: 123})
       * ```
       *
       * There are also selected supported custom chains which can be initialized by using one of the
       * {@link CustomChains} for {@link chainParamsOrName}, e.g.:
       *
       * ```javascript
       * Common.custom(CustomChains.MaticMumbai)
       * ```
       *
       * Note that these supported custom chains only provide some base parameters (usually the chain and
       * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with
       * the `@ethereumjs/tx` library to a Layer-2 chain).
       *
       * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain
       * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others
       */
      static custom(chainParamsOrName, opts = {}) {
          const baseChain = opts.baseChain ?? 'mainnet';
          const standardChainParams = { ...Common._getChainParams(baseChain) };
          standardChainParams['name'] = 'custom-chain';
          if (typeof chainParamsOrName !== 'string') {
              return new Common({
                  chain: {
                      ...standardChainParams,
                      ...chainParamsOrName,
                  },
                  ...opts,
              });
          }
          else {
              if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {
                  return Common.custom({
                      name: enums_1.CustomChain.PolygonMainnet,
                      chainId: 137,
                      networkId: 137,
                  }, opts);
              }
              if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {
                  return Common.custom({
                      name: enums_1.CustomChain.PolygonMumbai,
                      chainId: 80001,
                      networkId: 80001,
                  }, opts);
              }
              if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {
                  return Common.custom({
                      name: enums_1.CustomChain.ArbitrumRinkebyTestnet,
                      chainId: 421611,
                      networkId: 421611,
                  }, opts);
              }
              if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {
                  return Common.custom({
                      name: enums_1.CustomChain.xDaiChain,
                      chainId: 100,
                      networkId: 100,
                  }, opts);
              }
              if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {
                  return Common.custom({
                      name: enums_1.CustomChain.OptimisticKovan,
                      chainId: 69,
                      networkId: 69,
                  }, 
                  // Optimism has not implemented the London hardfork yet (targeting Q1.22)
                  { hardfork: enums_1.Hardfork.Berlin, ...opts });
              }
              if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {
                  return Common.custom({
                      name: enums_1.CustomChain.OptimisticEthereum,
                      chainId: 10,
                      networkId: 10,
                  }, 
                  // Optimism has not implemented the London hardfork yet (targeting Q1.22)
                  { hardfork: enums_1.Hardfork.Berlin, ...opts });
              }
              throw new Error(`Custom chain ${chainParamsOrName} not supported`);
          }
      }
      /**
       * Static method to determine if a {@link chainId} is supported as a standard chain
       * @param chainId bigint id (`1`) of a standard chain
       * @returns boolean
       */
      static isSupportedChainId(chainId) {
          const initializedChains = this._getInitializedChains();
          return Boolean(initializedChains['names'][chainId.toString()]);
      }
      static _getChainParams(chain, customChains) {
          const initializedChains = this._getInitializedChains(customChains);
          if (typeof chain === 'number' || typeof chain === 'bigint') {
              chain = chain.toString();
              if (initializedChains['names'][chain]) {
                  const name = initializedChains['names'][chain];
                  return initializedChains[name];
              }
              throw new Error(`Chain with ID ${chain} not supported`);
          }
          if ((0, util_1$S.isTruthy)(initializedChains[chain])) {
              return initializedChains[chain];
          }
          throw new Error(`Chain with name ${chain} not supported`);
      }
      /**
       * Sets the chain
       * @param chain String ('mainnet') or Number (1) chain representation.
       *              Or, a Dictionary of chain parameters for a private network.
       * @returns The dictionary with parameters set as chain
       */
      setChain(chain) {
          if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {
              this._chainParams = Common._getChainParams(chain, this._customChains);
          }
          else if (typeof chain === 'object') {
              if (this._customChains.length > 0) {
                  throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');
              }
              const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];
              for (const param of required) {
                  if (!(param in chain)) {
                      throw new Error(`Missing required chain parameter: ${param}`);
                  }
              }
              this._chainParams = chain;
          }
          else {
              throw new Error('Wrong input format');
          }
          return this._chainParams;
      }
      /**
       * Sets the hardfork to get params for
       * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum
       */
      setHardfork(hardfork) {
          let existing = false;
          for (const hfChanges of hardforks_1.hardforks) {
              if (hfChanges[0] === hardfork) {
                  if (this._hardfork !== hardfork) {
                      this._hardfork = hardfork;
                      this.emit('hardforkChanged', hardfork);
                  }
                  existing = true;
              }
          }
          if (!existing) {
              throw new Error(`Hardfork with name ${hardfork} not supported`);
          }
      }
      /**
       * Returns the hardfork based on the block number or an optional
       * total difficulty (Merge HF) provided.
       *
       * An optional TD takes precedence in case the corresponding HF block
       * is set to `null` or otherwise needs to match (if not an error
       * will be thrown).
       *
       * @param blockNumber
       * @param td
       * @returns The name of the HF
       */
      getHardforkByBlockNumber(blockNumber, td) {
          blockNumber = (0, util_1$S.toType)(blockNumber, util_1$S.TypeOutput.BigInt);
          td = (0, util_1$S.toType)(td, util_1$S.TypeOutput.BigInt);
          let hardfork = enums_1.Hardfork.Chainstart;
          let minTdHF;
          let maxTdHF;
          let previousHF;
          for (const hf of this.hardforks()) {
              // Skip comparison for not applied HFs
              if (hf.block === null) {
                  if (td !== undefined && td !== null && hf.ttd !== undefined && hf.ttd !== null) {
                      if (td >= BigInt(hf.ttd)) {
                          return hf.name;
                      }
                  }
                  continue;
              }
              if (blockNumber >= BigInt(hf.block)) {
                  hardfork = hf.name;
              }
              if (td && (0, util_1$S.isTruthy)(hf.ttd)) {
                  if (td >= BigInt(hf.ttd)) {
                      minTdHF = hf.name;
                  }
                  else {
                      maxTdHF = previousHF;
                  }
              }
              previousHF = hf.name;
          }
          if (td) {
              let msgAdd = `block number: ${blockNumber} (-> ${hardfork}), `;
              if ((0, util_1$S.isTruthy)(minTdHF)) {
                  if (!this.hardforkGteHardfork(hardfork, minTdHF)) {
                      const msg = 'HF determined by block number is lower than the minimum total difficulty HF';
                      msgAdd += `total difficulty: ${td} (-> ${minTdHF})`;
                      throw new Error(`${msg}: ${msgAdd}`);
                  }
              }
              if ((0, util_1$S.isTruthy)(maxTdHF)) {
                  if (!this.hardforkGteHardfork(maxTdHF, hardfork)) {
                      const msg = 'Maximum HF determined by total difficulty is lower than the block number HF';
                      msgAdd += `total difficulty: ${td} (-> ${maxTdHF})`;
                      throw new Error(`${msg}: ${msgAdd}`);
                  }
              }
          }
          return hardfork;
      }
      /**
       * Sets a new hardfork based on the block number or an optional
       * total difficulty (Merge HF) provided.
       *
       * An optional TD takes precedence in case the corresponding HF block
       * is set to `null` or otherwise needs to match (if not an error
       * will be thrown).
       *
       * @param blockNumber
       * @param td
       * @returns The name of the HF set
       */
      setHardforkByBlockNumber(blockNumber, td) {
          const hardfork = this.getHardforkByBlockNumber(blockNumber, td);
          this.setHardfork(hardfork);
          return hardfork;
      }
      /**
       * Internal helper function, returns the params for the given hardfork for the chain set
       * @param hardfork Hardfork name
       * @returns Dictionary with hardfork params or null if hardfork not on chain
       */
      _getHardfork(hardfork) {
          const hfs = this.hardforks();
          for (const hf of hfs) {
              if (hf['name'] === hardfork)
                  return hf;
          }
          return null;
      }
      /**
       * Sets the active EIPs
       * @param eips
       */
      setEIPs(eips = []) {
          for (const eip of eips) {
              if (!(eip in eips_1.EIPs)) {
                  throw new Error(`${eip} not supported`);
              }
              const minHF = this.gteHardfork(eips_1.EIPs[eip]['minimumHardfork']);
              if (!minHF) {
                  throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
              }
              if ((0, util_1$S.isTruthy)(eips_1.EIPs[eip].requiredEIPs)) {
                  eips_1.EIPs[eip].requiredEIPs.forEach((elem) => {
                      if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
                          throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
                      }
                  });
              }
          }
          this._eips = eips;
      }
      /**
       * Returns a parameter for the current chain setup
       *
       * If the parameter is present in an EIP, the EIP always takes precendence.
       * Otherwise the parameter if taken from the latest applied HF with
       * a change on the respective parameter.
       *
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @returns The value requested or `BigInt(0)` if not found
       */
      param(topic, name) {
          // TODO: consider the case that different active EIPs
          // can change the same parameter
          let value;
          for (const eip of this._eips) {
              value = this.paramByEIP(topic, name, eip);
              if (value !== undefined)
                  return value;
          }
          return this.paramByHardfork(topic, name, this._hardfork);
      }
      /**
       * Returns the parameter corresponding to a hardfork
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @param hardfork Hardfork name
       * @returns The value requested or `BigInt(0)` if not found
       */
      paramByHardfork(topic, name, hardfork) {
          let value = null;
          for (const hfChanges of hardforks_1.hardforks) {
              // EIP-referencing HF file (e.g. berlin.json)
              if ('eips' in hfChanges[1]) {
                  const hfEIPs = hfChanges[1]['eips'];
                  for (const eip of hfEIPs) {
                      const valueEIP = this.paramByEIP(topic, name, eip);
                      value = valueEIP !== undefined ? valueEIP : value;
                  }
                  // Parameter-inlining HF file (e.g. istanbul.json)
              }
              else {
                  if ((0, util_1$S.isFalsy)(hfChanges[1][topic])) {
                      throw new Error(`Topic ${topic} not defined`);
                  }
                  if (hfChanges[1][topic][name] !== undefined) {
                      value = hfChanges[1][topic][name].v;
                  }
              }
              if (hfChanges[0] === hardfork)
                  break;
          }
          return BigInt(value ?? 0);
      }
      /**
       * Returns a parameter corresponding to an EIP
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @param eip Number of the EIP
       * @returns The value requested or `undefined` if not found
       */
      paramByEIP(topic, name, eip) {
          if (!(eip in eips_1.EIPs)) {
              throw new Error(`${eip} not supported`);
          }
          const eipParams = eips_1.EIPs[eip];
          if (!(topic in eipParams)) {
              throw new Error(`Topic ${topic} not defined`);
          }
          if (eipParams[topic][name] === undefined) {
              return undefined;
          }
          const value = eipParams[topic][name].v;
          return BigInt(value);
      }
      /**
       * Returns a parameter for the hardfork active on block number or
       * optional provided total difficulty (Merge HF)
       * @param topic Parameter topic
       * @param name Parameter name
       * @param blockNumber Block number
       * @param td Total difficulty
       *    * @returns The value requested or `BigInt(0)` if not found
       */
      paramByBlock(topic, name, blockNumber, td) {
          const hardfork = this.getHardforkByBlockNumber(blockNumber, td);
          return this.paramByHardfork(topic, name, hardfork);
      }
      /**
       * Checks if an EIP is activated by either being included in the EIPs
       * manually passed in with the {@link CommonOpts.eips} or in a
       * hardfork currently being active
       *
       * Note: this method only works for EIPs being supported
       * by the {@link CommonOpts.eips} constructor option
       * @param eip
       */
      isActivatedEIP(eip) {
          if (this.eips().includes(eip)) {
              return true;
          }
          for (const hfChanges of hardforks_1.hardforks) {
              const hf = hfChanges[1];
              if (this.gteHardfork(hf['name']) && 'eips' in hf) {
                  if (hf['eips'].includes(eip)) {
                      return true;
                  }
              }
          }
          return false;
      }
      /**
       * Checks if set or provided hardfork is active on block number
       * @param hardfork Hardfork name or null (for HF set)
       * @param blockNumber
       * @returns True if HF is active on block number
       */
      hardforkIsActiveOnBlock(hardfork, blockNumber) {
          blockNumber = (0, util_1$S.toType)(blockNumber, util_1$S.TypeOutput.BigInt);
          hardfork = hardfork ?? this._hardfork;
          const hfBlock = this.hardforkBlock(hardfork);
          if ((0, util_1$S.isTruthy)(hfBlock) && blockNumber >= hfBlock) {
              return true;
          }
          return false;
      }
      /**
       * Alias to hardforkIsActiveOnBlock when hardfork is set
       * @param blockNumber
       * @returns True if HF is active on block number
       */
      activeOnBlock(blockNumber) {
          return this.hardforkIsActiveOnBlock(null, blockNumber);
      }
      /**
       * Sequence based check if given or set HF1 is greater than or equal HF2
       * @param hardfork1 Hardfork name or null (if set)
       * @param hardfork2 Hardfork name
       * @param opts Hardfork options
       * @returns True if HF1 gte HF2
       */
      hardforkGteHardfork(hardfork1, hardfork2) {
          hardfork1 = hardfork1 ?? this._hardfork;
          const hardforks = this.hardforks();
          let posHf1 = -1, posHf2 = -1;
          let index = 0;
          for (const hf of hardforks) {
              if (hf['name'] === hardfork1)
                  posHf1 = index;
              if (hf['name'] === hardfork2)
                  posHf2 = index;
              index += 1;
          }
          return posHf1 >= posHf2 && posHf2 !== -1;
      }
      /**
       * Alias to hardforkGteHardfork when hardfork is set
       * @param hardfork Hardfork name
       * @returns True if hardfork set is greater than hardfork provided
       */
      gteHardfork(hardfork) {
          return this.hardforkGteHardfork(null, hardfork);
      }
      /**
       * Returns the hardfork change block for hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block number or null if unscheduled
       */
      hardforkBlock(hardfork) {
          hardfork = hardfork ?? this._hardfork;
          const block = this._getHardfork(hardfork)?.['block'];
          if (block === undefined || block === null) {
              return null;
          }
          return BigInt(block);
      }
      /**
       * Returns the hardfork change block for eip
       * @param eip EIP number
       * @returns Block number or null if unscheduled
       */
      eipBlock(eip) {
          for (const hfChanges of hardforks_1.hardforks) {
              const hf = hfChanges[1];
              if ('eips' in hf) {
                  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                  if (hf['eips'].includes(eip)) {
                      return this.hardforkBlock(hfChanges[0]);
                  }
              }
          }
          return null;
      }
      /**
       * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Total difficulty or null if no set
       */
      hardforkTTD(hardfork) {
          hardfork = hardfork ?? this._hardfork;
          const ttd = this._getHardfork(hardfork)?.['ttd'];
          if (ttd === undefined || ttd === null) {
              return null;
          }
          return BigInt(ttd);
      }
      /**
       * True if block number provided is the hardfork (given or set) change block
       * @param blockNumber Number of the block to check
       * @param hardfork Hardfork name, optional if HF set
       * @returns True if blockNumber is HF block
       */
      isHardforkBlock(blockNumber, hardfork) {
          blockNumber = (0, util_1$S.toType)(blockNumber, util_1$S.TypeOutput.BigInt);
          hardfork = hardfork ?? this._hardfork;
          const block = this.hardforkBlock(hardfork);
          return (0, util_1$S.isTruthy)(block) ? block === blockNumber : false;
      }
      /**
       * Returns the change block for the next hardfork after the hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block number or null if not available
       */
      nextHardforkBlock(hardfork) {
          hardfork = hardfork ?? this._hardfork;
          const hfBlock = this.hardforkBlock(hardfork);
          if (hfBlock === null) {
              return null;
          }
          // Next fork block number or null if none available
          // Logic: if accumulator is still null and on the first occurrence of
          // a block greater than the current hfBlock set the accumulator,
          // pass on the accumulator as the final result from this time on
          const nextHfBlock = this.hardforks().reduce((acc, hf) => {
              const block = BigInt(hf.block === null ? 0 : hf.block);
              return block > hfBlock && acc === null ? block : acc;
          }, null);
          return nextHfBlock;
      }
      /**
       * True if block number provided is the hardfork change block following the hardfork given or set
       * @param blockNumber Number of the block to check
       * @param hardfork Hardfork name, optional if HF set
       * @returns True if blockNumber is HF block
       */
      isNextHardforkBlock(blockNumber, hardfork) {
          blockNumber = (0, util_1$S.toType)(blockNumber, util_1$S.TypeOutput.BigInt);
          hardfork = hardfork ?? this._hardfork;
          const nextHardforkBlock = this.nextHardforkBlock(hardfork);
          return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
      }
      /**
       * Internal helper function to calculate a fork hash
       * @param hardfork Hardfork name
       * @param genesisHash Genesis block hash of the chain
       * @returns Fork hash as hex string
       */
      _calcForkHash(hardfork, genesisHash) {
          let hfBuffer = Buffer$8.alloc(0);
          let prevBlock = 0;
          for (const hf of this.hardforks()) {
              const block = hf.block;
              // Skip for chainstart (0), not applied HFs (null) and
              // when already applied on same block number HFs
              if (block !== 0 && block !== null && block !== prevBlock) {
                  const hfBlockBuffer = Buffer$8.from(block.toString(16).padStart(16, '0'), 'hex');
                  hfBuffer = Buffer$8.concat([hfBuffer, hfBlockBuffer]);
              }
              if (hf.name === hardfork)
                  break;
              if (block !== null) {
                  prevBlock = block;
              }
          }
          const inputBuffer = Buffer$8.concat([genesisHash, hfBuffer]);
          // CRC32 delivers result as signed (negative) 32-bit integer,
          // convert to hex string
          const forkhash = (0, util_1$S.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString('hex');
          return `0x${forkhash}`;
      }
      /**
       * Returns an eth/64 compliant fork hash (EIP-2124)
       * @param hardfork Hardfork name, optional if HF set
       * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated
       */
      forkHash(hardfork, genesisHash) {
          hardfork = hardfork ?? this._hardfork;
          const data = this._getHardfork(hardfork);
          if (data === null || (data?.block === null && data?.ttd === undefined)) {
              const msg = 'No fork hash calculation possible for future hardfork';
              throw new Error(msg);
          }
          if (data?.forkHash !== null && data?.forkHash !== undefined) {
              return data.forkHash;
          }
          if (!genesisHash)
              throw new Error('genesisHash required for forkHash calculation');
          return this._calcForkHash(hardfork, genesisHash);
      }
      /**
       *
       * @param forkHash Fork hash as a hex string
       * @returns Array with hardfork data (name, block, forkHash)
       */
      hardforkForForkHash(forkHash) {
          const resArray = this.hardforks().filter((hf) => {
              return hf.forkHash === forkHash;
          });
          return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
      }
      /**
       * Returns the Genesis parameters of the current chain
       * @returns Genesis dictionary
       */
      genesis() {
          return this._chainParams.genesis;
      }
      /**
       * Returns the hardforks for current chain
       * @returns {Array} Array with arrays of hardforks
       */
      hardforks() {
          return this._chainParams.hardforks;
      }
      /**
       * Returns bootstrap nodes for the current chain
       * @returns {Dictionary} Dict with bootstrap nodes
       */
      bootstrapNodes() {
          return this._chainParams.bootstrapNodes;
      }
      /**
       * Returns DNS networks for the current chain
       * @returns {String[]} Array of DNS ENR urls
       */
      dnsNetworks() {
          return this._chainParams.dnsNetworks;
      }
      /**
       * Returns the hardfork set
       * @returns Hardfork name
       */
      hardfork() {
          return this._hardfork;
      }
      /**
       * Returns the Id of current chain
       * @returns chain Id
       */
      chainId() {
          return BigInt(this._chainParams.chainId);
      }
      /**
       * Returns the name of current chain
       * @returns chain name (lower case)
       */
      chainName() {
          return this._chainParams.name;
      }
      /**
       * Returns the Id of current network
       * @returns network Id
       */
      networkId() {
          return BigInt(this._chainParams.networkId);
      }
      /**
       * Returns the active EIPs
       * @returns List of EIPs
       */
      eips() {
          return this._eips;
      }
      /**
       * Returns the consensus type of the network
       * Possible values: "pow"|"poa"|"pos"
       *
       * Note: This value can update along a Hardfork.
       */
      consensusType() {
          const hardfork = this.hardfork();
          let value;
          for (const hfChanges of hardforks_1.hardforks) {
              if ('consensus' in hfChanges[1]) {
                  value = hfChanges[1]['consensus']['type'];
              }
              if (hfChanges[0] === hardfork)
                  break;
          }
          return value ?? this._chainParams['consensus']['type'];
      }
      /**
       * Returns the concrete consensus implementation
       * algorithm or protocol for the network
       * e.g. "ethash" for "pow" consensus type,
       * "clique" for "poa" consensus type or
       * "casper" for "pos" consensus type.
       *
       * Note: This value can update along a Hardfork.
       */
      consensusAlgorithm() {
          const hardfork = this.hardfork();
          let value;
          for (const hfChanges of hardforks_1.hardforks) {
              if ('consensus' in hfChanges[1]) {
                  value = hfChanges[1]['consensus']['algorithm'];
              }
              if (hfChanges[0] === hardfork)
                  break;
          }
          return (0, util_1$S.isTruthy)(value)
              ? value
              : this._chainParams['consensus']['algorithm'];
      }
      /**
       * Returns a dictionary with consensus configuration
       * parameters based on the consensus algorithm
       *
       * Expected returns (parameters must be present in
       * the respective chain json files):
       *
       * ethash: -
       * clique: period, epoch
       * aura: -
       * casper: -
       *
       * Note: This value can update along a Hardfork.
       */
      consensusConfig() {
          const hardfork = this.hardfork();
          let value;
          for (const hfChanges of hardforks_1.hardforks) {
              if ('consensus' in hfChanges[1]) {
                  // The config parameter is named after the respective consensus algorithm
                  value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']];
              }
              if (hfChanges[0] === hardfork)
                  break;
          }
          return (0, util_1$S.isTruthy)(value)
              ? value
              : this._chainParams['consensus'][this.consensusAlgorithm()];
      }
      /**
       * Returns a deep copy of this {@link Common} instance.
       */
      copy() {
          const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
          copy.removeAllListeners();
          return copy;
      }
      static _getInitializedChains(customChains) {
          const names = {};
          for (const [name, id] of Object.entries(enums_1.Chain)) {
              names[id] = name.toLowerCase();
          }
          const chains = { mainnet, ropsten, rinkeby, kovan, goerli, sepolia };
          if (customChains) {
              for (const chain of customChains) {
                  const { name } = chain;
                  names[chain.chainId.toString()] = name;
                  chains[name] = chain;
              }
          }
          chains.names = names;
          return chains;
      }
  }
  common$2.Common = Common;

  var types$4 = {};

  Object.defineProperty(types$4, "__esModule", { value: true });

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(common$2, exports);
  __exportStar(enums, exports);
  __exportStar(types$4, exports);

  }(dist$8));

  var precompiles$1 = {};

  var _01Ecrecover = {};

  var evm$1 = {};

  var util$6 = {};

  var isBuffer$2 = function isBuffer(arg) {
    return arg instanceof Buffer$8;
  };

  var inherits = {exports: {}};

  var inherits_browser = {exports: {}};

  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    inherits_browser.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    inherits_browser.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }

  try {
    var util$5 = require('util');
    if (typeof util$5.inherits !== 'function') throw '';
    inherits.exports = util$5.inherits;
  } catch (e) {
    inherits.exports = inherits_browser.exports;
  }

  (function (exports) {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
    function getOwnPropertyDescriptors(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };

  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  };


  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  exports.deprecate = function(fn, msg) {
    if (typeof browser$1$1 !== 'undefined' && browser$1$1.noDeprecation === true) {
      return fn;
    }

    // Allow for deprecating things in the process of starting up.
    if (typeof browser$1$1 === 'undefined') {
      return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        if (browser$1$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  };


  var debugs = {};
  var debugEnviron;
  exports.debuglog = function(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = browser$1$1.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = browser$1$1.pid;
        debugs[set] = function() {
          var msg = exports.format.apply(exports, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  };


  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      exports._extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports.inspect = inspect;


  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray(ar) {
    return Array.isArray(ar);
  }
  exports.isArray = isArray;

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  exports.isBoolean = isBoolean;

  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;

  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;

  function isNumber(arg) {
    return typeof arg === 'number';
  }
  exports.isNumber = isNumber;

  function isString(arg) {
    return typeof arg === 'string';
  }
  exports.isString = isString;

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  exports.isSymbol = isSymbol;

  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }
  exports.isRegExp = isRegExp;

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  exports.isObject = isObject;

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }
  exports.isDate = isDate;

  function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }
  exports.isError = isError;

  function isFunction(arg) {
    return typeof arg === 'function';
  }
  exports.isFunction = isFunction;

  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }
  exports.isPrimitive = isPrimitive;

  exports.isBuffer = isBuffer$2;

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }


  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }


  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

  // 26 Feb 16:19:34
  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }


  // log is just a thin wrapper to console.log that prepends a timestamp
  exports.log = function() {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
  };


  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * The Function.prototype.inherits from lang.js rewritten as a standalone
   * function (not on Function.prototype). NOTE: If this file is to be loaded
   * during bootstrapping this function needs to be rewritten using some native
   * functions as prototype setup using normal JavaScript does not work as
   * expected during bootstrapping (see mirror.js in r114903).
   *
   * @param {function} ctor Constructor function which needs to inherit the
   *     prototype.
   * @param {function} superCtor Constructor function to inherit prototype from.
   */
  exports.inherits = inherits.exports;

  exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  };

  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

  exports.promisify = function promisify(original) {
    if (typeof original !== 'function')
      throw new TypeError('The "original" argument must be of type Function');

    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== 'function') {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn, enumerable: false, writable: false, configurable: true
      });
      return fn;
    }

    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function (resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });

      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      args.push(function (err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });

      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }

      return promise;
    }

    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return Object.defineProperties(
      fn,
      getOwnPropertyDescriptors(original)
    );
  };

  exports.promisify.custom = kCustomPromisifiedSymbol;

  function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
      var newReason = new Error('Promise was rejected with a falsy value');
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }

  function callbackify(original) {
    if (typeof original !== 'function') {
      throw new TypeError('The "original" argument must be of type Function');
    }

    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      var maybeCb = args.pop();
      if (typeof maybeCb !== 'function') {
        throw new TypeError('The last argument must be of type Function');
      }
      var self = this;
      var cb = function() {
        return maybeCb.apply(self, arguments);
      };
      // In true node style we process the callback on `nextTick` with all the
      // implications (stack, `uncaughtException`, `async_hooks`)
      original.apply(this, args)
        .then(function(ret) { browser$1$1.nextTick(cb, null, ret); },
              function(rej) { browser$1$1.nextTick(callbackifyOnRejected, rej, cb); });
    }

    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified,
                            getOwnPropertyDescriptors(original));
    return callbackified;
  }
  exports.callbackify = callbackify;
  }(util$6));

  var AsyncEventEmitter$2 = {exports: {}};

  var eachSeries = {exports: {}};

  var eachLimit = {exports: {}};

  var eachOfLimit = {exports: {}};

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */

  function noop$5() {
    // No operation performed.
  }

  var noop_1 = noop$5;

  var once$2 = {exports: {}};

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = once;
  function once(fn) {
      return function () {
          if (fn === null) return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
      };
  }
  module.exports = exports["default"];
  }(once$2, once$2.exports));

  var iterator = {exports: {}};

  /** Detect free variable `global` from Node.js. */

  var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal$1;

  var freeGlobal = _freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal || freeSelf || Function('return this')();

  var _root = root$1;

  var root = _root;

  /** Built-in value references. */
  var Symbol$4 = root.Symbol;

  var _Symbol = Symbol$4;

  var Symbol$3 = _Symbol;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$5.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$5.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag$1;

  /** Used for built-in method references. */

  var objectProto$4 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$4.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$2(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString$2;

  var Symbol$2 = _Symbol,
      getRawTag = _getRawTag,
      objectToString$1 = _objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$3(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString$1(value);
  }

  var _baseGetTag = baseGetTag$3;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */

  function isObject$b(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject$b;

  var baseGetTag$2 = _baseGetTag,
      isObject$a = isObject_1;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject$a(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$2(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction$1;

  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$2(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength$2;

  var isFunction = isFunction_1,
      isLength$1 = isLength_1;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike$1(value) {
    return value != null && isLength$1(value.length) && !isFunction(value);
  }

  var isArrayLike_1 = isArrayLike$1;

  var getIterator$2 = {exports: {}};

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  exports.default = function (coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
  };

  var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

  module.exports = exports['default'];
  }(getIterator$2, getIterator$2.exports));

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */

  function baseTimes$1(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes$1;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */

  function isObjectLike$3(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike$3;

  var baseGetTag$1 = _baseGetTag,
      isObjectLike$2 = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments$1(value) {
    return isObjectLike$2(value) && baseGetTag$1(value) == argsTag$1;
  }

  var _baseIsArguments = baseIsArguments$1;

  var baseIsArguments = _baseIsArguments,
      isObjectLike$1 = isObjectLike_1;

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$3.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$1 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike$1(value) && hasOwnProperty$4.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments_1 = isArguments$1;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray$3 = Array.isArray;

  var isArray_1 = isArray$3;

  var isBuffer$1 = {exports: {}};

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  (function (module, exports) {
  var root = _root,
      stubFalse = stubFalse_1;

  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  module.exports = isBuffer;
  }(isBuffer$1, isBuffer$1.exports));

  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex$1(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex$1;

  var baseGetTag = _baseGetTag,
      isLength = isLength_1,
      isObjectLike = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray$1(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray$1;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */

  function baseUnary$1(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary$1;

  var _nodeUtil = {exports: {}};

  (function (module, exports) {
  var freeGlobal = _freeGlobal;

  /** Detect free variable `exports`. */
  var freeExports = exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  }(_nodeUtil, _nodeUtil.exports));

  var baseIsTypedArray = _baseIsTypedArray,
      baseUnary = _baseUnary,
      nodeUtil = _nodeUtil.exports;

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  var isTypedArray_1 = isTypedArray$1;

  var baseTimes = _baseTimes,
      isArguments = isArguments_1,
      isArray$2 = isArray_1,
      isBuffer = isBuffer$1.exports,
      isIndex = _isIndex,
      isTypedArray = isTypedArray_1;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys$1(value, inherited) {
    var isArr = isArray$2(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$3.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys$1;

  /** Used for built-in method references. */

  var objectProto$1 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype$1(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$1;

    return value === proto;
  }

  var _isPrototype = isPrototype$1;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */

  function overArg$1(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg$1;

  var overArg = _overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys$1 = overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys$1;

  var isPrototype = _isPrototype,
      nativeKeys = _nativeKeys;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys$1(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys$1;

  var arrayLikeKeys = _arrayLikeKeys,
      baseKeys = _baseKeys,
      isArrayLike = isArrayLike_1;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys$3(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  var keys_1 = keys$3;

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = iterator;

  var _isArrayLike = isArrayLike_1;

  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

  var _getIterator = getIterator$2.exports;

  var _getIterator2 = _interopRequireDefault(_getIterator);

  var _keys = keys_1;

  var _keys2 = _interopRequireDefault(_keys);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
      };
  }

  function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
          var item = iterator.next();
          if (item.done) return null;
          i++;
          return { value: item.value, key: i };
      };
  }

  function createObjectIterator(obj) {
      var okeys = (0, _keys2.default)(obj);
      var i = -1;
      var len = okeys.length;
      return function next() {
          var key = okeys[++i];
          if (key === '__proto__') {
              return next();
          }
          return i < len ? { value: obj[key], key: key } : null;
      };
  }

  function iterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
          return createArrayIterator(coll);
      }

      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
  }
  module.exports = exports['default'];
  }(iterator, iterator.exports));

  var onlyOnce = {exports: {}};

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = onlyOnce;
  function onlyOnce(fn) {
      return function () {
          if (fn === null) throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
      };
  }
  module.exports = exports["default"];
  }(onlyOnce, onlyOnce.exports));

  var breakLoop = {exports: {}};

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // A temporary value used to identify if the loop should be broken.
  // See #1064, #1293
  exports.default = {};
  module.exports = exports["default"];
  }(breakLoop, breakLoop.exports));

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = _eachOfLimit;

  var _noop = noop_1;

  var _noop2 = _interopRequireDefault(_noop);

  var _once = once$2.exports;

  var _once2 = _interopRequireDefault(_once);

  var _iterator = iterator.exports;

  var _iterator2 = _interopRequireDefault(_iterator);

  var _onlyOnce = onlyOnce.exports;

  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

  var _breakLoop = breakLoop.exports;

  var _breakLoop2 = _interopRequireDefault(_breakLoop);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _eachOfLimit(limit) {
      return function (obj, iteratee, callback) {
          callback = (0, _once2.default)(callback || _noop2.default);
          if (limit <= 0 || !obj) {
              return callback(null);
          }
          var nextElem = (0, _iterator2.default)(obj);
          var done = false;
          var running = 0;
          var looping = false;

          function iterateeCallback(err, value) {
              running -= 1;
              if (err) {
                  done = true;
                  callback(err);
              } else if (value === _breakLoop2.default || done && running <= 0) {
                  done = true;
                  return callback(null);
              } else if (!looping) {
                  replenish();
              }
          }

          function replenish() {
              looping = true;
              while (running < limit && !done) {
                  var elem = nextElem();
                  if (elem === null) {
                      done = true;
                      if (running <= 0) {
                          callback(null);
                      }
                      return;
                  }
                  running += 1;
                  iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
              }
              looping = false;
          }

          replenish();
      };
  }
  module.exports = exports['default'];
  }(eachOfLimit, eachOfLimit.exports));

  var withoutIndex = {exports: {}};

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = _withoutIndex;
  function _withoutIndex(iteratee) {
      return function (value, index, callback) {
          return iteratee(value, callback);
      };
  }
  module.exports = exports["default"];
  }(withoutIndex, withoutIndex.exports));

  var wrapAsync$1 = {};

  var asyncify = {exports: {}};

  var initialParams = {exports: {}};

  var slice = {exports: {}};

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = slice;
  function slice(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
          newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
  }
  module.exports = exports["default"];
  }(slice, slice.exports));

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  exports.default = function (fn) {
      return function () /*...args, callback*/{
          var args = (0, _slice2.default)(arguments);
          var callback = args.pop();
          fn.call(this, args, callback);
      };
  };

  var _slice = slice.exports;

  var _slice2 = _interopRequireDefault(_slice);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  module.exports = exports['default'];
  }(initialParams, initialParams.exports));

  var setImmediate$1 = {};

  Object.defineProperty(setImmediate$1, "__esModule", {
      value: true
  });
  setImmediate$1.hasNextTick = setImmediate$1.hasSetImmediate = undefined;
  setImmediate$1.fallback = fallback;
  setImmediate$1.wrap = wrap;

  var _slice = slice.exports;

  var _slice2 = _interopRequireDefault$1(_slice);

  function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var hasSetImmediate = setImmediate$1.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
  var hasNextTick = setImmediate$1.hasNextTick = typeof browser$1$1 === 'object' && typeof browser$1$1.nextTick === 'function';

  function fallback(fn) {
      setTimeout(fn, 0);
  }

  function wrap(defer) {
      return function (fn /*, ...args*/) {
          var args = (0, _slice2.default)(arguments, 1);
          defer(function () {
              fn.apply(null, args);
          });
      };
  }

  var _defer;

  if (hasSetImmediate) {
      _defer = setImmediate;
  } else if (hasNextTick) {
      _defer = browser$1$1.nextTick;
  } else {
      _defer = fallback;
  }

  setImmediate$1.default = wrap(_defer);

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = asyncify;

  var _isObject = isObject_1;

  var _isObject2 = _interopRequireDefault(_isObject);

  var _initialParams = initialParams.exports;

  var _initialParams2 = _interopRequireDefault(_initialParams);

  var _setImmediate = setImmediate$1;

  var _setImmediate2 = _interopRequireDefault(_setImmediate);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Take a sync function and make it async, passing its return value to a
   * callback. This is useful for plugging sync functions into a waterfall,
   * series, or other async functions. Any arguments passed to the generated
   * function will be passed to the wrapped function (except for the final
   * callback argument). Errors thrown will be passed to the callback.
   *
   * If the function passed to `asyncify` returns a Promise, that promises's
   * resolved/rejected state will be used to call the callback, rather than simply
   * the synchronous return value.
   *
   * This also means you can asyncify ES2017 `async` functions.
   *
   * @name asyncify
   * @static
   * @memberOf module:Utils
   * @method
   * @alias wrapSync
   * @category Util
   * @param {Function} func - The synchronous function, or Promise-returning
   * function to convert to an {@link AsyncFunction}.
   * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
   * invoked with `(args..., callback)`.
   * @example
   *
   * // passing a regular synchronous function
   * async.waterfall([
   *     async.apply(fs.readFile, filename, "utf8"),
   *     async.asyncify(JSON.parse),
   *     function (data, next) {
   *         // data is the result of parsing the text.
   *         // If there was a parsing error, it would have been caught.
   *     }
   * ], callback);
   *
   * // passing a function returning a promise
   * async.waterfall([
   *     async.apply(fs.readFile, filename, "utf8"),
   *     async.asyncify(function (contents) {
   *         return db.model.create(contents);
   *     }),
   *     function (model, next) {
   *         // `model` is the instantiated model object.
   *         // If there was an error, this function would be skipped.
   *     }
   * ], callback);
   *
   * // es2017 example, though `asyncify` is not needed if your JS environment
   * // supports async functions out of the box
   * var q = async.queue(async.asyncify(async function(file) {
   *     var intermediateStep = await processFile(file);
   *     return await somePromise(intermediateStep)
   * }));
   *
   * q.push(files);
   */
  function asyncify(func) {
      return (0, _initialParams2.default)(function (args, callback) {
          var result;
          try {
              result = func.apply(this, args);
          } catch (e) {
              return callback(e);
          }
          // if result is Promise object
          if ((0, _isObject2.default)(result) && typeof result.then === 'function') {
              result.then(function (value) {
                  invokeCallback(callback, null, value);
              }, function (err) {
                  invokeCallback(callback, err.message ? err : new Error(err));
              });
          } else {
              callback(null, result);
          }
      });
  }

  function invokeCallback(callback, error, value) {
      try {
          callback(error, value);
      } catch (e) {
          (0, _setImmediate2.default)(rethrow, e);
      }
  }

  function rethrow(error) {
      throw error;
  }
  module.exports = exports['default'];
  }(asyncify, asyncify.exports));

  Object.defineProperty(wrapAsync$1, "__esModule", {
      value: true
  });
  wrapAsync$1.isAsync = undefined;

  var _asyncify = asyncify.exports;

  var _asyncify2 = _interopRequireDefault(_asyncify);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var supportsSymbol = typeof Symbol === 'function';

  function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
  }

  function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  }

  wrapAsync$1.default = wrapAsync;
  wrapAsync$1.isAsync = isAsync;

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachLimit;

  var _eachOfLimit = eachOfLimit.exports;

  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

  var _withoutIndex = withoutIndex.exports;

  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);

  var _wrapAsync = wrapAsync$1;

  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
   *
   * @name eachLimit
   * @static
   * @memberOf module:Collections
   * @method
   * @see [async.each]{@link module:Collections.each}
   * @alias forEachLimit
   * @category Collection
   * @param {Array|Iterable|Object} coll - A collection to iterate over.
   * @param {number} limit - The maximum number of async operations at a time.
   * @param {AsyncFunction} iteratee - An async function to apply to each item in
   * `coll`.
   * The array index is not passed to the iteratee.
   * If you need the index, use `eachOfLimit`.
   * Invoked with (item, callback).
   * @param {Function} [callback] - A callback which is called when all
   * `iteratee` functions have finished, or an error occurs. Invoked with (err).
   */
  function eachLimit(coll, limit, iteratee, callback) {
    (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  }
  module.exports = exports['default'];
  }(eachLimit, eachLimit.exports));

  var doLimit = {exports: {}};

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = doLimit;
  function doLimit(fn, limit) {
      return function (iterable, iteratee, callback) {
          return fn(iterable, limit, iteratee, callback);
      };
  }
  module.exports = exports["default"];
  }(doLimit, doLimit.exports));

  (function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _eachLimit = eachLimit.exports;

  var _eachLimit2 = _interopRequireDefault(_eachLimit);

  var _doLimit = doLimit.exports;

  var _doLimit2 = _interopRequireDefault(_doLimit);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
   *
   * @name eachSeries
   * @static
   * @memberOf module:Collections
   * @method
   * @see [async.each]{@link module:Collections.each}
   * @alias forEachSeries
   * @category Collection
   * @param {Array|Iterable|Object} coll - A collection to iterate over.
   * @param {AsyncFunction} iteratee - An async function to apply to each
   * item in `coll`.
   * The array index is not passed to the iteratee.
   * If you need the index, use `eachOfSeries`.
   * Invoked with (item, callback).
   * @param {Function} [callback] - A callback which is called when all
   * `iteratee` functions have finished, or an error occurs. Invoked with (err).
   */
  exports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
  module.exports = exports['default'];
  }(eachSeries, eachSeries.exports));

  (function (module, exports) {

  var EventEmitter = events.exports.EventEmitter,
      util = util$6,
      eachSeries$1 = eachSeries.exports,
      AsyncEventEmitter;


  module.exports = AsyncEventEmitter = function AsyncEventEmitter () {
    EventEmitter.call(this);
  };

  util.inherits(AsyncEventEmitter, EventEmitter);


  /* Public methods
  ============================================================================= */

  AsyncEventEmitter.prototype.emit = function(event, data, callback) {
    var self = this,
        listeners = self._events[event] || [];

    // Optional data argument
    if(!callback && typeof data === 'function') {
      callback = data;
      data = undefined;
    }

    // Special treatment of internal newListener and removeListener events
    if(event === 'newListener' || event === 'removeListener') {
      data = {
        event: data,
        fn: callback
      };

      callback = undefined;
    }

    // A single listener is just a function not an array...
    listeners = Array.isArray(listeners) ? listeners : [listeners];

    eachSeries$1(listeners.slice(), function (fn, next) {
      var err;

      // Support synchronous functions
      if(fn.length < 2) {
        try {
          fn.call(self, data);
        }
        catch (e) {
          err = e;
        }

        return next(err);
      }

      // Async
      fn.call(self, data, next);
    }, callback);

    return self;
  };


  AsyncEventEmitter.prototype.once = function (type, listener) {
    var self = this,
        g;

    if (typeof listener !== 'function') {
      throw new TypeError('listener must be a function');
    }

    // Hack to support set arity
    if(listener.length >= 2) {
      g = function (e, next) {
        self.removeListener(type, g);
        listener(e, next);
      };
    }
    else {
      g = function (e) {
        self.removeListener(type, g);
        listener(e);
      };
    }

    g.listener = listener;
    self.on(type, g);

    return self;
  };


  AsyncEventEmitter.prototype.first = function(event, listener) {
    var listeners = this._events[event] || [];

    // Contract
    if(typeof listener !== 'function') {
      throw new TypeError('listener must be a function');
    }

    // Listeners are not always an array
    if(!Array.isArray(listeners)) {
      this._events[event] = listeners = [listeners];
    }

    listeners.unshift(listener);

    return this;
  };


  AsyncEventEmitter.prototype.at = function(event, index, listener) {
    var listeners = this._events[event] || [];

    // Contract
    if(typeof listener !== 'function') {
      throw new TypeError('listener must be a function');
    }
    if(typeof index !== 'number' || index < 0) {
      throw new TypeError('index must be a non-negative integer');
    }

    // Listeners are not always an array
    if(!Array.isArray(listeners)) {
      this._events[event] = listeners = [listeners];
    }

    listeners.splice(index, 0, listener);

    return this;
  };


  AsyncEventEmitter.prototype.before = function(event, target, listener) {
    return this._beforeOrAfter(event, target, listener);
  };


  AsyncEventEmitter.prototype.after = function(event, target, listener) {
    return this._beforeOrAfter(event, target, listener, 'after');
  };


  /* Private methods
  ============================================================================= */

  AsyncEventEmitter.prototype._beforeOrAfter = function(event, target, listener, beforeOrAfter) {
    var listeners = this._events[event] || [],
        i, index,
        add = beforeOrAfter === 'after' ? 1 : 0;

    // Contract
    if(typeof listener !== 'function') {
      throw new TypeError('listener must be a function');
    }
    if(typeof target !== 'function') {
      throw new TypeError('target must be a function');
    }

    // Listeners are not always an array
    if(!Array.isArray(listeners)) {
      this._events[event] = listeners = [listeners];
    }

    index = listeners.length;
    
    for(i = listeners.length; i--;) {
      if(listeners[i] === target) {
        index = i + add;
        break;
      }
    }

    listeners.splice(index, 0, listener);

    return this;
  };
  }(AsyncEventEmitter$2));

  var asyncEventemitter = AsyncEventEmitter$2.exports;

  var src$1 = {exports: {}};

  var browser = {exports: {}};

  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val)
    );
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
  	createDebug.debug = createDebug;
  	createDebug.default = createDebug;
  	createDebug.coerce = coerce;
  	createDebug.disable = disable;
  	createDebug.enable = enable;
  	createDebug.enabled = enabled;
  	createDebug.humanize = ms;
  	createDebug.destroy = destroy;

  	Object.keys(env).forEach(key => {
  		createDebug[key] = env[key];
  	});

  	/**
  	* The currently active debug mode names, and names to skip.
  	*/

  	createDebug.names = [];
  	createDebug.skips = [];

  	/**
  	* Map of special "%n" handling functions, for the debug "format" argument.
  	*
  	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  	*/
  	createDebug.formatters = {};

  	/**
  	* Selects a color for a debug namespace
  	* @param {String} namespace The namespace string for the debug instance to be colored
  	* @return {Number|String} An ANSI color code for the given namespace
  	* @api private
  	*/
  	function selectColor(namespace) {
  		let hash = 0;

  		for (let i = 0; i < namespace.length; i++) {
  			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
  			hash |= 0; // Convert to 32bit integer
  		}

  		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  	}
  	createDebug.selectColor = selectColor;

  	/**
  	* Create a debugger with the given `namespace`.
  	*
  	* @param {String} namespace
  	* @return {Function}
  	* @api public
  	*/
  	function createDebug(namespace) {
  		let prevTime;
  		let enableOverride = null;
  		let namespacesCache;
  		let enabledCache;

  		function debug(...args) {
  			// Disabled?
  			if (!debug.enabled) {
  				return;
  			}

  			const self = debug;

  			// Set `diff` timestamp
  			const curr = Number(new Date());
  			const ms = curr - (prevTime || curr);
  			self.diff = ms;
  			self.prev = prevTime;
  			self.curr = curr;
  			prevTime = curr;

  			args[0] = createDebug.coerce(args[0]);

  			if (typeof args[0] !== 'string') {
  				// Anything else let's inspect with %O
  				args.unshift('%O');
  			}

  			// Apply any `formatters` transformations
  			let index = 0;
  			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
  				// If we encounter an escaped % then don't increase the array index
  				if (match === '%%') {
  					return '%';
  				}
  				index++;
  				const formatter = createDebug.formatters[format];
  				if (typeof formatter === 'function') {
  					const val = args[index];
  					match = formatter.call(self, val);

  					// Now we need to remove `args[index]` since it's inlined in the `format`
  					args.splice(index, 1);
  					index--;
  				}
  				return match;
  			});

  			// Apply env-specific formatting (colors, etc.)
  			createDebug.formatArgs.call(self, args);

  			const logFn = self.log || createDebug.log;
  			logFn.apply(self, args);
  		}

  		debug.namespace = namespace;
  		debug.useColors = createDebug.useColors();
  		debug.color = createDebug.selectColor(namespace);
  		debug.extend = extend;
  		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

  		Object.defineProperty(debug, 'enabled', {
  			enumerable: true,
  			configurable: false,
  			get: () => {
  				if (enableOverride !== null) {
  					return enableOverride;
  				}
  				if (namespacesCache !== createDebug.namespaces) {
  					namespacesCache = createDebug.namespaces;
  					enabledCache = createDebug.enabled(namespace);
  				}

  				return enabledCache;
  			},
  			set: v => {
  				enableOverride = v;
  			}
  		});

  		// Env-specific initialization logic for debug instances
  		if (typeof createDebug.init === 'function') {
  			createDebug.init(debug);
  		}

  		return debug;
  	}

  	function extend(namespace, delimiter) {
  		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  		newDebug.log = this.log;
  		return newDebug;
  	}

  	/**
  	* Enables a debug mode by namespaces. This can include modes
  	* separated by a colon and wildcards.
  	*
  	* @param {String} namespaces
  	* @api public
  	*/
  	function enable(namespaces) {
  		createDebug.save(namespaces);
  		createDebug.namespaces = namespaces;

  		createDebug.names = [];
  		createDebug.skips = [];

  		let i;
  		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  		const len = split.length;

  		for (i = 0; i < len; i++) {
  			if (!split[i]) {
  				// ignore empty strings
  				continue;
  			}

  			namespaces = split[i].replace(/\*/g, '.*?');

  			if (namespaces[0] === '-') {
  				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
  			} else {
  				createDebug.names.push(new RegExp('^' + namespaces + '$'));
  			}
  		}
  	}

  	/**
  	* Disable debug output.
  	*
  	* @return {String} namespaces
  	* @api public
  	*/
  	function disable() {
  		const namespaces = [
  			...createDebug.names.map(toNamespace),
  			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
  		].join(',');
  		createDebug.enable('');
  		return namespaces;
  	}

  	/**
  	* Returns true if the given mode name is enabled, false otherwise.
  	*
  	* @param {String} name
  	* @return {Boolean}
  	* @api public
  	*/
  	function enabled(name) {
  		if (name[name.length - 1] === '*') {
  			return true;
  		}

  		let i;
  		let len;

  		for (i = 0, len = createDebug.skips.length; i < len; i++) {
  			if (createDebug.skips[i].test(name)) {
  				return false;
  			}
  		}

  		for (i = 0, len = createDebug.names.length; i < len; i++) {
  			if (createDebug.names[i].test(name)) {
  				return true;
  			}
  		}

  		return false;
  	}

  	/**
  	* Convert regexp to namespace
  	*
  	* @param {RegExp} regxep
  	* @return {String} namespace
  	* @api private
  	*/
  	function toNamespace(regexp) {
  		return regexp.toString()
  			.substring(2, regexp.toString().length - 2)
  			.replace(/\.\*\?$/, '*');
  	}

  	/**
  	* Coerce `val`.
  	*
  	* @param {Mixed} val
  	* @return {Mixed}
  	* @api private
  	*/
  	function coerce(val) {
  		if (val instanceof Error) {
  			return val.stack || val.message;
  		}
  		return val;
  	}

  	/**
  	* XXX DO NOT USE. This is a temporary stub function.
  	* XXX It WILL be removed in the next major release.
  	*/
  	function destroy() {
  		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  	}

  	createDebug.enable(createDebug.load());

  	return createDebug;
  }

  var common$1 = setup;

  (function (module, exports) {
  /**
   * This is the web browser implementation of `debug()`.
   */

  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
  	let warned = false;

  	return () => {
  		if (!warned) {
  			warned = true;
  			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  		}
  	};
  })();

  /**
   * Colors.
   */

  exports.colors = [
  	'#0000CC',
  	'#0000FF',
  	'#0033CC',
  	'#0033FF',
  	'#0066CC',
  	'#0066FF',
  	'#0099CC',
  	'#0099FF',
  	'#00CC00',
  	'#00CC33',
  	'#00CC66',
  	'#00CC99',
  	'#00CCCC',
  	'#00CCFF',
  	'#3300CC',
  	'#3300FF',
  	'#3333CC',
  	'#3333FF',
  	'#3366CC',
  	'#3366FF',
  	'#3399CC',
  	'#3399FF',
  	'#33CC00',
  	'#33CC33',
  	'#33CC66',
  	'#33CC99',
  	'#33CCCC',
  	'#33CCFF',
  	'#6600CC',
  	'#6600FF',
  	'#6633CC',
  	'#6633FF',
  	'#66CC00',
  	'#66CC33',
  	'#9900CC',
  	'#9900FF',
  	'#9933CC',
  	'#9933FF',
  	'#99CC00',
  	'#99CC33',
  	'#CC0000',
  	'#CC0033',
  	'#CC0066',
  	'#CC0099',
  	'#CC00CC',
  	'#CC00FF',
  	'#CC3300',
  	'#CC3333',
  	'#CC3366',
  	'#CC3399',
  	'#CC33CC',
  	'#CC33FF',
  	'#CC6600',
  	'#CC6633',
  	'#CC9900',
  	'#CC9933',
  	'#CCCC00',
  	'#CCCC33',
  	'#FF0000',
  	'#FF0033',
  	'#FF0066',
  	'#FF0099',
  	'#FF00CC',
  	'#FF00FF',
  	'#FF3300',
  	'#FF3333',
  	'#FF3366',
  	'#FF3399',
  	'#FF33CC',
  	'#FF33FF',
  	'#FF6600',
  	'#FF6633',
  	'#FF9900',
  	'#FF9933',
  	'#FFCC00',
  	'#FFCC33'
  ];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  // eslint-disable-next-line complexity
  function useColors() {
  	// NB: In an Electron preload script, document will be defined but not fully
  	// initialized. Since we know we're in Chrome, we'll just detect this case
  	// explicitly
  	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
  		return true;
  	}

  	// Internet Explorer and Edge do not support colors.
  	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
  		return false;
  	}

  	// Is webkit? http://stackoverflow.com/a/16459606/376773
  	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
  		// Is firebug? http://stackoverflow.com/a/398120/376773
  		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
  		// Is firefox >= v31?
  		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
  		// Double check webkit in userAgent just in case we are in a worker
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }

  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
  	args[0] = (this.useColors ? '%c' : '') +
  		this.namespace +
  		(this.useColors ? ' %c' : ' ') +
  		args[0] +
  		(this.useColors ? '%c ' : ' ') +
  		'+' + module.exports.humanize(this.diff);

  	if (!this.useColors) {
  		return;
  	}

  	const c = 'color: ' + this.color;
  	args.splice(1, 0, c, 'color: inherit');

  	// The final "%c" is somewhat tricky, because there could be other
  	// arguments passed either before or after the %c, so we need to
  	// figure out the correct index to insert the CSS into
  	let index = 0;
  	let lastC = 0;
  	args[0].replace(/%[a-zA-Z%]/g, match => {
  		if (match === '%%') {
  			return;
  		}
  		index++;
  		if (match === '%c') {
  			// We only are interested in the *last* %c
  			// (the user may have provided their own)
  			lastC = index;
  		}
  	});

  	args.splice(lastC, 0, c);
  }

  /**
   * Invokes `console.debug()` when available.
   * No-op when `console.debug` is not a "function".
   * If `console.debug` is not available, falls back
   * to `console.log`.
   *
   * @api public
   */
  exports.log = console.debug || console.log || (() => {});

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  function save(namespaces) {
  	try {
  		if (namespaces) {
  			exports.storage.setItem('debug', namespaces);
  		} else {
  			exports.storage.removeItem('debug');
  		}
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  function load() {
  	let r;
  	try {
  		r = exports.storage.getItem('debug');
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}

  	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  	if (!r && typeof browser$1$1 !== 'undefined' && 'env' in browser$1$1) {
  		r = browser$1$1.env.DEBUG;
  	}

  	return r;
  }

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
  	try {
  		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
  		// The Browser also has localStorage in the global context.
  		return localStorage;
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  module.exports = common$1(exports);

  const {formatters} = module.exports;

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v) {
  	try {
  		return JSON.stringify(v);
  	} catch (error) {
  		return '[UnexpectedJSONParseError]: ' + error.message;
  	}
  };
  }(browser, browser.exports));

  var node$2 = {exports: {}};

  // MIT lisence
  // from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js

  function isatty() {
    return false;
  }

  function ReadStream() {
    throw new Error('tty.ReadStream is not implemented');
  }

  function WriteStream() {
    throw new Error('tty.ReadStream is not implemented');
  }

  var _polyfillNode_tty = {
    isatty: isatty,
    ReadStream: ReadStream,
    WriteStream: WriteStream
  };

  var _polyfillNode_tty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isatty: isatty,
    ReadStream: ReadStream,
    WriteStream: WriteStream,
    'default': _polyfillNode_tty
  });

  var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_tty$1);

  (function (module, exports) {
  const tty = require$$0$3;
  const util = util$6;

  /**
   * This is the Node.js implementation of `debug()`.
   */

  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(
  	() => {},
  	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
  );

  /**
   * Colors.
   */

  exports.colors = [6, 2, 3, 4, 5, 1];

  try {
  	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
  	// eslint-disable-next-line import/no-extraneous-dependencies
  	const supportsColor = require('supports-color');

  	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
  		exports.colors = [
  			20,
  			21,
  			26,
  			27,
  			32,
  			33,
  			38,
  			39,
  			40,
  			41,
  			42,
  			43,
  			44,
  			45,
  			56,
  			57,
  			62,
  			63,
  			68,
  			69,
  			74,
  			75,
  			76,
  			77,
  			78,
  			79,
  			80,
  			81,
  			92,
  			93,
  			98,
  			99,
  			112,
  			113,
  			128,
  			129,
  			134,
  			135,
  			148,
  			149,
  			160,
  			161,
  			162,
  			163,
  			164,
  			165,
  			166,
  			167,
  			168,
  			169,
  			170,
  			171,
  			172,
  			173,
  			178,
  			179,
  			184,
  			185,
  			196,
  			197,
  			198,
  			199,
  			200,
  			201,
  			202,
  			203,
  			204,
  			205,
  			206,
  			207,
  			208,
  			209,
  			214,
  			215,
  			220,
  			221
  		];
  	}
  } catch (error) {
  	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
  }

  /**
   * Build up the default `inspectOpts` object from the environment variables.
   *
   *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
   */

  exports.inspectOpts = Object.keys(browser$1$1.env).filter(key => {
  	return /^debug_/i.test(key);
  }).reduce((obj, key) => {
  	// Camel-case
  	const prop = key
  		.substring(6)
  		.toLowerCase()
  		.replace(/_([a-z])/g, (_, k) => {
  			return k.toUpperCase();
  		});

  	// Coerce string value into JS value
  	let val = browser$1$1.env[key];
  	if (/^(yes|on|true|enabled)$/i.test(val)) {
  		val = true;
  	} else if (/^(no|off|false|disabled)$/i.test(val)) {
  		val = false;
  	} else if (val === 'null') {
  		val = null;
  	} else {
  		val = Number(val);
  	}

  	obj[prop] = val;
  	return obj;
  }, {});

  /**
   * Is stdout a TTY? Colored output is enabled when `true`.
   */

  function useColors() {
  	return 'colors' in exports.inspectOpts ?
  		Boolean(exports.inspectOpts.colors) :
  		tty.isatty(browser$1$1.stderr.fd);
  }

  /**
   * Adds ANSI color escape codes if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
  	const {namespace: name, useColors} = this;

  	if (useColors) {
  		const c = this.color;
  		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
  		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

  		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
  		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
  	} else {
  		args[0] = getDate() + name + ' ' + args[0];
  	}
  }

  function getDate() {
  	if (exports.inspectOpts.hideDate) {
  		return '';
  	}
  	return new Date().toISOString() + ' ';
  }

  /**
   * Invokes `util.format()` with the specified arguments and writes to stderr.
   */

  function log(...args) {
  	return browser$1$1.stderr.write(util.format(...args) + '\n');
  }

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  function save(namespaces) {
  	if (namespaces) {
  		browser$1$1.env.DEBUG = namespaces;
  	} else {
  		// If you set a process.env field to null or undefined, it gets cast to the
  		// string 'null' or 'undefined'. Just delete instead.
  		delete browser$1$1.env.DEBUG;
  	}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */

  function load() {
  	return browser$1$1.env.DEBUG;
  }

  /**
   * Init logic for `debug` instances.
   *
   * Create a new `inspectOpts` object in case `useColors` is set
   * differently for a particular `debug` instance.
   */

  function init(debug) {
  	debug.inspectOpts = {};

  	const keys = Object.keys(exports.inspectOpts);
  	for (let i = 0; i < keys.length; i++) {
  		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  	}
  }

  module.exports = common$1(exports);

  const {formatters} = module.exports;

  /**
   * Map %o to `util.inspect()`, all on a single line.
   */

  formatters.o = function (v) {
  	this.inspectOpts.colors = this.useColors;
  	return util.inspect(v, this.inspectOpts)
  		.split('\n')
  		.map(str => str.trim())
  		.join(' ');
  };

  /**
   * Map %O to `util.inspect()`, allowing multiple lines if needed.
   */

  formatters.O = function (v) {
  	this.inspectOpts.colors = this.useColors;
  	return util.inspect(v, this.inspectOpts);
  };
  }(node$2, node$2.exports));

  if (typeof browser$1$1 === 'undefined' || browser$1$1.type === 'renderer' || browser$1$1.browser === true || browser$1$1.__nwjs) {
  	src$1.exports = browser.exports;
  } else {
  	src$1.exports = node$2.exports;
  }

  var eof = {};

  var opcodes$1 = {};

  var codes$1 = {};

  var functions = {};

  var exceptions = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EvmError = exports.ERROR = void 0;
  (function (ERROR) {
      ERROR["OUT_OF_GAS"] = "out of gas";
      ERROR["CODESTORE_OUT_OF_GAS"] = "code store out of gas";
      ERROR["STACK_UNDERFLOW"] = "stack underflow";
      ERROR["STACK_OVERFLOW"] = "stack overflow";
      ERROR["INVALID_JUMP"] = "invalid JUMP";
      ERROR["INVALID_OPCODE"] = "invalid opcode";
      ERROR["OUT_OF_RANGE"] = "value out of range";
      ERROR["REVERT"] = "revert";
      ERROR["STATIC_STATE_CHANGE"] = "static state change";
      ERROR["INTERNAL_ERROR"] = "internal error";
      ERROR["CREATE_COLLISION"] = "create collision";
      ERROR["STOP"] = "stop";
      ERROR["REFUND_EXHAUSTED"] = "refund exhausted";
      ERROR["VALUE_OVERFLOW"] = "value overflow";
      ERROR["INSUFFICIENT_BALANCE"] = "insufficient balance";
      ERROR["INVALID_BEGINSUB"] = "invalid BEGINSUB";
      ERROR["INVALID_RETURNSUB"] = "invalid RETURNSUB";
      ERROR["INVALID_JUMPSUB"] = "invalid JUMPSUB";
      ERROR["INVALID_BYTECODE_RESULT"] = "invalid bytecode deployed";
      ERROR["INVALID_EOF_FORMAT"] = "invalid EOF format";
      ERROR["INITCODE_SIZE_VIOLATION"] = "initcode exceeds max initcode size";
      ERROR["AUTHCALL_UNSET"] = "attempting to AUTHCALL without AUTH set";
      ERROR["AUTHCALL_NONZERO_VALUEEXT"] = "attempting to execute AUTHCALL with nonzero external value";
      ERROR["AUTH_INVALID_S"] = "invalid Signature: s-values greater than secp256k1n/2 are considered invalid";
      // BLS errors
      ERROR["BLS_12_381_INVALID_INPUT_LENGTH"] = "invalid input length";
      ERROR["BLS_12_381_POINT_NOT_ON_CURVE"] = "point not on curve";
      ERROR["BLS_12_381_INPUT_EMPTY"] = "input is empty";
      ERROR["BLS_12_381_FP_NOT_IN_FIELD"] = "fp point not in field";
  })(exports.ERROR || (exports.ERROR = {}));
  class EvmError {
      constructor(error) {
          this.error = error;
          this.errorType = 'EvmError';
      }
  }
  exports.EvmError = EvmError;

  }(exceptions));

  var util$4 = {};

  Object.defineProperty(util$4, "__esModule", { value: true });
  util$4.exponentation = util$4.abs = util$4.toTwos = util$4.fromTwos = util$4.mod = util$4.updateSstoreGas = util$4.writeCallOutput = util$4.subMemUsage = util$4.maxCallGas = util$4.jumpSubIsValid = util$4.jumpIsValid = util$4.getFullname = util$4.getDataSlice = util$4.divCeil = util$4.describeLocation = util$4.addressToBuffer = util$4.trap = util$4.setLengthLeftStorage = void 0;
  const common_1$g = dist$8;
  const util_1$R = dist$a;
  const keccak_1$9 = keccak;
  const utils_1$2 = utils.exports;
  const exceptions_1$f = exceptions;
  const MASK_160 = (BigInt(1) << BigInt(160)) - BigInt(1);
  /**
   * Proxy function for @ethereumjs/util's setLengthLeft, except it returns a zero
   * length buffer in case the buffer is full of zeros.
   * @param value Buffer which we want to pad
   */
  function setLengthLeftStorage(value) {
      if (value.equals(Buffer$8.alloc(value.length, 0))) {
          // return the empty buffer (the value is zero)
          return Buffer$8.alloc(0);
      }
      else {
          return (0, util_1$R.setLengthLeft)(value, 32);
      }
  }
  util$4.setLengthLeftStorage = setLengthLeftStorage;
  /**
   * Wraps error message as EvmError
   */
  function trap(err) {
      // TODO: facilitate extra data along with errors
      throw new exceptions_1$f.EvmError(err);
  }
  util$4.trap = trap;
  /**
   * Converts bigint address (they're stored like this on the stack) to buffer address
   */
  function addressToBuffer(address) {
      if (Buffer$8.isBuffer(address))
          return address;
      return (0, util_1$R.setLengthLeft)((0, util_1$R.bigIntToBuffer)(address & MASK_160), 20);
  }
  util$4.addressToBuffer = addressToBuffer;
  /**
   * Error message helper - generates location string
   */
  function describeLocation(runState) {
      const hash = (0, utils_1$2.bytesToHex)((0, keccak_1$9.keccak256)(runState.interpreter.getCode()));
      const address = runState.interpreter.getAddress().buf.toString('hex');
      const pc = runState.programCounter - 1;
      return `${hash}/${address}:${pc}`;
  }
  util$4.describeLocation = describeLocation;
  /**
   * Find Ceil(a / b)
   *
   * @param {bigint} a
   * @param {bigint} b
   * @return {bigint}
   */
  function divCeil(a, b) {
      const div = a / b;
      const modulus = mod(a, b);
      // Fast case - exact division
      if (modulus === BigInt(0))
          return div;
      // Round up
      return div < BigInt(0) ? div - BigInt(1) : div + BigInt(1);
  }
  util$4.divCeil = divCeil;
  /**
   * Returns an overflow-safe slice of an array. It right-pads
   * the data with zeros to `length`.
   */
  function getDataSlice(data, offset, length) {
      const len = BigInt(data.length);
      if (offset > len) {
          offset = len;
      }
      let end = offset + length;
      if (end > len) {
          end = len;
      }
      data = data.slice(Number(offset), Number(end));
      // Right-pad with zeros to fill dataLength bytes
      data = (0, util_1$R.setLengthRight)(data, Number(length));
      return data;
  }
  util$4.getDataSlice = getDataSlice;
  /**
   * Get full opcode name from its name and code.
   *
   * @param code Integer code of opcode.
   * @param name Short name of the opcode.
   * @returns Full opcode name
   */
  function getFullname(code, name) {
      switch (name) {
          case 'LOG':
              name += code - 0xa0;
              break;
          case 'PUSH':
              name += code - 0x5f;
              break;
          case 'DUP':
              name += code - 0x7f;
              break;
          case 'SWAP':
              name += code - 0x8f;
              break;
      }
      return name;
  }
  util$4.getFullname = getFullname;
  /**
   * Checks if a jump is valid given a destination (defined as a 1 in the validJumps array)
   */
  function jumpIsValid(runState, dest) {
      return runState.validJumps[dest] === 1;
  }
  util$4.jumpIsValid = jumpIsValid;
  /**
   * Checks if a jumpsub is valid given a destination (defined as a 2 in the validJumps array)
   */
  function jumpSubIsValid(runState, dest) {
      return runState.validJumps[dest] === 2;
  }
  util$4.jumpSubIsValid = jumpSubIsValid;
  /**
   * Returns an overflow-safe slice of an array. It right-pads
   * the data with zeros to `length`.
   * @param gasLimit requested gas Limit
   * @param gasLeft current gas left
   * @param runState the current runState
   * @param common the common
   */
  function maxCallGas(gasLimit, gasLeft, runState, common) {
      if (common.gteHardfork(common_1$g.Hardfork.TangerineWhistle)) {
          const gasAllowed = gasLeft - gasLeft / BigInt(64);
          return gasLimit > gasAllowed ? gasAllowed : gasLimit;
      }
      else {
          return gasLimit;
      }
  }
  util$4.maxCallGas = maxCallGas;
  /**
   * Subtracts the amount needed for memory usage from `runState.gasLeft`
   */
  function subMemUsage(runState, offset, length, common) {
      // YP (225): access with zero length will not extend the memory
      if (length === BigInt(0))
          return BigInt(0);
      const newMemoryWordCount = divCeil(offset + length, BigInt(32));
      if (newMemoryWordCount <= runState.memoryWordCount)
          return BigInt(0);
      const words = newMemoryWordCount;
      const fee = common.param('gasPrices', 'memory');
      const quadCoeff = common.param('gasPrices', 'quadCoeffDiv');
      // words * 3 + words ^2 / 512
      let cost = words * fee + (words * words) / quadCoeff;
      if (cost > runState.highestMemCost) {
          const currentHighestMemCost = runState.highestMemCost;
          runState.highestMemCost = cost;
          cost -= currentHighestMemCost;
      }
      runState.memoryWordCount = newMemoryWordCount;
      return cost;
  }
  util$4.subMemUsage = subMemUsage;
  /**
   * Writes data returned by eei.call* methods to memory
   */
  function writeCallOutput(runState, outOffset, outLength) {
      const returnData = runState.interpreter.getReturnData();
      if (returnData.length > 0) {
          const memOffset = Number(outOffset);
          let dataLength = Number(outLength);
          if (BigInt(returnData.length) < dataLength) {
              dataLength = returnData.length;
          }
          const data = getDataSlice(returnData, BigInt(0), BigInt(dataLength));
          runState.memory.extend(memOffset, dataLength);
          runState.memory.write(memOffset, dataLength, data);
      }
  }
  util$4.writeCallOutput = writeCallOutput;
  /**
   * The first rule set of SSTORE rules, which are the rules pre-Constantinople and in Petersburg
   */
  function updateSstoreGas(runState, currentStorage, value, common) {
      if ((value.length === 0 && currentStorage.length === 0) ||
          (value.length > 0 && currentStorage.length > 0)) {
          const gas = common.param('gasPrices', 'sstoreReset');
          return gas;
      }
      else if (value.length === 0 && currentStorage.length > 0) {
          const gas = common.param('gasPrices', 'sstoreReset');
          runState.interpreter.refundGas(common.param('gasPrices', 'sstoreRefund'), 'updateSstoreGas');
          return gas;
      }
      else {
          /*
            The situations checked above are:
            -> Value/Slot are both 0
            -> Value/Slot are both nonzero
            -> Value is zero, but slot is nonzero
            Thus, the remaining case is where value is nonzero, but slot is zero, which is this clause
          */
          return common.param('gasPrices', 'sstoreSet');
      }
  }
  util$4.updateSstoreGas = updateSstoreGas;
  function mod(a, b) {
      let r = a % b;
      if (r < BigInt(0)) {
          r = b + r;
      }
      return r;
  }
  util$4.mod = mod;
  function fromTwos(a) {
      return BigInt.asIntN(256, a);
  }
  util$4.fromTwos = fromTwos;
  function toTwos(a) {
      return BigInt.asUintN(256, a);
  }
  util$4.toTwos = toTwos;
  function abs$1(a) {
      if (a > 0) {
          return a;
      }
      return a * BigInt(-1);
  }
  util$4.abs = abs$1;
  const N = BigInt(115792089237316195423570985008687907853269984665640564039457584007913129639936);
  function exponentation(bas, exp) {
      let t = BigInt(1);
      while (exp > BigInt(0)) {
          if (exp % BigInt(2) != BigInt(0)) {
              t = (t * bas) % N;
          }
          bas = (bas * bas) % N;
          exp = exp / BigInt(2);
      }
      return t;
  }
  util$4.exponentation = exponentation;

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.handlers = void 0;
  const util_1 = dist$a;
  const keccak_1 = keccak;
  const utils_1 = utils.exports;
  const exceptions_1 = exceptions;
  const util_2 = util$4;
  const EIP3074MAGIC = Buffer$8.from('03', 'hex');
  // the opcode functions
  exports.handlers = new Map([
      // 0x00: STOP
      [
          0x00,
          function () {
              (0, util_2.trap)(exceptions_1.ERROR.STOP);
          },
      ],
      // 0x01: ADD
      [
          0x01,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = (0, util_2.mod)(a + b, util_1.TWO_POW256);
              runState.stack.push(r);
          },
      ],
      // 0x02: MUL
      [
          0x02,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = (0, util_2.mod)(a * b, util_1.TWO_POW256);
              runState.stack.push(r);
          },
      ],
      // 0x03: SUB
      [
          0x03,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = (0, util_2.mod)(a - b, util_1.TWO_POW256);
              runState.stack.push(r);
          },
      ],
      // 0x04: DIV
      [
          0x04,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              let r;
              if (b === BigInt(0)) {
                  r = BigInt(0);
              }
              else {
                  r = (0, util_2.mod)(a / b, util_1.TWO_POW256);
              }
              runState.stack.push(r);
          },
      ],
      // 0x05: SDIV
      [
          0x05,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              let r;
              if (b === BigInt(0)) {
                  r = BigInt(0);
              }
              else {
                  r = (0, util_2.toTwos)((0, util_2.fromTwos)(a) / (0, util_2.fromTwos)(b));
              }
              runState.stack.push(r);
          },
      ],
      // 0x06: MOD
      [
          0x06,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              let r;
              if (b === BigInt(0)) {
                  r = b;
              }
              else {
                  r = (0, util_2.mod)(a, b);
              }
              runState.stack.push(r);
          },
      ],
      // 0x07: SMOD
      [
          0x07,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              let r;
              if (b === BigInt(0)) {
                  r = b;
              }
              else {
                  r = (0, util_2.fromTwos)(a) % (0, util_2.fromTwos)(b);
              }
              runState.stack.push((0, util_2.toTwos)(r));
          },
      ],
      // 0x08: ADDMOD
      [
          0x08,
          function (runState) {
              const [a, b, c] = runState.stack.popN(3);
              let r;
              if (c === BigInt(0)) {
                  r = BigInt(0);
              }
              else {
                  r = (0, util_2.mod)(a + b, c);
              }
              runState.stack.push(r);
          },
      ],
      // 0x09: MULMOD
      [
          0x09,
          function (runState) {
              const [a, b, c] = runState.stack.popN(3);
              let r;
              if (c === BigInt(0)) {
                  r = BigInt(0);
              }
              else {
                  r = (0, util_2.mod)(a * b, c);
              }
              runState.stack.push(r);
          },
      ],
      // 0x0a: EXP
      [
          0x0a,
          function (runState) {
              const [base, exponent] = runState.stack.popN(2);
              if (exponent === BigInt(0)) {
                  runState.stack.push(BigInt(1));
                  return;
              }
              if (base === BigInt(0)) {
                  runState.stack.push(base);
                  return;
              }
              const r = (0, util_2.exponentation)(base, exponent);
              runState.stack.push(r);
          },
      ],
      // 0x0b: SIGNEXTEND
      [
          0x0b,
          function (runState) {
              /* eslint-disable-next-line prefer-const */
              let [k, val] = runState.stack.popN(2);
              if (k < BigInt(31)) {
                  const signBit = k * BigInt(8) + BigInt(7);
                  const mask = (BigInt(1) << signBit) - BigInt(1);
                  if ((val >> signBit) & BigInt(1)) {
                      val = val | BigInt.asUintN(256, ~mask);
                  }
                  else {
                      val = val & mask;
                  }
              }
              runState.stack.push(val);
          },
      ],
      // 0x10 range - bit ops
      // 0x10: LT
      [
          0x10,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = a < b ? BigInt(1) : BigInt(0);
              runState.stack.push(r);
          },
      ],
      // 0x11: GT
      [
          0x11,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = a > b ? BigInt(1) : BigInt(0);
              runState.stack.push(r);
          },
      ],
      // 0x12: SLT
      [
          0x12,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = (0, util_2.fromTwos)(a) < (0, util_2.fromTwos)(b) ? BigInt(1) : BigInt(0);
              runState.stack.push(r);
          },
      ],
      // 0x13: SGT
      [
          0x13,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = (0, util_2.fromTwos)(a) > (0, util_2.fromTwos)(b) ? BigInt(1) : BigInt(0);
              runState.stack.push(r);
          },
      ],
      // 0x14: EQ
      [
          0x14,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = a === b ? BigInt(1) : BigInt(0);
              runState.stack.push(r);
          },
      ],
      // 0x15: ISZERO
      [
          0x15,
          function (runState) {
              const a = runState.stack.pop();
              const r = a === BigInt(0) ? BigInt(1) : BigInt(0);
              runState.stack.push(r);
          },
      ],
      // 0x16: AND
      [
          0x16,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = a & b;
              runState.stack.push(r);
          },
      ],
      // 0x17: OR
      [
          0x17,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = a | b;
              runState.stack.push(r);
          },
      ],
      // 0x18: XOR
      [
          0x18,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              const r = a ^ b;
              runState.stack.push(r);
          },
      ],
      // 0x19: NOT
      [
          0x19,
          function (runState) {
              const a = runState.stack.pop();
              const r = BigInt.asUintN(256, ~a);
              runState.stack.push(r);
          },
      ],
      // 0x1a: BYTE
      [
          0x1a,
          function (runState) {
              const [pos, word] = runState.stack.popN(2);
              if (pos > BigInt(32)) {
                  runState.stack.push(BigInt(0));
                  return;
              }
              const r = (word >> ((BigInt(31) - pos) * BigInt(8))) & BigInt(0xff);
              runState.stack.push(r);
          },
      ],
      // 0x1b: SHL
      [
          0x1b,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              if (a > BigInt(256)) {
                  runState.stack.push(BigInt(0));
                  return;
              }
              const r = (b << a) & util_1.MAX_INTEGER_BIGINT;
              runState.stack.push(r);
          },
      ],
      // 0x1c: SHR
      [
          0x1c,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              if (a > 256) {
                  runState.stack.push(BigInt(0));
                  return;
              }
              const r = b >> a;
              runState.stack.push(r);
          },
      ],
      // 0x1d: SAR
      [
          0x1d,
          function (runState) {
              const [a, b] = runState.stack.popN(2);
              let r;
              const bComp = BigInt.asIntN(256, b);
              const isSigned = bComp < 0;
              if (a > 256) {
                  if (isSigned) {
                      r = util_1.MAX_INTEGER_BIGINT;
                  }
                  else {
                      r = BigInt(0);
                  }
                  runState.stack.push(r);
                  return;
              }
              const c = b >> a;
              if (isSigned) {
                  const shiftedOutWidth = BigInt(255) - a;
                  const mask = (util_1.MAX_INTEGER_BIGINT >> shiftedOutWidth) << shiftedOutWidth;
                  r = c | mask;
              }
              else {
                  r = c;
              }
              runState.stack.push(r);
          },
      ],
      // 0x20 range - crypto
      // 0x20: SHA3
      [
          0x20,
          function (runState) {
              const [offset, length] = runState.stack.popN(2);
              let data = Buffer$8.alloc(0);
              if (length !== BigInt(0)) {
                  data = runState.memory.read(Number(offset), Number(length));
              }
              const r = BigInt('0x' + (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(data)));
              runState.stack.push(r);
          },
      ],
      // 0x30 range - closure state
      // 0x30: ADDRESS
      [
          0x30,
          function (runState) {
              const address = (0, util_1.bufferToBigInt)(runState.interpreter.getAddress().buf);
              runState.stack.push(address);
          },
      ],
      // 0x31: BALANCE
      [
          0x31,
          async function (runState) {
              const addressBigInt = runState.stack.pop();
              const address = new util_1.Address((0, util_2.addressToBuffer)(addressBigInt));
              const balance = await runState.interpreter.getExternalBalance(address);
              runState.stack.push(balance);
          },
      ],
      // 0x32: ORIGIN
      [
          0x32,
          function (runState) {
              runState.stack.push(runState.interpreter.getTxOrigin());
          },
      ],
      // 0x33: CALLER
      [
          0x33,
          function (runState) {
              runState.stack.push(runState.interpreter.getCaller());
          },
      ],
      // 0x34: CALLVALUE
      [
          0x34,
          function (runState) {
              runState.stack.push(runState.interpreter.getCallValue());
          },
      ],
      // 0x35: CALLDATALOAD
      [
          0x35,
          function (runState) {
              const pos = runState.stack.pop();
              if (pos > runState.interpreter.getCallDataSize()) {
                  runState.stack.push(BigInt(0));
                  return;
              }
              const i = Number(pos);
              let loaded = runState.interpreter.getCallData().slice(i, i + 32);
              loaded = loaded.length ? loaded : Buffer$8.from([0]);
              let r = (0, util_1.bufferToBigInt)(loaded);
              if (loaded.length < 32) {
                  r = r << (BigInt(8) * BigInt(32 - loaded.length));
              }
              runState.stack.push(r);
          },
      ],
      // 0x36: CALLDATASIZE
      [
          0x36,
          function (runState) {
              const r = runState.interpreter.getCallDataSize();
              runState.stack.push(r);
          },
      ],
      // 0x37: CALLDATACOPY
      [
          0x37,
          function (runState) {
              const [memOffset, dataOffset, dataLength] = runState.stack.popN(3);
              if (dataLength !== BigInt(0)) {
                  const data = (0, util_2.getDataSlice)(runState.interpreter.getCallData(), dataOffset, dataLength);
                  const memOffsetNum = Number(memOffset);
                  const dataLengthNum = Number(dataLength);
                  runState.memory.extend(memOffsetNum, dataLengthNum);
                  runState.memory.write(memOffsetNum, dataLengthNum, data);
              }
          },
      ],
      // 0x38: CODESIZE
      [
          0x38,
          function (runState) {
              runState.stack.push(runState.interpreter.getCodeSize());
          },
      ],
      // 0x39: CODECOPY
      [
          0x39,
          function (runState) {
              const [memOffset, codeOffset, dataLength] = runState.stack.popN(3);
              if (dataLength !== BigInt(0)) {
                  const data = (0, util_2.getDataSlice)(runState.interpreter.getCode(), codeOffset, dataLength);
                  const memOffsetNum = Number(memOffset);
                  const lengthNum = Number(dataLength);
                  runState.memory.extend(memOffsetNum, lengthNum);
                  runState.memory.write(memOffsetNum, lengthNum, data);
              }
          },
      ],
      // 0x3b: EXTCODESIZE
      [
          0x3b,
          async function (runState) {
              const addressBigInt = runState.stack.pop();
              const size = BigInt((await runState.eei.getContractCode(new util_1.Address((0, util_2.addressToBuffer)(addressBigInt)))).length);
              runState.stack.push(size);
          },
      ],
      // 0x3c: EXTCODECOPY
      [
          0x3c,
          async function (runState) {
              const [addressBigInt, memOffset, codeOffset, dataLength] = runState.stack.popN(4);
              if (dataLength !== BigInt(0)) {
                  const code = await runState.eei.getContractCode(new util_1.Address((0, util_2.addressToBuffer)(addressBigInt)));
                  const data = (0, util_2.getDataSlice)(code, codeOffset, dataLength);
                  const memOffsetNum = Number(memOffset);
                  const lengthNum = Number(dataLength);
                  runState.memory.extend(memOffsetNum, lengthNum);
                  runState.memory.write(memOffsetNum, lengthNum, data);
              }
          },
      ],
      // 0x3f: EXTCODEHASH
      [
          0x3f,
          async function (runState) {
              const addressBigInt = runState.stack.pop();
              const address = new util_1.Address((0, util_2.addressToBuffer)(addressBigInt));
              const empty = (await runState.eei.getAccount(address)).isEmpty();
              if (empty) {
                  runState.stack.push(BigInt(0));
                  return;
              }
              const codeHash = (await runState.eei.getAccount(new util_1.Address((0, util_2.addressToBuffer)(addressBigInt))))
                  .codeHash;
              runState.stack.push(BigInt('0x' + codeHash.toString('hex')));
          },
      ],
      // 0x3d: RETURNDATASIZE
      [
          0x3d,
          function (runState) {
              runState.stack.push(runState.interpreter.getReturnDataSize());
          },
      ],
      // 0x3e: RETURNDATACOPY
      [
          0x3e,
          function (runState) {
              const [memOffset, returnDataOffset, dataLength] = runState.stack.popN(3);
              if (dataLength !== BigInt(0)) {
                  const data = (0, util_2.getDataSlice)(runState.interpreter.getReturnData(), returnDataOffset, dataLength);
                  const memOffsetNum = Number(memOffset);
                  const lengthNum = Number(dataLength);
                  runState.memory.extend(memOffsetNum, lengthNum);
                  runState.memory.write(memOffsetNum, lengthNum, data);
              }
          },
      ],
      // 0x3a: GASPRICE
      [
          0x3a,
          function (runState) {
              runState.stack.push(runState.interpreter.getTxGasPrice());
          },
      ],
      // '0x40' range - block operations
      // 0x40: BLOCKHASH
      [
          0x40,
          async function (runState) {
              const number = runState.stack.pop();
              const diff = runState.interpreter.getBlockNumber() - number;
              // block lookups must be within the past 256 blocks
              if (diff > BigInt(256) || diff <= BigInt(0)) {
                  runState.stack.push(BigInt(0));
                  return;
              }
              const hash = await runState.eei.getBlockHash(number);
              runState.stack.push(hash);
          },
      ],
      // 0x41: COINBASE
      [
          0x41,
          function (runState) {
              runState.stack.push(runState.interpreter.getBlockCoinbase());
          },
      ],
      // 0x42: TIMESTAMP
      [
          0x42,
          function (runState) {
              runState.stack.push(runState.interpreter.getBlockTimestamp());
          },
      ],
      // 0x43: NUMBER
      [
          0x43,
          function (runState) {
              runState.stack.push(runState.interpreter.getBlockNumber());
          },
      ],
      // 0x44: DIFFICULTY (EIP-4399: supplanted as PREVRANDAO)
      [
          0x44,
          function (runState, common) {
              if (common.isActivatedEIP(4399)) {
                  runState.stack.push(runState.interpreter.getBlockPrevRandao());
              }
              else {
                  runState.stack.push(runState.interpreter.getBlockDifficulty());
              }
          },
      ],
      // 0x45: GASLIMIT
      [
          0x45,
          function (runState) {
              runState.stack.push(runState.interpreter.getBlockGasLimit());
          },
      ],
      // 0x46: CHAINID
      [
          0x46,
          function (runState) {
              runState.stack.push(runState.interpreter.getChainId());
          },
      ],
      // 0x47: SELFBALANCE
      [
          0x47,
          function (runState) {
              runState.stack.push(runState.interpreter.getSelfBalance());
          },
      ],
      // 0x48: BASEFEE
      [
          0x48,
          function (runState) {
              runState.stack.push(runState.interpreter.getBlockBaseFee());
          },
      ],
      // 0x50 range - 'storage' and execution
      // 0x50: POP
      [
          0x50,
          function (runState) {
              runState.stack.pop();
          },
      ],
      // 0x51: MLOAD
      [
          0x51,
          function (runState) {
              const pos = runState.stack.pop();
              const word = runState.memory.read(Number(pos), 32);
              runState.stack.push((0, util_1.bufferToBigInt)(word));
          },
      ],
      // 0x52: MSTORE
      [
          0x52,
          function (runState) {
              const [offset, word] = runState.stack.popN(2);
              const buf = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(word), 32);
              const offsetNum = Number(offset);
              runState.memory.extend(offsetNum, 32);
              runState.memory.write(offsetNum, 32, buf);
          },
      ],
      // 0x53: MSTORE8
      [
          0x53,
          function (runState) {
              const [offset, byte] = runState.stack.popN(2);
              const buf = (0, util_1.bigIntToBuffer)(byte & BigInt(0xff));
              const offsetNum = Number(offset);
              runState.memory.extend(offsetNum, 1);
              runState.memory.write(offsetNum, 1, buf);
          },
      ],
      // 0x54: SLOAD
      [
          0x54,
          async function (runState) {
              const key = runState.stack.pop();
              const keyBuf = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(key), 32);
              const value = await runState.interpreter.storageLoad(keyBuf);
              const valueBigInt = value.length ? (0, util_1.bufferToBigInt)(value) : BigInt(0);
              runState.stack.push(valueBigInt);
          },
      ],
      // 0x55: SSTORE
      [
          0x55,
          async function (runState) {
              const [key, val] = runState.stack.popN(2);
              const keyBuf = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(key), 32);
              // NOTE: this should be the shortest representation
              let value;
              if (val === BigInt(0)) {
                  value = Buffer$8.from([]);
              }
              else {
                  value = (0, util_1.bigIntToBuffer)(val);
              }
              await runState.interpreter.storageStore(keyBuf, value);
          },
      ],
      // 0x56: JUMP
      [
          0x56,
          function (runState) {
              const dest = runState.stack.pop();
              if (dest > runState.interpreter.getCodeSize()) {
                  (0, util_2.trap)(exceptions_1.ERROR.INVALID_JUMP + ' at ' + (0, util_2.describeLocation)(runState));
              }
              const destNum = Number(dest);
              if (!(0, util_2.jumpIsValid)(runState, destNum)) {
                  (0, util_2.trap)(exceptions_1.ERROR.INVALID_JUMP + ' at ' + (0, util_2.describeLocation)(runState));
              }
              runState.programCounter = destNum;
          },
      ],
      // 0x57: JUMPI
      [
          0x57,
          function (runState) {
              const [dest, cond] = runState.stack.popN(2);
              if (cond !== BigInt(0)) {
                  if (dest > runState.interpreter.getCodeSize()) {
                      (0, util_2.trap)(exceptions_1.ERROR.INVALID_JUMP + ' at ' + (0, util_2.describeLocation)(runState));
                  }
                  const destNum = Number(dest);
                  if (!(0, util_2.jumpIsValid)(runState, destNum)) {
                      (0, util_2.trap)(exceptions_1.ERROR.INVALID_JUMP + ' at ' + (0, util_2.describeLocation)(runState));
                  }
                  runState.programCounter = destNum;
              }
          },
      ],
      // 0x58: PC
      [
          0x58,
          function (runState) {
              runState.stack.push(BigInt(runState.programCounter - 1));
          },
      ],
      // 0x59: MSIZE
      [
          0x59,
          function (runState) {
              runState.stack.push(runState.memoryWordCount * BigInt(32));
          },
      ],
      // 0x5a: GAS
      [
          0x5a,
          function (runState) {
              runState.stack.push(runState.interpreter.getGasLeft());
          },
      ],
      // 0x5b: JUMPDEST
      [0x5b, function () { }],
      // 0x5c: BEGINSUB
      [
          0x5c,
          function (runState) {
              (0, util_2.trap)(exceptions_1.ERROR.INVALID_BEGINSUB + ' at ' + (0, util_2.describeLocation)(runState));
          },
      ],
      // 0x5d: RETURNSUB
      [
          0x5d,
          function (runState) {
              if (runState.returnStack.length < 1) {
                  (0, util_2.trap)(exceptions_1.ERROR.INVALID_RETURNSUB);
              }
              const dest = runState.returnStack.pop();
              runState.programCounter = Number(dest);
          },
      ],
      // 0x5e: JUMPSUB
      [
          0x5e,
          function (runState) {
              const dest = runState.stack.pop();
              if (dest > runState.interpreter.getCodeSize()) {
                  (0, util_2.trap)(exceptions_1.ERROR.INVALID_JUMPSUB + ' at ' + (0, util_2.describeLocation)(runState));
              }
              const destNum = Number(dest);
              if (!(0, util_2.jumpSubIsValid)(runState, destNum)) {
                  (0, util_2.trap)(exceptions_1.ERROR.INVALID_JUMPSUB + ' at ' + (0, util_2.describeLocation)(runState));
              }
              runState.returnStack.push(BigInt(runState.programCounter));
              runState.programCounter = destNum + 1;
          },
      ],
      // 0x5f: PUSH0
      [
          0x5f,
          function (runState) {
              runState.stack.push(BigInt(0));
          },
      ],
      // 0x60: PUSH
      [
          0x60,
          function (runState, common) {
              const numToPush = runState.opCode - 0x5f;
              if (common.isActivatedEIP(3540) &&
                  runState.programCounter + numToPush > runState.code.length) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_RANGE);
              }
              const loaded = (0, util_1.bufferToBigInt)(runState.interpreter
                  .getCode()
                  .slice(runState.programCounter, runState.programCounter + numToPush));
              runState.programCounter += numToPush;
              runState.stack.push(loaded);
          },
      ],
      // 0x80: DUP
      [
          0x80,
          function (runState) {
              const stackPos = runState.opCode - 0x7f;
              runState.stack.dup(stackPos);
          },
      ],
      // 0x90: SWAP
      [
          0x90,
          function (runState) {
              const stackPos = runState.opCode - 0x8f;
              runState.stack.swap(stackPos);
          },
      ],
      // 0xa0: LOG
      [
          0xa0,
          function (runState) {
              const [memOffset, memLength] = runState.stack.popN(2);
              const topicsCount = runState.opCode - 0xa0;
              const topics = runState.stack.popN(topicsCount);
              const topicsBuf = topics.map(function (a) {
                  return (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(a), 32);
              });
              let mem = Buffer$8.alloc(0);
              if (memLength !== BigInt(0)) {
                  mem = runState.memory.read(Number(memOffset), Number(memLength));
              }
              runState.interpreter.log(mem, topicsCount, topicsBuf);
          },
      ],
      // 0xb3: TLOAD
      [
          0xb3,
          function (runState) {
              const key = runState.stack.pop();
              const keyBuf = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(key), 32);
              const value = runState.interpreter.transientStorageLoad(keyBuf);
              const valueBN = value.length ? (0, util_1.bufferToBigInt)(value) : BigInt(0);
              runState.stack.push(valueBN);
          },
      ],
      // 0xb4: TSTORE
      [
          0xb4,
          function (runState) {
              if (runState.interpreter.isStatic()) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              const [key, val] = runState.stack.popN(2);
              const keyBuf = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(key), 32);
              // NOTE: this should be the shortest representation
              let value;
              if (val === BigInt(0)) {
                  value = Buffer$8.from([]);
              }
              else {
                  value = (0, util_1.bigIntToBuffer)(val);
              }
              runState.interpreter.transientStorageStore(keyBuf, value);
          },
      ],
      // '0xf0' range - closures
      // 0xf0: CREATE
      [
          0xf0,
          async function (runState) {
              const [value, offset, length] = runState.stack.popN(3);
              const gasLimit = runState.messageGasLimit;
              runState.messageGasLimit = undefined;
              let data = Buffer$8.alloc(0);
              if (length !== BigInt(0)) {
                  data = runState.memory.read(Number(offset), Number(length));
              }
              const ret = await runState.interpreter.create(gasLimit, value, data);
              runState.stack.push(ret);
          },
      ],
      // 0xf5: CREATE2
      [
          0xf5,
          async function (runState) {
              if (runState.interpreter.isStatic()) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              const [value, offset, length, salt] = runState.stack.popN(4);
              const gasLimit = runState.messageGasLimit;
              runState.messageGasLimit = undefined;
              let data = Buffer$8.alloc(0);
              if (length !== BigInt(0)) {
                  data = runState.memory.read(Number(offset), Number(length));
              }
              const ret = await runState.interpreter.create2(gasLimit, value, data, (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(salt), 32));
              runState.stack.push(ret);
          },
      ],
      // 0xf1: CALL
      [
          0xf1,
          async function (runState) {
              const [_currentGasLimit, toAddr, value, inOffset, inLength, outOffset, outLength] = runState.stack.popN(7);
              const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
              let data = Buffer$8.alloc(0);
              if (inLength !== BigInt(0)) {
                  data = runState.memory.read(Number(inOffset), Number(inLength));
              }
              const gasLimit = runState.messageGasLimit;
              runState.messageGasLimit = undefined;
              const ret = await runState.interpreter.call(gasLimit, toAddress, value, data);
              // Write return data to memory
              (0, util_2.writeCallOutput)(runState, outOffset, outLength);
              runState.stack.push(ret);
          },
      ],
      // 0xf2: CALLCODE
      [
          0xf2,
          async function (runState) {
              const [_currentGasLimit, toAddr, value, inOffset, inLength, outOffset, outLength] = runState.stack.popN(7);
              const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
              const gasLimit = runState.messageGasLimit;
              runState.messageGasLimit = undefined;
              let data = Buffer$8.alloc(0);
              if (inLength !== BigInt(0)) {
                  data = runState.memory.read(Number(inOffset), Number(inLength));
              }
              const ret = await runState.interpreter.callCode(gasLimit, toAddress, value, data);
              // Write return data to memory
              (0, util_2.writeCallOutput)(runState, outOffset, outLength);
              runState.stack.push(ret);
          },
      ],
      // 0xf4: DELEGATECALL
      [
          0xf4,
          async function (runState) {
              const value = runState.interpreter.getCallValue();
              const [_currentGasLimit, toAddr, inOffset, inLength, outOffset, outLength] = runState.stack.popN(6);
              const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
              let data = Buffer$8.alloc(0);
              if (inLength !== BigInt(0)) {
                  data = runState.memory.read(Number(inOffset), Number(inLength));
              }
              const gasLimit = runState.messageGasLimit;
              runState.messageGasLimit = undefined;
              const ret = await runState.interpreter.callDelegate(gasLimit, toAddress, value, data);
              // Write return data to memory
              (0, util_2.writeCallOutput)(runState, outOffset, outLength);
              runState.stack.push(ret);
          },
      ],
      // 0xf6: AUTH
      [
          0xf6,
          async function (runState) {
              // eslint-disable-next-line prefer-const
              let [authority, memOffset, memLength] = runState.stack.popN(3);
              if (memLength > BigInt(128)) {
                  memLength = BigInt(128);
              }
              let mem = runState.memory.read(Number(memOffset), Number(memLength));
              if (mem.length < 128) {
                  mem = (0, util_1.setLengthRight)(mem, 128);
              }
              const yParity = BigInt(mem[31]);
              const r = mem.slice(32, 64);
              const s = mem.slice(64, 96);
              const commit = mem.slice(96, 128);
              if ((0, util_1.bufferToBigInt)(s) > util_1.SECP256K1_ORDER_DIV_2) {
                  (0, util_2.trap)(exceptions_1.ERROR.AUTH_INVALID_S);
              }
              const paddedInvokerAddress = (0, util_1.setLengthLeft)(runState.interpreter._env.address.buf, 32);
              const chainId = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(runState.interpreter.getChainId()), 32);
              const message = Buffer$8.concat([EIP3074MAGIC, chainId, paddedInvokerAddress, commit]);
              const msgHash = Buffer$8.from((0, keccak_1.keccak256)(message));
              let recover;
              try {
                  recover = (0, util_1.ecrecover)(msgHash, yParity + BigInt(27), r, s);
              }
              catch (e) {
                  // Malformed signature, push 0 on stack, clear auth variable
                  runState.stack.push(BigInt(0));
                  runState.auth = undefined;
                  return;
              }
              const addressBuffer = (0, util_1.publicToAddress)(recover);
              const address = new util_1.Address(addressBuffer);
              runState.auth = address;
              const expectedAddress = new util_1.Address((0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(authority), 20));
              if (!expectedAddress.equals(address)) {
                  // expected address does not equal the recovered address, clear auth variable
                  runState.stack.push(BigInt(0));
                  runState.auth = undefined;
                  return;
              }
              runState.auth = address;
              runState.stack.push(BigInt(1));
          },
      ],
      // 0xf7: AUTHCALL
      [
          0xf7,
          async function (runState) {
              const [_currentGasLimit, addr, value, _valueExt, argsOffset, argsLength, retOffset, retLength,] = runState.stack.popN(8);
              const toAddress = new util_1.Address((0, util_2.addressToBuffer)(addr));
              const gasLimit = runState.messageGasLimit;
              runState.messageGasLimit = undefined;
              let data = Buffer$8.alloc(0);
              if (argsLength !== BigInt(0)) {
                  data = runState.memory.read(Number(argsOffset), Number(argsLength));
              }
              const ret = await runState.interpreter.authcall(gasLimit, toAddress, value, data);
              // Write return data to memory
              (0, util_2.writeCallOutput)(runState, retOffset, retLength);
              runState.stack.push(ret);
          },
      ],
      // 0xfa: STATICCALL
      [
          0xfa,
          async function (runState) {
              const value = BigInt(0);
              const [_currentGasLimit, toAddr, inOffset, inLength, outOffset, outLength] = runState.stack.popN(6);
              const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
              const gasLimit = runState.messageGasLimit;
              runState.messageGasLimit = undefined;
              let data = Buffer$8.alloc(0);
              if (inLength !== BigInt(0)) {
                  data = runState.memory.read(Number(inOffset), Number(inLength));
              }
              const ret = await runState.interpreter.callStatic(gasLimit, toAddress, value, data);
              // Write return data to memory
              (0, util_2.writeCallOutput)(runState, outOffset, outLength);
              runState.stack.push(ret);
          },
      ],
      // 0xf3: RETURN
      [
          0xf3,
          function (runState) {
              const [offset, length] = runState.stack.popN(2);
              let returnData = Buffer$8.alloc(0);
              if (length !== BigInt(0)) {
                  returnData = runState.memory.read(Number(offset), Number(length));
              }
              runState.interpreter.finish(returnData);
          },
      ],
      // 0xfd: REVERT
      [
          0xfd,
          function (runState) {
              const [offset, length] = runState.stack.popN(2);
              let returnData = Buffer$8.alloc(0);
              if (length !== BigInt(0)) {
                  returnData = runState.memory.read(Number(offset), Number(length));
              }
              runState.interpreter.revert(returnData);
          },
      ],
      // '0x70', range - other
      // 0xff: SELFDESTRUCT
      [
          0xff,
          async function (runState) {
              const selfdestructToAddressBigInt = runState.stack.pop();
              const selfdestructToAddress = new util_1.Address((0, util_2.addressToBuffer)(selfdestructToAddressBigInt));
              return runState.interpreter.selfDestruct(selfdestructToAddress);
          },
      ],
  ]);
  // Fill in rest of PUSHn, DUPn, SWAPn, LOGn for handlers
  const pushFn = exports.handlers.get(0x60);
  for (let i = 0x61; i <= 0x7f; i++) {
      exports.handlers.set(i, pushFn);
  }
  const dupFn = exports.handlers.get(0x80);
  for (let i = 0x81; i <= 0x8f; i++) {
      exports.handlers.set(i, dupFn);
  }
  const swapFn = exports.handlers.get(0x90);
  for (let i = 0x91; i <= 0x9f; i++) {
      exports.handlers.set(i, swapFn);
  }
  const logFn = exports.handlers.get(0xa0);
  for (let i = 0xa1; i <= 0xa4; i++) {
      exports.handlers.set(i, logFn);
  }

  }(functions));

  var gas = {};

  var EIP1283 = {};

  Object.defineProperty(EIP1283, "__esModule", { value: true });
  EIP1283.updateSstoreGasEIP1283 = void 0;
  /**
   * Adjusts gas usage and refunds of SStore ops per EIP-1283 (Constantinople)
   *
   * @param {RunState} runState
   * @param {Buffer}   currentStorage
   * @param {Buffer}   originalStorage
   * @param {Buffer}   value
   * @param {Common}   common
   */
  function updateSstoreGasEIP1283(runState, currentStorage, originalStorage, value, common) {
      if (currentStorage.equals(value)) {
          // If current value equals new value (this is a no-op), 200 gas is deducted.
          return common.param('gasPrices', 'netSstoreNoopGas');
      }
      // If current value does not equal new value
      if (originalStorage.equals(currentStorage)) {
          // If original value equals current value (this storage slot has not been changed by the current execution context)
          if (originalStorage.length === 0) {
              // If original value is 0, 20000 gas is deducted.
              return common.param('gasPrices', 'netSstoreInitGas');
          }
          if (value.length === 0) {
              // If new value is 0, add 15000 gas to refund counter.
              runState.interpreter.refundGas(common.param('gasPrices', 'netSstoreClearRefund'), 'EIP-1283 -> netSstoreClearRefund');
          }
          // Otherwise, 5000 gas is deducted.
          return common.param('gasPrices', 'netSstoreCleanGas');
      }
      // If original value does not equal current value (this storage slot is dirty), 200 gas is deducted. Apply both of the following clauses.
      if (originalStorage.length !== 0) {
          // If original value is not 0
          if (currentStorage.length === 0) {
              // If current value is 0 (also means that new value is not 0), remove 15000 gas from refund counter. We can prove that refund counter will never go below 0.
              runState.interpreter.subRefund(common.param('gasPrices', 'netSstoreClearRefund'), 'EIP-1283 -> netSstoreClearRefund');
          }
          else if (value.length === 0) {
              // If new value is 0 (also means that current value is not 0), add 15000 gas to refund counter.
              runState.interpreter.refundGas(common.param('gasPrices', 'netSstoreClearRefund'), 'EIP-1283 -> netSstoreClearRefund');
          }
      }
      if (originalStorage.equals(value)) {
          // If original value equals new value (this storage slot is reset)
          if (originalStorage.length === 0) {
              // If original value is 0, add 19800 gas to refund counter.
              runState.interpreter.refundGas(common.param('gasPrices', 'netSstoreResetClearRefund'), 'EIP-1283 -> netSstoreResetClearRefund');
          }
          else {
              // Otherwise, add 4800 gas to refund counter.
              runState.interpreter.refundGas(common.param('gasPrices', 'netSstoreResetRefund'), 'EIP-1283 -> netSstoreResetRefund');
          }
      }
      return common.param('gasPrices', 'netSstoreDirtyGas');
  }
  EIP1283.updateSstoreGasEIP1283 = updateSstoreGasEIP1283;

  var EIP2200 = {};

  var EIP2929 = {};

  Object.defineProperty(EIP2929, "__esModule", { value: true });
  EIP2929.adjustSstoreGasEIP2929 = EIP2929.accessStorageEIP2929 = EIP2929.accessAddressEIP2929 = void 0;
  /**
   * Adds address to accessedAddresses set if not already included.
   * Adjusts cost incurred for executing opcode based on whether address read
   * is warm/cold. (EIP 2929)
   * @param {RunState} runState
   * @param {Address}  address
   * @param {Common}   common
   * @param {Boolean}  chargeGas (default: true)
   * @param {Boolean}  isSelfdestruct (default: false)
   */
  function accessAddressEIP2929(runState, address, common, chargeGas = true, isSelfdestructOrAuthcall = false) {
      if (common.isActivatedEIP(2929) === false)
          return BigInt(0);
      const eei = runState.eei;
      const addressStr = address.buf;
      // Cold
      if (!eei.isWarmedAddress(addressStr)) {
          eei.addWarmedAddress(addressStr);
          // CREATE, CREATE2 opcodes have the address warmed for free.
          // selfdestruct beneficiary address reads are charged an *additional* cold access
          if (chargeGas) {
              return common.param('gasPrices', 'coldaccountaccess');
          }
          // Warm: (selfdestruct beneficiary address reads are not charged when warm)
      }
      else if (chargeGas && !isSelfdestructOrAuthcall) {
          return common.param('gasPrices', 'warmstorageread');
      }
      return BigInt(0);
  }
  EIP2929.accessAddressEIP2929 = accessAddressEIP2929;
  /**
   * Adds (address, key) to accessedStorage tuple set if not already included.
   * Adjusts cost incurred for executing opcode based on whether storage read
   * is warm/cold. (EIP 2929)
   * @param {RunState} runState
   * @param {Buffer} key (to storage slot)
   * @param {Common} common
   */
  function accessStorageEIP2929(runState, key, isSstore, common) {
      if (common.isActivatedEIP(2929) === false)
          return BigInt(0);
      const eei = runState.eei;
      const address = runState.interpreter.getAddress().buf;
      const slotIsCold = !eei.isWarmedStorage(address, key);
      // Cold (SLOAD and SSTORE)
      if (slotIsCold) {
          eei.addWarmedStorage(address, key);
          return common.param('gasPrices', 'coldsload');
      }
      else if (!isSstore) {
          return common.param('gasPrices', 'warmstorageread');
      }
      return BigInt(0);
  }
  EIP2929.accessStorageEIP2929 = accessStorageEIP2929;
  /**
   * Adjusts cost of SSTORE_RESET_GAS or SLOAD (aka sstorenoop) (EIP-2200) downward when storage
   * location is already warm
   * @param  {RunState} runState
   * @param  {Buffer}   key          storage slot
   * @param  {BigInt}   defaultCost  SSTORE_RESET_GAS / SLOAD
   * @param  {string}   costName     parameter name ('noop')
   * @param  {Common}   common
   * @return {BigInt}                adjusted cost
   */
  function adjustSstoreGasEIP2929(runState, key, defaultCost, costName, common) {
      if (common.isActivatedEIP(2929) === false)
          return defaultCost;
      const eei = runState.eei;
      const address = runState.interpreter.getAddress().buf;
      const warmRead = common.param('gasPrices', 'warmstorageread');
      const coldSload = common.param('gasPrices', 'coldsload');
      if (eei.isWarmedStorage(address, key)) {
          switch (costName) {
              case 'noop':
                  return warmRead;
              case 'initRefund':
                  return common.param('gasPrices', 'sstoreInitGasEIP2200') - warmRead;
              case 'cleanRefund':
                  return common.param('gasPrices', 'sstoreReset') - coldSload - warmRead;
          }
      }
      return defaultCost;
  }
  EIP2929.adjustSstoreGasEIP2929 = adjustSstoreGasEIP2929;

  Object.defineProperty(EIP2200, "__esModule", { value: true });
  EIP2200.updateSstoreGasEIP2200 = void 0;
  const exceptions_1$e = exceptions;
  const EIP2929_1 = EIP2929;
  const util_1$Q = util$4;
  /**
   * Adjusts gas usage and refunds of SStore ops per EIP-2200 (Istanbul)
   *
   * @param {RunState} runState
   * @param {Buffer}   currentStorage
   * @param {Buffer}   originalStorage
   * @param {Buffer}   value
   * @param {Common}   common
   */
  function updateSstoreGasEIP2200(runState, currentStorage, originalStorage, value, key, common) {
      // Fail if not enough gas is left
      if (runState.interpreter.getGasLeft() <= common.param('gasPrices', 'sstoreSentryGasEIP2200')) {
          (0, util_1$Q.trap)(exceptions_1$e.ERROR.OUT_OF_GAS);
      }
      // Noop
      if (currentStorage.equals(value)) {
          const sstoreNoopCost = common.param('gasPrices', 'sstoreNoopGasEIP2200');
          return (0, EIP2929_1.adjustSstoreGasEIP2929)(runState, key, sstoreNoopCost, 'noop', common);
      }
      if (originalStorage.equals(currentStorage)) {
          // Create slot
          if (originalStorage.length === 0) {
              return common.param('gasPrices', 'sstoreInitGasEIP2200');
          }
          // Delete slot
          if (value.length === 0) {
              runState.interpreter.refundGas(common.param('gasPrices', 'sstoreClearRefundEIP2200'), 'EIP-2200 -> sstoreClearRefundEIP2200');
          }
          // Write existing slot
          return common.param('gasPrices', 'sstoreCleanGasEIP2200');
      }
      if (originalStorage.length > 0) {
          if (currentStorage.length === 0) {
              // Recreate slot
              runState.interpreter.subRefund(common.param('gasPrices', 'sstoreClearRefundEIP2200'), 'EIP-2200 -> sstoreClearRefundEIP2200');
          }
          else if (value.length === 0) {
              // Delete slot
              runState.interpreter.refundGas(common.param('gasPrices', 'sstoreClearRefundEIP2200'), 'EIP-2200 -> sstoreClearRefundEIP2200');
          }
      }
      if (originalStorage.equals(value)) {
          if (originalStorage.length === 0) {
              // Reset to original non-existent slot
              const sstoreInitRefund = common.param('gasPrices', 'sstoreInitRefundEIP2200');
              runState.interpreter.refundGas((0, EIP2929_1.adjustSstoreGasEIP2929)(runState, key, sstoreInitRefund, 'initRefund', common), 'EIP-2200 -> initRefund');
          }
          else {
              // Reset to original existing slot
              const sstoreCleanRefund = common.param('gasPrices', 'sstoreCleanRefundEIP2200');
              runState.interpreter.refundGas(BigInt((0, EIP2929_1.adjustSstoreGasEIP2929)(runState, key, sstoreCleanRefund, 'cleanRefund', common)), 'EIP-2200 -> cleanRefund');
          }
      }
      // Dirty update
      return common.param('gasPrices', 'sstoreDirtyGasEIP2200');
  }
  EIP2200.updateSstoreGasEIP2200 = updateSstoreGasEIP2200;

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dynamicGasHandlers = void 0;
  const common_1 = dist$8;
  const util_1 = dist$a;
  const exceptions_1 = exceptions;
  const EIP1283_1 = EIP1283;
  const EIP2200_1 = EIP2200;
  const EIP2929_1 = EIP2929;
  const util_2 = util$4;
  exports.dynamicGasHandlers = new Map([
      [
          /* EXP */
          0x0a,
          async function (runState, gas, common) {
              const [_base, exponent] = runState.stack.peek(2);
              if (exponent === BigInt(0)) {
                  return gas;
              }
              let byteLength = exponent.toString(2).length / 8;
              if (byteLength > Math.trunc(byteLength)) {
                  byteLength = Math.trunc(byteLength) + 1;
              }
              if (byteLength < 1 || byteLength > 32) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_RANGE);
              }
              const expPricePerByte = common.param('gasPrices', 'expByte');
              gas += BigInt(byteLength) * expPricePerByte;
              return gas;
          },
      ],
      [
          /* SHA3 */
          0x20,
          async function (runState, gas, common) {
              const [offset, length] = runState.stack.peek(2);
              gas += (0, util_2.subMemUsage)(runState, offset, length, common);
              gas += common.param('gasPrices', 'sha3Word') * (0, util_2.divCeil)(length, BigInt(32));
              return gas;
          },
      ],
      [
          /* BALANCE */
          0x31,
          async function (runState, gas, common) {
              if (common.isActivatedEIP(2929) === true) {
                  const addressBigInt = runState.stack.peek()[0];
                  const address = new util_1.Address((0, util_2.addressToBuffer)(addressBigInt));
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, address, common);
              }
              return gas;
          },
      ],
      [
          /* CALLDATACOPY */
          0x37,
          async function (runState, gas, common) {
              const [memOffset, _dataOffset, dataLength] = runState.stack.peek(3);
              gas += (0, util_2.subMemUsage)(runState, memOffset, dataLength, common);
              if (dataLength !== BigInt(0)) {
                  gas += common.param('gasPrices', 'copy') * (0, util_2.divCeil)(dataLength, BigInt(32));
              }
              return gas;
          },
      ],
      [
          /* CODECOPY */
          0x39,
          async function (runState, gas, common) {
              const [memOffset, _codeOffset, dataLength] = runState.stack.peek(3);
              gas += (0, util_2.subMemUsage)(runState, memOffset, dataLength, common);
              if (dataLength !== BigInt(0)) {
                  gas += common.param('gasPrices', 'copy') * (0, util_2.divCeil)(dataLength, BigInt(32));
              }
              return gas;
          },
      ],
      [
          /* EXTCODESIZE */
          0x3b,
          async function (runState, gas, common) {
              if (common.isActivatedEIP(2929) === true) {
                  const addressBigInt = runState.stack.peek()[0];
                  const address = new util_1.Address((0, util_2.addressToBuffer)(addressBigInt));
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, address, common);
              }
              return gas;
          },
      ],
      [
          /* EXTCODECOPY */
          0x3c,
          async function (runState, gas, common) {
              const [addressBigInt, memOffset, _codeOffset, dataLength] = runState.stack.peek(4);
              gas += (0, util_2.subMemUsage)(runState, memOffset, dataLength, common);
              if (common.isActivatedEIP(2929) === true) {
                  const address = new util_1.Address((0, util_2.addressToBuffer)(addressBigInt));
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, address, common);
              }
              if (dataLength !== BigInt(0)) {
                  gas += common.param('gasPrices', 'copy') * (0, util_2.divCeil)(dataLength, BigInt(32));
              }
              return gas;
          },
      ],
      [
          /* RETURNDATACOPY */
          0x3e,
          async function (runState, gas, common) {
              const [memOffset, returnDataOffset, dataLength] = runState.stack.peek(3);
              if (returnDataOffset + dataLength > runState.interpreter.getReturnDataSize()) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_GAS);
              }
              gas += (0, util_2.subMemUsage)(runState, memOffset, dataLength, common);
              if (dataLength !== BigInt(0)) {
                  gas += common.param('gasPrices', 'copy') * (0, util_2.divCeil)(dataLength, BigInt(32));
              }
              return gas;
          },
      ],
      [
          /* EXTCODEHASH */
          0x3f,
          async function (runState, gas, common) {
              if (common.isActivatedEIP(2929) === true) {
                  const addressBigInt = runState.stack.peek()[0];
                  const address = new util_1.Address((0, util_2.addressToBuffer)(addressBigInt));
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, address, common);
              }
              return gas;
          },
      ],
      [
          /* MLOAD */
          0x51,
          async function (runState, gas, common) {
              const pos = runState.stack.peek()[0];
              gas += (0, util_2.subMemUsage)(runState, pos, BigInt(32), common);
              return gas;
          },
      ],
      [
          /* MSTORE */
          0x52,
          async function (runState, gas, common) {
              const offset = runState.stack.peek()[0];
              gas += (0, util_2.subMemUsage)(runState, offset, BigInt(32), common);
              return gas;
          },
      ],
      [
          /* MSTORE8 */
          0x53,
          async function (runState, gas, common) {
              const offset = runState.stack.peek()[0];
              gas += (0, util_2.subMemUsage)(runState, offset, BigInt(1), common);
              return gas;
          },
      ],
      [
          /* SLOAD */
          0x54,
          async function (runState, gas, common) {
              const key = runState.stack.peek()[0];
              const keyBuf = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(key), 32);
              if (common.isActivatedEIP(2929) === true) {
                  gas += (0, EIP2929_1.accessStorageEIP2929)(runState, keyBuf, false, common);
              }
              return gas;
          },
      ],
      [
          /* SSTORE */
          0x55,
          async function (runState, gas, common) {
              if (runState.interpreter.isStatic()) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              const [key, val] = runState.stack.peek(2);
              const keyBuf = (0, util_1.setLengthLeft)((0, util_1.bigIntToBuffer)(key), 32);
              // NOTE: this should be the shortest representation
              let value;
              if (val === BigInt(0)) {
                  value = Buffer$8.from([]);
              }
              else {
                  value = (0, util_1.bigIntToBuffer)(val);
              }
              const currentStorage = (0, util_2.setLengthLeftStorage)(await runState.interpreter.storageLoad(keyBuf));
              const originalStorage = (0, util_2.setLengthLeftStorage)(await runState.interpreter.storageLoad(keyBuf, true));
              if (common.hardfork() === common_1.Hardfork.Constantinople) {
                  gas += (0, EIP1283_1.updateSstoreGasEIP1283)(runState, currentStorage, originalStorage, (0, util_2.setLengthLeftStorage)(value), common);
              }
              else if (common.gteHardfork(common_1.Hardfork.Istanbul)) {
                  gas += (0, EIP2200_1.updateSstoreGasEIP2200)(runState, currentStorage, originalStorage, (0, util_2.setLengthLeftStorage)(value), keyBuf, common);
              }
              else {
                  gas += (0, util_2.updateSstoreGas)(runState, currentStorage, (0, util_2.setLengthLeftStorage)(value), common);
              }
              if (common.isActivatedEIP(2929) === true) {
                  // We have to do this after the Istanbul (EIP2200) checks.
                  // Otherwise, we might run out of gas, due to "sentry check" of 2300 gas,
                  // if we deduct extra gas first.
                  gas += (0, EIP2929_1.accessStorageEIP2929)(runState, keyBuf, true, common);
              }
              return gas;
          },
      ],
      [
          /* LOG */
          0xa0,
          async function (runState, gas, common) {
              if (runState.interpreter.isStatic()) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              const [memOffset, memLength] = runState.stack.peek(2);
              const topicsCount = runState.opCode - 0xa0;
              if (topicsCount < 0 || topicsCount > 4) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_RANGE);
              }
              gas += (0, util_2.subMemUsage)(runState, memOffset, memLength, common);
              gas +=
                  common.param('gasPrices', 'logTopic') * BigInt(topicsCount) +
                      memLength * common.param('gasPrices', 'logData');
              return gas;
          },
      ],
      [
          /* CREATE */
          0xf0,
          async function (runState, gas, common) {
              if (runState.interpreter.isStatic()) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              const [_value, offset, length] = runState.stack.peek(3);
              if (common.isActivatedEIP(2929) === true) {
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, runState.interpreter.getAddress(), common, false);
              }
              gas += (0, util_2.subMemUsage)(runState, offset, length, common);
              let gasLimit = BigInt(runState.interpreter.getGasLeft()) - gas;
              gasLimit = (0, util_2.maxCallGas)(gasLimit, gasLimit, runState, common);
              runState.messageGasLimit = gasLimit;
              return gas;
          },
      ],
      [
          /* CALL */
          0xf1,
          async function (runState, gas, common) {
              const [currentGasLimit, toAddr, value, inOffset, inLength, outOffset, outLength] = runState.stack.peek(7);
              const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
              if (runState.interpreter.isStatic() && value !== BigInt(0)) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              gas += (0, util_2.subMemUsage)(runState, inOffset, inLength, common);
              gas += (0, util_2.subMemUsage)(runState, outOffset, outLength, common);
              if (common.isActivatedEIP(2929) === true) {
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, toAddress, common);
              }
              if (value !== BigInt(0)) {
                  gas += common.param('gasPrices', 'callValueTransfer');
              }
              if (common.gteHardfork(common_1.Hardfork.SpuriousDragon)) {
                  // We are at or after Spurious Dragon
                  // Call new account gas: account is DEAD and we transfer nonzero value
                  if ((await runState.eei.getAccount(toAddress)).isEmpty() && !(value === BigInt(0))) {
                      gas += common.param('gasPrices', 'callNewAccount');
                  }
              }
              else if (!(await runState.eei.accountExists(toAddress))) {
                  // We are before Spurious Dragon and the account does not exist.
                  // Call new account gas: account does not exist (it is not in the state trie, not even as an "empty" account)
                  gas += common.param('gasPrices', 'callNewAccount');
              }
              let gasLimit = (0, util_2.maxCallGas)(currentGasLimit, runState.interpreter.getGasLeft() - gas, runState, common);
              // note that TangerineWhistle or later this cannot happen
              // (it could have ran out of gas prior to getting here though)
              if (gasLimit > runState.interpreter.getGasLeft() - gas) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_GAS);
              }
              if (gas > runState.interpreter.getGasLeft()) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_GAS);
              }
              if (value !== BigInt(0)) {
                  const callStipend = common.param('gasPrices', 'callStipend');
                  runState.interpreter.addStipend(callStipend);
                  gasLimit += callStipend;
              }
              runState.messageGasLimit = gasLimit;
              return gas;
          },
      ],
      [
          /* CALLCODE */
          0xf2,
          async function (runState, gas, common) {
              const [currentGasLimit, toAddr, value, inOffset, inLength, outOffset, outLength] = runState.stack.peek(7);
              gas += (0, util_2.subMemUsage)(runState, inOffset, inLength, common);
              gas += (0, util_2.subMemUsage)(runState, outOffset, outLength, common);
              if (common.isActivatedEIP(2929) === true) {
                  const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, toAddress, common);
              }
              if (value !== BigInt(0)) {
                  gas += common.param('gasPrices', 'callValueTransfer');
              }
              let gasLimit = (0, util_2.maxCallGas)(currentGasLimit, runState.interpreter.getGasLeft() - gas, runState, common);
              // note that TangerineWhistle or later this cannot happen
              // (it could have ran out of gas prior to getting here though)
              if (gasLimit > runState.interpreter.getGasLeft() - gas) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_GAS);
              }
              if (value !== BigInt(0)) {
                  const callStipend = common.param('gasPrices', 'callStipend');
                  runState.interpreter.addStipend(callStipend);
                  gasLimit += callStipend;
              }
              runState.messageGasLimit = gasLimit;
              return gas;
          },
      ],
      [
          /* RETURN */
          0xf3,
          async function (runState, gas, common) {
              const [offset, length] = runState.stack.peek(2);
              gas += (0, util_2.subMemUsage)(runState, offset, length, common);
              return gas;
          },
      ],
      [
          /* DELEGATECALL */
          0xf4,
          async function (runState, gas, common) {
              const [currentGasLimit, toAddr, inOffset, inLength, outOffset, outLength] = runState.stack.peek(6);
              gas += (0, util_2.subMemUsage)(runState, inOffset, inLength, common);
              gas += (0, util_2.subMemUsage)(runState, outOffset, outLength, common);
              if (common.isActivatedEIP(2929) === true) {
                  const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, toAddress, common);
              }
              const gasLimit = (0, util_2.maxCallGas)(currentGasLimit, runState.interpreter.getGasLeft() - gas, runState, common);
              // note that TangerineWhistle or later this cannot happen
              // (it could have ran out of gas prior to getting here though)
              if (gasLimit > runState.interpreter.getGasLeft() - gas) {
                  (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_GAS);
              }
              runState.messageGasLimit = gasLimit;
              return gas;
          },
      ],
      [
          /* CREATE2 */
          0xf5,
          async function (runState, gas, common) {
              if (runState.interpreter.isStatic()) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              const [_value, offset, length, _salt] = runState.stack.peek(4);
              gas += (0, util_2.subMemUsage)(runState, offset, length, common);
              if (common.isActivatedEIP(2929) === true) {
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, runState.interpreter.getAddress(), common, false);
              }
              gas += common.param('gasPrices', 'sha3Word') * (0, util_2.divCeil)(length, BigInt(32));
              let gasLimit = runState.interpreter.getGasLeft() - gas;
              gasLimit = (0, util_2.maxCallGas)(gasLimit, gasLimit, runState, common); // CREATE2 is only available after TangerineWhistle (Constantinople introduced this opcode)
              runState.messageGasLimit = gasLimit;
              return gas;
          },
      ],
      [
          /* AUTH */
          0xf6,
          async function (runState, gas, common) {
              const [_address, memOffset, memLength] = runState.stack.peek(3);
              gas += (0, util_2.subMemUsage)(runState, memOffset, memLength, common);
              return gas;
          },
      ],
      [
          /* AUTHCALL */
          0xf7,
          async function (runState, gas, common) {
              if (runState.auth === undefined) {
                  (0, util_2.trap)(exceptions_1.ERROR.AUTHCALL_UNSET);
              }
              const [currentGasLimit, addr, value, valueExt, argsOffset, argsLength, retOffset, retLength,] = runState.stack.peek(8);
              if (valueExt !== 0n) {
                  (0, util_2.trap)(exceptions_1.ERROR.AUTHCALL_NONZERO_VALUEEXT);
              }
              const toAddress = new util_1.Address((0, util_2.addressToBuffer)(addr));
              gas += common.param('gasPrices', 'warmstorageread');
              gas += (0, EIP2929_1.accessAddressEIP2929)(runState, toAddress, common, true, true);
              gas += (0, util_2.subMemUsage)(runState, argsOffset, argsLength, common);
              gas += (0, util_2.subMemUsage)(runState, retOffset, retLength, common);
              if (value > BigInt(0)) {
                  gas += common.param('gasPrices', 'authcallValueTransfer');
                  const account = await runState.eei.getAccount(toAddress);
                  if (account.isEmpty()) {
                      gas += common.param('gasPrices', 'callNewAccount');
                  }
              }
              let gasLimit = (0, util_2.maxCallGas)(runState.interpreter.getGasLeft() - gas, runState.interpreter.getGasLeft() - gas, runState, common);
              if (currentGasLimit !== BigInt(0)) {
                  if (currentGasLimit > gasLimit) {
                      (0, util_2.trap)(exceptions_1.ERROR.OUT_OF_GAS);
                  }
                  gasLimit = currentGasLimit;
              }
              runState.messageGasLimit = gasLimit;
              return gas;
          },
      ],
      [
          /* STATICCALL */
          0xfa,
          async function (runState, gas, common) {
              const [currentGasLimit, toAddr, inOffset, inLength, outOffset, outLength] = runState.stack.peek(6);
              gas += (0, util_2.subMemUsage)(runState, inOffset, inLength, common);
              gas += (0, util_2.subMemUsage)(runState, outOffset, outLength, common);
              if (common.isActivatedEIP(2929) === true) {
                  const toAddress = new util_1.Address((0, util_2.addressToBuffer)(toAddr));
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, toAddress, common);
              }
              const gasLimit = (0, util_2.maxCallGas)(currentGasLimit, runState.interpreter.getGasLeft() - gas, runState, common); // we set TangerineWhistle or later to true here, as STATICCALL was available from Byzantium (which is after TangerineWhistle)
              runState.messageGasLimit = gasLimit;
              return gas;
          },
      ],
      [
          /* REVERT */
          0xfd,
          async function (runState, gas, common) {
              const [offset, length] = runState.stack.peek(2);
              gas += (0, util_2.subMemUsage)(runState, offset, length, common);
              return gas;
          },
      ],
      [
          /* SELFDESTRUCT */
          0xff,
          async function (runState, gas, common) {
              if (runState.interpreter.isStatic()) {
                  (0, util_2.trap)(exceptions_1.ERROR.STATIC_STATE_CHANGE);
              }
              const selfdestructToaddressBigInt = runState.stack.peek()[0];
              const selfdestructToAddress = new util_1.Address((0, util_2.addressToBuffer)(selfdestructToaddressBigInt));
              let deductGas = false;
              if (common.gteHardfork(common_1.Hardfork.SpuriousDragon)) {
                  // EIP-161: State Trie Clearing
                  const balance = await runState.interpreter.getExternalBalance(runState.interpreter.getAddress());
                  if (balance > BigInt(0)) {
                      // This technically checks if account is empty or non-existent
                      const empty = (await runState.eei.getAccount(selfdestructToAddress)).isEmpty();
                      if (empty) {
                          deductGas = true;
                      }
                  }
              }
              else if (common.gteHardfork(common_1.Hardfork.TangerineWhistle)) {
                  // EIP-150 (Tangerine Whistle) gas semantics
                  const exists = await runState.eei.accountExists(selfdestructToAddress);
                  if (!exists) {
                      deductGas = true;
                  }
              }
              if (deductGas) {
                  gas += common.param('gasPrices', 'callNewAccount');
              }
              if (common.isActivatedEIP(2929) === true) {
                  gas += (0, EIP2929_1.accessAddressEIP2929)(runState, selfdestructToAddress, common, true, true);
              }
              return gas;
          },
      ],
  ]);
  // Set the range [0xa0, 0xa4] to the LOG handler
  const logDynamicFunc = exports.dynamicGasHandlers.get(0xa0);
  for (let i = 0xa1; i <= 0xa4; i++) {
      exports.dynamicGasHandlers.set(i, logDynamicFunc);
  }

  }(gas));

  Object.defineProperty(codes$1, "__esModule", { value: true });
  codes$1.getOpcodesForHF = codes$1.Opcode = void 0;
  const common_1$f = dist$8;
  const util_1$P = dist$a;
  const functions_1 = functions;
  const gas_1 = gas;
  const util_2$6 = util$4;
  class Opcode {
      constructor({ code, name, fullName, fee, isAsync, dynamicGas, }) {
          this.code = code;
          this.name = name;
          this.fullName = fullName;
          this.fee = fee;
          this.isAsync = isAsync;
          this.dynamicGas = dynamicGas;
          // Opcode isn't subject to change, thus all futher modifications are prevented.
          Object.freeze(this);
      }
  }
  codes$1.Opcode = Opcode;
  // Base opcode list. The opcode list is extended in future hardforks
  const opcodes = {
      // 0x0 range - arithmetic ops
      // name, async
      0x00: { name: 'STOP', isAsync: false, dynamicGas: false },
      0x01: { name: 'ADD', isAsync: false, dynamicGas: false },
      0x02: { name: 'MUL', isAsync: false, dynamicGas: false },
      0x03: { name: 'SUB', isAsync: false, dynamicGas: false },
      0x04: { name: 'DIV', isAsync: false, dynamicGas: false },
      0x05: { name: 'SDIV', isAsync: false, dynamicGas: false },
      0x06: { name: 'MOD', isAsync: false, dynamicGas: false },
      0x07: { name: 'SMOD', isAsync: false, dynamicGas: false },
      0x08: { name: 'ADDMOD', isAsync: false, dynamicGas: false },
      0x09: { name: 'MULMOD', isAsync: false, dynamicGas: false },
      0x0a: { name: 'EXP', isAsync: false, dynamicGas: true },
      0x0b: { name: 'SIGNEXTEND', isAsync: false, dynamicGas: false },
      // 0x10 range - bit ops
      0x10: { name: 'LT', isAsync: false, dynamicGas: false },
      0x11: { name: 'GT', isAsync: false, dynamicGas: false },
      0x12: { name: 'SLT', isAsync: false, dynamicGas: false },
      0x13: { name: 'SGT', isAsync: false, dynamicGas: false },
      0x14: { name: 'EQ', isAsync: false, dynamicGas: false },
      0x15: { name: 'ISZERO', isAsync: false, dynamicGas: false },
      0x16: { name: 'AND', isAsync: false, dynamicGas: false },
      0x17: { name: 'OR', isAsync: false, dynamicGas: false },
      0x18: { name: 'XOR', isAsync: false, dynamicGas: false },
      0x19: { name: 'NOT', isAsync: false, dynamicGas: false },
      0x1a: { name: 'BYTE', isAsync: false, dynamicGas: false },
      // 0x20 range - crypto
      0x20: { name: 'SHA3', isAsync: false, dynamicGas: true },
      // 0x30 range - closure state
      0x30: { name: 'ADDRESS', isAsync: true, dynamicGas: false },
      0x31: { name: 'BALANCE', isAsync: true, dynamicGas: true },
      0x32: { name: 'ORIGIN', isAsync: true, dynamicGas: false },
      0x33: { name: 'CALLER', isAsync: true, dynamicGas: false },
      0x34: { name: 'CALLVALUE', isAsync: true, dynamicGas: false },
      0x35: { name: 'CALLDATALOAD', isAsync: true, dynamicGas: false },
      0x36: { name: 'CALLDATASIZE', isAsync: true, dynamicGas: false },
      0x37: { name: 'CALLDATACOPY', isAsync: true, dynamicGas: true },
      0x38: { name: 'CODESIZE', isAsync: false, dynamicGas: false },
      0x39: { name: 'CODECOPY', isAsync: false, dynamicGas: true },
      0x3a: { name: 'GASPRICE', isAsync: false, dynamicGas: false },
      0x3b: { name: 'EXTCODESIZE', isAsync: true, dynamicGas: true },
      0x3c: { name: 'EXTCODECOPY', isAsync: true, dynamicGas: true },
      // '0x40' range - block operations
      0x40: { name: 'BLOCKHASH', isAsync: true, dynamicGas: false },
      0x41: { name: 'COINBASE', isAsync: true, dynamicGas: false },
      0x42: { name: 'TIMESTAMP', isAsync: true, dynamicGas: false },
      0x43: { name: 'NUMBER', isAsync: true, dynamicGas: false },
      0x44: { name: 'DIFFICULTY', isAsync: true, dynamicGas: false },
      0x45: { name: 'GASLIMIT', isAsync: true, dynamicGas: false },
      // 0x50 range - 'storage' and execution
      0x50: { name: 'POP', isAsync: false, dynamicGas: false },
      0x51: { name: 'MLOAD', isAsync: false, dynamicGas: true },
      0x52: { name: 'MSTORE', isAsync: false, dynamicGas: true },
      0x53: { name: 'MSTORE8', isAsync: false, dynamicGas: true },
      0x54: { name: 'SLOAD', isAsync: true, dynamicGas: true },
      0x55: { name: 'SSTORE', isAsync: true, dynamicGas: true },
      0x56: { name: 'JUMP', isAsync: false, dynamicGas: false },
      0x57: { name: 'JUMPI', isAsync: false, dynamicGas: false },
      0x58: { name: 'PC', isAsync: false, dynamicGas: false },
      0x59: { name: 'MSIZE', isAsync: false, dynamicGas: false },
      0x5a: { name: 'GAS', isAsync: false, dynamicGas: false },
      0x5b: { name: 'JUMPDEST', isAsync: false, dynamicGas: false },
      // 0x60, range
      0x60: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x61: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x62: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x63: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x64: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x65: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x66: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x67: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x68: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x69: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x6a: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x6b: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x6c: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x6d: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x6e: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x6f: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x70: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x71: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x72: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x73: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x74: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x75: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x76: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x77: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x78: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x79: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x7a: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x7b: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x7c: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x7d: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x7e: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x7f: { name: 'PUSH', isAsync: false, dynamicGas: false },
      0x80: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x81: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x82: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x83: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x84: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x85: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x86: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x87: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x88: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x89: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x8a: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x8b: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x8c: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x8d: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x8e: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x8f: { name: 'DUP', isAsync: false, dynamicGas: false },
      0x90: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x91: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x92: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x93: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x94: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x95: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x96: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x97: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x98: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x99: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x9a: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x9b: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x9c: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x9d: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x9e: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0x9f: { name: 'SWAP', isAsync: false, dynamicGas: false },
      0xa0: { name: 'LOG', isAsync: false, dynamicGas: true },
      0xa1: { name: 'LOG', isAsync: false, dynamicGas: true },
      0xa2: { name: 'LOG', isAsync: false, dynamicGas: true },
      0xa3: { name: 'LOG', isAsync: false, dynamicGas: true },
      0xa4: { name: 'LOG', isAsync: false, dynamicGas: true },
      // '0xf0' range - closures
      0xf0: { name: 'CREATE', isAsync: true, dynamicGas: true },
      0xf1: { name: 'CALL', isAsync: true, dynamicGas: true },
      0xf2: { name: 'CALLCODE', isAsync: true, dynamicGas: true },
      0xf3: { name: 'RETURN', isAsync: false, dynamicGas: true },
      // '0x70', range - other
      0xfe: { name: 'INVALID', isAsync: false, dynamicGas: false },
      0xff: { name: 'SELFDESTRUCT', isAsync: true, dynamicGas: true },
  };
  // Array of hard forks in order. These changes are repeatedly applied to `opcodes` until the hard fork is in the future based upon the common
  // TODO: All gas price changes should be moved to common
  // If the base gas cost of any of the operations change, then these should also be added to this list.
  // If there are context variables changed (such as "warm slot reads") which are not the base gas fees,
  // Then this does not have to be added.
  const hardforkOpcodes = [
      {
          hardfork: common_1$f.Hardfork.Homestead,
          opcodes: {
              0xf4: { name: 'DELEGATECALL', isAsync: true, dynamicGas: true }, // EIP 7
          },
      },
      {
          hardfork: common_1$f.Hardfork.TangerineWhistle,
          opcodes: {
              0x54: { name: 'SLOAD', isAsync: true, dynamicGas: true },
              0xf1: { name: 'CALL', isAsync: true, dynamicGas: true },
              0xf2: { name: 'CALLCODE', isAsync: true, dynamicGas: true },
              0x3b: { name: 'EXTCODESIZE', isAsync: true, dynamicGas: true },
              0x3c: { name: 'EXTCODECOPY', isAsync: true, dynamicGas: true },
              0xf4: { name: 'DELEGATECALL', isAsync: true, dynamicGas: true },
              0xff: { name: 'SELFDESTRUCT', isAsync: true, dynamicGas: true },
              0x31: { name: 'BALANCE', isAsync: true, dynamicGas: true },
          },
      },
      {
          hardfork: common_1$f.Hardfork.Byzantium,
          opcodes: {
              0xfd: { name: 'REVERT', isAsync: false, dynamicGas: true },
              0xfa: { name: 'STATICCALL', isAsync: true, dynamicGas: true },
              0x3d: { name: 'RETURNDATASIZE', isAsync: true, dynamicGas: false },
              0x3e: { name: 'RETURNDATACOPY', isAsync: true, dynamicGas: true }, // EIP 211
          },
      },
      {
          hardfork: common_1$f.Hardfork.Constantinople,
          opcodes: {
              0x1b: { name: 'SHL', isAsync: false, dynamicGas: false },
              0x1c: { name: 'SHR', isAsync: false, dynamicGas: false },
              0x1d: { name: 'SAR', isAsync: false, dynamicGas: false },
              0x3f: { name: 'EXTCODEHASH', isAsync: true, dynamicGas: true },
              0xf5: { name: 'CREATE2', isAsync: true, dynamicGas: true }, // EIP 1014
          },
      },
      {
          hardfork: common_1$f.Hardfork.Istanbul,
          opcodes: {
              0x46: { name: 'CHAINID', isAsync: false, dynamicGas: false },
              0x47: { name: 'SELFBALANCE', isAsync: false, dynamicGas: false }, // EIP 1884
          },
      },
  ];
  const eipOpcodes = [
      {
          eip: 1153,
          opcodes: {
              0xb3: { name: 'TLOAD', isAsync: false, dynamicGas: false },
              0xb4: { name: 'TSTORE', isAsync: false, dynamicGas: false },
          },
      },
      {
          eip: 2315,
          opcodes: {
              0x5c: { name: 'BEGINSUB', isAsync: false, dynamicGas: false },
              0x5d: { name: 'RETURNSUB', isAsync: false, dynamicGas: false },
              0x5e: { name: 'JUMPSUB', isAsync: false, dynamicGas: false },
          },
      },
      {
          eip: 3198,
          opcodes: {
              0x48: { name: 'BASEFEE', isAsync: false, dynamicGas: false },
          },
      },
      {
          eip: 3855,
          opcodes: {
              0x5f: { name: 'PUSH0', isAsync: false, dynamicGas: false },
          },
      },
      {
          eip: 3074,
          opcodes: {
              0xf6: { name: 'AUTH', isAsync: true, dynamicGas: true },
              0xf7: { name: 'AUTHCALL', isAsync: true, dynamicGas: true },
          },
      },
  ];
  /**
   * Convert basic opcode info dictonary into complete OpcodeList instance.
   *
   * @param opcodes {Object} Receive basic opcodes info dictionary.
   * @returns {OpcodeList} Complete Opcode list
   */
  function createOpcodes(opcodes) {
      const result = new Map();
      for (const [key, value] of Object.entries(opcodes)) {
          const code = parseInt(key, 10);
          if (isNaN(value.fee))
              value.fee = 0;
          result.set(code, new Opcode({
              code,
              fullName: (0, util_2$6.getFullname)(code, value.name),
              ...value,
          }));
      }
      return result;
  }
  /**
   * Get suitable opcodes for the required hardfork.
   *
   * @param common {Common} Ethereumjs Common metadata object.
   * @param customOpcodes List with custom opcodes (see EVM `customOpcodes` option description).
   * @returns {OpcodeList} Opcodes dictionary object.
   */
  function getOpcodesForHF(common, customOpcodes) {
      let opcodeBuilder = { ...opcodes };
      const handlersCopy = new Map(functions_1.handlers);
      const dynamicGasHandlersCopy = new Map(gas_1.dynamicGasHandlers);
      for (let fork = 0; fork < hardforkOpcodes.length; fork++) {
          if (common.gteHardfork(hardforkOpcodes[fork].hardfork)) {
              opcodeBuilder = { ...opcodeBuilder, ...hardforkOpcodes[fork].opcodes };
          }
      }
      for (const eipOps of eipOpcodes) {
          if (common.isActivatedEIP(eipOps.eip)) {
              opcodeBuilder = { ...opcodeBuilder, ...eipOps.opcodes };
          }
      }
      for (const key in opcodeBuilder) {
          const baseFee = Number(common.param('gasPrices', opcodeBuilder[key].name.toLowerCase()));
          // explicitly verify that we have defined a base fee
          if (baseFee === undefined) {
              throw new Error(`base fee not defined for: ${opcodeBuilder[key].name}`);
          }
          opcodeBuilder[key].fee = baseFee;
      }
      if (customOpcodes) {
          for (const _code of customOpcodes) {
              const code = _code;
              if (code.logicFunction === undefined) {
                  delete opcodeBuilder[code.opcode];
                  continue;
              }
              // Sanity checks
              if (code.opcodeName === undefined || code.baseFee === undefined) {
                  throw new Error(`Custom opcode ${code.opcode} does not have the required values: opcodeName and baseFee are required`);
              }
              const entry = {
                  [code.opcode]: {
                      name: code.opcodeName,
                      isAsync: true,
                      dynamicGas: code.gasFunction !== undefined,
                      fee: code.baseFee,
                  },
              };
              opcodeBuilder = { ...opcodeBuilder, ...entry };
              if ((0, util_1$P.isTruthy)(code.gasFunction)) {
                  dynamicGasHandlersCopy.set(code.opcode, code.gasFunction);
              }
              // logicFunction is never undefined
              handlersCopy.set(code.opcode, code.logicFunction);
          }
      }
      return {
          dynamicGasHandlers: dynamicGasHandlersCopy,
          handlers: handlersCopy,
          opcodes: createOpcodes(opcodeBuilder),
      };
  }
  codes$1.getOpcodesForHF = getOpcodesForHF;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(codes$1, exports);
  __exportStar(functions, exports);
  __exportStar(util$4, exports);

  }(opcodes$1));

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EOF = exports.validOpcodes = exports.codeAnalysis = exports.VERSION = exports.MAGIC = exports.FORMAT = void 0;
  const opcodes_1 = opcodes$1;
  exports.FORMAT = 0xef;
  exports.MAGIC = 0x00;
  exports.VERSION = 0x01;
  /**
   *
   * @param container A `Buffer` containing bytecode to be checked for EOF1 compliance
   * @returns an object containing the size of the code section and data sections for a valid
   * EOF1 container or else undefined if `container` is not valid EOF1 bytecode
   *
   * Note: See https://eips.ethereum.org/EIPS/eip-3540 for further details
   */
  const codeAnalysis = (container) => {
      const secCode = 0x01;
      const secData = 0x02;
      const secTerminator = 0x00;
      let computedContainerSize = 0;
      const sectionSizes = {
          code: 0,
          data: 0,
      };
      if (container[1] !== exports.MAGIC || container[2] !== exports.VERSION)
          // Bytecode does not contain EOF1 "magic" or version number in expected positions
          return;
      if (
      // EOF1 bytecode must be more than 7 bytes long for EOF1 header plus code section (but no data section)
      container.length > 7 &&
          // EOF1 code section indicator
          container[3] === secCode &&
          // EOF1 header terminator
          container[6] === secTerminator) {
          sectionSizes.code = (container[4] << 8) | container[5];
          // Calculate expected length of EOF1 container based on code section
          computedContainerSize = 7 + sectionSizes.code;
          // EOF1 code section must be at least 1 byte long
          if (sectionSizes.code < 1)
              return;
      }
      else if (
      // EOF1 container must be more than 10 bytes long if data section is included
      container.length > 10 &&
          // EOF1 code section indicator
          container[3] === secCode &&
          // EOF1 data section indicator
          container[6] === secData &&
          // EOF1 header terminator
          container[9] === secTerminator) {
          sectionSizes.code = (container[4] << 8) | container[5];
          sectionSizes.data = (container[7] << 8) | container[8];
          // Calculate expected length of EOF1 container based on code and data sections
          computedContainerSize = 10 + sectionSizes.code + sectionSizes.data;
          // Code & Data sizes cannot be 0
          if (sectionSizes.code < 1 || sectionSizes.data < 1)
              return;
      }
      if (container.length !== computedContainerSize) {
          // Computed container length based on section details does not match length of actual bytecode
          return;
      }
      return sectionSizes;
  };
  exports.codeAnalysis = codeAnalysis;
  const validOpcodes = (code) => {
      // EIP-3670 - validate all opcodes
      const opcodes = new Set(opcodes_1.handlers.keys());
      opcodes.add(0xfe); // Add INVALID opcode to set
      let x = 0;
      while (x < code.length) {
          const opcode = code[x];
          x++;
          if (!opcodes.has(opcode)) {
              // No invalid/undefined opcodes
              return false;
          }
          if (opcode >= 0x60 && opcode <= 0x7f) {
              // Skip data block following push
              x += opcode - 0x5f;
              if (x > code.length - 1) {
                  // Push blocks must not exceed end of code section
                  return false;
              }
          }
      }
      const terminatingOpcodes = new Set([0x00, 0xf3, 0xfd, 0xfe, 0xff]);
      // Per EIP-3670, the final opcode of a code section must be STOP, RETURN, REVERT, INVALID, or SELFDESTRUCT
      if (!terminatingOpcodes.has(code[code.length - 1])) {
          return false;
      }
      return true;
  };
  exports.validOpcodes = validOpcodes;
  exports.EOF = { FORMAT: exports.FORMAT, MAGIC: exports.MAGIC, VERSION: exports.VERSION, codeAnalysis: exports.codeAnalysis, validOpcodes: exports.validOpcodes };

  }(eof));

  var interpreter = {};

  var memory = {};

  Object.defineProperty(memory, "__esModule", { value: true });
  memory.Memory = void 0;
  const ceil$1 = (value, ceiling) => {
      const r = value % ceiling;
      if (r === 0) {
          return value;
      }
      else {
          return value + ceiling - r;
      }
  };
  /**
   * Memory implements a simple memory model
   * for the ethereum virtual machine.
   */
  class Memory {
      constructor() {
          this._store = Buffer$8.alloc(0);
      }
      /**
       * Extends the memory given an offset and size. Rounds extended
       * memory to word-size.
       */
      extend(offset, size) {
          if (size === 0) {
              return;
          }
          const newSize = ceil$1(offset + size, 32);
          const sizeDiff = newSize - this._store.length;
          if (sizeDiff > 0) {
              this._store = Buffer$8.concat([this._store, Buffer$8.alloc(sizeDiff)]);
          }
      }
      /**
       * Writes a byte array with length `size` to memory, starting from `offset`.
       * @param offset - Starting position
       * @param size - How many bytes to write
       * @param value - Value
       */
      write(offset, size, value) {
          if (size === 0) {
              return;
          }
          this.extend(offset, size);
          if (value.length !== size)
              throw new Error('Invalid value size');
          if (offset + size > this._store.length)
              throw new Error('Value exceeds memory capacity');
          for (let i = 0; i < size; i++) {
              this._store[offset + i] = value[i];
          }
      }
      /**
       * Reads a slice of memory from `offset` till `offset + size` as a `Buffer`.
       * It fills up the difference between memory's length and `offset + size` with zeros.
       * @param offset - Starting position
       * @param size - How many bytes to read
       */
      read(offset, size) {
          this.extend(offset, size);
          const returnBuffer = Buffer$8.allocUnsafe(size);
          // Copy the stored "buffer" from memory into the return Buffer
          const loaded = Buffer$8.from(this._store.slice(offset, offset + size));
          returnBuffer.fill(loaded, 0, loaded.length);
          if (loaded.length < size) {
              // fill the remaining part of the Buffer with zeros
              returnBuffer.fill(0, loaded.length, size);
          }
          return returnBuffer;
      }
  }
  memory.Memory = Memory;

  var message = {};

  Object.defineProperty(message, "__esModule", { value: true });
  message.Message = void 0;
  const util_1$O = dist$a;
  const defaults$1 = {
      value: BigInt(0),
      caller: util_1$O.Address.zero(),
      data: Buffer$8.alloc(0),
      depth: 0,
      isStatic: false,
      isCompiled: false,
      delegatecall: false,
      gasRefund: BigInt(0),
  };
  class Message {
      constructor(opts) {
          this.to = opts.to;
          this.value = opts.value ?? defaults$1.value;
          this.caller = opts.caller ?? defaults$1.caller;
          this.gasLimit = opts.gasLimit;
          this.data = opts.data ?? defaults$1.data;
          this.depth = opts.depth ?? defaults$1.depth;
          this.code = opts.code;
          this._codeAddress = opts.codeAddress;
          this.isStatic = opts.isStatic ?? defaults$1.isStatic;
          this.isCompiled = opts.isCompiled ?? defaults$1.isCompiled;
          this.salt = opts.salt;
          this.selfdestruct = opts.selfdestruct;
          this.delegatecall = opts.delegatecall ?? defaults$1.delegatecall;
          this.authcallOrigin = opts.authcallOrigin;
          this.gasRefund = opts.gasRefund ?? defaults$1.gasRefund;
          if (this.value < 0) {
              throw new Error(`value field cannot be negative, received ${this.value}`);
          }
      }
      /**
       * Note: should only be called in instances where `_codeAddress` or `to` is defined.
       */
      get codeAddress() {
          const codeAddress = this._codeAddress ?? this.to;
          if (!codeAddress) {
              throw new Error('Missing codeAddress');
          }
          return codeAddress;
      }
  }
  message.Message = Message;

  var stack = {};

  Object.defineProperty(stack, "__esModule", { value: true });
  stack.Stack = void 0;
  const util_1$N = dist$a;
  const exceptions_1$d = exceptions;
  /**
   * Implementation of the stack used in evm.
   */
  class Stack {
      constructor(maxHeight) {
          this._store = [];
          this._maxHeight = maxHeight ?? 1024;
      }
      get length() {
          return this._store.length;
      }
      push(value) {
          if (typeof value !== 'bigint') {
              throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.INTERNAL_ERROR);
          }
          if (value > util_1$N.MAX_INTEGER_BIGINT) {
              throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.OUT_OF_RANGE);
          }
          if (this._store.length >= this._maxHeight) {
              throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.STACK_OVERFLOW);
          }
          this._store.push(value);
      }
      pop() {
          if (this._store.length < 1) {
              throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.STACK_UNDERFLOW);
          }
          // Length is checked above, so pop shouldn't return undefined
          return this._store.pop();
      }
      /**
       * Pop multiple items from stack. Top of stack is first item
       * in returned array.
       * @param num - Number of items to pop
       */
      popN(num = 1) {
          if (this._store.length < num) {
              throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.STACK_UNDERFLOW);
          }
          if (num === 0) {
              return [];
          }
          return this._store.splice(-1 * num).reverse();
      }
      /**
       * Return items from the stack
       * @param num Number of items to return
       * @throws {@link ERROR.STACK_UNDERFLOW}
       */
      peek(num = 1) {
          const peekArray = [];
          for (let peek = 1; peek <= num; peek++) {
              const index = this._store.length - peek;
              if (index < 0) {
                  throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.STACK_UNDERFLOW);
              }
              peekArray.push(this._store[index]);
          }
          return peekArray;
      }
      /**
       * Swap top of stack with an item in the stack.
       * @param position - Index of item from top of the stack (0-indexed)
       */
      swap(position) {
          if (this._store.length <= position) {
              throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.STACK_UNDERFLOW);
          }
          const head = this._store.length - 1;
          const i = this._store.length - position - 1;
          const tmp = this._store[head];
          this._store[head] = this._store[i];
          this._store[i] = tmp;
      }
      /**
       * Pushes a copy of an item in the stack.
       * @param position - Index of item to be copied (1-indexed)
       */
      // I would say that we do not need this method any more
      // since you can't copy a primitive data type
      // Nevertheless not sure if we "loose" something here?
      // Will keep commented out for now
      dup(position) {
          if (this._store.length < position) {
              throw new exceptions_1$d.EvmError(exceptions_1$d.ERROR.STACK_UNDERFLOW);
          }
          const i = this._store.length - position;
          this.push(this._store[i]);
      }
  }
  stack.Stack = Stack;

  Object.defineProperty(interpreter, "__esModule", { value: true });
  interpreter.Interpreter = void 0;
  const common_1$e = dist$8;
  const util_1$M = dist$a;
  const debug_1$5 = src$1.exports;
  const eof_1$1 = eof;
  const exceptions_1$c = exceptions;
  const memory_1 = memory;
  const message_1$1 = message;
  const opcodes_1$1 = opcodes$1;
  const stack_1 = stack;
  const debugGas$2 = (0, debug_1$5.debug)('evm:eei:gas');
  /**
   * Parses and executes EVM bytecode.
   */
  class Interpreter {
      // TODO remove eei from constructor this can be directly read from EVM
      // EEI gets created on EVM creation and will not be re-instantiated
      // TODO remove gasLeft as constructor argument
      constructor(evm, eei, env, gasLeft) {
          // Opcode debuggers (e.g. { 'push': [debug Object], 'sstore': [debug Object], ...})
          this.opDebuggers = {};
          this._evm = evm;
          this._eei = eei;
          this._common = this._evm._common;
          this._runState = {
              programCounter: 0,
              opCode: 0xfe,
              memory: new memory_1.Memory(),
              memoryWordCount: BigInt(0),
              highestMemCost: BigInt(0),
              stack: new stack_1.Stack(),
              returnStack: new stack_1.Stack(1023),
              code: Buffer$8.alloc(0),
              validJumps: Uint8Array.from([]),
              eei: this._eei,
              env: env,
              shouldDoJumpAnalysis: true,
              interpreter: this,
              gasRefund: env.gasRefund,
              gasLeft,
              returnBuffer: Buffer$8.alloc(0),
          };
          this._env = env;
          this._result = {
              logs: [],
              returnValue: undefined,
              selfdestruct: {},
          };
      }
      async run(code, opts = {}) {
          if (!this._common.isActivatedEIP(3540) || code[0] !== eof_1$1.EOF.FORMAT) {
              // EIP-3540 isn't active and first byte is not 0xEF - treat as legacy bytecode
              this._runState.code = code;
          }
          else if (this._common.isActivatedEIP(3540)) {
              if (code[1] !== eof_1$1.EOF.MAGIC) {
                  // Bytecode contains invalid EOF magic byte
                  return {
                      runState: this._runState,
                      exceptionError: new exceptions_1$c.EvmError(exceptions_1$c.ERROR.INVALID_BYTECODE_RESULT),
                  };
              }
              if (code[2] !== eof_1$1.EOF.VERSION) {
                  // Bytecode contains invalid EOF version number
                  return {
                      runState: this._runState,
                      exceptionError: new exceptions_1$c.EvmError(exceptions_1$c.ERROR.INVALID_EOF_FORMAT),
                  };
              }
              // Code is EOF1 format
              const codeSections = eof_1$1.EOF.codeAnalysis(code);
              if (!codeSections) {
                  // Code is invalid EOF1 format if `codeSections` is falsy
                  return {
                      runState: this._runState,
                      exceptionError: new exceptions_1$c.EvmError(exceptions_1$c.ERROR.INVALID_EOF_FORMAT),
                  };
              }
              if (codeSections.data) {
                  // Set code to EOF container code section which starts at byte position 10 if data section is present
                  this._runState.code = code.slice(10, 10 + codeSections.code);
              }
              else {
                  // Set code to EOF container code section which starts at byte position 7 if no data section is present
                  this._runState.code = code.slice(7, 7 + codeSections.code);
              }
          }
          this._runState.programCounter = opts.pc ?? this._runState.programCounter;
          // Check that the programCounter is in range
          const pc = this._runState.programCounter;
          if (pc !== 0 && (pc < 0 || pc >= this._runState.code.length)) {
              throw new Error('Internal error: program counter not in range');
          }
          let err;
          // Iterate through the given ops until something breaks or we hit STOP
          while (this._runState.programCounter < this._runState.code.length) {
              const opCode = this._runState.code[this._runState.programCounter];
              if (this._runState.shouldDoJumpAnalysis &&
                  (opCode === 0x56 || opCode === 0x57 || opCode === 0x5e)) {
                  // Only run the jump destination analysis if `code` actually contains a JUMP/JUMPI/JUMPSUB opcode
                  this._runState.validJumps = this._getValidJumpDests(this._runState.code);
                  this._runState.shouldDoJumpAnalysis = false;
              }
              this._runState.opCode = opCode;
              try {
                  await this.runStep();
              }
              catch (e) {
                  // re-throw on non-VM errors
                  if (!('errorType' in e && e.errorType === 'EvmError')) {
                      throw e;
                  }
                  // STOP is not an exception
                  if (e.error !== exceptions_1$c.ERROR.STOP) {
                      err = e;
                  }
                  break;
              }
          }
          return {
              runState: this._runState,
              exceptionError: err,
          };
      }
      /**
       * Executes the opcode to which the program counter is pointing,
       * reducing its base gas cost, and increments the program counter.
       */
      async runStep() {
          const opInfo = this.lookupOpInfo(this._runState.opCode);
          let gas = BigInt(opInfo.fee);
          // clone the gas limit; call opcodes can add stipend,
          // which makes it seem like the gas left increases
          const gasLimitClone = this.getGasLeft();
          if (opInfo.dynamicGas) {
              const dynamicGasHandler = this._evm._dynamicGasHandlers.get(this._runState.opCode);
              // This function updates the gas in-place.
              // It needs the base fee, for correct gas limit calculation for the CALL opcodes
              gas = await dynamicGasHandler(this._runState, gas, this._common);
          }
          if (this._evm.listenerCount('step') > 0 || this._evm.DEBUG) {
              // Only run this stepHook function if there is an event listener (e.g. test runner)
              // or if the vm is running in debug mode (to display opcode debug logs)
              await this._runStepHook(gas, gasLimitClone);
          }
          // Check for invalid opcode
          if (opInfo.name === 'INVALID') {
              throw new exceptions_1$c.EvmError(exceptions_1$c.ERROR.INVALID_OPCODE);
          }
          // Reduce opcode's base fee
          this.useGas(gas, `${opInfo.name} fee`);
          // Advance program counter
          this._runState.programCounter++;
          // Execute opcode handler
          const opFn = this.getOpHandler(opInfo);
          if (opInfo.isAsync) {
              await opFn.apply(null, [this._runState, this._common]);
          }
          else {
              opFn.apply(null, [this._runState, this._common]);
          }
      }
      /**
       * Get the handler function for an opcode.
       */
      getOpHandler(opInfo) {
          return this._evm._handlers.get(opInfo.code);
      }
      /**
       * Get info for an opcode from EVM's list of opcodes.
       */
      lookupOpInfo(op) {
          // if not found, return 0xfe: INVALID
          return this._evm._opcodes.get(op) ?? this._evm._opcodes.get(0xfe);
      }
      async _runStepHook(dynamicFee, gasLeft) {
          const opcode = this.lookupOpInfo(this._runState.opCode);
          const eventObj = {
              pc: this._runState.programCounter,
              gasLeft,
              gasRefund: this._runState.gasRefund,
              opcode: {
                  name: opcode.fullName,
                  fee: opcode.fee,
                  dynamicFee,
                  isAsync: opcode.isAsync,
              },
              stack: this._runState.stack._store,
              returnStack: this._runState.returnStack._store,
              depth: this._env.depth,
              address: this._env.address,
              account: this._env.contract,
              memory: this._runState.memory._store,
              memoryWordCount: this._runState.memoryWordCount,
              codeAddress: this._env.codeAddress,
              eei: this._runState.eei,
          };
          if (this._evm.DEBUG) {
              // Create opTrace for debug functionality
              let hexStack = [];
              hexStack = eventObj.stack.map((item) => {
                  return (0, util_1$M.bigIntToHex)(BigInt(item));
              });
              const name = eventObj.opcode.name;
              const opTrace = {
                  pc: eventObj.pc,
                  op: name,
                  gas: (0, util_1$M.bigIntToHex)(eventObj.gasLeft),
                  gasCost: (0, util_1$M.intToHex)(eventObj.opcode.fee),
                  stack: hexStack,
                  depth: eventObj.depth,
              };
              if (!(name in this.opDebuggers)) {
                  this.opDebuggers[name] = (0, debug_1$5.debug)(`evm:ops:${name}`);
              }
              this.opDebuggers[name](JSON.stringify(opTrace));
          }
          /**
           * The `step` event for trace output
           *
           * @event Event: step
           * @type {Object}
           * @property {Number} pc representing the program counter
           * @property {Object} opcode the next opcode to be ran
           * @property {string}     opcode.name
           * @property {fee}        opcode.number Base fee of the opcode
           * @property {dynamicFee} opcode.dynamicFee Dynamic opcode fee
           * @property {boolean}    opcode.isAsync opcode is async
           * @property {BigInt} gasLeft amount of gasLeft
           * @property {BigInt} gasRefund gas refund
           * @property {StateManager} stateManager a {@link StateManager} instance
           * @property {Array} stack an `Array` of `Buffers` containing the stack
           * @property {Array} returnStack the return stack
           * @property {Account} account the Account which owns the code running
           * @property {Address} address the address of the `account`
           * @property {Number} depth the current number of calls deep the contract is
           * @property {Buffer} memory the memory of the EVM as a `buffer`
           * @property {BigInt} memoryWordCount current size of memory in words
           * @property {Address} codeAddress the address of the code which is currently being ran (this differs from `address` in a `DELEGATECALL` and `CALLCODE` call)
           */
          return this._evm._emit('step', eventObj);
      }
      // Returns all valid jump and jumpsub destinations.
      _getValidJumpDests(code) {
          const jumps = new Uint8Array(code.length).fill(0);
          for (let i = 0; i < code.length; i++) {
              const opcode = code[i];
              // skip over PUSH0-32 since no jump destinations in the middle of a push block
              if (opcode <= 0x7f) {
                  if (opcode >= 0x60) {
                      i += opcode - 0x5f;
                  }
                  else if (opcode === 0x5b) {
                      // Define a JUMPDEST as a 1 in the valid jumps array
                      jumps[i] = 1;
                  }
                  else if (opcode === 0x5c) {
                      // Define a BEGINSUB as a 2 in the valid jumps array
                      jumps[i] = 2;
                  }
              }
          }
          return jumps;
      }
      /**
       * Logic extracted from EEI
       */
      /**
       * Subtracts an amount from the gas counter.
       * @param amount - Amount of gas to consume
       * @param context - Usage context for debugging
       * @throws if out of gas
       */
      useGas(amount, context) {
          this._runState.gasLeft -= amount;
          if (this._evm.DEBUG) {
              debugGas$2(`${typeof context === 'string' ? context + ': ' : ''}used ${amount} gas (-> ${this._runState.gasLeft})`);
          }
          if (this._runState.gasLeft < BigInt(0)) {
              this._runState.gasLeft = BigInt(0);
              (0, opcodes_1$1.trap)(exceptions_1$c.ERROR.OUT_OF_GAS);
          }
      }
      /**
       * Adds a positive amount to the gas counter.
       * @param amount - Amount of gas refunded
       * @param context - Usage context for debugging
       */
      refundGas(amount, context) {
          if (this._evm.DEBUG) {
              debugGas$2(`${typeof context === 'string' ? context + ': ' : ''}refund ${amount} gas (-> ${this._runState.gasRefund})`);
          }
          this._runState.gasRefund += amount;
      }
      /**
       * Reduces amount of gas to be refunded by a positive value.
       * @param amount - Amount to subtract from gas refunds
       * @param context - Usage context for debugging
       */
      subRefund(amount, context) {
          if (this._evm.DEBUG) {
              debugGas$2(`${typeof context === 'string' ? context + ': ' : ''}sub gas refund ${amount} (-> ${this._runState.gasRefund})`);
          }
          this._runState.gasRefund -= amount;
          if (this._runState.gasRefund < BigInt(0)) {
              this._runState.gasRefund = BigInt(0);
              (0, opcodes_1$1.trap)(exceptions_1$c.ERROR.REFUND_EXHAUSTED);
          }
      }
      /**
       * Increments the internal gasLeft counter. Used for adding callStipend.
       * @param amount - Amount to add
       */
      addStipend(amount) {
          if (this._evm.DEBUG) {
              debugGas$2(`add stipend ${amount} (-> ${this._runState.gasLeft})`);
          }
          this._runState.gasLeft += amount;
      }
      /**
       * Returns balance of the given account.
       * @param address - Address of account
       */
      async getExternalBalance(address) {
          // shortcut if current account
          if (address.equals(this._env.address)) {
              return this._env.contract.balance;
          }
          return (await this._eei.getAccount(address)).balance;
      }
      /**
       * Store 256-bit a value in memory to persistent storage.
       */
      async storageStore(key, value) {
          await this._eei.storageStore(this._env.address, key, value);
          const account = await this._eei.getAccount(this._env.address);
          this._env.contract = account;
      }
      /**
       * Loads a 256-bit value to memory from persistent storage.
       * @param key - Storage key
       * @param original - If true, return the original storage value (default: false)
       */
      async storageLoad(key, original = false) {
          return this._eei.storageLoad(this._env.address, key, original);
      }
      /**
       * Store 256-bit a value in memory to transient storage.
       * @param address Address to use
       * @param key Storage key
       * @param value Storage value
       */
      transientStorageStore(key, value) {
          return this._evm._transientStorage.put(this._env.address, key, value);
      }
      /**
       * Loads a 256-bit value to memory from transient storage.
       * @param address Address to use
       * @param key Storage key
       */
      transientStorageLoad(key) {
          return this._evm._transientStorage.get(this._env.address, key);
      }
      /**
       * Set the returning output data for the execution.
       * @param returnData - Output data to return
       */
      finish(returnData) {
          this._result.returnValue = returnData;
          (0, opcodes_1$1.trap)(exceptions_1$c.ERROR.STOP);
      }
      /**
       * Set the returning output data for the execution. This will halt the
       * execution immediately and set the execution result to "reverted".
       * @param returnData - Output data to return
       */
      revert(returnData) {
          this._result.returnValue = returnData;
          (0, opcodes_1$1.trap)(exceptions_1$c.ERROR.REVERT);
      }
      /**
       * Returns address of currently executing account.
       */
      getAddress() {
          return this._env.address;
      }
      /**
       * Returns balance of self.
       */
      getSelfBalance() {
          return this._env.contract.balance;
      }
      /**
       * Returns the deposited value by the instruction/transaction
       * responsible for this execution.
       */
      getCallValue() {
          return this._env.callValue;
      }
      /**
       * Returns input data in current environment. This pertains to the input
       * data passed with the message call instruction or transaction.
       */
      getCallData() {
          return this._env.callData;
      }
      /**
       * Returns size of input data in current environment. This pertains to the
       * input data passed with the message call instruction or transaction.
       */
      getCallDataSize() {
          return BigInt(this._env.callData.length);
      }
      /**
       * Returns caller address. This is the address of the account
       * that is directly responsible for this execution.
       */
      getCaller() {
          return (0, util_1$M.bufferToBigInt)(this._env.caller.buf);
      }
      /**
       * Returns the size of code running in current environment.
       */
      getCodeSize() {
          return BigInt(this._env.code.length);
      }
      /**
       * Returns the code running in current environment.
       */
      getCode() {
          return this._env.code;
      }
      /**
       * Returns the current gasCounter.
       */
      getGasLeft() {
          return this._runState.gasLeft;
      }
      /**
       * Returns size of current return data buffer. This contains the return data
       * from the last executed call, callCode, callDelegate, callStatic or create.
       * Note: create only fills the return data buffer in case of a failure.
       */
      getReturnDataSize() {
          return BigInt(this._runState.returnBuffer.length);
      }
      /**
       * Returns the current return data buffer. This contains the return data
       * from last executed call, callCode, callDelegate, callStatic or create.
       * Note: create only fills the return data buffer in case of a failure.
       */
      getReturnData() {
          return this._runState.returnBuffer;
      }
      /**
       * Returns true if the current call must be executed statically.
       */
      isStatic() {
          return this._env.isStatic;
      }
      /**
       * Returns price of gas in current environment.
       */
      getTxGasPrice() {
          return this._env.gasPrice;
      }
      /**
       * Returns the execution's origination address. This is the
       * sender of original transaction; it is never an account with
       * non-empty associated code.
       */
      getTxOrigin() {
          return (0, util_1$M.bufferToBigInt)(this._env.origin.buf);
      }
      /**
       * Returns the block’s number.
       */
      getBlockNumber() {
          return this._env.block.header.number;
      }
      /**
       * Returns the block's beneficiary address.
       */
      getBlockCoinbase() {
          let coinbase;
          if (this._common.consensusAlgorithm() === common_1$e.ConsensusAlgorithm.Clique) {
              coinbase = this._env.block.header.cliqueSigner();
          }
          else {
              coinbase = this._env.block.header.coinbase;
          }
          return (0, util_1$M.bufferToBigInt)(coinbase.toBuffer());
      }
      /**
       * Returns the block's timestamp.
       */
      getBlockTimestamp() {
          return this._env.block.header.timestamp;
      }
      /**
       * Returns the block's difficulty.
       */
      getBlockDifficulty() {
          return this._env.block.header.difficulty;
      }
      /**
       * Returns the block's prevRandao field.
       */
      getBlockPrevRandao() {
          return (0, util_1$M.bufferToBigInt)(this._env.block.header.prevRandao);
      }
      /**
       * Returns the block's gas limit.
       */
      getBlockGasLimit() {
          return this._env.block.header.gasLimit;
      }
      /**
       * Returns the Base Fee of the block as proposed in [EIP-3198](https;//eips.etheruem.org/EIPS/eip-3198)
       */
      getBlockBaseFee() {
          const baseFee = this._env.block.header.baseFeePerGas;
          if (baseFee === undefined) {
              // Sanity check
              throw new Error('Block has no Base Fee');
          }
          return baseFee;
      }
      /**
       * Returns the chain ID for current chain. Introduced for the
       * CHAINID opcode proposed in [EIP-1344](https://eips.ethereum.org/EIPS/eip-1344).
       */
      getChainId() {
          return this._common.chainId();
      }
      /**
       * Sends a message with arbitrary data to a given address path.
       */
      async call(gasLimit, address, value, data) {
          const msg = new message_1$1.Message({
              caller: this._env.address,
              gasLimit,
              to: address,
              value,
              data,
              isStatic: this._env.isStatic,
              depth: this._env.depth + 1,
          });
          return this._baseCall(msg);
      }
      /**
       * Sends a message with arbitrary data to a given address path.
       */
      async authcall(gasLimit, address, value, data) {
          const msg = new message_1$1.Message({
              caller: this._runState.auth,
              gasLimit,
              to: address,
              value,
              data,
              isStatic: this._env.isStatic,
              depth: this._env.depth + 1,
              authcallOrigin: this._env.address,
          });
          return this._baseCall(msg);
      }
      /**
       * Message-call into this account with an alternative account's code.
       */
      async callCode(gasLimit, address, value, data) {
          const msg = new message_1$1.Message({
              caller: this._env.address,
              gasLimit,
              to: this._env.address,
              codeAddress: address,
              value,
              data,
              isStatic: this._env.isStatic,
              depth: this._env.depth + 1,
          });
          return this._baseCall(msg);
      }
      /**
       * Sends a message with arbitrary data to a given address path, but disallow
       * state modifications. This includes log, create, selfdestruct and call with
       * a non-zero value.
       */
      async callStatic(gasLimit, address, value, data) {
          const msg = new message_1$1.Message({
              caller: this._env.address,
              gasLimit,
              to: address,
              value,
              data,
              isStatic: true,
              depth: this._env.depth + 1,
          });
          return this._baseCall(msg);
      }
      /**
       * Message-call into this account with an alternative account’s code, but
       * persisting the current values for sender and value.
       */
      async callDelegate(gasLimit, address, value, data) {
          const msg = new message_1$1.Message({
              caller: this._env.caller,
              gasLimit,
              to: this._env.address,
              codeAddress: address,
              value,
              data,
              isStatic: this._env.isStatic,
              delegatecall: true,
              depth: this._env.depth + 1,
          });
          return this._baseCall(msg);
      }
      async _baseCall(msg) {
          const selfdestruct = { ...this._result.selfdestruct };
          msg.selfdestruct = selfdestruct;
          msg.gasRefund = this._runState.gasRefund;
          // empty the return data buffer
          this._runState.returnBuffer = Buffer$8.alloc(0);
          // Check if account has enough ether and max depth not exceeded
          if (this._env.depth >= Number(this._common.param('vm', 'stackLimit')) ||
              (msg.delegatecall !== true && this._env.contract.balance < msg.value)) {
              return BigInt(0);
          }
          const results = await this._evm.runCall({ message: msg });
          if (results.execResult.logs) {
              this._result.logs = this._result.logs.concat(results.execResult.logs);
          }
          // this should always be safe
          this.useGas(results.execResult.executionGasUsed, 'CALL, STATICCALL, DELEGATECALL, CALLCODE');
          // Set return value
          if ((0, util_1$M.isTruthy)(results.execResult.returnValue) &&
              (!results.execResult.exceptionError ||
                  results.execResult.exceptionError.error === exceptions_1$c.ERROR.REVERT)) {
              this._runState.returnBuffer = results.execResult.returnValue;
          }
          if (!results.execResult.exceptionError) {
              Object.assign(this._result.selfdestruct, selfdestruct);
              // update stateRoot on current contract
              const account = await this._eei.getAccount(this._env.address);
              this._env.contract = account;
              this._runState.gasRefund = results.execResult.gasRefund ?? BigInt(0);
          }
          return this._getReturnCode(results);
      }
      /**
       * Creates a new contract with a given value.
       */
      async create(gasLimit, value, data, salt) {
          const selfdestruct = { ...this._result.selfdestruct };
          const caller = this._env.address;
          const depth = this._env.depth + 1;
          // empty the return data buffer
          this._runState.returnBuffer = Buffer$8.alloc(0);
          // Check if account has enough ether and max depth not exceeded
          if (this._env.depth >= Number(this._common.param('vm', 'stackLimit')) ||
              this._env.contract.balance < value) {
              return BigInt(0);
          }
          // EIP-2681 check
          if (this._env.contract.nonce >= util_1$M.MAX_UINT64) {
              return BigInt(0);
          }
          this._env.contract.nonce += BigInt(1);
          await this._eei.putAccount(this._env.address, this._env.contract);
          if (this._common.isActivatedEIP(3860)) {
              if (data.length > Number(this._common.param('vm', 'maxInitCodeSize'))) {
                  return BigInt(0);
              }
          }
          const message = new message_1$1.Message({
              caller,
              gasLimit,
              value,
              data,
              salt,
              depth,
              selfdestruct,
              gasRefund: this._runState.gasRefund,
          });
          const results = await this._evm.runCall({ message });
          if (results.execResult.logs) {
              this._result.logs = this._result.logs.concat(results.execResult.logs);
          }
          // this should always be safe
          this.useGas(results.execResult.executionGasUsed, 'CREATE');
          // Set return buffer in case revert happened
          if (results.execResult.exceptionError &&
              results.execResult.exceptionError.error === exceptions_1$c.ERROR.REVERT) {
              this._runState.returnBuffer = results.execResult.returnValue;
          }
          if (!results.execResult.exceptionError ||
              results.execResult.exceptionError.error === exceptions_1$c.ERROR.CODESTORE_OUT_OF_GAS) {
              Object.assign(this._result.selfdestruct, selfdestruct);
              // update stateRoot on current contract
              const account = await this._eei.getAccount(this._env.address);
              this._env.contract = account;
              this._runState.gasRefund = results.execResult.gasRefund ?? BigInt(0);
              if (results.createdAddress) {
                  // push the created address to the stack
                  return (0, util_1$M.bufferToBigInt)(results.createdAddress.buf);
              }
          }
          return this._getReturnCode(results);
      }
      /**
       * Creates a new contract with a given value. Generates
       * a deterministic address via CREATE2 rules.
       */
      async create2(gasLimit, value, data, salt) {
          return this.create(gasLimit, value, data, salt);
      }
      /**
       * Mark account for later deletion and give the remaining balance to the
       * specified beneficiary address. This will cause a trap and the
       * execution will be aborted immediately.
       * @param toAddress - Beneficiary address
       */
      async selfDestruct(toAddress) {
          return this._selfDestruct(toAddress);
      }
      async _selfDestruct(toAddress) {
          // only add to refund if this is the first selfdestruct for the address
          if ((0, util_1$M.isFalsy)(this._result.selfdestruct[this._env.address.buf.toString('hex')])) {
              this.refundGas(this._common.param('gasPrices', 'selfdestructRefund'));
          }
          this._result.selfdestruct[this._env.address.buf.toString('hex')] = toAddress.buf;
          // Add to beneficiary balance
          const toAccount = await this._eei.getAccount(toAddress);
          toAccount.balance += this._env.contract.balance;
          await this._eei.putAccount(toAddress, toAccount);
          // Subtract from contract balance
          await this._eei.modifyAccountFields(this._env.address, {
              balance: BigInt(0),
          });
          (0, opcodes_1$1.trap)(exceptions_1$c.ERROR.STOP);
      }
      /**
       * Creates a new log in the current environment.
       */
      log(data, numberOfTopics, topics) {
          if (numberOfTopics < 0 || numberOfTopics > 4) {
              (0, opcodes_1$1.trap)(exceptions_1$c.ERROR.OUT_OF_RANGE);
          }
          if (topics.length !== numberOfTopics) {
              (0, opcodes_1$1.trap)(exceptions_1$c.ERROR.INTERNAL_ERROR);
          }
          const log = [this._env.address.buf, topics, data];
          this._result.logs.push(log);
      }
      _getReturnCode(results) {
          // This preserves the previous logic, but seems to contradict the EEI spec
          // https://github.com/ewasm/design/blob/38eeded28765f3e193e12881ea72a6ab807a3371/eth_interface.md
          if (results.execResult.exceptionError) {
              return BigInt(0);
          }
          else {
              return BigInt(1);
          }
      }
  }
  interpreter.Interpreter = Interpreter;

  var transientStorage = {};

  Object.defineProperty(transientStorage, "__esModule", { value: true });
  transientStorage.TransientStorage = void 0;
  class TransientStorage {
      constructor() {
          /**
           * The current values of the transient storage, keyed by contract address and then slot
           */
          this._storage = new Map();
          /**
           * Each change to storage is recorded in the journal. This is never cleared.
           */
          this._changeJournal = [];
          /**
           * The length of the journal at the beginning of each call in the call stack.
           */
          this._indices = [0];
      }
      /**
       * Get the value for the given address and key
       * @param addr the address for which transient storage is accessed
       * @param key the key of the address to get
       */
      get(addr, key) {
          const map = this._storage.get(addr.toString());
          if (!map) {
              return Buffer$8.alloc(32);
          }
          const value = map.get(key.toString('hex'));
          if (!value) {
              return Buffer$8.alloc(32);
          }
          return value;
      }
      /**
       * Put the given value for the address and key
       * @param addr the address of the contract for which the key is being set
       * @param key the slot to set for the address
       * @param value the new value of the transient storage slot to set
       */
      put(addr, key, value) {
          if (key.length !== 32) {
              throw new Error('Transient storage key must be 32 bytes long');
          }
          if (value.length > 32) {
              throw new Error('Transient storage value cannot be longer than 32 bytes');
          }
          const addrString = addr.toString();
          if (!this._storage.has(addrString)) {
              this._storage.set(addrString, new Map());
          }
          const map = this._storage.get(addrString);
          const keyStr = key.toString('hex');
          const prevValue = map.get(keyStr) ?? Buffer$8.alloc(32);
          this._changeJournal.push({
              addr: addrString,
              key: keyStr,
              prevValue,
          });
          map.set(keyStr, value);
      }
      /**
       * Commit all the changes since the last checkpoint
       */
      commit() {
          if (this._indices.length === 0)
              throw new Error('Nothing to commit');
          // by discarding the length of the array from the last time checkpoint was called, all changes are included in the last stack
          this._indices.pop();
      }
      /**
       * To be called whenever entering a new context. If revert is called after checkpoint, all changes after the latest checkpoint are reverted.
       */
      checkpoint() {
          this._indices.push(this._changeJournal.length);
      }
      /**
       * Revert transient storage to the last checkpoint
       */
      revert() {
          const lastCheckpoint = this._indices.pop();
          if (typeof lastCheckpoint === 'undefined')
              throw new Error('Nothing to revert');
          for (let i = this._changeJournal.length - 1; i >= lastCheckpoint; i--) {
              const { key, prevValue, addr } = this._changeJournal[i];
              this._storage.get(addr).set(key, prevValue);
          }
          this._changeJournal.splice(lastCheckpoint, this._changeJournal.length - lastCheckpoint);
      }
      /**
       * Create a JSON representation of the current transient storage state
       */
      toJSON() {
          const result = {};
          for (const [address, map] of this._storage.entries()) {
              result[address] = {};
              for (const [key, value] of map.entries()) {
                  result[address][key] = value.toString('hex');
              }
          }
          return result;
      }
      /**
       * Clear transient storage state.
       */
      clear() {
          this._storage = new Map();
          this._changeJournal = [];
      }
  }
  transientStorage.TransientStorage = TransientStorage;

  var __filename = '/home/node/services/node_modules/mcl-wasm/src';

  var __dirname = '/home/node/services/node_modules/mcl-wasm/src';

  var mcl_c = {exports: {}};

  (function (module, exports) {
  var Module = (function() {
    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
    _scriptDir = _scriptDir || __filename;
    return (
  function(Module) {
    Module = Module || {};

  var Module = typeof Module !== "undefined" ? Module : {};

  var readyPromiseResolve, readyPromiseReject;

  Module["ready"] = new Promise(function(resolve, reject) {
   readyPromiseResolve = resolve;
   readyPromiseReject = reject;
  });

  var moduleOverrides = {};

  var key;

  for (key in Module) {
   if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
   }
  }

  var ENVIRONMENT_IS_WEB = false;

  var ENVIRONMENT_IS_WORKER = false;

  var ENVIRONMENT_IS_NODE = false;

  var ENVIRONMENT_IS_SHELL = false;

  ENVIRONMENT_IS_WEB = typeof window === "object";

  ENVIRONMENT_IS_WORKER = typeof importScripts === "function";

  ENVIRONMENT_IS_NODE = typeof browser$1$1 === "object" && typeof browser$1$1.versions === "object" && typeof browser$1$1.versions.node === "string";

  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

  var scriptDirectory = "";

  function locateFile(path) {
   if (Module["locateFile"]) {
    return Module["locateFile"](path, scriptDirectory);
   }
   return scriptDirectory + path;
  }

  var read_, readBinary;

  var nodeFS;

  var nodePath;

  if (ENVIRONMENT_IS_NODE) {
   if (ENVIRONMENT_IS_WORKER) ; else {
    scriptDirectory = __dirname + "/";
   }
   read_ = function shell_read(filename, binary) {
    var ret = tryParseAsDataURI(filename);
    if (ret) {
     return binary ? ret : ret.toString();
    }
  //  if (!nodeFS) nodeFS = require("fs");
  //  if (!nodePath) nodePath = require("path");
    filename = nodePath["normalize"](filename);
    return nodeFS["readFileSync"](filename, binary ? null : "utf8");
   };
   readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
     ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
   };
   if (browser$1$1["argv"].length > 1) {
    browser$1$1["argv"][1].replace(/\\/g, "/");
   }
   browser$1$1["argv"].slice(2);
   Module["inspect"] = function() {
    return "[Emscripten Module object]";
   };
  } else if (ENVIRONMENT_IS_SHELL) {
   if (typeof read != "undefined") {
    read_ = function shell_read(f) {
     var data = tryParseAsDataURI(f);
     if (data) {
      return intArrayToString(data);
     }
     return read(f);
    };
   }
   readBinary = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
     return data;
    }
    if (typeof readbuffer === "function") {
     return new Uint8Array(readbuffer(f));
    }
    data = read(f, "binary");
    assert(typeof data === "object");
    return data;
   };
   if (typeof scriptArgs != "undefined") {
    scriptArgs;
   }
   if (typeof print !== "undefined") {
    if (typeof console === "undefined") console = {};
    console.log = print;
    console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
   }
  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
   if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = self.location.href;
   } else if (document.currentScript) {
    scriptDirectory = document.currentScript.src;
   }
   if (_scriptDir) {
    scriptDirectory = _scriptDir;
   }
   if (scriptDirectory.indexOf("blob:") !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
   } else {
    scriptDirectory = "";
   }
   {
    read_ = function shell_read(url) {
     try {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, false);
      xhr.send(null);
      return xhr.responseText;
     } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
       return intArrayToString(data);
      }
      throw err;
     }
    };
    if (ENVIRONMENT_IS_WORKER) {
     readBinary = function readBinary(url) {
      try {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url, false);
       xhr.responseType = "arraybuffer";
       xhr.send(null);
       return new Uint8Array(xhr.response);
      } catch (err) {
       var data = tryParseAsDataURI(url);
       if (data) {
        return data;
       }
       throw err;
      }
     };
    }
   }
  } else ;

  Module["print"] || console.log.bind(console);

  var err = Module["printErr"] || console.warn.bind(console);

  for (key in moduleOverrides) {
   if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
   }
  }

  moduleOverrides = null;

  if (Module["arguments"]) ;

  if (Module["thisProgram"]) ;

  if (Module["quit"]) ;

  var wasmBinary;

  if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

  if (Module["noExitRuntime"]) ;

  if (typeof WebAssembly !== "object") {
   abort("no native wasm support detected");
  }

  var wasmMemory;

  var wasmTable;

  var ABORT = false;

  function assert(condition, text) {
   if (!condition) {
    abort("Assertion failed: " + text);
   }
  }

  var WASM_PAGE_SIZE = 65536;

  var buffer, HEAPU8, HEAP32, HEAPF64;

  function updateGlobalBufferAndViews(buf) {
   buffer = buf;
   Module["HEAP8"] = new Int8Array(buf);
   Module["HEAP16"] = new Int16Array(buf);
   Module["HEAP32"] = HEAP32 = new Int32Array(buf);
   Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
   Module["HEAPU16"] = new Uint16Array(buf);
   Module["HEAPU32"] = new Uint32Array(buf);
   Module["HEAPF32"] = new Float32Array(buf);
   Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }

  var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;

  if (Module["wasmMemory"]) {
   wasmMemory = Module["wasmMemory"];
  } else {
   wasmMemory = new WebAssembly.Memory({
    "initial": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
    "maximum": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
   });
  }

  if (wasmMemory) {
   buffer = wasmMemory.buffer;
  }

  INITIAL_INITIAL_MEMORY = buffer.byteLength;

  updateGlobalBufferAndViews(buffer);

  var __ATPRERUN__ = [];

  var __ATINIT__ = [];

  var __ATMAIN__ = [];

  var __ATPOSTRUN__ = [];

  function preRun() {
   if (Module["preRun"]) {
    if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
    while (Module["preRun"].length) {
     addOnPreRun(Module["preRun"].shift());
    }
   }
   callRuntimeCallbacks(__ATPRERUN__);
  }

  function initRuntime() {
   callRuntimeCallbacks(__ATINIT__);
  }

  function preMain() {
   callRuntimeCallbacks(__ATMAIN__);
  }

  function postRun() {
   if (Module["postRun"]) {
    if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
    while (Module["postRun"].length) {
     addOnPostRun(Module["postRun"].shift());
    }
   }
   callRuntimeCallbacks(__ATPOSTRUN__);
  }

  function addOnPreRun(cb) {
   __ATPRERUN__.unshift(cb);
  }

  function addOnPostRun(cb) {
   __ATPOSTRUN__.unshift(cb);
  }

  var runDependencies = 0;

  var dependenciesFulfilled = null;

  function addRunDependency(id) {
   runDependencies++;
   if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
   }
  }

  function removeRunDependency(id) {
   runDependencies--;
   if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
   }
   if (runDependencies == 0) {
    if (dependenciesFulfilled) {
     var callback = dependenciesFulfilled;
     dependenciesFulfilled = null;
     callback();
    }
   }
  }

  Module["preloadedImages"] = {};

  Module["preloadedAudios"] = {};

  function abort(what) {
   if (Module["onAbort"]) {
    Module["onAbort"](what);
   }
   what += "";
   err(what);
   ABORT = true;
   what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
   var e = new WebAssembly.RuntimeError(what);
   readyPromiseReject(e);
   throw e;
  }

  function hasPrefix(str, prefix) {
   return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
  }

  var dataURIPrefix = "data:application/octet-stream;base64,";

  function isDataURI(filename) {
   return hasPrefix(filename, dataURIPrefix);
  }

  var fileURIPrefix = "file://";

  function isFileURI(filename) {
   return hasPrefix(filename, fileURIPrefix);
  }

  var wasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAABZg9gBH9/f38AYAN/f38AYAJ/fwBgAX8AYAF/AX9gA39/fwF/YAR/f39/AX9gAn9/AX9gBn9/f39/fwBgBX9/f39/AGAAAGAAAX9gBX9/f39/AX9gB39/f39/f38AYAZ/f39/f38BfwIdBAFhAWIABQFhAWMABAFhAWQABQFhAWECAYACgAIDnwSdBAUAAgIBCQEBAQEBAQMCAgICAgIBAAAFAQICDQEOAgEEAQcCAgEGAQgDBAEFAwMCAQACAAIJAgUEAQEGAQEBAQACAgMDCQEBAQEIBQIJBgcBCQcCCQAFAQAAAQQBBAwGAAIBAAICAgIEAQAFAAUGBQkABQYGBwMBAAAAAQEJAAcCAwIBAgIBCQIBAAACBAcCAAcCBAQAAAEABAABBQAAAQACCwACAQACAQACAQACAQEACQUFCgAFAAABAQAAAgEBAQABAgEBAAAFAAABAQAAAQEBBQUAAQIBAQAAAAMEAwQEAAkCAgcCAQICAQECAgICAAwCAQEBAQEBBAICAAIBAgIGAAYAAAMCAwMKCgEKAQEKCgIKCgoKBAcEBAcDAQUFAwcHBQQEBAQEBwQFBQUFBQMDBQUGBgMDAgkGCQYGCQYJBgkABgYJCQkJAQICCwEAAQICAAIBAAAGAAAGAAABAQEBAQEBAgICAgICBQYEBAcFAQYDAQEBBAECAgIDBQYBAQUCBAQHBwcHAAQFBgMBAQEBAQICAAIFBgEFBAQHBwcHBAQBBAUGAwcHAgcHBwcBAQEBAQICAQEBAQICAgQBAQEBAgICBQYDBQIBAQQBAQQEBAIEBAcEBQUFBQAFBQYDBAsDAQcHCwsLBggGAAgIBgICBwsDBAUBAQEFAAEFBgYCBwcEAgIBAAEBAgEBAAAFBQAABAEBAAECAQEAAwYEBwFwAaEBoQEGCQF/AUGwhsICCweaB6IBAWUBAAFmALYBAWcA9wMBaAD2AwFpAPUDAWoA9AMBawDqAwFsAOkDAW0ApAEBbgCkAQFvAOgDAXAA5wMBcQDmAwFyAOQDAXMA4wMBdADiAwF1AOEDAXYAowEBdwCjAQF4AOADAXkA3wMBegDeAwFBANwDAUIA2gMBQwDZAwFEANgDAUUA1wMBRgDWAwFHANUDAUgA0wMBSQDSAwFKANEDAUsAzgMBTADLAwFNAMoDAU4AyAMBTwDHAwFQAMYDAVEAxQMBUgDEAwFTAMMDAVQAwgMBVQDBAwFWAMADAVcAvgMBWAC9AwFZALwDAVoAuwMBXwC6AwEkALkDAmFhALgDAmJhALcDAmNhALYDAmRhADgCZWEAtAMCZmEAswMCZ2EAsgMCaGEAsQMCaWEAsAMCamEArQMCa2EAqgMCbGEAqQMCbWEAqAMCbmEApwMCb2EApgMCcGEAogMCcWEAngMCcmEAnQMCc2EAnAMCdGEAmgMCdWEAmQMCdmEAmAMCd2EAlgMCeGEAlQMCeWEAlAMCemEAkgMCQWEAkQMCQmEAkAMCQ2EAjwMCRGEAjgMCRWEAjQMCRmEAjAMCR2EAigMCSGEAhgMCSWEAhQMCSmEAgwMCS2EAgAMCTGEA/wICTWEA/QICTmEA/AICT2EA+wICUGEA+gICUWEA+AICUmEA9wICU2EA9gICVGEA9QICVWEAkQECVmEAkQECV2EA9AICWGEA8gICWWEA8QICWmEA8AICX2EA7wICJGEA7gICYWIA7QICYmIA6wICY2IA6gICZGIA6QICZWIA5wICZmIA5gICZ2IA5AICaGIA4wICaWIA4gICamIA4QICa2IA4AICbGIA3wICbWIA3AICbmIA2QICb2IA1wICcGIA1gICcWIA0gICcmIA0QICc2IAzwICdGIAzgICdWIAzAICdmIAywICd2IAyQICeGIAxwICeWIAwwICemIAwQICQWIAvwICQmIAvgICQ2IAvAICRGIAuQICRWIAuAICRmIAhwECR2IAhwECSGIAtwICSWIAtgICSmIAtQICS2IAtAICTGIAswICTWIAsQICTmIAsAICT2IArwICUGIArgICUWIArAICUmIAqwICU2IAqgICVGIAqQICVWIApwICVmIApgICV2IApQICWGIApAICWWIAoQICWmIAoAICX2IAngICJGIAnQICYWMAnAICYmMAmwICY2MAmgICZGMAmQIJswIBAEEBC6ABvwGeBJUEigSCBP4DsQH5A6UB7gPlA6UB3QPUA8kDvwO1A6wDpQOaAZcDkwOaAYsDhAP+AvkC8wLsAuUCjAHVAtACjAHFAroCsgKoAp8ClAKOAoAB/gH4AYAB8gHsAekB4wHdAS453AHbAdoB2QHYAdcB1gHVAdQBxgLTAdIB0QFz0AHPAc4BzQHMAcsBygFxyQHIAccBxgHFAcQB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KAIAEQEACwJAIANBwABxDQBBlcYBLQAARQ0AIAAgAEHowwFBmLYBQbzFASgCABEAAAsgAUEBOgAACyAKQZADaiQAC4sEAQR/IwBBwAFrIgIkAAJAAkBBtLcBKAIAQQFGBEAgACABRgRAIABB4ABqIQMMAwsgACABQajFASgCABECACAAQTBqIAFBMGpBqMUBKAIAEQIADAELIAAgAUcEQCAAIAFBqMUBKAIAEQIACyAAQTBqIAFBMGpBmLYBQbDFASgCABEBAAsgAUHgAGohAyAAQeAAaiEEAkBBtLcBKAIAQQFGBEAgACABRg0CIABB4ABqIAFB4ABqQajFASgCABECACAAQZABaiABQZABakGoxQEoAgARAgAMAQsgACABRwRAIAQgA0GoxQEoAgARAgALIABBkAFqIAFBkAFqQZi2AUGwxQEoAgARAQALIAQhAwsgAUHAAWohBCAAQcABaiEFAkBBtLcBKAIAQQFGBEAgACABRg0BIAUgBEGoxQEoAgARAgAgAEHwAWogAUHwAWpBqMUBKAIAEQIADAELIAAgAUcEQCAFIARBqMUBKAIAEQIACyAAQfABaiABQfABakGYtgFBsMUBKAIAEQEACyACIABB0LABQYjFASgCABEBACAAIAJBmLYBQezFASgCABEBACAAQTBqIAJB4ABqIgBBmLYBQezFASgCABEBACACIANBsLEBQYjFASgCABEBACADIAJBmLYBQezFASgCABEBACADQTBqIABBmLYBQezFASgCABEBACACQcABaiQAC+gIAQJ/IwBBwAFrIgMkAEG0twEoAgAhAgJAAkACQAJAAkACQCAAIAFHBEAgACABQajFASgCABECACACQQFHDQEgAEEwaiABQTBqQajFASgCABECAAwCCyACQQFGDQUgAEEwaiABQTBqQZi2AUGwxQEoAgARAQBBtLcBKAIAQQFHDQIMBQsgAEEwaiABQTBqQZi2AUGwxQEoAgARAQALQbS3ASgCACECIABB4ABqIAFB4ABqQajFASgCABECACACQQFGDQEgAEGQAWogAUGQAWpBmLYBQbDFASgCABEBAAwCCyAAQZABaiABQZABakGYtgFBsMUBKAIAEQEAQbS3ASgCAEEBRg0CIABB8AFqIAFB8AFqQZi2AUGwxQEoAgARAQBBtLcBKAIAQQFGDQIgAEHQAmogAUHQAmpBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNAiAAQbADaiABQbADakGYtgFBsMUBKAIAEQEAQbS3ASgCAEEBRg0CIABBkARqIAFBkARqQZi2AUGwxQEoAgARAQAMAgsgAEGQAWogAUGQAWpBqMUBKAIAEQIAC0G0twEoAgAhAiAAQcABaiABQcABakGoxQEoAgARAgACQCACQQFHBEAgAEHwAWogAUHwAWpBmLYBQbDFASgCABEBAAwBCyAAQfABaiABQfABakGoxQEoAgARAgALQbS3ASgCACECIABBoAJqIAFBoAJqQajFASgCABECAAJAIAJBAUcEQCAAQdACaiABQdACakGYtgFBsMUBKAIAEQEADAELIABB0AJqIAFB0AJqQajFASgCABECAAtBtLcBKAIAIQIgAEGAA2ogAUGAA2pBqMUBKAIAEQIAAkAgAkEBRwRAIABBsANqIAFBsANqQZi2AUGwxQEoAgARAQAMAQsgAEGwA2ogAUGwA2pBqMUBKAIAEQIAC0G0twEoAgAhAiAAQeADaiABQeADakGoxQEoAgARAgAgAkEBRwRAIABBkARqIAFBkARqQZi2AUGwxQEoAgARAQAMAQsgAEGQBGogAUGQBGpBqMUBKAIAEQIACyADIABB4ABqIgFBsOEBQYjFASgCABEBACABIANBmLYBQezFASgCABEBACAAQZABaiADQeAAaiIBQZi2AUHsxQEoAgARAQAgAyAAQcABaiICQZDiAUGIxQEoAgARAQAgAiADQZi2AUHsxQEoAgARAQAgAEHwAWogAUGYtgFB7MUBKAIAEQEAIAMgAEGgAmoiAkHw4gFBiMUBKAIAEQEAIAIgA0GYtgFB7MUBKAIAEQEAIABB0AJqIAFBmLYBQezFASgCABEBACADIABBgANqIgJB0OMBQYjFASgCABEBACACIANBmLYBQezFASgCABEBACAAQbADaiABQZi2AUHsxQEoAgARAQAgAyAAQeADaiICQbDkAUGIxQEoAgARAQAgAiADQZi2AUHsxQEoAgARAQAgAEGQBGogAUGYtgFB7MUBKAIAEQEAIANBwAFqJAALuQkBDX8jAEHAE2siAyQAIANB4A9qIAEgAUGgAmoiBEGYtgFBtMUBKAIAEQAAIANBkBBqIAFBMGogAUHQAmpBmLYBQbTFASgCABEAACADQcAQaiABQeAAaiABQYADakGYtgFBtMUBKAIAEQAAIANB8BBqIAFBkAFqIAFBsANqQZi2AUG0xQEoAgARAAAgA0GgEWogAUHAAWogAUHgA2pBmLYBQbTFASgCABEAACADQdARaiABQfABaiABQZAEakGYtgFBtMUBKAIAEQAAIANBwA1qIAIgAkGgAmoiBUGYtgFBtMUBKAIAEQAAIANB8A1qIAJBMGogAkHQAmpBmLYBQbTFASgCABEAACADQaAOaiACQeAAaiACQYADakGYtgFBtMUBKAIAEQAAIANB0A5qIAJBkAFqIAJBsANqQZi2AUG0xQEoAgARAAAgA0GAD2ogAkHAAWogAkHgA2pBmLYBQbTFASgCABEAACADQbAPaiACQfABaiACQZAEakGYtgFBtMUBKAIAEQAAIANBwARqIAEgAhA7IAMgBCAFEDsgA0GAEmogA0GAA2oiB0GQxQEoAgARAgAgA0GADGoiASADQcABaiIIIANBwAdqIglBmLYBQeTFASgCABEAACADQeAMaiICIANBoAJqIgogA0GgCGoiC0GYtgFB5MUBKAIAEQAAIANBwApqIgQgAyADQYAGaiIMQZi2AUHkxQEoAgARAAAgA0GgC2oiBSADQeAAaiINIANB4AZqIg5BmLYBQeTFASgCABEAACADQYAJaiADQYASaiADQcAEakGYtgFB5MUBKAIAEQAAIANB4AlqIgYgA0HgEmogA0GgBWoiD0GYtgFB5MUBKAIAEQAAIAAgA0GACWpBmLYBQezFASgCABEBACAAQTBqIAZBmLYBQezFASgCABEBACAAQeAAaiAEQZi2AUHsxQEoAgARAQAgAEGQAWogBUGYtgFB7MUBKAIAEQEAIABBwAFqIAFBmLYBQezFASgCABEBACAAQfABaiACQZi2AUHsxQEoAgARAQAgA0GACWogA0HgD2ogA0HADWoQOyADQYAJaiADQYAJaiADQcAEakGYtgFB6MUBKAIAEQAAIAYgBiAPQZi2AUHoxQEoAgARAAAgBCAEIAxBmLYBQejFASgCABEAACAFIAUgDkGYtgFB6MUBKAIAEQAAIAEgASAJQZi2AUHoxQEoAgARAAAgAiACIAtBmLYBQejFASgCABEAACADQYAJaiADQYAJaiADQZi2AUHoxQEoAgARAAAgBiAGIA1BmLYBQejFASgCABEAACAEIAQgCEGYtgFB6MUBKAIAEQAAIAUgBSAKQZi2AUHoxQEoAgARAAAgASABIAdBmLYBQejFASgCABEAACACIAIgA0HgA2pBmLYBQejFASgCABEAACAAQaACaiADQYAJakGYtgFB7MUBKAIAEQEAIABB0AJqIAZBmLYBQezFASgCABEBACAAQYADaiAEQZi2AUHsxQEoAgARAQAgAEGwA2ogBUGYtgFB7MUBKAIAEQEAIABB4ANqIAFBmLYBQezFASgCABEBACAAQZAEaiACQZi2AUHsxQEoAgARAQAgA0HAE2okAAuHBQIKfwJ+IwAiBiENAkAgBCACTQRAIAEhCSACIQUgAyEBIAQhAgwBCyADIQkgBCEFCwJAIAAgCUcNACAGIAVBAnRBD2pBcHFrIgkiBiQAIAVFDQBBACEEA0AgCSAEQQJ0IgNqIAAgA2ooAgA2AgAgBEEBaiIEIAVHDQALCwJAIAAgAUcNACAGIAJBAnRBD2pBcHFrIgEiBiQAIAJFDQBBACEEA0AgASAEQQJ0IgNqIAAgA2ooAgA2AgAgBEEBaiIEIAJHDQALCwJAIAVFBEBBACEEDAELIAE1AgAhD0EAIQNBACEEA0AgACADQQJ0IgdqIAQgByAJajUCACAPfiIQp2oiBzYCACAQQiCIpyAHIARJaiEEIANBAWoiAyAFRw0ACwsgACAFQQJ0IgNqIgcgBDYCAAJAIAJBf2oiBEUNACAHQQRqQQAgBEECdBAWIAYgA0ETakFwcWsiByQAIAJBAkkNACAHIAVBAnRqIQxBASEGIAVFBEAgBUF/RiEBA0AgDEEANgIAIAFFBEAgACAGQQJ0aiIDIAMoAgAgBygCAGo2AgALIAZBAWoiBiACRw0ACwwBCyAFQX9GIQ4DQCABIAZBAnQiCmo1AgAhD0EAIQNBACEEA0AgByADQQJ0IghqIAQgCCAJajUCACAPfiIQp2oiCDYCACAQQiCIpyAIIARJaiEEIANBAWoiAyAFRw0ACyAMIAQ2AgAgDkUEQCAAIApqIQpBACEDQQAhBANAIAogBEECdCIIaiILIAsoAgAiCyADaiIDIAcgCGooAgBqIgg2AgAgCCADSSADIAtJaiEDIAQgBUchCCAEQQFqIQQgCA0ACwsgBkEBaiIGIAJHDQALCyANJAALpwwBCn8jAEHABGsiAyQAAkACQCABQcABaiIEQaDFASgCABEEAEUNACABQfABakGgxQEoAgARBABFDQAgACACQajFASgCABECACAAQTBqIAJBMGpBqMUBKAIAEQIAIABB4ABqIAJB4ABqQajFASgCABECACAAQZABaiACQZABakGoxQEoAgARAgAgAEHAAWogAkHAAWpBqMUBKAIAEQIAIABB8AFqIAJB8AFqQajFASgCABECAAwBCwJAIAJBwAFqQaDFASgCABEEAEUNACACQfABakGgxQEoAgARBABFDQAgACABQajFASgCABECACAAQTBqIAFBMGpBqMUBKAIAEQIAIABB4ABqIAFB4ABqQajFASgCABECACAAQZABaiABQZABakGoxQEoAgARAgAgAEHAAWogBEGoxQEoAgARAgAgAEHwAWogAUHwAWpBqMUBKAIAEQIADAELIANB4ABqIAIgAUGYtgFBuMUBKAIAEQAAIANBkAFqIgUgAkEwaiIIIAFBMGoiB0GYtgFBuMUBKAIAEQAAAkAgA0HgAGpBoMUBKAIAEQQARQ0AIAVBoMUBKAIAEQQARQ0AAkACQEGYxQEoAgAiBkUNACABKAJgIAIoAmBHDQFBASEEAkADQCAEIgUgBkYNASAFQQFqIQQgASAFQQJ0IgdqKAJgIAIgB2ooAmBGDQALIAUgBkkNAgsgASgCkAEgAigCkAFHDQFBASEEA0AgBCIFIAZGDQEgBUEBaiEEIAEgBUECdCIHaigCkAEgAiAHaigCkAFGDQALIAUgBkkNAQsgACABEBQMAgsgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwAgAEHgAGpBpMUBKAIAEQMAIABBkAFqQaTFASgCABEDACAAQcABakGkxQEoAgARAwAgAEHwAWpBpMUBKAIAEQMADAELIAMgAkHgAGogAUHgAGoiCUGYtgFBuMUBKAIAEQAAIANBMGoiBiACQZABaiABQZABaiIKQZi2AUG4xQEoAgARAAAgA0GAA2ogA0HgAGpB1MUBKAIAEQIAIANBwAFqIAVB1MUBKAIAEQIAIANBgANqIANBgANqIANBwAFqQfjFASgCABEFABogA0HQAmogA0GAA2pBmLYBQezFASgCABEBACADQdACaiADQdACakGUtgFByMUBKAIAEQEAIANBwAFqIANB4ABqIANB0AJqQZi2AUG8xQEoAgARAAAgA0HwAWoiBCAFIANB0AJqQZi2AUG8xQEoAgARAAAgBCAEQZi2AUGwxQEoAgARAQAgA0GAA2ogAyADQcABakGIxQEoAgARAQAgA0HgAGogA0GAA2pBmLYBQezFASgCABEBACAFIANB4ANqIgtBmLYBQezFASgCABEBACADQYADakGIwwFBqMUBKAIAEQIAIANBsANqIgxBpMUBKAIAEQMAIABBwAFqIANBgANqQajFASgCABECACAAQfABaiAMQajFASgCABECACADQYADaiAFQZi2AUHExQEoAgARAQAgA0GAA2ogA0GAA2ogA0HgAGpBmLYBQbzFASgCABEAACADQdACaiADQeAAaiAFQZi2AUG0xQEoAgARAAAgA0GgAmogA0HgAGogBUGYtgFBuMUBKAIAEQAAIANBwAFqIANB0AJqIANBoAJqQZi2AUG8xQEoAgARAAAgBCADQYADakGoxQEoAgARAgAgA0HAAWogA0HAAWogAUGYtgFBuMUBKAIAEQAAIAQgBCAHQZi2AUG4xQEoAgARAAAgA0HAAWogA0HAAWogAkGYtgFBuMUBKAIAEQAAIAQgBCAIQZi2AUG4xQEoAgARAAAgAyABIANBwAFqQZi2AUG4xQEoAgARAAAgBiAHIARBmLYBQbjFASgCABEAACADQYADaiADIANB4ABqQYjFASgCABEBACADIANBgANqQZi2AUHsxQEoAgARAQAgBiALQZi2AUHsxQEoAgARAQAgAEHgAGogAyAJQZi2AUG4xQEoAgARAAAgAEGQAWogBiAKQZi2AUG4xQEoAgARAAAgACADQcABakGoxQEoAgARAgAgAEEwaiAEQajFASgCABECAAsgA0HABGokAAvYFQEKfyMAQYAGayIDJAACQAJAIAFBwAFqIgRBoMUBKAIAEQQARQ0AIAFB8AFqQaDFASgCABEEAEUNACAAIAJBqMUBKAIAEQIAIABBMGogAkEwakGoxQEoAgARAgAgAEHgAGogAkHgAGpBqMUBKAIAEQIAIABBkAFqIAJBkAFqQajFASgCABECACAAQcABaiACQcABakGoxQEoAgARAgAgAEHwAWogAkHwAWpBqMUBKAIAEQIADAELAkAgAkHAAWpBoMUBKAIAEQQARQ0AIAJB8AFqQaDFASgCABEEAEUNACAAIAFBqMUBKAIAEQIAIABBMGogAUEwakGoxQEoAgARAgAgAEHgAGogAUHgAGpBqMUBKAIAEQIAIABBkAFqIAFBkAFqQajFASgCABECACAAQcABaiAEQajFASgCABECACAAQfABaiABQfABakGoxQEoAgARAgAMAQsgAUHAAWohBgJAAkACQAJAQZjFASgCACIHRQ0AIAYoAgBBiMMBKAIARgRAQQEhBANAIAQiBSAHRg0CIAVBAWohBCABIAVBAnQiCGooAsABIAhBiMMBaigCAEYNAAsgBSAHTw0BCyACQcABaiEIDAELIAJBwAFqIQggAUHwAWpBoMUBKAIAEQQAIQpBmMUBKAIAIgdFDQELIAIoAsABQYjDASgCAEcNAUEBIQQDQCAEIgUgB0YNASAFQQFqIQQgAiAFQQJ0IglqKALAASAJQYjDAWooAgBGDQALIAUgB0kNAQsgAkHwAWpBoMUBKAIAEQQAIQsLAkAgCwRAIANBgANqIAFBqMUBKAIAEQIAIANBsANqIAFBMGpBqMUBKAIAEQIAIANBoAJqIAFB4ABqQajFASgCABECACADQdACaiABQZABakGoxQEoAgARAgAMAQsgA0HABGogASAIQYjFASgCABEBACADQYADaiADQcAEakGYtgFB7MUBKAIAEQEAIANBsANqIANBoAVqIgRBmLYBQezFASgCABEBACADQcAEaiABQeAAaiAIQYjFASgCABEBACADQaACaiADQcAEakGYtgFB7MUBKAIAEQEAIANB0AJqIARBmLYBQezFASgCABEBAAsCQCAKBEAgA0HgAGogAkHgAGpBqMUBKAIAEQIAIANBkAFqIAJBkAFqQajFASgCABECACADQcABaiACQajFASgCABECACADQfABaiACQTBqQajFASgCABECAAwBCyADQcAEaiACQeAAaiAGQYjFASgCABEBACADQeAAaiADQcAEakGYtgFB7MUBKAIAEQEAIANBkAFqIANBoAVqIgRBmLYBQezFASgCABEBACADQcAEaiACIAZBiMUBKAIAEQEAIANBwAFqIANBwARqQZi2AUHsxQEoAgARAQAgA0HwAWogBEGYtgFB7MUBKAIAEQEACyADQcABaiADQcABaiADQYADakGYtgFBuMUBKAIAEQAAIANB8AFqIgUgBSADQbADaiIHQZi2AUG4xQEoAgARAAACQCADQcABakGgxQEoAgARBABFDQAgBUGgxQEoAgARBABFDQACQAJAQZjFASgCACIFRQ0AIAMoAmAgAygCoAJHDQFBASECAkADQCACIgQgBUYNASAEQQFqIQIgBEECdCIGIANB4ABqaigCACADQaACaiAGaigCAEYNAAsgBCAFSQ0CCyADKAKQASADKALQAkcNAUEBIQIDQCACIgQgBUYNASAEQQFqIQIgAyAEQQJ0IgZqKAKQASADIAZqKALQAkYNAAsgBCAFSQ0BCyAAIAEQEAwCCyAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwAgAEGQAWpBpMUBKAIAEQMAIABBwAFqQaTFASgCABEDACAAQfABakGkxQEoAgARAwAMAQsgAEHgAGoiBCADQeAAaiADQaACakGYtgFBuMUBKAIAEQAAIABBkAFqIgkgA0GQAWoiDCADQdACakGYtgFBuMUBKAIAEQAAIANBwARqIAlBmLYBQcTFASgCABEBACADQcAEaiADQcAEaiAEQZi2AUG8xQEoAgARAAAgAyAEIAlBmLYBQbTFASgCABEAACADQZAEaiAEIAlBmLYBQbjFASgCABEAACADQeAAaiADIANBkARqQZi2AUG8xQEoAgARAAAgDCADQcAEakGoxQEoAgARAgAgA0HABGogBUGYtgFBxMUBKAIAEQEAIANBwARqIANBwARqIANBwAFqQZi2AUG8xQEoAgARAAAgA0GQBGogA0HAAWogBUGYtgFBtMUBKAIAEQAAIANB4ANqIANBwAFqIAVBmLYBQbjFASgCABEAACADIANBkARqIANB4ANqQZi2AUG8xQEoAgARAAAgA0EwaiIFIANBwARqQajFASgCABECACADQcAEaiADQYADaiADQYjFASgCABEBACADQYADaiADQcAEakGYtgFB7MUBKAIAEQEAIAcgA0GgBWoiCUGYtgFB7MUBKAIAEQEAIANBwARqIAMgA0HAAWpBiMUBKAIAEQEAIAMgA0HABGpBmLYBQezFASgCABEBACAFIAlBmLYBQezFASgCABEBAAJAAkACQCALRQRAIApFDQEgAEHAAWogCEGoxQEoAgARAgAgAEHwAWogAkHwAWpBqMUBKAIAEQIADAILIABBwAFqIgIgBkGoxQEoAgARAgAgAEHwAWoiBiABQfABakGoxQEoAgARAgAgCkUNASACIANBqMUBKAIAEQIAIAYgBUGoxQEoAgARAgAMAgsgA0HABGogBiAIQYjFASgCABEBACAAQcABaiADQcAEakGYtgFB7MUBKAIAEQEAIABB8AFqIANBoAVqQZi2AUHsxQEoAgARAQALIANBwARqIANB4ABqIABBwAFqIgFBiMUBKAIAEQEAIANB4ABqIANBwARqQZi2AUHsxQEoAgARAQAgA0GQAWogA0GgBWoiAkGYtgFB7MUBKAIAEQEAIANBwARqIAEgA0GIxQEoAgARAQAgASADQcAEakGYtgFB7MUBKAIAEQEAIABB8AFqIAJBmLYBQezFASgCABEBAAsgA0HgAGogA0HgAGogA0GYtgFBuMUBKAIAEQAAIANBkAFqIgEgASAFQZi2AUG4xQEoAgARAAAgA0HABGogAyADQaACakGIxQEoAgARAQAgAyADQcAEakGYtgFB7MUBKAIAEQEAIAUgA0GgBWoiAkGYtgFB7MUBKAIAEQEAIANB4ABqIANB4ABqIANBgANqQZi2AUG4xQEoAgARAAAgASABIAdBmLYBQbjFASgCABEAACADQeAAaiADQeAAaiADQYADakGYtgFBuMUBKAIAEQAAIAEgASAHQZi2AUG4xQEoAgARAAAgA0HABGogA0HAAWogA0HgAGpBiMUBKAIAEQEAIAAgA0HABGpBmLYBQezFASgCABEBACAAQTBqIAJBmLYBQezFASgCABEBACADQYADaiADQYADaiADQeAAakGYtgFBuMUBKAIAEQAAIAcgByAMQZi2AUG4xQEoAgARAAAgA0HABGogBCADQYADakGIxQEoAgARAQAgBCADQcAEakGYtgFB7MUBKAIAEQEAIABBkAFqIgAgAkGYtgFB7MUBKAIAEQEAIAQgBCADQZi2AUG4xQEoAgARAAAgACAAIAVBmLYBQbjFASgCABEAAAsgA0GABmokAAu/GQEJfyMAQYAGayIDJAACQAJAIAFBwAFqIgRBoMUBKAIAEQQARQ0AIAFB8AFqQaDFASgCABEEAEUNACAAIAJBqMUBKAIAEQIAIABBMGogAkEwakGoxQEoAgARAgAgAEHgAGogAkHgAGpBqMUBKAIAEQIAIABBkAFqIAJBkAFqQajFASgCABECACAAQcABaiACQcABakGoxQEoAgARAgAgAEHwAWogAkHwAWpBqMUBKAIAEQIADAELAkAgAkHAAWpBoMUBKAIAEQQARQ0AIAJB8AFqQaDFASgCABEEAEUNACAAIAFBqMUBKAIAEQIAIABBMGogAUEwakGoxQEoAgARAgAgAEHgAGogAUHgAGpBqMUBKAIAEQIAIABBkAFqIAFBkAFqQajFASgCABECACAAQcABaiAEQajFASgCABECACAAQfABaiABQfABakGoxQEoAgARAgAMAQsgAUHAAWohBgJAAkACQAJAQZjFASgCACIJRQ0AIAYoAgBBiMMBKAIARgRAQQEhBANAIAQiBSAJRg0CIAVBAWohBCABIAVBAnQiB2ooAsABIAdBiMMBaigCAEYNAAsgBSAJTw0BCyACQcABaiEHDAELIAJBwAFqIQcgAUHwAWpBoMUBKAIAEQQAIQhBmMUBKAIAIglFDQELIAIoAsABQYjDASgCAEcNAUEBIQQDQCAEIgUgCUYNASAFQQFqIQQgAiAFQQJ0IgtqKALAASALQYjDAWooAgBGDQALIAUgCUkNAQsgAkHwAWpBoMUBKAIAEQQAIQoLIAhFBEAgA0HABGogAUHwAWoiBEGYtgFBxMUBKAIAEQEAIANBwARqIANBwARqIAZBmLYBQbzFASgCABEAACADQaACaiAGIARBmLYBQbTFASgCABEAACADQcABaiAGIARBmLYBQbjFASgCABEAACADQYADaiADQaACaiADQcABakGYtgFBvMUBKAIAEQAAIANBsANqIANBwARqQajFASgCABECAAsCQCAKBEAgA0GgAmogAUGoxQEoAgARAgAgA0HQAmogAUEwakGoxQEoAgARAgACQCAIBEAgA0HgAGogAkGoxQEoAgARAgAgA0GQAWogAkEwakGoxQEoAgARAgAMAQsgA0HABGogAiADQYADakGIxQEoAgARAQAgA0HgAGogA0HABGpBmLYBQezFASgCABEBACADQZABaiADQaAFakGYtgFB7MUBKAIAEQEACyADQeAAaiADQeAAaiADQaACakGYtgFBuMUBKAIAEQAAIANBkAFqIgQgBCADQdACakGYtgFBuMUBKAIAEQAAIANBwAFqIAFB4ABqQajFASgCABECACADQfABaiABQZABakGoxQEoAgARAgAMAQsgA0HABGogAkHwAWoiBEGYtgFBxMUBKAIAEQEAIANBwARqIANBwARqIAdBmLYBQbzFASgCABEAACADQaACaiAHIARBmLYBQbTFASgCABEAACADQeAAaiAHIARBmLYBQbjFASgCABEAACADQcABaiADQaACaiADQeAAakGYtgFBvMUBKAIAEQAAIANB8AFqIANBwARqQajFASgCABECACADQcAEaiABIANBwAFqQYjFASgCABEBACADQaACaiADQcAEakGYtgFB7MUBKAIAEQEAIANB0AJqIgQgA0GgBWoiBUGYtgFB7MUBKAIAEQEAAkAgCARAIANB4ABqIAJBqMUBKAIAEQIAIANBkAFqIAJBMGpBqMUBKAIAEQIADAELIANBwARqIAIgA0GAA2pBiMUBKAIAEQEAIANB4ABqIANBwARqQZi2AUHsxQEoAgARAQAgA0GQAWogBUGYtgFB7MUBKAIAEQEACyADQeAAaiADQeAAaiADQaACakGYtgFBuMUBKAIAEQAAIANBkAFqIgUgBSAEQZi2AUG4xQEoAgARAAAgA0HABGogA0HAAWogB0GIxQEoAgARAQAgA0HAAWogA0HABGpBmLYBQezFASgCABEBACADQfABaiIEIANBoAVqIgVBmLYBQezFASgCABEBACADQcAEaiADQcABaiABQeAAakGIxQEoAgARAQAgA0HAAWogA0HABGpBmLYBQezFASgCABEBACAEIAVBmLYBQezFASgCABEBAAsCQCAIBEAgA0GAA2ogAkHgAGpBqMUBKAIAEQIAIANBsANqIAJBkAFqQajFASgCABECAAwBCyADQcAEaiADQYADaiAGQYjFASgCABEBACADQYADaiADQcAEakGYtgFB7MUBKAIAEQEAIANBsANqIgQgA0GgBWoiBUGYtgFB7MUBKAIAEQEAIANBwARqIANBgANqIAJB4ABqQYjFASgCABEBACADQYADaiADQcAEakGYtgFB7MUBKAIAEQEAIAQgBUGYtgFB7MUBKAIAEQEACyADQYADaiADQYADaiADQcABakGYtgFBuMUBKAIAEQAAIANBsANqIgIgAiADQfABakGYtgFBuMUBKAIAEQAAAkAgA0HgAGpBoMUBKAIAEQQARQ0AIANBkAFqQaDFASgCABEEAEUNAAJAIANBgANqQaDFASgCABEEAEUNACACQaDFASgCABEEAEUNACAAIAEQEQwCCyAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwAgAEGQAWpBpMUBKAIAEQMAIABBwAFqQaTFASgCABEDACAAQfABakGkxQEoAgARAwAMAQsCQCAIBEAgCgRAIABBwAFqIANB4ABqQajFASgCABECACAAQfABaiADQZABakGoxQEoAgARAgAMAgsgA0HABGogA0HgAGogB0GIxQEoAgARAQAgAEHAAWogA0HABGpBmLYBQezFASgCABEBACAAQfABaiADQaAFakGYtgFB7MUBKAIAEQEADAELIABBwAFqIQEgCgRAIANBwARqIAYgA0HgAGpBiMUBKAIAEQEAIAEgA0HABGpBmLYBQezFASgCABEBACAAQfABaiADQaAFakGYtgFB7MUBKAIAEQEADAELIANBwARqIAYgB0GIxQEoAgARAQAgASADQcAEakGYtgFB7MUBKAIAEQEAIABB8AFqIgIgA0GgBWoiBEGYtgFB7MUBKAIAEQEAIANBwARqIAEgA0HgAGpBiMUBKAIAEQEAIAEgA0HABGpBmLYBQezFASgCABEBACACIARBmLYBQezFASgCABEBAAsgA0HABGogA0GQAWoiAUGYtgFBxMUBKAIAEQEAIANBwARqIANBwARqIANB4ABqQZi2AUG8xQEoAgARAAAgA0GQBGogA0HgAGogAUGYtgFBtMUBKAIAEQAAIANB4ANqIANB4ABqIAFBmLYBQbjFASgCABEAACADIANBkARqIANB4ANqQZi2AUG8xQEoAgARAAAgA0EwaiIFIANBwARqQajFASgCABECACADQcAEaiADQbADaiIBQZi2AUHExQEoAgARAQAgA0HABGogA0HABGogA0GAA2pBmLYBQbzFASgCABEAACADQZAEaiADQYADaiABQZi2AUG0xQEoAgARAAAgA0HgA2ogA0GAA2ogAUGYtgFBuMUBKAIAEQAAIABB4ABqIgEgA0GQBGogA0HgA2pBmLYBQbzFASgCABEAACAAQZABaiICIANBwARqQajFASgCABECACADQcAEaiADQaACaiADQYjFASgCABEBACADQaACaiADQcAEakGYtgFB7MUBKAIAEQEAIANB0AJqIgQgA0GgBWoiBkGYtgFB7MUBKAIAEQEAIANBwARqIAMgA0HgAGpBiMUBKAIAEQEAIAMgA0HABGpB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aiIBIANBMGogA0GQAWpBmLYBQbjFASgCABEAACADQTBqIAFBmLYBQcDFASgCABEBACADIANB4ABqQZi2AUHAxQEoAgARAQAgA0HAAWogA0HAAWogA0GYtgFBvMUBKAIAEQAAIAMgAyADQeAAakGYtgFBvMUBKAIAEQAAAkACQAJAIARFBEAgBkUNASAAQeAAaiAFQajFASgCABECAAwCCyAAQeAAaiICIAhBqMUBKAIAEQIAIAZFDQEgAiADQajFASgCABECAAwCCyAAQeAAaiAIIAVBmLYBQbzFASgCABEAAAsgA0EwaiADQTBqIABB4ABqIgJBmLYBQbzFASgCABEAACACIAIgA0GYtgFBvMUBKAIAEQAACyADQTBqIANBMGogA0GYtgFBuMUBKAIAEQAAIAMgAyADQZABakGYtgFBvMUBKAIAEQAAIANBMGogA0EwaiADQcABakGYtgFBuMUBKAIAEQAAIANBMGogA0EwaiADQcABakGYtgFBuMUBKAIAEQAAIAAgA0HgAGogA0EwakGYtgFBvMUBKAIAEQAAIANBwAFqIANBwAFqIANBMGpBmLYBQbjFASgCABEAACABIAEgA0HAAWpBmLYBQbzFASgCABEAACABIAEgA0GYtgFBuMUBKAIAEQAACyADQfABaiQAC9YKAQd/IwBB8AFrIgMkAAJAIAFB4ABqIgRBoMUBKAIAEQQABEAgACACQajFASgCABECACAAQTBqIAJBMGpBqMUBKAIAEQIAIABB4ABqIAJB4ABqQajFASgCABECAAwBCyACQeAAakGgxQEoAgARBAAEQCAAIAFBqMUBKAIAEQIAIABBMGogAUEwakGoxQEoAgARAgAgAEHgAGogBEGoxQEoAgARAgAMAQsgAUHgAGohBwJ/QZjFASgCACIFRQRAQQEhBkEBDAELQYjDASgCACIJIAcoAgBGBEBBASEIA0ACQCAFIAgiBEYEQCAFIQQMAQsgBEEBaiEIIAEgBEECdCIGaigCYCAGQYjDAWooAgBGDQELCyAEIAVPIQYLQQAgAigCYCAJRw0AGkEBIQgDQAJAIAUgCCIERgRAIAUhBAwBCyAEQQFqIQggAiAEQQJ0IglqKAJgIAlBiMMBaigCAEYNAQsLIAQgBU8LIQQgBkUEQCADQcABaiAHQZi2AUHAxQEoAgARAQALIAJB4ABqIQUCQCAEBEAgA0GQAWogAUGoxQEoAgARAgACQCAGBEAgA0EwaiACQajFASgCABECAAwBCyADQTBqIAIgA0HAAWpBmLYBQbzFASgCABEAAAsgA0EwaiADQTBqIANBkAFqQZi2AUG4xQEoAgARAAAgA0HgAGogAUEwakGoxQEoAgARAgAMAQsgA0HgAGogBUGYtgFBwMUBKAIAEQEAIANBkAFqIAEgA0HgAGpBmLYBQbzFASgCABEAAAJAIAYEQCADQTBqIAJBqMUBKAIAEQIADAELIANBMGogAiADQcABakGYtgFBvMUBKAIAEQAACyADQTBqIANBMGogA0GQAWpBmLYBQbjFASgCABEAACADQeAAaiADQeAAaiAFQZi2AUG8xQEoAgARAAAgA0HgAGogA0HgAGogAUEwakGYtgFBvMUBKAIAEQAACwJAIAYEQCADQcABaiACQTBqQajFASgCABECAAwBCyADQcABaiADQcABaiAHQZi2AUG8xQEoAgARAAAgA0HAAWogA0HAAWogAkEwakGYtgFBvMUBKAIAEQAACyADQcABaiADQcABaiADQeAAakGYtgFBuMUBKAIAEQAAIANBMGpBoMUBKAIAEQQABEAgA0HAAWpBoMUBKAIAEQQABEAgACABEBMMAgsgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwAgAEHgAGpBpMUBKAIAEQMADAELAkAgBgRAIAQEQCAAQeAAaiADQTBqQajFASgCABECAAwCCyAAQeAAaiADQTBqIAVBmLYBQbzFASgCABEAAAwBCyAAQeAAaiEBQbzFASgCACECIAQEQCABIAcgA0EwakGYtgEgAhEAAAwBCyABIAcgBUGYtgEgAhEAACABIAEgA0EwakGYtgFBvMUBKAIAEQAACyADIANBMGpBmLYBQcDFASgCABEBACAAQTBqIgEgA0HAAWpBmLYBQcDFASgCABEBACADQZABaiADQZABaiADQZi2AUG8xQEoAgARAAAgAyADIANBMGpBmLYBQbzFASgCABEAACABIAEgA0GQAWpBmLYBQbjFASgCABEAACABIAEgA0GQAWpBmLYBQbjFASgCABEAACAAIAEgA0GYtgFBuMUBKAIAEQAAIANBkAFqIANBkAFqIABBmLYBQbjFASgCABEAACADQZABaiADQZABaiADQcABakGYtgFBvMUBKAIAEQAAIAMgAyADQeAAakGYtgFBvMUBKAIAEQAAIAEgA0GQAWogA0GYtgFBuMUBKAIAEQAACyADQfABaiQAC7YLAQl/IwBBoAhrIgEkACABQcAEaiAAKAIQQYzFASgCABECACABQYADaiAAKAIUQYzFASgCABECACABQcABaiABQYADakGQxQEoAgARAgAgAUHAAWogAUHAAWogAUHABGpBmLYBQeTFASgCABEAACABQaACaiIEIAQgAUGgBWoiAkGYtgFB5MUBKAIAEQAAIAFBgAZqIAFBwAFqQZi2AUHsxQEoAgARAQAgAUGwBmoiByAEQZi2AUHsxQEoAgARAQAgAUHAB2ogACgCECIFIAAoAhQiA0GYtgFBtMUBKAIAEQAAIAFB8AdqIgYgBUEwaiADQTBqQZi2AUG0xQEoAgARAAAgAUHAAWogAUHAB2pBjMUBKAIAEQIAIAFBwARqIAFBwARqIAFBgANqQZi2AUHkxQEoAgARAAAgAiACIAFB4ANqIghBmLYBQeTFASgCABEAACABQcABaiABQcABaiABQcAEakGYtgFB6MUBKAIAEQAAIAQgBCACQZi2AUHoxQEoAgARAAAgAUHAB2ogAUHAAWpBmLYBQezFASgCABEBACAGIARBmLYBQezFASgCABEBACABQeAGaiAAKAIIIgMgACgCDCIJQZi2AUG0xQEoAgARAAAgAUGQB2oiBSADQTBqIAlBMGpBmLYBQbTFASgCABEAACABIAFB4AZqQYzFASgCABECACABQcABaiAAKAIIQYzFASgCABECACABQeAGaiABQcAHakGIxgEoAgARAgAgACgCCCIDIAMgAUHgBmpBmLYBQbTFASgCABEAACADQTBqIgMgAyAFQZi2AUG0xQEoAgARAAAgACgCCCIDIANBmLYBQcTFASgCABEBACADQTBqIgMgA0GYtgFBxMUBKAIAEQEAIAAoAggiAyADIAFB4AZqQZi2AUG0xQEoAgARAAAgA0EwaiIDIAMgBUGYtgFBtMUBKAIAEQAAIAFB4AZqIAFBgAZqIAAoAgwiA0GYtgFBuMUBKAIAEQAAIAUgByADQTBqQZi2AUG4xQEoAgARAAAgAUHgBmogAUHgBmpBmLYBQcTFASgCABEBACAFIAVBmLYBQcTFASgCABEBACABQYADaiAAKAIMQYzFASgCABECACAAKAIMIgMgAUHgBmogAUGABmpBmLYBQbTFASgCABEAACADQTBqIAUgB0GYtgFBtMUBKAIAEQAAIAFBwARqIAFBgANqQZDFASgCABECACABQcAEaiABQcAEaiABQcABakGYtgFB5MUBKAIAEQAAIAIgAiAEQZi2AUHkxQEoAgARAAAgAUHAB2ogAUHABGpBmLYBQezFASgCABEBACAGIAJBmLYBQezFASgCABEBACAAKAIQIgIgAUHAB2ogAkGYtgFBuMUBKAIAEQAAIAJBMGoiAiAGIAJBmLYBQbjFASgCABEAACAAKAIQIgIgAkGYtgFBxMUBKAIAEQEAIAJBMGoiAiACQZi2AUHExQEoAgARAQAgACgCECICIAIgAUHAB2pBmLYBQbTFASgCABEAACACQTBqIgIgAiAGQZi2AUG0xQEoAgARAAAgAUHAAWogAUHAAWogAUGAA2pB+MUBKAIAEQUAGiAEIAQgCEH4xQEoAgARBQAaIAEgASABQcABakGYtgFB6MUBKAIAEQAAIAFB4ABqIgIgAiAEQZi2AUHoxQEoAgARAAAgAUHAB2ogAUGYtgFB7MUBKAIAEQEAIAYgAkGYtgFB7MUBKAIAEQEAIAAoAhQiBCAEIAFBwAdqQZi2AUG0xQEoAgARAAAgBEEwaiIEIAQgBkGYtgFBtMUBKAIAEQAAIAAoAhQiBCAEQZi2AUHExQEoAgARAQAgBEEwaiIEIARBmLYBQcTFASgCABEBACAAKAIUIgAgACABQcAHakGYtgFBtMUBKAIAEQAAIABBMGoiACAAIAZBmLYBQbTFASgCABEAACABQaAIaiQAC7YYAQh/IwBBwARrIgIkAAJAAkAgAUHAAWoiBUGgxQEoAgARBABFDQAgAUHwAWpBoMUBKAIAEQQARQ0AIABBpMUBKAIAEQMAIABBMGpBpMUBKAIAEQMAIABB4ABqQaTFASgCABEDACAAQZABakGkxQEoAgARAwAgAEHAAWpBpMUBKAIAEQMAIABB8AFqQaTFASgCABEDAAwBCwJAAkBBmMUBKAIAIgdFDQAgBSgCAEGIwwEoAgBHDQFBASEEA0AgBCIDIAdGDQEgA0EBaiEEIAEgA0ECdCIIaigCwAEgCEGIwwFqKAIARg0ACyADIAdJDQELIAFB8AFqQaDFASgCABEEACEGCwJAAkACQAJAQZCCAigCAA4CAAECCyACQYADaiABQTBqIgNBmLYBQcTFASgCABEBACACQYADaiACQYADaiABQZi2AUG8xQEoAgARAAAgAkHgAGogASADQZi2AUG0xQEoAgARAAAgAiABIANBmLYBQbjFASgCABEAACACQcABaiACQeAAaiACQZi2AUG8xQEoAgARAAAgAkHwAWoiAyACQYADakGoxQEoAgARAgAgAkHgAGogAkHAAWogAkHAAWpBmLYBQbTFASgCABEAACACQZABaiIEIAMgA0GYtgFBtMUBKAIAEQAAIAJBwAFqIAJBwAFqIAJB4ABqQZi2AUG0xQEoAgARAAAgAyADIARBmLYBQbTFASgCABEAAAwCCyACQYADaiABQTBqIgNBmLYBQcTFASgCABEBACACQYADaiACQYADaiABQZi2AUG8xQEoAgARAAAgAkHgAGogASADQZi2AUG0xQEoAgARAAAgAiABIANBmLYBQbjFASgCABEAACACQcABaiACQeAAaiACQZi2AUG8xQEoAgARAAAgAkHwAWoiAyACQYADakGoxQEoAgARAgACQCAGBEAgAkHAAWogAkHAAWogBUGYtgFBuMUBKAIAEQAAIAMgAyABQfABakGYtgFBuMUBKAIAEQAADAELIAJBgANqIAFB8AFqIgRBmLYBQcTFASgCABEBACACQYADaiACQYADaiAFQZi2AUG8xQEoAgARAAAgAiAFIARBmLYBQbTFASgCABEAACACQdACaiAFIARBmLYBQbjFASgCABEAACACQeAAaiACIAJB0AJqQZi2AUG8xQEoAgARAAAgAkGQAWoiBCACQYADakGoxQEoAgARAgAgAkHAAWogAkHAAWogAkHgAGpBmLYBQbjFASgCABEAACADIAMgBEGYtgFBuMUBKAIAEQAACyACQeAAaiACQcABaiACQcABakGYtgFBtMUBKAIAEQAAIAJBkAFqIgQgAyADQZi2AUG0xQEoAgARAAAgAkHAAWogAkHAAWogAkHgAGpBmLYBQbTFASgCABEAACACQfABaiIDIAMgBEGYtgFBtMUBKAIAEQAADAELAkAgBgRAIAJBwAFqQZzGAUGoxQEoAgARAgAgAkHwAWpBzMYBQajFASgCABECAAwBCyACQYADaiABQfABaiIDQZi2AUHExQEoAgARAQAgAkGAA2ogAkGAA2ogBUGYtgFBvMUBKAIAEQAAIAJB4ABqIAUgA0GYtgFBtMUBKAIAEQAAIAIgBSADQZi2AUG4xQEoAgARAAAgAkHAAWogAkHgAGogAkGYtgFBvMUBKAIAEQAAIAJB8AFqIgMgAkGAA2pBqMUBKAIAEQIAIAJBgANqIAJBwAFqQZzGAUGIxQEoAgARAQAgAkHAAWogAkGAA2pBmLYBQezFASgCABEBACADIAJB4ANqQZi2AUHsxQEoAgARAQALIAJBgANqIAFBMGoiA0GYtgFBxMUBKAIAEQEAIAJBgANqIAJBgANqIAFBmLYBQbzFASgCABEAACACIAEgA0GYtgFBtMUBKAIAEQAAIAJB0AJqIAEgA0GYtgFBuMUBKAIAEQAAIAJB4ABqIAIgAkHQAmpBmLYBQbzFASgCABEAACACQZABaiIEIAJBgANqQajFASgCABECACACQcABaiACQcABaiACQeAAakGYtgFBtMUBKAIAEQAAIAJB8AFqIgMgAyAEQZi2AUG0xQEoAgARAAAgAkHAAWogAkHAAWogAkHgAGpBmLYBQbTFASgCABEAACADIAMgBEGYtgFBtMUBKAIAEQAAIAJBwAFqIAJBwAFqIAJB4ABqQZi2AUG0xQEoAgARAAAgAyADIARBmLYBQbTFASgCABEAAAsCQCAGBEAgAEHAAWogAUHgAGpBqMUBKAIAEQIAIABB8AFqIAFBkAFqQajFASgCABECAAwBCyACQYADaiABQeAAaiAFQYjFASgCABEBACAAQcABaiACQYADakGYtgFB7MUBKAIAEQEAIABB8AFqIAJB4ANqQZi2AUHsxQEoAgARAQALIAJBgANqIABBwAFqIgQgAUGIxQEoAgARAQAgAkHgAGogAkGAA2pBmLYBQezFASgCABEBACACQZABaiIDIAJB4ANqIgdBmLYBQezFASgCABEBACACQYADaiACQeAAaiABQeAAaiIIQYjFASgCABEBACACQeAAaiACQYADakGYtgFB7MUBKAIAEQEAIAMgB0GYtgFB7MUBKAIAEQEAIAJB4ABqIAJB4ABqIAJB4ABqQZi2AUG0xQEoAgARAAAgAyADIANBmLYBQbTFASgCABEAACACQeAAaiACQeAAaiACQeAAakGYtgFBtMUBKAIAEQAAIAMgAyADQZi2AUG0xQEoAgARAAAgAkGAA2ogAkHwAWoiBUGYtgFBxMUBKAIAEQEAIAJBgANqIAJBgANqIAJBwAFqQZi2AUG8xQEoAgARAAAgAkHQAmogAkHAAWogBUGYtgFBtMUBKAIAEQAAIAJBoAJqIAJBwAFqIAVBmLYBQbjFASgCABEAACACIAJB0AJqIAJBoAJqQZi2AUG8xQEoAgARAAAgAkEwaiIGIAJBgANqQajFASgCABECACACIAIgAkHgAGpBmLYBQbjFASgCABEAACAGIAYgA0GYtgFBuMUBKAIAEQAAIAIgAiACQeAAakGYtgFBuMUBKAIAEQAAIAYgBiADQZi2AUG4xQEoAgARAAAgAkGAA2ogAiAEQYjFASgCABEBACAAIAJBgANqQZi2AUHsxQEoAgARAQAgAEEwaiIJIAdBmLYBQezFASgCABEBACACQeAAaiACQeAAaiACQZi2AUG4xQEoAgARAAAgAyADIAZBmLYBQbjFASgCABEAACACQYADaiACQeAAaiACQcABakGIxQEoAgARAQAgAkHgAGogAkGAA2pBmLYBQezFASgCABEBACADIAdBmLYBQezFASgCABEBACACQYADaiABQZABaiIBQZi2AUHExQEoAgARAQAgAkGAA2ogAkGAA2ogCEGYtgFBvMUBKAIAEQAAIAJB0AJqIAggAUGYtgFBtMUBKAIAEQAAIAJBoAJqIAggAUGYtgFBuMUBKAIAEQAAIAJBwAFqIAJB0AJqIAJBoAJqQZi2AUG8xQEoAgARAAAgBSACQYADakGoxQEoAgARAgAgACAAIABBmLYBQbTFASgCABEAACAJIAkgCUGYtgFBtMUBKAIAEQAAIAQgBCAEQZi2AUG0xQEoAgARAAAgAEHwAWoiASABIAFBmLYBQbTFASgCABEAACACQYADaiABQZi2AUHExQEoAgARAQAgAkGAA2ogAkGAA2ogBEGYtgFBvMUBKAIAEQAAIAJB0AJqIAQgAUGYtgFBtMUBKAIAEQAAIAJBoAJqIAQgAUGYtgFBuMUBKAIAEQAAIAIgAkHQAmogAkGgAmpBmLYBQbzFASgCABEAACAGIAJBgANqQajFASgCABECACACQYADaiACQcABaiACQYjFASgCABEBACACQcABaiACQYADakGYtgFB7MUBKAIAEQEAIAUgB0GYtgFB7MUBKAIAEQEAIAJBgANqIAQgAkGI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QZi2AUHExQEoAgARAQAgAkEwaiIDIAVBmLYBQcTFASgCABEBACACQaACaiACQaACaiACQZi2AUG0xQEoAgARAAAgAkHQAmoiCCAIIANBmLYBQbTFASgCABEAAAwBCwJAIAkEQCACQZzGAUGoxQEoAgARAgAgAkEwakHMxgFBqMUBKAIAEQIADAELIAJB4ANqIAFB8AFqIgNBmLYBQcTFASgCABEBACACQeADaiACQeADaiAHQZi2AUG8xQEoAgARAAAgAkGwA2ogByADQZi2AUG0xQEoAgARAAAgAkGAA2ogByADQZi2AUG4xQEoAgARAAAgAiACQbADaiACQYADakGYtgFBvMUBKAIAEQAAIAJBMGoiAyACQeADakGoxQEoAgARAgAgAkHgA2ogA0GYtgFBxMUBKAIAEQEAIAJB4ANqIAJB4ANqIAJBmLYBQbzFASgCABEAACACQbADaiACIANBmLYBQbTFASgCABEAACACQYADaiACIANBmLYBQbjFASgCABEAACACIAJBsANqIAJBgANqQZi2AUG8xQEoAgARAAAgAyACQeADakGoxQEoAgARAgAgAkHgA2ogAkGcxgFBiMUBKAIAEQEAIAIgAkHgA2pBmLYBQezFASgCABEBACADIAJBwARqQZi2AUHsxQEoAgARAQALIAIgAiACQaACakGYtgFBtMUBKAIAEQAAIAJBMGoiAyADIAVBmLYBQbTFASgCABEAACACQaACaiACQaACakGYtgFBxMUBKAIAEQEAIAUgBUGYtgFBxMUBKAIAEQEAIAJBoAJqIAJBoAJqIAJBmLYBQbTFASgCABEAACACQdACaiIIIAggA0GYtgFBtMUBKAIAEQAACyACQeADaiAFQZi2AUHExQEoAgARAQAgAkHgA2ogAkHgA2ogAkGgAmpBmLYBQbzFASgCABEAACACQbADaiACQaACaiAFQZi2AUG0xQEoAgARAAAgAkGAA2ogAkGgAmogBUGYtgFBuMUBKAIAEQAAIAAgAkGwA2ogAkGAA2pBmLYBQbzFASgCABEAACAAQTBqIgUgAkHgA2pBqMUBKAIAEQIAIAAgACACQeAAakGYtgFBuMUBKAIAEQAAIAUgBSAEQZi2AUG4xQEoAgARAAAgACAAIAJB4ABqQZi2AUG4xQEoAgARAAAgBSAFIARBmLYBQbjFASgCABEAAAJAIAkEQCAAQcABaiAKQajFASgCABECACAAQfABaiABQZABakGoxQEoAgARAgAMAQsgAkHgA2ogCiAHQYjFASgCABEBACAAQcABaiACQeADakGYtgFB7MUBKAIAEQEAIABB8AFqIAJBwARqQZi2AUHsxQEoAgARAQALIABBwAFqIgEgAUGYtgFBxMUBKAIAEQEAIABB8AFqIgEgAUGYtgFBxMUBKAIAEQEAIABB4ABqIgEgAkHgAGogAEGYtgFBuMUBKAIAEQAAIABBkAFqIgAgBCAFQZi2AUG4xQEoAgARAAAgAkHgA2ogASACQaACakGIxQEoAgARAQAgASACQeADakGYtgFB7MUBKAIAEQEAIAAgAkHABGpBmLYBQezFASgCABEBACACQcABaiACQcABakGYtgFBxMUBKAIAEQEAIAYgBkGYtgFBxMUBKAIAEQEAIAJBwAFqIAJBwAFqQZi2AUHExQEoAgARAQAgBiAGQZi2AUHExQEoAgARAQAgAkHAAWogAkHAAWpBmLYBQcTFASgCABEBACAGIAZBmLYBQcTFASgCABEBACABIAEgAkHAAWpBmLYBQbjFASgCABEAACAAIAAgBkGYtgFBuMUBKAIAEQAACyACQaAFaiQAC90IAQZ/IwBBkAFrIgIkAAJAIAFB4ABqIgRBoMUBKAIAEQQABEAgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwAgAEHgAGpBpMUBKAIAEQMADAELAn9BAUGYxQEoAgAiBUUNABpBACAEKAIAQYjDASgCAEcNABpBASEGA0ACQCAFIAYiA0YEQCAFIQMMAQsgA0EBaiEGIAEgA0ECdCIHaigCYCAHQYjDAWooAgBGDQELCyADIAVPCyEDAkACQAJAAkBB2IECKAIADgIAAQILIAJB4ABqIAFBmLYBQcDFASgCABEBACACQTBqIAJB4ABqIAJB4ABqQZi2AUG0xQEoAgARAAAMAgsgAkHgAGogAUGYtgFBwMUBKAIAEQEAAkAgAwRAIAJB4ABqIAJB4ABqIARBmLYBQbjFASgCABEAAAwBCyACQTBqIARBmLYBQcDFASgCABEBACACQeAAaiACQeAAaiACQTBqQZi2AUG4xQEoAgARAAALIAJBMGogAkHgAGogAkHgAGpBmLYBQbTFASgCABEAAAwBCwJAIAMEQCACQeAAakG42QFBqMUBKAIAEQIADAELIAJB4ABqIARBmLYBQcDFASgCABEBACACQeAAaiACQeAAakG42QFBmLYBQbzFASgCABEAAAsgAkEwaiABQZi2AUHAxQEoAgARAQAgAkHgAGogAkHgAGogAkEwakGYtgFBtMUBKAIAEQAAIAJB4ABqIAJB4ABqIAJBMGpBmLYBQbTFASgCABEAAAsgAkHgAGogAkHgAGogAkEwakGYtgFBtMUBKAIAEQAAAkAgAwRAIABB4ABqIAFBMGpBqMUBKAIAEQIADAELIABB4ABqIAFBMGogBEGYtgFBvMUBKAIAEQAACyACQTBqIABB4ABqIgMgAUGYtgFBvMUBKAIAEQAAIAJBMGogAkEwaiABQTBqIgFBmLYBQbzFASgCABEAACACQTBqIAJBMGogAkEwakGYtgFBtMUBKAIAEQAAIAJBMGogAkEwaiACQTBqQZi2AUG0xQEoAgARAAAgAiACQeAAakGYtgFBwMUBKAIAEQEAIAIgAiACQTBqQZi2AUG4xQEoAgARAAAgAiACIAJBMGpBmLYBQbjFASgCABEAACAAIAIgA0GYtgFBvMUBKAIAEQAAIAJBMGogAkEwaiACQZi2AUG4xQEoAgARAAAgAkEwaiACQTBqIAJB4ABqQZi2AUG8xQEoAgARAAAgAkHgAGogAUGYtgFBwMUBKAIAEQEAIAAgACAAQZi2AUG0xQEoAgARAAAgAyADIANBmLYBQbTFASgCABEAACACIANBmLYBQcDFASgCABEBACACQeAAaiACQeAAaiACQZi2AUG8xQEoAgARAAAgAyADIAJBmLYBQbzFASgCABEAACAAQTBqIgAgAkEwaiACQeAAakGYtgFBuMUBKAIAEQAAIAAgACACQeAAakGYtgFBuMUBKAIAEQAACyACQZABaiQAC5IIAQZ/IwBBwAFrIgIkAAJAIAFB4ABqIgVBoMUBKAIAEQQABEAgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwAgAEHgAGpBpMUBKAIAEQMADAELAn9BAUGYxQEoAgAiBEUNABpBACAFKAIAQYjDASgCAEcNABpBASEGA0ACQCAEIAYiA0YEQCAEIQMMAQsgA0EBaiEGIAEgA0ECdCIHaigCYCAHQYjDAWooAgBGDQELCyADIARPCyEDIAJBkAFqIAFBmLYBQcDFASgCABEBACACQeAAaiABQTBqIgRBmLYBQcDFASgCABEBACACQTBqIAEgAkHgAGpBmLYBQbTFASgCABEAACACQeAAaiACQeAAakGYtgFBwMUBKAIAEQEAIAJBMGogAkEwakGYtgFBwMUBKAIAEQEAIAJBMGogAkEwaiACQZABakGYtgFBuMUBKAIAEQAAIAJBMGogAkEwaiACQeAAakGYtgFBuMUBKAIAEQAAIAJBMGogAkEwaiACQTBqQZi2AUG0xQEoAgARAAACQAJAAkACQEHYgQIoAgAOAgABAgsgAiACQZABakGYtgFBxMUBKAIAEQEADAILAkAgAwRAIAJBkAFqIAJBkAFqIAVBmLYBQbjFASgCABEAAAwBCyACIAVBmLYBQcDFASgCABEBACACIAJBmLYBQcDFASgCABEBACACQZABaiACQZABaiACQZi2AUG4xQEoAgARAAALIAIgAkGQAWpBmLYBQcTFASgCABEBAAwBCwJAIAMEQCACQbjZAUGoxQEoAgARAgAMAQsgAiAFQZi2AUHAxQEoAgARAQAgAiACQZi2AUHAxQEoAgARAQAgAiACQbjZAUGYtgFBvMUBKAIAEQAACyACIAIgAkGQAWpBmLYBQbTFASgCABEAACACQZABaiACQZABakGYtgFBxMUBKAIAEQEACyACQZABaiACQZABaiACQZi2AUG0xQEoAgARAAAgACACQZABakGYtgFBwMUBKAIAEQEAIAAgACACQTBqQZi2AUG4xQEoAgARAAAgACAAIAJBMGpBmLYBQbjFASgCABEAAAJAIAMEQCAAQeAAaiAEQajFASgCABECAAwBCyAAQeAAaiAEIAVBmLYBQbzFASgCABEAAAsgAEHgAGoiASABQZi2AUHExQEoAgARAQAgAEEwaiIBIAJBMGogAEGYtgFBuMUBKAIAEQAAIAEgASACQZABakGYtgFBvMUBKAIAEQAAIAJB4ABqIAJB4ABqQZi2AUHExQEoAgARAQAgAkHgAGogAkHgAGpBmLYBQcTFASgCABEBACACQeAAaiACQeAAakGYtgFBxMUBKAIAEQEAIAEgASACQeAAakGYtgFBuMUBKAIAEQAACyACQcABaiQAC5ELAQh/IwBBkARrIgIkAAJAAkAgAUHAAWpBoMUBKAIAEQQARQ0AIAFB8AFqQaDFASgCABEEAEUN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LQABIgVB4gBHBEAgBUH4AEcNAQJAIAAOEQAEBAQEBAQEBAQEBAQEBAQABAsgBkECciEGQRAhAAwCCwJAIAAOAwACAAILQQIhACAGQQJyIQYMAQsgAEEKIAAbIQALIAQgBkYNAAJAAkACQCAAQX5qDg8CAwMDAwMDAwADAwMDAwEDCyABIAIgAyAGaiAEIAZrEIEEDwsgASACIAMgBmogBCAGaxCABA8LIAQgBmsiAEUNACAAQQV2IgggAEEfcSIJQQBHaiIFIAJLDQAgAyAGaiECAkAgCEUNAEEAIQADQCABIABBAnRqIQYgAiAIIABBf3NqQQV0IAlyaiEKQQAhBEEBIQdBACEDAkACQAJAA0ACfwJAAkAgBCAKai0AAEFQag4CAAEECyADQQF0DAELIANBAXRBAXILIQMgBEEfSSEHIARBAWoiBEEgRw0ACyAGIAM2AgAMAQsgB0EBcQ0BCyAAQQFqIgAgCEYNAgwBCwtBAA8LAkAgCUUNACABIAhBAnRqIQBBACEEQQEhBkEAIQMCQANAAn8CQAJAIAIgBGotAABBUGoOAgABBAsgA0EBdAwBCyADQQF0QQFyCyEDIARBAWoiBCAJSSEGIAQgCUcNAAsgACADNgIADAELQQAhByAGQQFxDQELIAUhBwsgBwvCAwEBf0GoxQEoAgAhAkHY/gAtAAAEQCAAIAEgAhECACAAQTBqIAFBMGpBqMUBKAIAEQIAIABBgANqIAFB4ABqQajFASgCABECACAAQbADaiABQZABakGoxQEoAgARAgAgAEHgAGogAUHAAWpBqMUBKAIAEQIAIABBkAFqIAFB8AFqQajFASgCABECACAAQcABakGkxQEoAgARAwAgAEHwAWpBpMUBKAIAEQMAIABBoAJqQaTFASgCABEDACAAQdACakGkxQEoAgARAwAgAEHgA2pBpMUBKAIAEQMAIABBkARqQaTFASgCABEDAA8LIABBgANqIAEgAhECACAAQbADaiABQTBqQajFASgCABECACAAIAFB4ABqQajFASgCABECACAAQTBqIAFBkAFqQajFASgCABECACAAQaACaiABQcABakGoxQEoAgARAgAgAEHQAmogAUHwAWpBqMUBKAIAEQIAIABB4ABqQaTFASgCABEDACAAQZABakGkxQEoAgARAwAgAEHAAWpBpMUBKAIAEQMAIABB8AFqQaTFASgCABEDACAAQeADakGkxQEoAgARAwAgAEGQBGpBpMUBKAIAEQMAC9wLAQt/IwBBwAdrIgMkACADQYAGaiABQcABaiIKIAJBiMUBKAIAEQEAIANBoAVqIANBgAZqQZi2AUHsxQEoAgARAQAgA0HQBWoiBSADQeAGaiIGQZi2AUHsxQEoAgARAQAgA0GABmogCiACQeAAaiIMQYjFASgCABEBACADQcAEaiADQYAGakGYtgFB7MUBKAIAEQEAIANB8ARqIgcgBkGYtgFB7MUBKAIAEQEAIANBoAVqIAEgA0GgBWpBmLYBQbjFASgCABEAACAFIAFBMGoiCCAFQZi2AUG4xQEoAgARAAAgA0HABGogAUHgAGoiCyADQcAEakGYtgFBuMUBKAIAEQAAIAcgAUGQAWoiDSAHQZi2AUG4xQEoAgARAAAgA0GABmogBUGYtgFBxMUBKAIAEQEAIANBgAZqIANBgAZqIANBoAVqQZi2AUG8xQEoAgARAAAgA0HAAWogA0GgBWogBUGYtgFBtMUBKAIAEQAAIAMgA0GgBWogBUGYtgFBuMUBKAIAEQAAIANB4ANqIANBwAFqIANBmLYBQbzFASgCABEAACADQZAEaiIJIANBgAZqQajFASgCABECACADQYAGaiADQeADaiABQYjFASgCABEBACABIANBgAZqQZi2AUHsxQEoAgARAQAgCCAGQZi2AUHsxQEoAgARAQAgA0GABmogB0GYtgFBxMUBKAIAEQEAIANBgAZqIANBgAZqIANBwARqQZi2AUG8xQEoAgARAAAgA0HAAWogA0HABGogB0GYtgFBtMUBKAIAEQAAIAMgA0HABGogB0GYtgFBuMUBKAIAEQAAIANBgANqIANBwAFqIANBmLYBQbzFASgCABEAACADQbADaiIEIANBgAZqQajFASgCABECACADQYAGaiADQeADaiADQaAFakGIxQEoAgARAQAgA0HgA2ogA0GABmpBmLYBQezFASgCABEBACAJIAZBmLYBQezFASgCABEBACADQYAGaiADQYADaiAKQYjFASgCABEBACADQYADaiADQYAGakGYtgFB7MUBKAIAEQEAIAQgBkGYtgFB7MUBKAIAEQEAIANBgANqIANBgANqIANB4ANqQZi2AUG0xQEoAgARAAAgBCAEIAlBmLYBQbTFASgCABEAACADQYADaiADQYADaiABQZi2AUG4xQEoAgARAAAgBCAEIAhBmLYBQbjFASgCABEAACADQYADaiADQYADaiABQZi2AUG4xQEoAgARAAAgBCAEIAhBmLYBQbjFASgCABEAACABIAEgA0GAA2pBmLYBQbjFASgCABEAACAIIAggBEGYtgFBuMUBKAIAEQAAIANBwAFqIANBwARqIAFBiMUBKAIAEQEAIAMgA0HgA2ogC0GIxQEoAgARAQAgAyADQcABaiADQZi2AUHoxQEoAgARAAAgA0HgAGoiBCADQaACaiIJIARBmLYBQejFASgCABEAACALIANBmLYBQezFASgCABEBACANIARBmLYBQezFASgCABEBACADQYAGaiADQaAFaiADQYADakGIxQEoAgARAQAgASADQYAGakGYtgFB7MUBKAIAEQEAIAggBkGYtgFB7MUBKAIAEQEAIANBgAZqIANB4ANqIApBiMUBKAIAEQEAIAogA0GABmpBmLYBQezFASgCABEBACABQfABaiAGQZi2AUHsxQEoAgARAQAgAEHAAWogA0HABGpBmLYBQbDFASgCABEBACAAQfABaiAHQZi2AUGwxQEoAgARAQAgA0HAAWogA0HABGogAkGIxQEoAgARAQAgAyADQaAFaiAMQYjFASgCABEBACADQcABaiADQcABaiADQZi2AUHoxQEoAgARAAAgCSAJIARBmLYBQejFASgCABEAACAAQeAAaiADQaAFakGoxQEoAgARAgAgAEGQAWogBUGoxQEoAgARAgAgACADQcABakGYtgFB7MUBKAIAEQEAIABBMGogCUGYtgFB7MUBKAIAEQEAIANBwAdqJAALkAEBA38gACEBAkACQCAAQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0H//ft3anFBgIGChHhxRQ0ACyADQf8BcUUEQCACIABrDwsDQCACLQABIQMgAkEBaiIBIQIgAw0ACwsgASAAawv7BAEIfyMAQfAAayIFJAAgAEEBOgAAIAFBADYCRCACKAJkIQQCQAJAIAItAGgiBgRAIARBAUcNAUEBIQQgAigCBA0BDAILAkAgBCIDDgIBAAILA0AgA0UNAiACIANBf2oiA0ECdGoo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CGogAUHgA2oiA0GoxQEoAgARAgAgAkHQCGogAUGQBGoiBEGoxQEoAgARAgAgACABQajFASgCABECACAAQTBqIAVBqMUBKAIAEQIAIABB4ABqIAZBqMUBKAIAEQIAIABBkAFqIAdBqMUBKAIAEQIAIABBwAFqIAhBqMUBKAIAEQIAIABB8AFqIAlBqMUBKAIAEQIAIABBoAJqIApBqMUBKAIAEQIAIABB0AJqIAtBqMUBKAIAEQIAIABBgANqIAxBqMUBKAIAEQIAIABBsANqIA1BqMUBKAIAEQIAIABB4ANqIANBqMUBKAIAEQIAIABBkARqIARBqMUBKAIAEQIAIAIgAUGoxQEoAgARAgAgAkEwaiAFQajFASgCABECACACQeAAaiAGQajFASgCABECACACQZABaiAHQajFASgCABECACACQcABaiAIQajFASgCABECACACQfABaiAJQajFASgCABECACACQaACaiAKQZi2AUGwxQEoAgARAQAgAkHQAmogC0GYtgFBsMUBKAIAEQEAIAJBgANqIAxBmLYBQbDFASgCABEBACACQbADaiANQZi2AUGwxQEoAgARAQAgAkHgA2ogA0GYtgFBsMUBKAIAEQEAIAJBkARqIARBmLYBQbDFASgCABEBAEEBIQFBgLUBKAIAQQFNDQADQCAAIAAQTiACQcAEaiEEAkAgACAAIAFBgLQBaiwAACIDQQBMBH8gA0F/Sg0BIAIFIAQLEAcLIAFBAWoiAUGAtQEoAgBJDQALC0G4gAEtAAAEQCAAQaACaiIBIAFBmLYBQbDFASgCABEBACAAQdACaiIBIAFBmLYBQbDFASgCABEBACAAQYADaiIBIAFBmLYBQbDFASgCABEBACAAQbADaiIBIAFBmLYBQbDFASgCABEBACAAQeADaiIBIAFBmLYBQbDFASgCABEBACAAQZAEaiIAIABBmLYBQbDFASgCABEBAAsgAkGACWokAAu8AgEBfyMAQcAEayIDJAAgAiADRwRAIAMgAkGoxQEoAgARAgAgA0EwaiACQTBqQajFASgCABECACADQeAAaiACQeAAakGoxQEoAgARAgAgA0GQAWogAkGQAWpBqMUBKAIAEQIAIANBwAFqIAJBwAFqQajFASgCABECACADQfABaiACQfABakGoxQEoAgARAgALIANBoAJqIAJBoAJq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tgFBuMUBKAIAEQAAIAJB4AZqIAJBwAFqIAJBmLYBQbzFASgCABEAACAGIAJBoAhqQajFASgCABECACACQcAEaiACQaAFakGYtgFBxMUBKAIAEQEAIAcgAkHQBWoiDUGYtgFBxMUBKAIAEQEAIAJBwARqIAJBwARqIAJBoAVqQZi2AUG0xQEoAgARAAAgAkHwBGoiAyADIA1BmLYBQbTFASgCABEAACABIAJBgAZqIAJBwARqQZi2AUG4xQEoAgARAAAgBCALIAdBmLYBQbjFASgCABEAACACQcAEaiACQcAEaiACQYAGakGYtgFBtMUBKAIAEQAAIAMgAyALQZi2AUG0xQEoAgARAAAgAkGgCGogASACQeADakGIxQEoAgARAQAgASACQaAIakGYtgFB7MUBKAIAEQEAIAQgAkGACWpBmLYBQezFASgCABEBACACKALABCEEIAJBwARqIAJBwARqQazFASgCABECACAEQQFxBEAgAkHABGogAkHABGpB2MIBQfDFASgCABEFABoLIAIoAvAEIQQgAyADQazFASgCABECACAEQQFxBEAgAyADQdjCAUHwxQEoAgARBQAaCyACQcABaiACQcAEakGMxQEoAgARAgAgAiACQaAFakGMxQEoAgARAgAgAkHAAWogAkHAAWogAkGYtgFB6MUBKAIAEQAAIAJBoAJqIgQgBCACQeAAaiIGQZi2AUHoxQEoAgARAAAgAiACIAJBmLYBQeTFASgCABEAACAGIAYgBkGYtgFB5MUBKAIAEQAAIAJBwAFqIAJBwAFqIAJBmLYBQejFASgCABEAACAEIAQgBkGYtgFB6MUBKAIAEQAAIAJBwARqIAggCkGYtgFBtMUBKAIAEQAAIAcgDCAJQZi2AUG0xQEoAgARAAAgCCACQcABakGYtgFB7MUBKAIAEQEAIAFBkAFqIARBmLYBQezFASgCABEBACACQaAIaiAHQZi2AUHExQEoAgARAQAgAkGgCGogAkGgCGogAkHABGpBmLYBQbzFASgCABEAACACQfAHaiACQcAEaiAHQZi2AUG0xQEoAgARAAAgAkHAB2ogAkHABGogB0GYtgFBuMUBKAIAEQAAIAJBwARqIAJB8AdqIAJBwAdqQZi2AUG8xQEoAgARAAAgByACQaAIakGoxQEoAgARAgAgAkHABGogAkHABGogAkGA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NgIoIAAgASgCLCIBIAQgA0kgAyAGSWpqIgAgAigCLGoiAjYCLCACIABJIAAgAUlqC1UBAn9BoP4AKAIAIgEgAEEDakF8cSICaiEAAkAgAkEBTkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAUUNAQtBoP4AIAA2AgAgAQ8LQbCCAkEwNgIAQX8LggcBDH8jAEGABmsiAyQAIANBoAVqIAFB4ABqIgUgAUHAAWoiB0HwxQEoAgARBQAaIANB0AVqIgQgAUGQAWoiBiABQfABaiIMQfDFASgCABEFABogA0HABGogAkHgAGoiCCACQcABaiIJQfDFASgCABEFABogA0HwBGoiCyACQZABaiIKIAJB8AFqIg1B8MUBKAIAEQUAGiAAIANBoAVqIANBwARqQYjFASgCABEBACADQaAFaiABIAVB8MUBKAIAEQUAGiAEIAFBMGoiDiAGQfDFASgCABEFABogA0HABGogCCACQfDFASgCABEFABogCyAKIAJBMGoiCkHwxQEoAgARBQAaIABBwAFqIgYgA0GgBWogA0HABGpBiMUBKAIAEQEAIANBoAVqIAEgB0HwxQEoAgARBQAaIAQgDiAMQfDFASgCABEFABogA0HABGogAiAJQfDFASgCABEFABogCyAKIA1B8MUBKAIAEQUAGiAAQYADaiIEIANBoAVqIANBwARqQYjFASgCABEBACADQYADaiAFIAhBiMUBKAIAEQEAIANBwAFqIAcgCUGIxQEoAgARAQAgAyABIAJBiMUBKAIAEQEAIAAgACADQYADakGYtgFB6MUBKAIAEQAAIABB4ABqIgEgASADQeADaiIHQfzFASgCABEFABogACAAIANBwAFqQZi2AUHoxQEoAgARAAAgASABIANBoAJqIghB/MUBKAIAEQUAGiAGIAYgA0GYtgFB6MUBKAIAEQAAIABBoAJqIgIgAiADQeAAaiIJQfzFASgCABEFABogBiAGIANBgANqQZi2AUHoxQEoAgARAAAgAiACIAdB/MUBKAIAEQUAGiAEIAQgA0GYtgFB6MUBKAIAEQAAIABB4ANqIgUgBSAJQfzFASgCABEFABogBCAEIANBwAFqQZi2AUHoxQEoAgARAAAgBSAFIAhB/MUBKAIAEQUAGiAAIABBkMUBKAIAEQIAIAAgACADQZi2AUHkxQEoAgARAAAgASABIAlBmLYBQeTFASgCABEAACADQcABaiADQcABakGQxQEoAgARAgAgBiAGIANBwAFqQZi2AUHkxQEoAgARAAAgAiACIAhBmLYBQeTFASgCABEAACAEIAQgA0GAA2pBmLYBQeTFASgCABEAACAFIAUgB0GYtgFB5MUBKAIAEQAAIANBgAZqJAAL1AIBAn8jAEGgAmsiAyQAAkACQCACQcABaiIEQaDFASgCABEEAEUNACACQfABakGgxQEoAgARBABFDQAgA0GkxQEoAgARAwAgA0EwakGkxQEoAgARAwAgA0HgAGpBpMUBKAIAEQMAIANBkAFqQaTFASgCABEDACADQcABakGkxQEoAgARAwAgA0HwAWpBpMUBKAIAEQMADAELIAMgAkGoxQEoAgARAgAgA0EwaiACQTBqQajFASgCABECACADQeAAaiACQeAAakGYtgFBsMUBKAIAEQEAIANBkAFqIAJBkAFqQZi2AUGwxQEoAgARAQAgA0HAAWogBEGoxQEoAgARAgAgA0HwAWogAkHwAWpBqMUBKAIAEQIACwJAAkACQAJAQZiCAigCAA4DAAECAwsgACABIAMQCwwCCyAAIAEgAxAKDAELIAAgASADEAkLIANBoAJqJAAL0h4BAn8jAEGgAmsiBCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDhEAAQIDBAUGBwgJCgsMDQ4PEBMLIABBpMUBKAIAEQMAIABBMGpBpMUBKAIAEQMAIABB4ABqQaTFASgCABEDAEEBIQUMEgsgACABQajFASgCABECACAAQTBqIAFBMGpBqMUBKAIAEQIAIABB4ABqIAFB4ABqQajFASgCABECAAwQCwJAAkACQEHsgQIoAgAOAwABAhILIAAgARATDBELIAAgARASDBALIAAgARAVDA8LAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgBEGQAWogARATDAILIARBkAFqIAEQEgwBCyAEQZABaiABEBULQeyBAigCACEFCwJAAkACQCAFDgMAAQIRCyAAIARBkAFqIAEQDgwQCyAAIARBkAFqIAEQDQwPCyAAIARBkAFqIAEQDAwOCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAAgARATDAILIAAgARASDAELIAAgARAVC0HsgQIoAgAhBQsCQAJAIAUOAwABDg8LIAAgABATDA4LIAAgABASDA0LAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgBEGQAWogARATDAILIARBkAFqIAEQEgwBCyAEQZABaiABEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBkAFqIARBkAFqEBMMAgsgBEGQAWogBEGQAWoQEgwBCyAEQZABaiAEQZABahAVCwJAAkACQEHsgQIoAgAOAwABAg8LIAAgBEGQAWogARAODA4LIAAgBEGQAWogARANDA0LIAAgBEGQAWogARAMDAwLAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgBEGQAWogARATDAILIARBkAFqIAEQEgwBCyAEQZABaiABEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIAAgBEGQAWogARAODAILIAAgBEGQAWogARANDAELIAAgBEGQAWogARAMCwJAAkBB7IECKAIADgMAAQwNCyAAIAAQEwwMCyAAIAAQEgwLCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAQgARATDAILIAQgARASDAELIAQgARAVC0HsgQIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEIAQQEwwCCyAEIAQQEgwBCyAEIAQQFQsCQAJAAkACQEHsgQIoAgAOAwABAgMLIAQgBBATDAILIAQgBBASDAELIAQgBBAVCwJAIAFB4ABqIgJBoMUBKAIAEQQABEAgBEGQAWpBpMUBKAIAEQMAIARBwAFqQaTFASgCABEDACAEQfABakGkxQEoAgARAwAMAQsgBEGQAWogAUGoxQEoAgARAgAgBEHAAWogAUEwakGYtgFBsMUBKAIAEQEAIARB8AFqIAJBqMUBKAIAEQIACwJAAkACQEHsgQIoAgAOAwABAg0LIAAgBCAEQZABahAODAwLIAAgBCAEQZABahANDAsLIAAgBCAEQZABahAMDAoLAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgACABEBMMAgsgACABEBIMAQsgACABEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIAAgABATDAILIAAgABASDAELIAAgABAVCwJAAkBB7IECKAIADgMAAQoLCyAAIAAQEwwKCyAAIAAQEgwJCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIARBkAFqIAEQEwwCCyAEQZABaiABEBIMAQsgBEGQAWogARAVC0HsgQIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEQZABaiAEQZABahATDAILIARBkAFqIARBkAFqEBIMAQsgBEGQAWogBEGQAWoQFQsCQAJAAkACQAJAQeyBAigCACIFDgMAAQIECyAEQZABaiAEQZABahATDAILIARBkAFqIARBkAFqEBIMAQsgBEGQAWogBEGQAWoQFQtB7IECKAIAIQULAkACQAJAIAUOAwABAgsLIAAgBEGQAWogARAODAoLIAAgBEGQAWogARANDAkLIAAgBEGQAWogARAMDAgLAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgBEGQAWogARATDAILIARBkAFqIAEQEgwBCyAEQZABaiABEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBkAFqIARBkAFqEBMMAgsgBEGQAWogBEGQAWoQEgwBCyAEQZABaiAEQZABahAVCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAAgBEGQAWogARAODAILIAAgBEGQAWogARANDAELIAAgBEGQAWogARAMC0HsgQIoAgAhBQsCQAJAIAUOAwABCAkLIAAgABATDAgLIAAgABASDAcLAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgBEGQAWogARATDAILIARBkAFqIAEQEgwBCyAEQZABaiABEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIAQgBEGQAWoQEwwCCyAEIARBkAFqEBIMAQsgBCAEQZABahAVCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAQgBBATDAILIAQgBBASDAELIAQgBBAVC0HsgQIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEIAQgBEGQAWoQDgwCCyAEIAQgBEGQAWoQDQwBCyAEIAQgBEGQAWoQDAsCQAJAAkBB7IECKAIADgMAAQIJCyAAIAQgARAODAgLIAAgBCABEA0MBwsgACAEIAEQDAwGCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIARBkAFqIAEQEwwCCyAEQZABaiABEBIMAQsgBEGQAWogARAVC0HsgQIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEQZABaiAEQZABahATDAILIARBkAFqIARBkAFqEBIMAQsgBEGQAWogBEGQAWoQFQsCQAJAAkACQAJAQeyBAigCACIFDgMAAQIECyAEIARBkAFqEBMMAgsgBCAEQZABahASDAELIAQgBEGQAWoQFQtB7IECKAIAIQULAkACQAJAIAUOAwABAggLIAAgBEGQAWogBBAODAcLIAAgBEGQAWogBBANDAYLIAAgBEGQAWogBBAMDAULAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgBEGQAWogARATDAILIARBkAFqIAEQEgwBCyAEQZABaiABEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBkAFqIARBkAFqEBMMAgsgBEGQAWogBEGQAWoQEgwBCyAEQZABaiAEQZABahAVCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAQgBEGQAWoQEwwCCyAEIARBkAFqEBIMAQsgBCAEQZABahAVC0HsgQIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEQZABaiAEQZABaiAEEA4MAgsgBEGQAWogBEGQAWogBBANDAELIARBkAFqIARBkAFqIAQQDAsCQAJAAkBB7IECKAIADgMAAQIHCyAAIARBkAFqIAEQDgwGCyAAIARBkAFqIAEQDQwFCyAAIARBkAFqIAEQDAwECwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAQgARATDAILIAQgARASDAELIAQgARAVC0HsgQIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEIAQQEwwCCyAEIAQQEgwBCyAEIAQQFQsCQAJAAkACQEHsgQIoAgAOAwABAgMLIAQgBBATDAILIAQgBBASDAELIAQgBBAVCwJAIAFB4ABqIgJBoMUBKAIAEQQABEAgBEGQAWpBpMUBKAIAEQMAIARBwAFqQaTFASgCABEDACAEQfABakGkxQEoAgARAwAMAQsgBEGQAWogAUGoxQEoAgARAgAgBEHAAWogAUEwakGYtgFBsMUBKAIAEQEAIARB8AFqIAJBqMUBKAIAEQIACwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAQgBCAEQZABahAODAILIAQgBCAEQZABahANDAELIAQgBCAEQZABahAMC0HsgQIoAgAhBQsCQAJAAkAgBQ4DAAECBgsgACAEEBMMBQsgACAEEBIMBAsgACAEEBUMAwsCQAJAAkACQAJAQeyBAigCACIFDgMAAQIECyAEIAEQEwwCCyAEIAEQEgwBCyAEIAEQFQtB7IECKAIAIQULAkACQAJAAkAgBQ4DAAECAwsgBCAEEBMMAgsgBCAEEBIMAQsgBCAEEBULAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgBCAEEBMMAgsgBCAEEBIMAQsgBCAEEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIAQgBBATDAILIAQgBBASDAELIAQgBBAVCwJAIAFB4ABqIgJBoMUBKAIAEQQABEAgBEGQAWpBpMUBKAIAEQMAIARBwAFqQaTFASgCABEDACAEQfABakGkxQEoAgARAwAMAQsgBEGQAWogAUGoxQEoAgARAgAgBEHAAWogAUEwakGYtgFBsMUBKAIAEQEAIARB8AFqIAJBqMUBKAIAEQIACwJAAkACQEHsgQIoAgAOAwABAgULIAAgBCAEQZABahAODAQLIAAgBCAEQZABahANDAMLIAAgBCAEQZABahAMDAILAkACQAJAAkACQEHsgQIoAgAiBQ4DAAECBAsgACABEBMMAgsgACABEBIMAQsgACABEBULQeyBAigCACEFCwJAAkACQAJAIAUOAwABAgMLIAAgABATDAILIAAgABASDAELIAAgABAVCwJAAkACQAJAAkBB7IECKAIAIgUOAwABAgQLIAAgABATDAILIAAgABASDAELIAAgABAVC0HsgQIoAgAhBQsCQAJAIAUOAwABAgMLIAAgABATDAILIAAgABASDAELIAAgABAVC0EBIQUgA0UNACAAQeAAaiIBQaDFASgCABEEAARAIABBpMUBKAIAEQMAIABBMGpBpMUBKAIAEQMAIAFBpMUBKAIAEQMADAELIAAgAEGoxQEoAgARAgAgAEEwaiIAIABBmLYBQbDFASgCABEBACABIAFBqMUBKAIAEQIACyAEQaACaiQAIAULzQoCCH8NfiMAIQMgACABRgRAIANBUGoiASEDIAEgACkCKDcCKCABIAApAiA3AiAgASAAKQIYNwIYIAEgACkCEDcCECABIAApAgg3AgggASAAKQIANwIACyAAIAJGBEAgA0FQ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BAsgAkEAOgCIBQsgBiAGIAJBoARqECkgB0EBaiIHQQRHDQALCyACQZAFaiQAC8gBAQJ/IwBBkAFrIgIkAAJAIAFB4ABqIgNBoMUBKAIAEQQABEAgAkGkxQEoAgARAwAgAkEwakGkxQEoAgARAwAgAkHgAGpBpMUBKAIAEQMADAELIAIgAUGoxQEoAgARAgAgAkEwaiABQTBqQZi2AUGwxQEoAgARAQAgAkHgAGogA0GoxQEoAgARAgALAkACQAJAAkBB7IECKAIADgMAAQIDCyAAIAAgAhAODAILIAAgACACEA0MAQsgACAAIAIQDAsgAkGQAWokAAu4AwEFfyMAQdACayIBJAACQCAAQcABaiICQaDFASgCABEEAARAIABB8AFqQaDFASgCABEEAA0BCyABQZABaiACQdTFASgCABECACABQTBqIABB8AFqIgNB1MUBKAIAEQIAIAFBkAFqIAFBkAFqIAFBMGpB+MUBKAIAEQUAGiABIAFBkAFqQZi2AUHsxQEoAgARAQAgASABQZS2AUHIxQEoAgARAQAgAiACIAFBmLYBQbzFASgCABEAACADIAMgAUGYtgFBvMUBKAIAEQAAIAMgA0GYtgFBsMUBKAIAEQEAIAFBkAFqIAAgAkGIxQEoAgARAQAgACABQZABakGYtgFB7MUBKAIAEQEAIABBMGogAUHwAWoiBEGYtgFB7MUBKAIAEQEAIAFBkAFqIABB4ABqIgUgAkGIxQEoAgARAQAgBSABQZABakGYtgFB7MUBKAIAEQEAIABBkAFqIARBmLYBQezFASgCABEBACABQZABakGIwwFBqMUBKAIAEQIAIAFBwAFqIgBBpMUBKAIAEQMAIAIgAUGQAWpBqMUBKAIAEQIAIAMgAEGoxQEoAgARAgALIAFB0AJqJAALlwUBBX8jAEGAA2siASQAAkAgAEHAAWoiAkGgxQEoAgARBAAEQCAAQfABakGgxQEoAgARBAANAQsgAUHAAWogAkHUxQEoAgARAgAgASAAQfABaiIDQdTFASgCABECACABQcABaiABQcABaiABQfjFASgCABEFABogAUGQAWogAUHAAWpBmLYBQezFASgCABEBACABQZABaiABQZABakGUtgFByMUBKAIAEQEAIAIgAiABQZABakGYtgFBvMUBKAIAEQAAIAMgAyABQZABakGYtgFB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RQ0ACwsgAUEEaiEDIAdBAWoiB0EHRwRAIAMoAgAhBCADIQEMAQsLIAEoAiAhDCAAIAEoAgQiBCALazYCACAAIAEoAggiByACKAIEIgUgBCALSWoiBGs2AgQgACABKAIMIgsgBCAFSSAHIARJaiIHIAIoAghqIgRrNgIIIAAgASgCECIFIAQgB0kgCyAESWoiByACKAIMaiIEazYCDCAAIAEoAhQiCyAEIAdJIAUgBElqIgcgAigCEGoiBGs2AhAgBCAHSSALIARJaiIHIAIoAhRqIQQgDARAIAAgASgCGCIDIARrNgIUIAAgASgCHCACKAIYayADIARJayAEIAdJazYCGA8LIAAgASgCGCIMIARrNgIUIAAgASgCHCILIAQgB0kgDCAESWoiBCACKAIYaiIBazYCGCABIARJQX9BACALIAFJG0cEQCAAIAMpAgA3AgAgACADKAIYNgIYIAAgAykCEDcCECAAIAMpAgg3AggLC9cKAgp/CH4gAkF8aigCACELIwBBQGoiAyABKAIcIgc2AhwgAyABKAIgNgIgIAMgASgCJDYCJCADIAEoAig2AiggAyABKAIsNgIsIANBADYCMCACNQIEIQ8gAjUCFCEQIAI1AhAhESACNQIMIRIgAjUCCCETIAMgASgCACIEIAIoAgAiDK0iFCAEIAtsrSIOfiINp2oiBTYCACADIAEoAgQiBiAFIARJaiIFIA1CIIinIgggDiAPfiINp2oiCWoiBDYCBCADIAQgBUkgBSAGSWoiBiABKAIIaiIFIA1CIIinIAkgCElqIgggDiATfiINp2oiCWoiCjYCCCADIAogBUkgBSAGSWoiBiABKAIMaiIFIA1CIIinIAkgCElqIgggDiASfiINp2oiCWoiCjYCDCADIAogBUkgBSAGSWoiBiABKAIQaiIFIA1CIIinIAkgCElqIgggDiARfiINp2oiCWoiCjYCECADIAogBUkgBSAGSWoiBiABKAIUaiIFIA1CIIinIAkgCElqIgggDiAQfiIOp2oiCWoiCjYCFCADIAogBUkgBSAGSWoiBSABKAIYaiIBIA5CIIinIAkgCElqaiIGNgIYAkBBACABIAVJayAGIAFJRg0AIAMgB0EBaiIBNgIcAkAgASAHTw0AIAMgAygCICIBQQFqIgc2AiAgByABTw0AIAMgAygCJCIBQQFqIgc2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AjgiByADIAZJIAUgA0lqaiIDazYCOCAAIAEoAjwiASACKAI8IgIgAyAHSSAEIANJamoiAGs2AjwgACACSSABIABJagv/DwEPfyMAQcAHayICJAAgAkGABmogAUGMxQEoAgARAgAgAkHABGogAUGAA2oiC0GMxQEoAgARAgAgAkGAA2ogAkHABGpBkMUBKAIAEQIAIAJBgANqIAJBgANqIAJBgAZqQZi2AUHkxQEoAgARAAAgAkHgA2oiAyADIAJB4AZqIgpBmLYBQeTFASgCABEAACACQcABaiABIAtBmLYBQbTFASgCABEAACACQfABaiIHIAFBMGoiBCABQbADaiIFQZi2AUG0xQEoAgARAAAgAkGgAmogAkGAA2pBmLYBQezFASgCABEBACACQdACaiIIIANBmLYBQezFASgCABEBACACQYADaiACQcABakGMxQEoAgARAgAgAkGAA2ogAkGAA2ogAkGABmpBmLYBQejFASgCABEAACADIAMgCkGYtgFB6MUBKAIAEQAAIAJBgANqIAJBgANqIAJBwARqQZi2AUHoxQEoAgARAAAgAyADIAJBoAVqIglBmLYBQejFASgCABEAACACQcABaiACQYADakGYtgFB7MUBKAIAEQEAIAcgA0GYtgFB7MUBKAIAEQEAIAAgAkGgAmogAUGYtgFBuMUBKAIAEQAAIABBMGoiBiAIIARBmLYBQbjFASgCABEAACAAIABBmLYBQcTFASgCABEBACAGIAZBmLYBQcTFASgCABEBACAAIAAgAkGgAmpBmLYBQbTFASgCABEAACAGIAYgCEGYtgFBtMUBKAIAEQAAIABBgANqIgYgAkHAAWogC0GYtgFBtMUBKAIAEQAAIABBsANqIgQgByAFQZi2AUG0xQEoAgARAAAgBiAGQZi2AUHExQEoAgARAQAgBCAEQZi2AUHExQEoAgARAQAgBiAGIAJBwAFqQZi2AUG0xQEoAgARAAAgBCAEIAdBmLYBQbTFASgCABEAACACQYAGaiABQaACaiIMQYzFASgCABECACACQcAEaiABQcABaiINQYzFASgCABECACACQYADaiACQcAEakGQxQEoAgARAgAgAkGAA2ogAkGAA2ogAkGABmpBmLYBQeTFASgCABEAACADIAMgCkGYtgFB5MUBKAIAEQAAIAJBwAFqIAwgDUGYtgFBtMUBKAIAEQAAIAcgAUHQAmoiBiABQfABaiILQZi2AUG0xQEoAgARAAAgAkGgAmogAkGAA2pBmLYBQezFASgCABEBACAIIANBmLYBQezFASgCABEBACACQYADaiACQcABakGMxQEoAgARAgAgAkGAA2ogAkGAA2ogAkGABmpBmLYBQejFASgCABEAACADIAMgCkGYtgFB6MUBKAIAEQAAIAJBgANqIAJBgANqIAJBwARqQZi2AUHoxQEoAgARAAAgAyADIAlBmLYBQejFASgCABEAACACQcABaiACQYADakGYtgFB7MUBKAIAEQEAIAcgA0GYtgFB7MUBKAIAEQEAIAJBgAZqIAFB4ABqIg5BjMUBKAIAEQIAIAJBwARqIAFB4ANqIg9BjMUBKAIAEQIAIAJBgANqIAJBwARqQZDFASgCABECACACQYADaiACQYADaiACQYAGakGYtgFB5MUBKAIAEQAAIAMgAyAKQZi2AUHkxQEoAgARAAAgAiAOIA9BmLYBQbTFASgCABEAACACQTBqIgQgAUGQAWoiBSABQZAEaiIBQZi2AUG0xQEoAgARAAAgAkHgAGogAkGAA2pBmLYBQezFASgCABEBACACQZABaiIQIANBmLYBQezFASgCABEBACACQYADaiACQYzFASgCABECACACQYADaiACQYADaiACQYAGakGYtgFB6MUBKAIAEQAAIAMgAyAKQZi2AUHoxQEoAgARAAAgAkGAA2ogAkGAA2ogAkHABGpBmLYBQejFASgCABEAACADIAMgCUGYtgFB6MUBKAIAEQAAIAIgAkGAA2pBmLYBQezFASgCABEBACAEIANBmLYBQezFASgCABEBACAAQeAAaiIJIAJBoAJqIA5BmLYBQbjFASgCABEAACAAQZABaiIEIAggBUGYtgFBuMUBKAIAEQAAIAkgCUGYtgFBxMUBKAIAEQEAIAQgBEGYtgFBxMUBKAIAEQEAIAkgCSACQaACakGYtgFBtMUBKAIAEQAAIAQgBCAIQZi2AUG0xQEoAgARAAAgAEHgA2oiBCACQcABaiAPQZi2AUG0xQEoAgARAAAgAEGQBGoiBSAHIAFBmLYBQbTFASgCABEAACAEIARBmLYBQcTFASgCABEBACAFIAVBmLYBQcTFASgCABEBACAEIAQgAkHAAWpBmLYBQbTFASgCABEAACAFIAUgB0GYtgFBtMUBKAIAEQAAIAJBoAJqIAJBiMYBKAIAEQIAIABBoAJqIgUgAkGgAmogDEGYtgFBtMUBKAIAEQAAIABB0AJqIgEgCCAGQZi2AUG0xQEoAgARAAAgBSAFQZi2AUHExQEoAgARAQAgASABQZi2AUHExQEoAgARAQAgBSAFIAJBoAJqQZi2AUG0xQEoAgARAAAgASABIAhBmLYBQbTFASgCABEAACAAQcABaiIBIAJB4ABqIA1BmLYBQbjFASgCABEAACAAQfABaiIAIBAgC0GYtgFBuMUBKAIAEQAAIAEgAUGYtgFBxMUBKAIAEQEAIAAgAEGYtgFBxMUBKAIAEQEAIAEgASACQeAAakGYtgFBtMUBKAIAEQAAIAAgACAQQZi2AUG0xQEoAgARAAAgAkHAB2okAAvbBAEEfyMAQaACayIGJAAgACABRgRAIAYgAEGoxQEoAgARAgAgBiEBCyAAQYjDAUGoxQEoAgARAgBBnMUBKAIAGgJAA0AgAyIFRQ0BIAIgBUF/aiIDQQJ0aiIHKAIARQ0ACwJAIAVBAUcNAAJAAkACQAJAIAIoAgBBf2oOBAABAgMECyAAIAFBqMUBKAIAEQIADAQLIAAgAUGYtgFBwMUBKAIAEQEADAMLIAAgAUGYtgFBwMUBKAIAEQEAIAAgACABQZi2AUG8xQEoAgARAAAMAgsgACABQZi2AUHAxQEoAgARAQAgACAAQZi2AUHAxQEoAgARAQAMAQsgBkHgAGogAUGoxQEoAgARAgAgBkGQAWoiBSAGQeAAakGoxQEoAgARAgAgBkHAAWoiCCAFQZi2AUHAxQEoAgARAQAgBkHwAWogCCABQZi2AUG8xQEoAgARAAACQCAHKAIAIgdnQR9zIgVBAXEEQCAAIAZB4ABqIAcgBUF/aiIFdkEDcUEwbGpBqMUBKAIAEQIADAELIAAgAUGoxQEoAgARAgALIANBAE4EQCADIQEDQCAFQQFKBEAgAiABQQJ0aigCACEHA0AgACAAQZi2AUHAxQEoAgARAQAgACAAQZi2AUHAxQEoAgARAQAgByAFQX5qIgN2QQNxIggEQCAAIAAgBkHgAGogCEEwbGpBmLYBQbzFASgCABEAAAsgBUEDSiEIIAMhBSAIDQALCyABQQBKIQNBICEFIAFBf2ohASADDQALCwsgBARAIAAgAEGUtgFByMUBKAIAEQEACyAGQaACaiQAC+0dAQJ/IwBBwARrIgQkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4RAAECAwQFBgcICQoLDA0ODxATCyAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwAgAEGQAWpBpMUBKAIAEQMAIABBwAFqQaTFASgCABEDACAAQfABakGkxQEoAgARAwBBASEFDBILIAAgAUGoxQEoAgARAgAgAEEwaiABQTBqQajFASgCABECACAAQeAAaiABQeAAakGoxQEoAgARAgAgAEGQAWogAUGQAWpBqMUBKAIAEQIAIABBwAFqIAFBwAFqQajFASgCABECACAAQfABaiABQfABakGoxQEoAgARAgAMEAsCQAJAAkBBmIICKAIADgMAAQISCyAAIAEQEQwRCyAAIAEQEAwQCyAAIAEQFAwPCwJAAkACQAJAAkBBmIICKAIAIgUOAwABAgQLIARBoAJqIAEQEQwCCyAEQaACaiABEBAMAQsgBEGgAmogARAUC0GYggIoAgAhBQsCQAJAAkAgBQ4DAAECEQsgACAEQaACaiABEAsMEAsgACAEQaACaiABEAoMDwsgACAEQaACaiABEAkMDgsCQAJAAkACQAJAQZiCAigCACIFDgMAAQIECyAAIAEQEQwCCyAAIAEQEAwBCyAAIAEQFAtBmIICKAIAIQULAkACQCAFDgMAAQ4PCyAAIAAQEQwOCyAAIAAQEAwNCwJAAkACQAJAAkBBmIICKAIAIgUOAwABAgQLIARBoAJqIAEQEQwCCyAEQaACaiABEBAMAQsgBEGgAmogARAUC0GYggIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEQaACaiAEQaACahARDAILIARBoAJqIARBoAJqEBAMAQsgBEGgAmogBEGgAmoQFAsCQAJAAkBBmIICKAIADgMAAQIPCyAAIARBoAJqIAEQCwwOCyAAIARBoAJqIAEQCgwNCyAAIARBoAJqIAEQCQwMCwJAAkACQAJAAkBBmIICKAIAIgUOAwABAgQLIARBoAJqIAEQEQwCCyAEQaACaiABEBAMAQsgBEGgAmogARAUC0GYggIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAAIARBoAJqIAEQCwwCCyAAIARBoAJqIAEQCgwBCyAAIARBoAJqIAEQCQsCQAJAQZiCAigCAA4DAAEMDQsgACAAEBEMDAsgACAAEBAMCwsCQAJAAkACQAJAQZiCAigCACIFDgMAAQIECyAEQaACaiABEBEMAgsgBEGgAmogARAQDAELIARBoAJqIAEQFAtBmIICKAIAIQULAkACQAJAAkAgBQ4DAAECAwsgBEGgAmogBEGgAmoQEQwCCyAEQaACaiAEQaACahAQDAELIARBoAJqIARBoAJqEBQLAkACQAJAAkBBmIICKAIADgMAAQIDCyAEQaACaiAEQaACahARDAILIARBoAJqIARBoAJqEBAMAQsgBEGgAmogBEGgAmoQFAsgACAEQaACaiABEDwMCgsCQAJAAkACQAJAQZiCAigCACIFDgMAAQIECyAAIAEQEQwCCyAAIAEQEAwBCyAAIAEQFAtBmIICKAIAIQULAkACQAJAAkAgBQ4DAAECAwsgACAAEBEMAgsgACAAEBAMAQsgACAAEBQLAkACQEGYggIoAgAOAwABCgsLIAAgABARDAoLIAAgABAQDAkLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgBEGgAmogARARDAILIARBoAJqIAEQEAwBCyAEQaACaiABEBQLQZiCAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBoAJqIARBoAJqEBEMAgsgBEGgAmogBEGgAmoQEAwBCyAEQaACaiAEQaACahAUCwJAAkACQAJAAkBBmIICKAIAIgUOAwABAgQLIARBoAJqIARBoAJqEBEMAgsgBEGgAmogBEGgAmoQEAwBCyAEQaACaiAEQaACahAUC0GYggIoAgAhBQsCQAJAAkAgBQ4DAAECCwsgACAEQaACaiABEAsMCgsgACAEQaACaiABEAoMCQsgACAEQaACaiABEAkMCAsCQAJAAkACQAJAQZiCAigCACIFDgMAAQIECyAEQaACaiABEBEMAgsgBEGgAmogARAQDAELIARBoAJqIAEQFAtBmIICKAIAIQULAkACQAJAAkAgBQ4DAAECAwsgBEGgAmogBEGgAmoQEQwCCyAEQaACaiAEQaACahAQDAELIARBoAJqIARBoAJqEBQLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgACAEQaACaiABEAsMAgsgACAEQaACaiABEAoMAQsgACAEQaACaiABEAkLQZiCAigCACEFCwJAAkAgBQ4DAAEICQsgACAAEBEMCAsgACAAEBAMBwsCQAJAAkACQAJAQZiCAigCACIFDgMAAQIECyAEQaACaiABEBEMAgsgBEGgAmogARAQDAELIARBoAJqIAEQFAtBmIICKAIAIQULAkACQAJAAkAgBQ4DAAECAwsgBCAEQaACahARDAILIAQgBEGgAmoQEAwBCyAEIARBoAJqEBQLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgBCAEEBEMAgsgBCAEEBAMAQsgBCAEEBQLQZiCAigCACEFCwJAAkACQAJAIAUOAwABAgMLIAQgBCAEQaACahALDAILIAQgBCAEQaACahAKDAELIAQgBCAEQaACahAJCwJAAkACQEGYggIoAgAOAwABAgkLIAAgBCABEAsMCAsgACAEIAEQCgwHCyAAIAQgARAJDAYLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgBEGgAmogARARDAILIARBoAJqIAEQEAwBCyAEQaACaiABEBQLQZiCAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBoAJqIARBoAJqEBEMAgsgBEGgAmogBEGgAmoQEAwBCyAEQaACaiAEQaACahAUCwJAAkACQAJAAkBBmIICKAIAIgUOAwABAgQLIAQgBEGgAmoQEQwCCyAEIARBoAJqEBAMAQsgBCAEQaACahAUC0GYggIoAgAhBQsCQAJAAkAgBQ4DAAECCAsgACAEQaACaiAEEAsMBwsgACAEQaACaiAEEAoMBgsgACAEQaACaiAEEAkMBQsCQAJAAkACQAJAQZiCAigCACIFDgMAAQIECyAEQaACaiABEBEMAgsgBEGgAmogARAQDAELIARBoAJqIAEQFAtBmIICKAIAIQULAkACQAJAAkAgBQ4DAAECAwsgBEGgAmogBEGgAmoQEQwCCyAEQaACaiAEQaACahAQDAELIARBoAJqIARBoAJqEBQLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgBCAEQaACahARDAILIAQgBEGgAmoQEAwBCyAEIARBoAJqEBQLQZiCAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBoAJqIARBoAJqIAQQCwwCCyAEQaACaiAEQaACaiAEEAoMAQsgBEGgAmogBEGgAmogBBAJCwJAAkACQEGYggIoAgAOAwABAgcLIAAgBEGgAmogARALDAYLIAAgBEGgAmogARAKDAULIAAgBEGgAmogARAJDAQLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgBEGgAmogARARDAILIARBoAJqIAEQEAwBCyAEQaACaiABEBQLQZiCAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBoAJqIARBoAJqEBEMAgsgBEGgAmogBEGgAmoQEAwBCyAEQaACaiAEQaACahAUCwJAAkACQAJAQZiCAigCAA4DAAECAwsgBEGgAmogBEGgAmoQEQwCCyAEQaACaiAEQaACahAQDAELIARBoAJqIARBoAJqEBQLIARBoAJqIARBoAJqIAEQPAJAAkACQEGYggIoAgAOAwABAgYLIAAgBEGgAmoQEQwFCyAAIARBoAJqEBAMBAsgACAEQaACahAUDAMLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgBEGgAmogARARDAILIARBoAJqIAEQEAwBCyAEQaACaiABEBQLQZiCAigCACEFCwJAAkACQAJAIAUOAwABAgMLIARBoAJqIARBoAJqEBEMAgsgBEGgAmogBEGgAmoQEAwBCyAEQaACaiAEQaACahAUCwJAAkACQAJAAkBBmIICKAIAIgUOAwABAgQLIARBoAJqIARBoAJqEBEMAgsgBEGgAmogBEGgAmoQEAwBCyAEQaACaiAEQaACahAUC0GYggIoAgAhBQsCQAJAAkACQCAFDgMAAQIDCyAEQaACaiAEQaACahARDAILIARBoAJqIARBoAJqEBAMAQsgBEGgAmogBEGgAmoQFAsgACAEQaACaiABEDwMAgsCQAJAAkACQAJAQZiCAigCACIFDgMAAQIECyAAIAEQEQwCCyAAIAEQEAwBCyAAIAEQFAtBmIICKAIAIQULAkACQAJAAkAgBQ4DAAECAwsgACAAEBEMAgsgACAAEBAMAQsgACAAEBQLAkACQAJAAkACQEGYggIoAgAiBQ4DAAECBAsgACAAEBEMAgsgACAAEBAMAQsgACAAEBQLQZiCAigCACEFCwJAAkAgBQ4DAAECAwsgACAAEBEMAgsgACAAEBAMAQsgACAAEBQLQQEhBSADRQ0AAkAgAEHAAWoiAUGg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EQEAIAQgBCAEQYAGakGYtgFB6MUBKAIAEQAAIARB4ABqIgEgASAEQeAGaiICQZi2AUHoxQEoAgARAAAgBCAEIARBgANqQZi2AUHoxQEoAgARAAAgASABIARB4ANqIgNBmLYBQejFASgCABEAACAAQeAAaiAEQZi2AUHsxQEoAgARAQAgAEGQAWogAUGYtgFB7MUBKAIAEQEAIARBwARqIARBwARqQZDFASgCABECACAEQYAGaiAEQYAGaiAEQcAEakGYtgFB5MUBKAIAEQAAIAIgAiAEQaAFakGYtgFB5MUBKAIAEQAAIAAgBEGABmpBmLYBQezFASgCABEBACAAQTBqIAJBmLYBQezFASgCABEBACAEQYADaiAEQYADaiAEQcABakGYtgFB5MUBKAIAEQAAIAMgAyAEQaACakGYtgFB5MUBKAIAEQAAIABBwAFqIARBgANqQZi2AUHsxQEoAgARAQAgAEHwAWogA0GYtgFB7MUBKAIAEQEAIARBgAlqJAALxwYBAn8jAEEwayIDJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4NAAECAwQFBgcICQoLDA4LIABBpMUBKAIAEQMADAwLIAAgAUGoxQEoAgARAgAMCwsgACABIAFBmLYBQbTFASgCABEAAAwKCyADIAEgAUGYtgFBtMUBKAIAEQAAIAAgAyABQZi2AUG0xQEoAgARAAAMCQsgACABIAFBmLYBQbTFASgCABEAACAAIAAgAEGYtgFBtMUBKAIAEQAADAgLIAMgASABQZi2AUG0xQEoAgARAAAgAyADIANBmLYBQbTFASgCABEAACAAIAMgAUGYtgFBtMUBKAIAEQAADAcLIAMgASABQZi2AUG0xQEoAgARAAAgAyADIAFBmLYBQbTFASgCABEAACAAIAMgA0GYtgFBtMUBKAIAEQAADAYLIAMgASABQZi2AUG0xQEoAgARAAAgAyADIANBmLYBQbTFASgCABEAACADIAMgA0GYtgFBtMUBKAIAEQAAIAAgAyABQZi2AUG4xQEoAgARAAAMBQsgACABIAFBmLYBQbTFASgCABEAACAAIAAgAEGYtgFBtMUBKAIAEQAAIAAgACAAQZi2AUG0xQEoAgARAAAMBAsgAyABIAFBmLYBQbTFASgCABEAACADIAMgA0GYtgFBtMUBKAIA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4ABqIANB4ABqIANBMGpBmLYBQbzFASgCABEAAEHEggEgA0HgAGpBqMUBKAIAEQIACyADQZABaiQAC7AJAQR/IwBBsAJrIgQkAEHMsAEoAgAhBSAEQcgBaiADQZi2AUHAxQEoAgARAQAgBEGYAWogBEHIAWogBRBYRQRAIARBmAFqIARByAFqIAVBmLYBQczFASgCABEAAAsgBEHoAGogBEGYAWpBmLYBQcDFASgCABEBACABIARB6ABqIARBmAFqQZi2AUG0xQEoAgARAAACQCABQaDFASgCABEEAARAIAFB0JkBIAUQWEUEQCABQdCZASAFQZi2AUHMxQEoAgARAAALIABBgJoBQajFASgCABECAAwBCyAAIAFBiMMBQZi2AUG0xQEoAgARAAAgACAAQYCaAUGYtgFBvMUBKAIAEQAAIAEgAUHQmQFBmLYBQbzFASgCABEAACABIAFBmLYBQbDFASgCABEBAAsgBEHoAGogAUGYtgFBwMUBKAIAEQEAIARBOGogBEHoAGogAUGYtgFBvMUBKAIAEQAAIARB6ABqIARB6ABqQdCZAUGYtgFBvMUBKAIAEQAAIARBCGogAEGYtgFBwMUBKAIAEQEAIARBCGogBEEIaiAEQegAakGYtgFBtMUBKAIAEQAAIARBCGogBEEIaiAAQZi2AUG8xQEoAgARAAAgBEHoAGogBEE4akGAmgFBmLYBQbzFASgCABEAACAEQQhqIARBCGogBEHoAGpBmLYBQbTFASgCABEAACACIARBOGpBmLYBQcDFASgCABEBACAEQegAaiAEQQhqIARBOGpBmLYBQbzFASgCABEAACACIAIgBEHoAGpBmLYBQbzFASgCABEAACAEQZjFASgCACIBNgL8AQJAQZXGAS0AAARAIARBgAJqIgVBsJoBQbjDAUGYtgFBvMUBKAIAEQAAIAQoAvwBIQEMAQtBsJoBIQULIAQgBTYC+AECQAJAIAFBAkkNAEGoggIoAgAiBkUNACACIAIgBSABQQBBACAGEQgADAELIAIgAiAFIAFBABBPCyACIAIgBEHoAGpBmLYBQbzFASgCABEAACAEQegAaiACQZi2AUHAxQEoAgARAQAgBEHoAGogBEHoAGogBEE4akGYtgFBvMUBKAIAEQAAQQAhBQJAQZjFASgCACIBRQ0AIAQoAmggBCgCCEYEQEEB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AQAgCCAIQZi2AUGwxQEoAgARAQAgBCAEQZi2AUGwxQEoAgARAQAgBSAFQZi2AUGwxQEoAgARAQAgBiAGQZi2AUGwxQEoAgARAQAgACAAQZi2AUGwxQEoAgARAQAgAkHgD2okAAvcCwEFfyMAQYAGayICJAAgAkEBNgJkIAJCATcDACACQQA6AGggAkH0ggFBAUEBEBggAigCZCEDAkACQAJAAn8gAi0AaARAIANBAUcgAigCBEEAR3IMAQsgA0EBRg0BIANFCyEFIANFDQELIAJBBHIhBgJAAkADQCADIgRFDQEgAiAEQX9qIgNBAnRqKAIERQ0ACyAEQQFLDQELQQEhBCACQaACaiABIAIoAgQgBRBQDQILIAJBoAJqIAEgBiAEIAUQRwwBCyACQaACakGkxQEoAgARAwAgAkHQAmpBpMUBKAIAEQMAIAJBgANqQaTFASgCABEDACACQbADakGkxQEoAgARAwAgAkHgA2pBpMUBKAIAEQMAIAJBkARqQaTFASgCABEDAAtB2IMBKAIAIQMCQAJAAkACf0HcgwEtAAAEQCADQQFHQfiCASgCAEEAR3IMAQtBACEFIANBAUYNASADRQshBSADRQ0BCwJAAkADQCADIgRFDQEgBEF/aiIDQQJ0QZSCAWooAmRFDQALIARBAUsNAQtBASEEIAIgAkGgAmpB+IIBKAIAIAUQUA0CCyACIAJBoAJqQfiCASAEIAUQRwwBCyACQaTFASgCABEDACACQTBqQaTFASgCABEDACACQeAAakGkxQEoAgARAwAgAkGQAWpBpMUBKAIAEQMAIAJBwAFqQaTFASgCABEDACACQfABakGkxQEoAgARAwALIAIgAiABEDwCQEG0twEoAgBBAUYNACACQdACaiIDIANBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACACQbADaiIDIANBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACACQZAEaiIDIANBmLYBQbDFASgCABEBAAsgAkHABGogAkGgAmpB0LABQYjFASgCABEBACACQaACaiACQcAEakGYtgFB7MUBKAIAEQEAIAJB0AJqIAJBoAVqIgNBmLYBQezFASgCABEBACACQcAEaiACQYADaiIEQbCxAUGIxQEoAgARAQAgBCACQcAEakGYtgFB7MUBKAIAEQEAIAJBsANq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KAIAEQEAIAJBoA5qIAQgAkHAB2pBiMUBKAIAEQEAIAQgAkGgDmpBmLYBQezFASgCABEBACAAQZABaiABQZi2AUHsxQEoAgARAQAgAEHAAWogAkGACWpBqMUBKAIAEQIAIABB8AFqIAJBsAlqQajFASgCABECAAwCCyAKQQFqIgpBBEcNAAsgAkGgDmogAkGADGogAkHgCWpBiMUBKAIAEQEAIAJBoAJqIAJBoA5qQZi2AUHsxQEoAgARAQAgAkHQAmogAkGAD2oiBUGYtgFB7MUBKAIAEQEAIAJBwAFqIAJBgAlqQajFASgCABECACACQfABaiILIAJBsAlqQajFASgCABECACACQaAOaiACQcAKaiACQYAMakGIxQEoAgARAQAgAkHgAGogAkGgDmpBmLYBQezFASgCABEBACACQZABaiIDIAVBmLYBQezFASgCABEBACACQaAOaiACQeAAaiACQYAGakGIxQEoAgARAQAgAkHgAGogAkGgDmpBmLYBQezFASgCABEBACADIAVBmLYBQezFASgCABEBACACIAJB4AZqQajFASgCABECACACQTBqIAlBqMUBKAIAEQIAIAJBoA5qIAJBgANqIAJB4AxqQYjFASgCABEBACACQYADaiACQaAOakGYtgFB7MUBKAIAEQEAIA0gBUGYtgFB7MUBKAIAEQEAIAJBoA5qIAJBgANqIAFBiMUBKAIAEQEAIAJBgANqIAJBoA5qQZi2AUHsxQEoAgARAQAgDSAFQZi2AUHsxQEoAgARAQBBACEKA0AgAkGgDmogAkGAA2ogCkHgAGxBsIsBakGIxQEoAgARAQAgBCACQaAOakGYtgFB7MUBKAIAEQEAIAYgBUGYtgFB7MUBKAIAEQEAIAJBoA5qIAZBmLYBQcTFASgCABEBACACQaAOaiACQaAOaiAEQZi2AUG8xQEoAgARAAAgAkHwDWogBCAGQZi2AUG0xQEoAgARAAAgAkHADWogBCAGQZi2AUG4xQEoAgARAAAgAkGgBWogAkHwDWogAkHADWpBmLYBQbzFASgCABEAACAHIAJBoA5qQajFASgCABECACACQaAOaiACQaAFaiACQYjFASgCABEBACACQaAFaiACQaAOakGYtgFB7MUBKAIAEQEAIAcgBUGYtgFB7MUBKAIAEQEAAkACQEGYxQEoAgAiCEUNAEEB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AUG4xQEoAgARAAAgAiACIANBmLYBQbjFASgCABEAACABQfABaiAAKAIIIAAoAhRBiMUBKAIAEQEAIAEgAUHwAWpBmLYBQezFASgCABEBACADIAVBmLYBQezFASgCABEBACABQeAAaiABQeAAaiABQZi2AUG0xQEoAgARAAAgAiACIANBmLYBQbTFASgCABEAACAEIAFB4ABqQYjGASgCABECACAEIARBiMMBQZi2AUG0xQEoAgARAAAgAUGwA2okAAuCBwEEfyMAQaACayIDJAACQAJAIAAoAggiBEGgxQEoAgARBABFDQAgBEEwakGgxQEoAgARBABFDQAgASAAKAIQIgRBmLYBQcTFASgCABEBACABQTBqIgUgBEEwakGYtgFBxMUBKAIAEQEAIAMgASAAKAIUQYjFASgCABEBACABIANBmLYBQezFASgCABEBACAFIANB4ABqQZi2AUHsxQEoAgARAQAgAiAAKAIMIgBBqMUBKAIAEQIADAELIAMgACgCFCIEQTBqIgVBmLYBQcTFASgCABEBACADIAMgBEGYtgFBvMUBKAIAEQAAIANB8AFqIAQgBUGYtgFBtMUBKAIAEQAAIANBwAFqIAQgBUGYtgFBuMUBKAIAEQAAIAEgA0HwAWogA0HAAWpBmLYBQbzFASgCABEAACABQTBqIgUgA0GoxQEoAgARAgAgAiABQYjGASgCABECACADIAAoAhAiBEEwaiIGQZi2AUHExQEoAgARAQAgAyADIARBmLYBQbzFASgCABEAACADQfABaiAEIAZBmLYBQbTFASgCABEAACADQcABaiAEIAZBmLYBQbjFASgCABEAACABIANB8AFqIANBwAFqQZi2AUG8xQEoAgARAAAgBSADQajFASgCABECACADIAEgACgCDCIGQZi2AUG4xQEoAgARAAAgA0EwaiIEIAUgBkEwakGYtgFBuMUBKAIAEQAAIAMgA0GYtgFBxMUBKAIAEQEAIAQgBEGYtgFBxMUBKAIAEQEAIAMgAyABQZi2AUG0xQEoAgARAAAgBCAEIAVBmLYBQbTFASgCABEAACABIAIgA0GYtgFBtMUBKAIAEQAAIAUgAkEwaiAEQZi2AUG0xQEoAgARAAAgASgCACEEIAEgAUGsxQEoAgARAgAgBEEBcQRAIAEgAUHYwgFB8MUBKAIAEQUAGgsgASgC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A3BBlcYBLQAABEAgA0HwAGogA0HwAGpB6MMBQZi2AUG8xQEoAgARAAALQfjgASADQfAAakGUtgFByMUBKAIAEQEAQciBAkEANgIAQcyBAkEAOgAAIABBAToAAAsgA0HgAWokAAviAwEDfyMAQfABayICJAAgAUHgAGoiA0GgxQEoAgARBABFBEAgAyADQZS2AUHIxQEoAgARAQAgAkHAAWogA0GYtgFBwMUBKAIAEQEAIAEgASACQcABakGYtgFBvMUBKAIAEQAAIAFBMGoiBCAEIAJBwAFqQZi2AUG8xQEoAgARAAAgBCAEIANBmLYBQbzFASgCABEAACADQYjDAUGoxQEoAgARAgALIAJBkAFqIAEQ8AEgAkHAAWogAkGQAWpBqMUBKAIAEQIAIAJB4ABqIAEQ7wEgAkGQAWogAkHgAGpBqMUBKAIAEQIAIAJBMGogAUHgowEQfSACQeAAaiACQTBqQajFASgCABECACACIAFB4KkBEH0gAkEwaiACQajFASgCABECACAAQeAAaiIDIAJBkAFqIAJBMGpBmLYBQbzFASgCABEAACAAIAJBwAFqIAJBMGpBmLYBQbzFASgCABEAACAAIAAgA0GYtgFBvMUBKAIAEQAAIABBMGoiACABQTBqIAJB4ABqQZi2AUG8xQEoAgARAAAgACAAIAJBkAFqQZi2AUG8xQEoAgARAAAgAkGQAWogA0GYtgFBwMUBKAIAEQEAIAAgACACQZABakGYtgFBvMUBKAIAEQAAIAJB8AFqJAALgAEBAX4gAUEBRgRAIABBiMMBQajFASgCABECAA8LIABBpMUBKAIAEQMAAkAgAUUNACAAIAGsIgIgAkI/hyICfCAChTcCACABQX9MBEAgACAAQZi2AUGwxQEoAgARAQALQZXGAS0AAEUNACAAIABB6MMBQZi2AUG8xQEoAgARAAALC7wMAQ9/IwBBoAtrIgMkACADQZAKaiABQajFASgCABECACADQcAKaiIEIAFBMGpBqMUBKAIAEQIAIANB8ApqIAFB4ABqQajFASgCABECACADQZAKahAwIAMgA0GQCmpBmLYBQcTFASgCABEBACADQYAJaiADIANBkApqQZi2AUG0xQEoAgARAAAgA0GwCWoiBiAEQZi2AUGwxQEoAgARAQAgA0HgBmogAkGoxQEoAgARAgAgA0GQB2oiDSACQTBqQajFASgCABECACADQaAIaiIOIAJBwAFqIANBgAlqQZi2AUG8xQEoAgARAAAgA0HQCGoiDyACQfABaiADQYAJakGYtgFBvMUBKAIAEQAAIANBwAdqIhAgAkHgAGogBkGYtgFBvMUBKAIAEQAAIANB8AdqIhEgAkGQAWogBkGYtgFBvMUBKAIAEQAAIANBwARqIAJBoAJqQajFASgCABECACADQfAEaiIHIAJB0AJqQajFASgCABECACADQYAGaiIIIAJB4ANqIANBkApqQZi2AUG8xQEoAgARAAAgA0GwBmoiCSACQZAEaiADQZAKakGYtgFBvMUBKAIAEQAAIANBoAVqIgogAkGAA2ogBEGYtgFBvMUBKAIAEQAAIANB0AVqIgsgAkGwA2ogBEGYtgFBvMUBKAIAEQAAIAAgA0HgBmoQIAJAQdj+AC0AAARAIAAgA0HABGoQHAwBCyAAIANBwARqEBsLQQIhDAJAQfSzASgCAEECTQRAQQIhBQwBC0ECIQUDQCADQcAEaiACIAVBoAJsaiIBQajFASgCABECACAHIAFBMGpBqMUBKAIAEQIAIAggAUHAAWogA0GACWpBmLYBQbzFASgCABEAACAJIAFB8AFqIANBgAlqQZi2AUG8xQEoAgARAAAgCiABQeAAaiAGQZi2AUG8xQEoAgARAAAgCyABQZABaiAGQZi2AUG8xQEoAgARAAAgACAAECUCQEHY/gAtAAAEQCAAIANBwARqEBwMAQsgACADQcAEahAbCyAFQQFqIQECQCAMQfSyAWotAABFBEAgASEFDAELIANBwARqIAIgAUGgAmxqIgFBqMUBKAIAEQIAIAcgAUEwakGoxQEoAgARAgAgCCABQcABaiADQZAKakGYtgFBvMUBKAIAEQAAIAkgAUHwAWogA0GQCmpBmLYBQbzFASgCABEAACAKIAFB4ABqIARBmLYBQbzFASgCABEAACALIAFBkAFqIARBmLYBQbzFASgCABEAACAFQQJqIQVB2P4ALQAABEAgACADQcAEahAcDAELIAAgA0HABGoQGwsgDEEBaiIMQfSzASgCAEkNAAsLQcT/ACgCACEBAkACQEHI/wAtAAAEQCABQQFHDQFB5P4AKAIARQ0CDAELAkAgAQ4CAQACCwNAIAFFDQIgAUF/aiIBQQJ0QeT+AGooAgBFDQALDAELIABBoAJqIgEgAUGYtgFBsMUBKAIAEQEAIABB0AJqIgEgAUGYtgFBsMUBKAIAEQEAIABBgANqIgEgAUGYtgFBsMUBKAIAEQEAIABBsANqIgEgAUGYtgFBsMUBKAIAEQEAIABB4ANqIgEgAUGYtgFBsMUBKAIAEQEAIABBkARqIgEgAUGYtgFBsMUBKAIAEQEAC0G5gAEtAABFBEAgA0HgBmogAiAFQaACbGoiAUGoxQEoAgARAgAgDSABQTBqQajFASgCABECACAOIAFBwAFqIANBkApqQZi2AUG8xQEoAgARAAAgDyABQfABaiADQZAKakGYtgFBvMUBKAIAEQAAIBAgAUHgAGogBEGYtgFBvMUBKAIAEQAAIBEgAUGQAWogBEGYtgFBvMUBKAIAEQAAIANBwARqIAFBoAJqQajFASgCABECACAHIAFB0AJqQajFASgCABECACAIIAFB4ANqIANBkApqQZi2AUG8xQEoAgARAAAgCSABQZAEaiADQZAKakGYtgFBvMUBKAIAEQAAIAogAUGAA2ogBEGYtgFBvMUBKAIAEQAAIAsgAUGwA2ogBEGYtgFBvMUBKAIAEQAAIAMgA0HgBmoQIAJAQdj+AC0AAARAIAMgA0HABGoQHAwBCyADIANBwARqEBsLIAAgACADEAcLIANBoAtqJAALlxsBEX8jAEHAnQFrIgUkACADBEADQAJAIAEgBkGQAWxqIgxB4ABqIgpBoMUBKAIAEQQADQAgAiAGQaACbGoiCEHAAWoiC0GgxQEoAgARBAAEQCAIQfABakGgxQEoAgARBAANAQsgBUHAiwFqIAlBkAFsaiIHIAxBqMUBKAIAEQIAIAdBMGogDEEwakGoxQEoAgARAgAgB0HgAGogCkGoxQEoAgARAgAgBxAwIAVBwOcAaiAJQaACbGoiByAIQajFASgCABECACAHQTBqIAhBMGpBqMUBKAIAEQIAIAdB4ABqIAhB4ABqQajFASgCABECACAHQZABaiAIQZABakGoxQEoAgARAgAgB0HAAWogC0GoxQEoAgARAgAgB0HwAWogCEHwAWpBqMUBKAIAEQIAAkACQAJAQZiCAigCAA4CAAECCyAHEEYMAQsgBxBFCyAJQQFqIQkLIAZBAWoiBiADRw0ACwsgCSADIAkbIQECQCAJDQAgBEUNACAFQYA/akGIwwFBqMUBKAIAEQIAIAVBsD9qIgFBpMUBKAIAEQMAIAVB4D9qIgJBpMUBKAIAEQMAIAVBkMAAaiIGQaTFASgCABEDACAFQcDAAGoiB0GkxQEoAgARAwAgBUHwwABqIghBpMUBKAIAEQMAIAVBoMEAaiIMQaTFASgCABEDACAFQdDBAGoiCkGkxQEoAgARAwAgBUGAwgBqIgtBpMUBKAIAEQMAIAVBsMIAaiIPQaTFASgCABEDACAFQeDCAGoiDUGkxQEoAgARAwAgBUGQwwBqIhBBpMUBKAIAEQMAIAAgBUGAP2pBqMUBKAIAEQIAIABBMGogAUGoxQEoAgARAgAgAEHgAGogAkGoxQEoAgARAgAgAEGQAWogBkGoxQEoAgARAgAgAEHAAWogB0GoxQEoAgARAgAgAEHwAWogCEGoxQEoAgARAgAgAEGgAmogDEGoxQEoAgARAgAgAEHQAmogCkGoxQEoAgARAgAgAEGAA2ogC0GoxQEoAgARAgAgAEGwA2ogD0GoxQEoAgARAgAgAEHgA2ogDUGoxQEoAgARAgAgAEGQBGogEEGoxQEoAgARAgAgAyEBCwJAIAlFDQAgACAFQYDjAGogBBshAyABBEAgBUGwBmohDCAFQYAGaiEKIAVB0AVqIQsgBUGgBWohDyAFQdAIaiENIAVBoAhqIRAgBUHwB2ohEiAFQcAHaiETQQAhCQNAIAlBoAJsIgIgBUGAP2pqIgYgBUHA5wBqIAJqIgdBqMUBKAIAEQIAIAZBMGogB0EwaiIOQajFASgCABECACAGQeAAaiAHQeAAaiIUQajFASgCABECACAGQZABaiAHQZABaiIVQajFASgCABECACAGQcABaiAHQcABaiIIQajFASgCABECACAGQfABaiAHQfABaiIRQajFASgCABECAAJAQfyzAS0AAEUNACAFQYAbaiACaiECAkAgCEGgxQEoAgARBABFDQAgEUGgxQEoAgARBABFDQAgAkGkxQEoAgARAwAgAkEwakGkxQEoAgARAwAgAkHgAGpBpMUBKAIAEQMAIAJBkAFqQaTFASgCABEDACACQcABakGkxQEoAgARAwAgAkHwAWpBpMUBKAIAEQMADAELIAIgB0GoxQEoAgARAgAgAkEwaiAOQajFASgCABECACACQeAAaiAUQZi2AUGwxQEoAgARAQAgAkGQAWogFUGYtgFBsMUBKAIAEQEAIAJBwAFqIAhBqMUBKAIAEQIAIAJB8AFqIBFBqMUBKAIAEQIACyAFIAlBkAFsIgggBUHAiwFqaiICQZi2AUHExQEoAgARAQAgBUGACWogCGoiCCAFIAJBmLYBQbTFASgCABEAACAIQTBqIhEgAkEwaiIOQZi2AUGwxQEoAgARAQAgBUHgBmogBhA2IBMgEyARQZi2AUG8xQEoAgARAAAgEiASIBFBmLYBQbzFASgCABEAACAQIBAgCEGYtgFBvMUBKAIAEQAAIA0gDSAIQZi2AUG8xQEoAgARAAAgBUHABGogBiAHECEgDyAPIA5BmLYBQbzFASgCABEAACALIAsgDkGYtgFBvMUBKAIAEQAAIAogCiACQZi2AUG8xQEoAgARAAAgDCAMIAJBmLYBQbzFASgCABEAAAJAIAlFBEAgAyAFQeAGahAgQdj+AC0AAARAIAMgBUHABGoQHAwCCyADIAVBwARqEBsMAQsgBSAFQeAGahAgAkBB2P4ALQAABEAgBSAFQcAEahAcDAELIAUgBUHABGoQGwsgAyADIAUQBwsgCUEBaiIJIAFHDQALC0H0swEoAgBBA08EQCAFQbAGaiECIAVBgAZqIQkgBUHQBWohByAFQaAFaiEIQQIhDANAIAMgAxAlIAEEQEEAIQYDQCAFQcAEaiAGQaACbCIKIAVBgD9qaiILEDYgCCAIIAZBkAFsIg8gBUGACWpqIg1BMGoiEEGYtgFBvMUBKAIAEQAAIAcgByAQQZi2AUG8xQEoAgARAAAgCSAJIA1BmLYBQbzFASgCABEAACACIAIgDUGYtgFBvMUBKAIAEQAAAkBB2P4ALQAABEAgAyAFQcAEahAcDAELIAMgBUHABGoQGwsCQCAMQfSyAWosAAAiDUUNAAJAIA1BAU4EQCAFQcAEaiALIAVBwOcAaiAKahAhDAELIAVBwARqIAsgBUGAG2ogCmoQIQsgCCAIIAVBwIsBaiAPaiIKQTBqIgtBmLYBQbzFASgCABEAACAHIAcgC0GYtgFBvMUBKAIAEQAAIAkgCSAKQZi2AUG8xQEoAgARAAAgAiACIApBmLYBQbzFASgCABEAAEHY/gAtAAAEQCADIAVBwARqEBwMAQsgAyAFQcAEahAbCyAGQQFqIgYgAUcNAAsLIAxBAWoiDEH0swEoAgBJDQALC0HE/wAoAgAhBgJAAkBByP8ALQAABEAgBkEBRw0BQeT+ACgCAEUNAgwBCwJAIAYOAgEAAgsDQCAGRQ0CIAZBf2oiBkECdEHk/gBqKAIARQ0ACwwBCyAAQaACaiAFQaDlAGogBBsiAiACQZi2AUGwxQEoAgARAQAgAEHQAmogBUHQ5QBqIAQbIgIgAkGYtgFBsMUBKAIAEQEAIABBgANqIAVBgOYAaiAEGyICIAJBmLYBQbDFASgCABEBACAAQbADaiAFQbDmAGogBBsiAiACQZi2AUGwxQEoAgARAQAgAEHgA2ogBUHg5gBqIAQbIgIgAkGYtgFBsMUBKAIAEQEAIABBkARqIAVBkOcAaiAEGyICIAJBmLYBQbDFASgCABEBAAsCQEG5gAEtAAANACABRQ0AIAVBsAZqIQwgBUGABmohCiAFQdAFaiELIAVBoAVqIQ8gBUHQCGohDSAFQaAIaiEQIAVB8AdqIRIgBUHAB2ohE0EAIQkDQEHE/wAoAgAhBgJAAkBByP8ALQAABEAgBkEBRw0BQeT+ACgCAEUNAgwBCwJAIAYOAgEAAgsDQCAGRQ0CIAZBf2oiBkECdEHk/gBqKAIARQ0ACwwBCwJAIAVBgD9qIAlBoAJsaiICQcABaiIGQaDFASgCABEEAEUNACACQfABaiIHQaDFASgCABEEAEUNACACQaTFASgCABEDACACQTBqQaTFASgCABEDACACQeAAakGkxQEoAgARAwAgAkGQAWpBpMUBKAIAEQMAIAZBpMUBKAIAEQMAIAdBpMUBKAIAEQMADAELIAIgAkGoxQEoAgARAgAgAkEwaiIHIAdBqMUBKAIAEQIAIAJB4ABqIgcgB0GYtgFBsMUBKAIAEQEAIAJBkAFqIgcgB0GYtgFBsMUBKAIAEQEAIAYgBkGoxQEoAgARAgAgAkHwAWoiAiACQajFASgCABECAAsgCUGgAmwiBiAFQcDnAGpqIgIgAhAFIAVB4AZqIAVBgD9qIAZqIhEgAhAhIBMgEyAFQcCLAWogCUGQAWxqIgZBMGoiB0GYtgFBvMUBKAIAEQAAIBIgEiAHQZi2AUG8xQEoAgARAAAgECAQIAZBmLYBQbzFASgCABEAACANIA0gBkGYtgFBvMUBKAIAEQAAIAIgAhAFAkACQCACQcABaiIIQaDFASgCABEEAEUNACACQfABaiIOQaDFASgCABEEAEUNACACQaTFASgCABEDACACQTBqQaTFASgCABEDACACQeAAakGkxQEoAgARAwAgAkGQAWpBpMUBKAIAEQMAIAhBpMUBKAIAEQMAIA5BpMUBKAIAEQMADAELIAIgAkGoxQEoAgARAgAgAkEwaiIOIA5BqMUBKAIAEQIAIAJB4ABqIg4gDkGYtgFBsMUBKAIAEQEAIAJBkAFqIg4gDkGYtgFBsMUBKAIAEQEAIAggCEGoxQEoAgARAgAgAkHwAWoiCCAIQajFASgCABECAAsgBUHABGogESACECEgDyAPIAdBmLYBQbzFASgCABEAACALIAsgB0GYtgFBvMUBKAIAEQAAIAogCiAGQZi2AUG8xQEoAgARAAAgDCAMIAZBmLYBQbzFASgCABEAACAFIAVB4AZqECACQEHY/gAtAAAEQCAFIAVBwARqEBwMAQsgBSAFQcAEahAbCyADIAMgBRAHIAlBAWoiCSABRw0ACwsgBA0AIAAgACADEAcLIAVBwJ0BaiQAC/4EAQF/IwBBwARrIgIkAAJAAkAgAUGgxQEoAgARBABFDQAgAUEwakGgxQEoAgARBABFDQAgAUHgAGpBoMUBKAIAEQQARQ0AIAFBkAFqQaDFASgCABEEAEUNACABQcABakGgxQEoAgARBABFDQAgAUHwAWpBoMUBKAIAEQQARQ0AIAFBoAJqQaDFASgCABEEAEUNACABQdACakGgxQEoAgARBABFDQAgAUGAA2pBoMUBKAIAEQQARQ0AIAFBsANqQaDFASgCABEEAEUNACABQeADakGgxQEoAgARBABFDQAgAUGQBGpBoMUBKAIAEQQARQ0AIABBpMUBKAIAEQMAIABBMGpBpMUBKAIAEQMAIABB4ABqQaTFASgCABEDACAAQZABakGkxQEoAgARAwAgAEHAAWpBpMUBKAIAEQMAIABB8AFqQaTFASgCABEDACAAQaACakGkxQEoAgARAwAgAEHQAmpBpMUBKAIAEQMAIABBgANqQaTFASgCABEDACAAQbADakGkxQEoAgARAwAgAEHgA2pBpMUBKAIAEQMAIABBkARqQaTFASgCABEDAAwBCyACIAEQZiACIAIgARAHIAAgAhBnIAJBoAJqIgEgAUGYtgFBsMUBKAIAEQEAIAJB0AJqIgEgAUGYtgFBsMUBKAIAEQEAIAJBgANqIgEgAUGYtgFBsMUBKAIAEQEAIAJBsANqIgEgAUGYtgFBsMUBKAIAEQEAIAJB4ANqIgEgAUGYtgFBsMUBKAIAEQEAIAJBkARqIgEgAUGYtgFBsMUBKAIAEQEAIAAgACACEAdBuYABLQAABEAgACAAENQCDAELIAAgABDTAgsgAkHABGokAAumGgEVfyMAQYASayIDJAAgA0HwEGogAUGoxQEoAgARAgAgA0GgEWoiBSABQTBqQajFASgCABECACADQdARaiABQeAAakGoxQEoAgARAgAgA0HQDmogAkGoxQEoAgARAgAgA0GAD2oiBiACQTBqQajFASgCABECACADQbAPaiIHIAJB4ABqQajFASgCABECACADQeAPaiILIAJBkAFqQajFASgCABECACADQZAQaiIMIAJBwAFqQajFASgCABECACADQcAQaiIEIAJB8AFqQajFASgCABECACADQfAQahAwAkACQAJAQZiCAigCAA4CAAECCyADQdAOahBGDAELIANB0A5qEEULAkACQCAMQaDFASgCABEEAEUNACAEQaDFASgCABEEAEUNACADQZAKakGIwwFBqMUBKAIAEQIAIANBwApqIgFBpMUBKAIAEQMAIANB8ApqIgJBpMUBKAIAEQMAIANBoAtqIgRBpMUBKAIAEQMAIANB0AtqIgVBpMUBKAIAEQMAIANBgAxqIgZBpMUBKAIAEQMAIANBsAxqIgdBpMUBKAIAEQMAIANB4AxqIghBpMUBKAIAEQMAIANBkA1qIglBpMUBKAIAEQMAIANBwA1qIgpBpMUBKAIAEQMAIANB8A1qIgtBpMUBKAIAEQMAIANBoA5qIgxBpMUBKAIAEQMAIAAgA0GQCmpBqMUBKAIAEQIAIABBMGogAUGoxQEoAgARAgAgAEHgAGogAkGoxQEoAgARAgAgAEGQAWogBEGoxQEoAgARAgAgAEHAAWogBUGoxQEoAgARAgAgAEHwAWogBkGoxQEoAgARAgAgAEGgAmogB0GoxQEoAgARAgAgAEHQAmogCEGoxQEoAgARAgAgAEGAA2ogCUGoxQEoAgARAgAgAEGwA2ogCkGoxQEoAgARAgAgAEHgA2ogC0GoxQEoAgARAgAgAEGQBGogDEGoxQEoAgARAgAMAQsgA0HwB2ogA0HQDmpBqMUBKAIAEQIAIANBoAhqIhAgBkGoxQEoAgARAgAgA0HQCGoiESAHQajFASgCABECACADQYAJaiIWIAtBqMUBKAIAEQIAIANBsAlqIg0gDEGoxQEoAgARAgAgA0HgCWoiDiAEQajFASgCABECAAJAQfyzAS0AAEUNAAJAIAxBoMUBKAIAEQQARQ0AIARBoMUBKAIAEQQARQ0AIANB0AVqQaTFASgCABEDACADQYAGakGkxQEoAgARAwAgA0GwBmpBpMUBKAIAEQMAIANB4AZqQaTFASgCABEDACADQZAHakGkxQEoAgARAwAgA0HAB2pBpMUBKAIAEQMADAELIANB0AVqIANB0A5qQajFASgCABECACADQYAGaiAGQajFASgCABECACADQbAGaiAHQZi2AUGwxQEoAgARAQAgA0HgBmogA0HgD2pBmLYBQbDFASgCABEBACADQZAHaiAMQajFASgCABECACADQcAHaiAEQajFASgCABECAAsgA0GQCmogA0HwEGpBmLYBQcTFASgCABEBACADIANBkApqIANB8BBqQZi2AUG0xQEoAgARAAAgA0EwaiIPIAVBmLYBQbDFASgCABEBACADQbADaiADQfAHahA2IANBkARqIhIgEiAPQZi2AUG8xQEoAgARAAAgA0HABGoiEyATIA9BmLYBQbzFASgCABEAACADQfAEaiIUIBQgA0GYtgFBvMUBKAIAEQAAIANBoAVqIhUgFSADQZi2AUG8xQEoAgARAAAgA0GQAWogA0HwB2ogA0HQDmoQISADQfABaiICIAIgBUGYtgFBvMUBKAIAEQAAIANBoAJqIgggCCAFQZi2AUG8xQEoAgARAAAgA0HQAmoiCSAJIANB8BBqQZi2AUG8xQEoAgARAAAgA0GAA2oiCiAKIANB8BBqQZi2AUG8xQEoAgARAAAgACADQbADahAgAkBB2P4ALQAABEAgACADQZABahAcDAELIAAgA0GQAWoQGwtBAiEBQfSzASgCAEECSwRAA0AgA0GQAWogA0HwB2oQNiACIAIgD0GYtgFBvMUBKAIAEQAAIAggCCAPQZi2AUG8xQEoAgARAAAgCSAJIANBmLYBQbzFASgCABEAACAKIAogA0GYtgFBvMUBKAIAEQAAIAAgABAlAkBB2P4ALQAABEAgACADQZABahAcDAELIAAgA0GQAWoQGwsCQCABQfSyAWosAAAiF0UNAAJAIBdBAU4EQCADQZABaiADQfAHaiADQdAOahAhDAELIANBkAFqIANB8AdqIANB0AVqECELIAIgAiAFQZi2AUG8xQEoAgARAAAgCCAIIAVBmLYBQbzFASgCABEAACAJIAkgA0HwEGpBmLYBQbzFASgCABEAACAKIAogA0HwEGpBmLYBQbzFASgCABEAAEHY/gAtAAAEQCAAIANBkAFqEBwMAQsgACADQZABahAbCyABQQFqIgFB9LMBKAIASQ0ACwtBxP8AKAIAIQECQAJAQcj/AC0AAARAIAFBAUcNAUHk/gAoAgBFDQIMAQsCQCABDgIBAAILA0AgAUUNAiABQX9qIgFBAnRB5P4AaigCAEUNAAsMAQsgAEGgAmoiASABQZi2AUGwxQEoAgARAQAgAEHQAmoiASABQZi2AUGwxQEoAgARAQAgAEGAA2oiASABQZi2AUGwxQEoAgARAQAgAEGwA2oiASABQZi2AUGwxQEoAgARAQAgAEHgA2oiASABQZi2AUGwxQEoAgARAQAgAEGQBGoiASABQZi2AUGwxQEoAgARAQALQbmAAS0AAA0AQcT/ACgCACEBAkACQEHI/wAtAAAEQCABQQFHDQFB5P4AKAIARQ0CDAELAkAgAQ4CAQACCwNAIAFFDQIgAUF/aiIBQQJ0QeT+AGooAgBFDQALDAELAkAgDUGgxQEoAgARBABFDQAgDkGgxQEoAgARBABFDQAgA0HwB2pBpMUBKAIAEQMAIBBBpMUBKAIAEQMAIBFBpMUBKAIAEQMAIBZBpMUBKAIAEQMAIA1BpMUBKAIAEQMAIA5BpMUBKAIAEQMADAELIANB8AdqIANB8AdqQajFASgCABECACAQIBBBqMUBKAIAEQIAIBEgEUGYtgFBsMUBKAIAEQEAIANBgAlqIgEgAUGYtgFBsMUBKAIAEQEAIA0gDUGoxQEoAgARAgAgDiAOQajFASgCABECAAsCQEG0twEoAgBBAUYNACAGIAZBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACALIAtBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACAEIARBmLYBQbDFASgCABEBAAsgA0GQCmogA0HQDmpB0LABQYjFASgCABEBACADQdAOaiADQZAKakGYtgFB7MUBKAIAEQEAIAYgA0HwCmoiAUGYtgFB7MUBKAIAEQEAIANBkApqIAdBsLEBQYjFASgCABEBACAHIANBkApqQZi2AUHsxQEoAgARAQAgCyABQZi2AUHsxQEoAgARAQAgA0GwA2ogA0HwB2ogA0HQDmoQISASIBIgBUGYtgFBvMUBKAIAEQAAIBMgEyAFQZi2AUG8xQEoAgARAAAgFCAUIANB8BBqQZi2AUG8xQEoAgARAAAgFSAVIANB8BBqQZi2AUG8xQEoAgARAAACQEG0twEoAgBBAUYNACAGIAZBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACALIAtBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACAEIARBmLYBQbDFASgCABEBAAsgA0GQCmogA0HQDmpB0LABQYjFASgCABEBACADQdAOaiADQZAKakGYtgFB7MUBKAIAEQEAIAYgAUGYtgFB7MUBKAIAEQEAIANBkApqIAdBsLEBQYjFASgCABEBACAHIANBkApqQZi2AUHsxQEoAgARAQAgCyABQZi2AUHsxQEoAgARAQACQAJAIAxBoMUBKAIAEQQARQ0AIARBoMUBKAIAEQQARQ0AIANB0A5qQaTFASgCABEDACAGQaTFASgCABEDACAHQaTFASgCABEDACALQaTFASgCABEDACAMQaTFASgCABEDACAEQaTFASgCABEDAAwBCyADQdAOaiADQdAOakGoxQEoAgARAgAgBiAGQajFASgCABECACAHIAdBmLYBQbDFASgCABEBACADQeAPaiIBIAFBmLYBQbDFASgCABEBACAMIAxBqMUBKAIAEQIAIAQgBEGoxQEoAgARAgALIANBkAFqIANB8AdqIANB0A5qECEgAiACIAVBmLYBQbzFASgCABEAACAIIAggBUGYtgFBvMUBKAIAEQAAIAkgCSADQfAQakGYtgFBvMUBKAIAEQAAIAogCiADQfAQakGYtgFBvMUBKAIAEQAAIANBkApqIANBsANqECACQEHY/gAtAAAEQCADQZAKaiADQZABahAcDAELIANBkApqIANBkAFqEBsLIAAgACADQZAKahAHCyADQYASaiQAC/8DAQt/IAAgASgCACIEIAIoAgAiBWsiDDYCACAAIAEoAgQiBiACKAIEIgcgBCAFSWoiBGsiBTYCBCAAIAEoAggiCCAEIAdJIAYgBElqIgYgAigCCGoiBGsiBzYCCCAAIAEoAgwiCSAEIAZJIAggBElqIgYgAigCDGoiBGsiCDYCDCAAIAEoAhAiCiAEIAZJIAkgBElqIgYgAigCEGoiBGsiCTYCECAAIAEoAhQiCyAEIAZJIAogBElqIgYgAigCFGoiBGsiCjYCFCAAIAEoAhgiDSAEIAZJIAsgBElqIgYgAigCGGoiBGsiCzYCGCAAIAEoAhwiDiAEIAZJIA0gBElqIgQgAigCHGoiAWsiAjYCHCABIARJQX9BACAOIAFJG0cEQCAAIAMoAgAiASAMaiIENgIAIAAgBSAEIAFJaiIBIAMoAgRqIgQ2AgQgACAEIAFJIAEgBUlqIgQgB2oiASADKAIIaiIFNgIIIAAgBSABSSABIARJaiIEIAhqIgEgAygCDGoiBTYCDCAAIAUgAUkgASAESWoiBCAJaiIBIAMoAhBqIgU2AhAgACAFIAFJIAEgBElqIgQgCmoiASADKAIUaiIFNgIUIAAgBSABSSABIARJaiIEIAtqIgEgAygCGGoiBTYCGCAAIAMoAhwgAmogASAESWogBSABSWo2AhwLC+kFAQx/IwBBgAlrIgQkACAAIAFGBEAgBEHABGogAEGoxQEoAgARAgAgBEHwBGogAEEwakGoxQEoAgARAgAgBEGgBWogAEHgAGpBqMUBKAIAEQIAIARB0AVqIABBkAFqQajFASgCABECACAEQYAGaiAAQcABakGoxQEoAgARAgAgBEGwBmogAEHwAWpBqMUBKAIAEQIAIARB4AZqIABBoAJqQajFASgCABECACAEQZAHaiAAQdACakGoxQEoAgARAgAgBEHAB2ogAEGAA2pBqMUBKAIAEQIAIARB8AdqIABBsANqQajFASgCABECACAEQaAIaiAAQeADakGoxQEoAgARAgAgBEHQCGogAEGQBGpBqMUBKAIAEQIAIARBwARqIQELIARBiMMBQajFASgCABECACAEQTBqIgVBpMUBKAIAEQMAIARB4ABqIgZBpMUBKAIAEQMAIARBkAFqIgdBpMUBKAIAEQMAIARBwAFqIghBpMUBKAIAEQMAIARB8AFqIglBpMUBKAIAEQMAIARBoAJqIgpBpMUBKAIAEQMAIARB0AJqIgtBpMUBKAIAEQMAIARBgANqIgxBpMUBKAIAEQMAIARBsANqIg1BpMUBKAIAEQMAIARB4ANqIg5BpMUBKAIAEQMAIARBkARqIg9BpMUBKAIAEQMAIAAgBEGoxQEoAgARAgAgAEEwaiAFQajFASgCABECACAAQeAAaiAGQajFASgCABECACAAQZABaiAHQajFASgCABECACAAQcABaiAIQajFASgCABECACAAQfABaiAJQajFASgCABECACAAQaACaiAKQajFASgCABECACAAQdACaiALQajFASgCABECACAAQYADaiAMQajFASgCABECACAAQbADaiANQajFASgCABECACAAQeADaiAOQajFASgCABECACAAQZAEaiAPQajFASgCABECACAAIAEgAiADAn9BnMUBKAIAGkEACxDkASAEQYAJaiQAC40FAQV/IwBBoAhrIgIkACACQcAHaiABQeAAaiIFQZi2AUHExQEoAgARAQAgAkHwB2oiAyABQZABaiIGQZi2AUHExQEoAgARAQAgAkGABmogAkHAB2ogAUHAAWoiBEGIxQEoAgARAQAgAkHABGogAkHAB2ogAUGIxQEoAgARAQAgAkGAA2ogAUGMxQEoAgARAgAgAkHAAWogBEGMxQEoAgARAgAgAkHAB2ogASAFQZi2AUG0xQEoAgARAAAgAyABQTBqIAZBmLYBQbTFASgCABEAACACQcAHaiACQcAHaiAEQZi2AUG0xQEoAgARAAAgAyADIAFB8AFqQZi2AUG0xQEoAgARAAAgAiACQcAHakGMxQEoAgARAgAgAiACIAJBgANqQZi2AUHoxQEoAgARAAAgAkHgAGoiASABIAJB4ANqIgNBmLYBQejFASgCABEAACACIAIgAkGABmpBmLYBQejFASgCABEAACABIAEgAkHgBmoiBEGYtgFB6MUBKAIAEQAAIAIgAiACQcABakGYtgFB6MUBKAIAEQAAIAEgASACQaACaiIFQZi2AUHoxQEoAgARAAAgAEGAA2ogAiACQcAEakGYtgFB6MUBKAIAEQAAIABB4ANqIAEgAkGgBWoiAUGYtgFB6MUBKAIAEQAAIAJBgAZqIAJBgAZqQZDFASgCABECACAAIAJBgANqIAJBgAZqQZi2AUHkxQEoAgARAAAgAEHgAGogAyAEQZi2AUHkxQEoAgARAAAgAkHAAWogAkHAAWpBkMUBKAIAEQIAIABBwAFqIAJBwAFqIAJBwARqQZi2AUHkxQEoAgARAAAgAEGgAmogBSABQZi2AUHkxQEoAgARAAAgAkGgCGokAAuuAgEFfwJAAkBBmMUBKAIAIgNFDQAgACgCAEGIwwEoAgBHDQFBASEEA0AgBCICIANGDQEgAkEBaiEEIAAgAkECdCIFaigCACAFQYjDAWooAgBGDQALIAIgA0kNAQsgAEEwakGgxQEoAgARBABFDQAgAEHgAGpBoMUBKAIAEQQARQ0AIABBkAFqQaDFASgCABEEAEUNACAAQcABakGgxQEoAgARBABFDQAgAEHwAWpBoMUBKAIAEQQARQ0AIABBoAJqQaDFASgCABEEAEUNACAAQdACakGgxQEoAgARBABFDQAgAEGAA2pBoMUBKAIAEQQARQ0AIABBsANqQaDFASgCABEEAEUNACAAQeADakGgxQEoAgARBABFDQAgAEGQBGpBoMUBKAIAEQQAIQELIAEL0AMBBX9BmMUBKAIAIgRFBEBBAQ8LAkAgACgCACABKAIARw0AQQEhAwJAA0AgAyICIARGDQEgAkEBaiEDIAAgAkECdCIFaigCACABIAVqKAIARg0ACyACIARJDQELIAAoAjAgASgCMEcNAEEBIQMCQANAIAMiAiAERg0BIAJBAWohAyAAIAJBAnQiBWooAjAgASAFaigCMEYNAAsgAiAESQ0BCyAAKAJgIAEoAmBHDQBBASEDAkADQCADIgIgBEYNASACQQFqIQMgACACQQJ0IgVqKAJgIAEgBWooAmBGDQALIAIgBEkNAQsgACgCkAEgASgCkAFHDQBBASEDAkADQCADIgIgBEYNASACQQFqIQMgACACQQJ0IgVqKAKQASABIAVqKAKQAUYNAAsgAiAESQ0BCyAAKALAASABKALAAUcNAEEBIQMCQANAIAMiAiAERg0BIAJBAWohAyAAIAJBAnQiBWooAsABIAEgBWooAsABRg0ACyACIARJDQELIAAoAvABIAEoAvABRw0AQQEhAwNAAkAgBCADIgJGBEAgBCECDAELIAJBAWohAyAAIAJBAnQiBmooAvABIAEgBmooAvABRg0BCwsgAiAETyEGCyAGC7sCAQF+IABBpMUBKAIAEQMAIABBMGpBpMUBKAIAEQMAIABB4ABqQaTFASgCABEDACAAQZABakGkxQEoAgARAwAgAEHAAWpBpMUBKAIAEQMAIABB8AFqQaTFASgCABEDACAAQaACakGkxQEoAgARAwAg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QbjDAUGYtgFBvMUBKAIAEQAADAELIAUhAAsgBCAANgIQIAIoAggiBSACKAIERgRAIAFBADoAAAwDCyACKAIAIAVqQTNBMiAAKAIAQQFxGzoAACACIAIoAghBAWoiADYCCCABQQE6AABBACEGIAdFBEAgACACKAIERgRAIAFBADoAAAwECyACKAIAIABqIAg6AAAgAiACKAIIQQFqNgIIIAFBAToAAEEgIQYLIARB+ABqIAEgAiADEBcgAS0AAEUNAiAHRQRAIAIoAggiACACKAIERgRAIAFBADoAAAwECyACKAIAIABqIAY6AAAgAiACKAIIQQFqNgIIIAFBAToAAAsgBEGoAWogASACIAMQFwwCCyACKAIIIgAgAigCBEYEQCABQQA6AAAMAgsgAigCACAAakExOgAAIAIgAigCCEEBaiIANgIIIAFBAToAAEEAIQYgB0UEQCAAIAIoAgRGBEAgAUEAOgAADAMLIAIoAgAgAGogCDoAACACIAIoAghBAWo2AgggAUEBOgAAQSAhBgsgBEH4AGogASACIAMQFyABLQAARQ0BIARBqAFqIQUCQAJAIAdFBEAgAigCCCIAIAIoAgRHDQEgAUEAOgAADAQLIAUgASACIAMQFyABLQAADQEMAwsgAigCACAAaiAGOgAAIAIgAigCCEEBajYCCCABQQE6AAAgBSABIAIgAxAXIAEtAABFDQIgAigCCCIAIAIoAgRGBEAgAUEAOgAADAMLIAIoAgAgAGogCDoAACACIAIoAghBAWo2AgggAUEBOgAACyAEQdgBaiABIAIgAxAXIAEtAABFDQEgB0UEQCACKAIIIgAgAigCBEYEQCABQQA6AAAMAwsgAigCACAAaiAGOgAAIAIgAigCCEEBajYCCCABQQE6AAALIARBiAJqIAEgAiADEBcMAQsgAUEAOgAACyAEQdADaiQAC54BAQJ/IwBBoAJrIgIkAAJAAkACQAJAAkBB/IUBKAIAQX9qDgUBAgICAAILIAIgARBpIAAgAhCUASAAIAAQaEEBIQMMAwsgACABEOgBDAELIAAgARDnAUUNAQtBASEDAkACQEH4hQEoAgAOAgABAgsgACAAEOYBDAELIAAgABBoQYCGAS0AAEUNACAAIABBuIUBEFwLIAJBoAJqJAAgAwvdCQEGfyMAQaAIayICJAAgAkHgAGogAUHwAWoiA0GYtgFBxMUBKAIAEQEAIAJB4ABqIAJB4ABqIAFBwAFqIgVBmLYBQbzFASgCABEAACACQeAGaiAFIANBmLYBQbTFASgCABEAACACIAUgA0GYtgFBuMUBKAIAEQAAIAJB4ANqIAJB4AZqIAJBmLYBQbzFASgCABEAACACQZAEaiIDIAJB4ABqQajFASgCABECACACQeAAaiADQZi2AUHExQEoAgARAQAgAkHgAGogAkHgAGogAkHgA2pBmLYBQbzFASgCABEAACACQeAGaiACQeADaiADQZi2AUG0xQEoAgARAAAgAiACQeADaiADQZi2AUG4xQEoAgARAAAgAkHABGoiAyACQeAGaiACQZi2AUG8xQEoAgARAAAgAkHwBGogAkHgAGpBqMUBKAIAEQIAIAJB4ABqIAMgAkHgA2pBiMUBKAIAEQEAIAJBoAVqIAJB4ABqQZi2AUHsxQEoAgARAQAgAkHQBWogAkHAAWoiBkGYtgFB7MUBKAIAEQEAIAJB4ABqIAEgAkHgA2pBsI4BEGIgBiABIAJB4ANqEO0BIAJBoAJqIgcgASACQeADakHQkwEQYiACQYADaiIEIAEgAkHgA2pB0JYBEGIgAkHgBmogBiACQeADakGIxQEoAgARAQAgBiACQeAGakGYtgFB7MUBKAIAEQEAIAJB8AFqIAJBwAdqIgNBmLYBQezFASgCABEBACACQeAGaiAHIAFB4ABqQYjFASgCABEBACAHIAJB4AZqQZi2AUHsxQEoAgARAQAgAkHQAmogA0GYtgFB7MUBKAIAEQEAIAJB4AZqIAQgAkHgA2pBiMUBKAIAEQEAIAQgAkHgBmpBmLYBQezFASgCABEBACACQbADaiIBIANBmLYBQezFASgCABEBACACQeAGaiAEIAVBiMUBKAIAEQEAIAQgAkHgBmpBmLYBQezFASgCABEBACABIANBmLYBQezFASgCABEBACACQeAGaiAGIARBiMUBKAIAEQEAIABBwAFqIgEgAkHgBmpBmLYBQezFASgCABEBACAAQfABaiIFIANBmLYBQezFASgCABEBACACQeAGaiACQeAAaiAEQYjFASgCABEBACAAIAJB4AZqQZi2AUHsxQEoAgARAQAgAEEwaiIEIANBmLYBQezFASgCABEBACACQeAGaiAAIAFBiMUBKAIAEQEAIAAgAkHgBmpBmLYBQezFASgCABEBACAEIANBmLYBQezFASgCABEBACACQeAGaiAFQZi2AUHExQEoAgARAQAgAkHgBmogAkHgBmogAUGYtgFBvMUBKAIAEQAAIAJBsAZqIAEgBUGYtgFBtMUBKAIAEQAAIAJBgAZqIAEgBUGYtgFBuMUBKAIAEQAAIAIgAkGwBmogAkGABmpBmLYBQbzFASgCABEAACACQTBqIAJB4AZqQajFASgCABECACACQeAGaiAHIAZBiMUBKAIAEQEAIABB4ABqIgEgAkHgBmpBmLYBQezFASgCABEBACAAQZABaiIAIANBmLYBQezFASgCABEBACACQeAGaiABIAJBiMUBKAIAEQEAIAEgAkHgBmpBmLYBQezFASgCABEBACAAIANBmLYBQezFASgCABEBACACQaAIaiQAC5YIAQh/IwBB8ARrIgEkACABQbADaiAAQTBqIgJBmLYBQcTFASgCABEBACABQbADaiABQbADaiAAQZi2AUG8xQEoAgARAAAgAUGgAmogACACQZi2AUG0xQEoAgARAAAgAUHgAGogACACQZi2AUG4xQEoAgARAAAgAUHAAWogAUGgAmogAUHgAGpBmLYBQbzFASgCABEAACABQfABaiIIIAFBsANqQajFASgCABECACABQbADaiAAQZABaiICQZi2AUHExQEoAgARAQAgAUGwA2ogAUGwA2ogAEHgAGoiA0GYtgFBvMUBKAIAEQAAIAFB4ABqIAMgAkGYtgFBtMUBKAIAEQAAIAEgAyACQZi2AUG4xQEoAgARAAAgAUGgAmogAUHgAGogAUGYtgFBvMUBKAIAEQAAIAFB0AJqIgIgAUGwA2pBqMUBKAIAEQIAIAFBsANqIABB8AFqIgRBmLYBQcTFASgCABEBACABQbADaiABQbADaiAAQcABaiIDQZi2AUG8xQEoAgARAAAgASADIARBmLYBQbTFASgCABEAACABQYADaiADIARBmLYBQbjFASgCABEAACABQeAAaiABIAFBgANqQZi2AUG8xQEoAgARAAAgAUGQAWoiByABQbADakGoxQEoAgARAgAgAUGwA2pBnMYBIAFB4ABqQYjFASgCABEBACABIAFBsANqQZi2AUHsxQEoAgARAQAgAUEwaiIEIAFBkARqIgZBmLYBQezFASgCABEBACABIAEgAUHAAWpBmLYBQbTFASgCABEAACAEIAQgCEGYtgFBtMUBKAIAEQAAIAFBsANqIAEgAEGIxQEoAgARAQAgASABQbADakGYtgFB7MUBKAIAEQEAIAQgBkGYtgFB7MUBKAIAEQEAIAFBsANqIAFB4ABqQaDaAUGIxQEoAgARAQAgAUHgAGogAUGwA2pBmLYBQezFASgCABEBACAHIAZBmLYBQezFASgCABEBACABQaACaiABQaACaiABQeAAakGYtgFBuMUBKAIAEQAAIAIgAiAHQZi2AUG4xQEoAgARAAAgAUGwA2ogAUGgAmogA0GIxQEoAgARAQAgAUGgAmogAUGwA2pBmLYBQezFASgCABEBACACIAZBmLYBQezFASgCABEBAAJAQZjFASgCACIDRQRAQQEhBQwBCyABKAKgAiABKAIARw0AQQEhAgJAA0AgAiIAIANGDQEgAEEBaiECIABBAnQiBCABQaACamooAgAgASAEaigCAEYNAAsgACADSQ0BCyABKALQAiABKAIwRw0AQQEhAgNAAkAgAyACIgBGBEAgAyEADAELIABBAWohAiABIABBAnQiBWooAtACIAEgBWooAjBGDQELCyAAIANPIQULIAFB8ARqJAAgBQu2CQEGfyMAQdAFayIBJAAgAUGQBGogAEEwaiICQZi2AUHExQEoAgARAQAgAUGQBGogAUGQBGogAEGYtgFBvMUBKAIAEQAAIAFBgANqIAAgAkGYtgFBtMUBKAIAEQAAIAFBwAFqIAAgAkGYtgFBuMUBKAIAEQAAIAFBoAJqIAFBgANqIAFBwAFqQZi2AUG8xQEoAgARAAAgAUHQAmoiBiABQZAEakGoxQEoAgARAgAgAUGQBGogAEGQAWoiAkGYtgFBxMUBKAIAEQEAIAFBkARqIAFBkARqIABB4ABqIgNBmLYBQbzFASgCABEAACABQcABaiADIAJBmLYBQbTFASgCABEAACABQeAAaiADIAJBmLYBQbjFASgCABEAACABQYADaiABQcABaiABQeAAakGYtgFBvMUBKAIAEQAAIAFBsANqIAFBkARqQajFASgCABECACABQZAEaiAAQfABaiICQZi2AUHExQEoAgARAQAgAUGQBGogAUGQBGogAEHAAWoiA0GYtgFBvMUBKAIAEQAAIAFB4ABqIAMgAkGYtgFBtMUBKAIAEQAAIAEgAyAC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IAxFBEAgBUEDRiAFQf4BcUECRg0BGiABQQA6AAAMAwsgBCALakF/aiICIAIsAAAiAkH/AHE6AAAgAkEASAshAiAAIAEgBCAOciIDIAcQQiABLQAARQ0BIABBMGogASADIAdqIAcQQiABLQAARQ0BIAEgAEHgAGogACACEHQiAjoAACACRQ0BCwJAQZSCAi0AAEUNACAAEF0NACABQQA6AAAMAQsgAUEBOgAACyAEQfADaiQAC+YPAQd/IwBBkAJrIgQkACADQeA0cSIGRUEFdCEHAkAgA0GACHEEQCACKAIIIgUgAigCBEYEQCABQQA6AAAMAgsgAigCACAFakE0OgAAIAIgAigCCEEBaiIFNgIIIAFBAToAACAGRQRAIAUgAigCBEYEQCABQQA6AAAMAwsgAigCACAFaiAHOgAAIAIgAigCCEEBajYCCCABQQE6AAALIAAgASACIAMQFyABLQAARQ0BIAZFBEAgAigCCCIFIAIoAgRGBEAgAUEAOgAADAMLIAIoAgAgBWogBzoAACACIAIoAghBAWo2AgggAUEBOgAACyAAQTBqIAEgAiADEBcgAS0AAEUNASAGRQRAIAIoAggiBSACKAIERgRAIAFBADoAAAwDCyACKAIAIAVqIAc6AAAgAiACKAIIQQFqNgIIIAFBAToAAAsgAEHgAGogASACIAMQFwwBCyAEQcgAaiAAQajFASgCABECACAEQfgAaiAAQTBqQajFASgCABECACAEQagBaiIJIABB4ABqIgVBqMUBKAIAEQIAIARByABqEDAgA0GAIHEEQCAEQdgBakGkxQEoAgARAwACQAJAQZjFASgCACIGRQ0AQezZASgCACAEKALYAUcNAUEBIQADQCAAIgMgBkYNASADQQFqIQAgA0ECdCIHQezZAWooAgAgBEHYAWogB2ooAgBGDQALIAMgBkkNAQsgAUEAOgAADAILIAVBoMUBKAIAEQQABEAgBEGoAWoiACABIAJBgAQQFyABLQAARQ0CIAAgASACQYAEEBcMAgsgBEHIAGogASACQYAEEBcgAS0AAEUNASAEQfgAaiABIAJBgAQQFwwBCwJAIANBgBRxBEBBnMUBKAIAIQBB7NkBQaDFASgCABEEACIGQZzFASgCAEEHcSIIRXIhCiAAQQdqQQN2IQdBoMUBKAIAIQACQEHMgQItAAAEQCAJIAARBAAEQCAEQcABOgAQIARBEGpBAXJBACAHQX9qEBYMAgsgBEEANgIIIAQgBzYCBCAEIARBEGo2AgAgBEHIAGogASAEQYAEEBcgAS0AAEUNBCAEQZjFASgCACIANgLcASAEQfgAaiEGAkBBlcYBLQAABEAgBEHgAWoiBSAGQbjDAUGYtgFBvMUBKAIAEQAAQZjFASgCACEADAELIAYhBQsgBCAFNgLYAQJAA0AgACIGRQ0BIAUgBkF/aiIAQQJ0IghqKAIAIgkgCEHYwgFqKAIAIghGDQALIAkgCE8hCAsgBCAELQAQQaB/QYB/IAhBAXEbQaB/IAYbcjoAEAwBCyAFIAARBAAEQCAEQRBqQQAgByAKahAWDAELIARBADYCCCAEIAc2AgQgBCAEQRBqIApyNgIAIARByABqIAEgBEGABBAXIAEtAABFDQMgBEH4AGohBSAGQQFzIAhBAEdxRQRAIARBmMUBKAIANgLcAQJAQZXGAS0AAARAIARB4AFqIgAgBUG4wwFBmLYBQbzFASgCABEAAAwBCyAFIQALIAQgADYC2AEgBEEDQQIgACgCAEEBcRs6ABAMAQsgBEGYxQEoAgA2AtwBAkBBlcYBLQAABEAgBEHgAWoiACAFQbjDAUGYtgFBvMUBKAIAEQAADAELIAUhAAsgBCAANgLYASAAKAIAQQFxRQ0AIAQgB2oiAEEPaiAALQAPQYABcjoAAAsgByAKaiEFIANBgBBxBEAgBQRAIAIoAgghA0EAIQADQCACKAIEIANrQQJJDQQgAigCACADakGY/gAoAgAiAyAEQRBqIABqLQAAIgZBD3FqLQAAQQh0IAMgBkHwAXFBBHZqLQAAcjsAACACIAIoAghBAmoiAzYCCCABQQE6AAAgAEEBaiIAIAVHDQALCyABQQE6AAAMAwtBACEDIAEgAigCBCACKAIIIgBrIAVPBH8gAigCACAAaiAEQRBqIAUQAxogAiACKAIIIAVqNgIIQQEFQQALOgAADAILQQAhACAFQaDFASgCABEEAARAIAEgAigCCCIDIAIoAgRHBH8gAigCACADakEwOgAAIAIgAigCCEEBajYCCEEBBUEACzoAAAwCCyADQYACcQRAIARBmMUBKAIANgLcASAEQfgAaiEFAkBBlcYBLQAABEAgBEHgAWoiACAFQbjDAUGYtgFBvMUBKAIAEQAADAELIAUhAAsgBCAANgLYASACKAIIIgUgAigCBEYEQCABQQA6AAAMAwsgAigCACAFakEzQTIgACgCAEEBcRs6AAAgAiACKAIIQQFqIgA2AgggAUEBOgAAIAZFBEAgACACKAIERgRAIAFBADoAAAwECyACKAIAIABqIAc6AAAgAiACKAIIQQFqNgIIIAFBAToAAAsgBEHIAGogASACIAMQFwwCCyACKAIIIgAgAigCBEYEQCABQQA6AAAMAgsgAigCACAAakExOgAAIAIgAigCCEEBaiIANgIIIAFBAToAACAGRQRAIAAgAigCBEYEQCABQQA6AAAMAwsgAigCACAAaiAHOgAAIAIgAigCCEEBajYCCCABQQE6AAALIARByABqIAEgAiADEBcgAS0AAEUNASAGRQRAIAIoAggiACACKAIERgRAIAFBADoAAAwDCyACKAIAIABqIAc6AAAgAiACKAIIQQFqNgIIIAFBAToAAAsgBEH4AGogASACIAMQFwwBCyABQQA6AAALIARBkAJqJAAL7QQBA38jAEHwAWsiAyQAAkACQAJAAkACQAJAAkBB/IUBKAIAQX9qDgUBAgICAAILIANBwAFqIANB4ABqIgQgA0GQAWogAhBlIAMgA0HAAWogBEGYtgFBvMUBKAIAEQAAIANBMGoiAiAEQZi2AUHAxQEoAgARAQAgAiACIARBmLYBQbzFASgCABEAACACIAIgA0GQAWpBmLYBQbzFASgCABEAACABIAMQhgFBxLABKAIAIQQCQAJ/QciwAS0AAARAIARBAUdB5K8BKAIAQQBHcgwBCyAEQQFGDQEgBEULIQUgBEUNBAsCQAJAA0AgBCICRQ0BIAJBf2oiBEECdEHkrwFqKAIARQ0ACyACQQFLDQELQQEhAiABIAFB5K8BKAIAIAUQPQ0FCyABIAFB5K8BIAIgBRA3DAQLIANBwAFqIAJBqMUBKAIAEQIAA0AgAyADQcABakGYtgFBwMUBKAIAEQEAIAMgA0G42QFBmLYBQbTFASgCABEAACADIAMgA0HAAWpBmLYBQbzFASgCABEAACADQZABaiADQezZAUGYtgFBtMUBKAIAEQAAIANBkAFqIANBkAFqECRFBEAgA0HAAWogA0HAAWpBiMMBQZi2AUG0xQEoAgARAAAMAQsLIAEgA0HAAWpBqMUBKAIAEQIA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aiIFIAsgEn4iEqdqIgZqIgc2AhQgAiACKAIYIgkgByADSSADIAhJamoiAyASQiCIpyAGIAVJaiIFIAsgEX4iEadqIgZqIgc2AhggAiACKAIcIgggByADSSADIAlJamoiAyARQiCIpyAGIAVJaiIFIAsgEH4iEKdqIgZqIgc2AhwgAiACKAIgIgkgByADSSADIAhJamoiAyAQQiCIpyAGIAVJaiIFIAsgD34iD6dqIgZqIgc2AiAgAiACKAIkIgggByADSSADIAlJamoiAyAPQiCIpyAGIAVJaiIFIAsgDn4iDqdqIgZqIgc2AiQgAiACKAIoIgkgByADSSADIAhJamoiAyAOQiCIpyAGIAVJaiIFIAsgDX4iDadqIgZqIgc2AiggAiACKAIsIgggByADSSADIAlJamoiAyANQiCIpyAGIAVJaiIFIAsgDH4iC6dqIgZqIgc2AiwgAiACKAIwIAcgA0kgAyAISWpqIAtCIIinIAYgBUlqajYCMCAEQQFqIgRBDEcNAAsLJgEBfyMAQeAAayIDJAAgAyABIAEQPiAAIAMgAhBIIANB4ABqJAALJgEBfyMAQeAAayIEJAAgBCABIAIQPiAAIAQgAxBIIARB4ABqJAALkgcCCn8JfiMAIQIgASEIIAAgAUYEQCACQWBqIgEgACkCGDcCGCABIAApAhA3AhAgASAAKQIINwIIIAEgACkCADcCACABQWBqIgggACkCGDcCGCAIIAApAhA3AhAgCCAAKQIINwIIIAggACkCADcCAAsgACAINQIAIgwgATUCAH4iDT4CACAAIA1CIIinIgIgDCABNQIEfiINp2oiCTYCBCAAIA1CIIinIAkgAklqIgIgDCABNQIIfiINp2oiBDYCCCAAIA1CIIinIAQgAklqIgIgDCABNQIMfiINp2oiBDYCDCAAIA1CIIinIAQgAklqIgIgDCABNQIQfiINp2oiBDYCECAAIA1CIIinIAQgAklqIgIgDCABNQIUfiINp2oiBDYCFCAAIA1CIIinIAQgAklqIgIgDCABNQIYfiINp2oiBDYCGCABNQIcIQ4gAEIANwIkIABCADcCLCAAQgA3AjQgAEEANgI8IAAgDUIgiKcgBCACSWoiAiAMIA5+IgynaiIENgIcIAAgDEIgiKcgBCACSWo2AiBBASEEA0AgATUCHCENIAE1AhghDiAB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NgIUIAAgCSAHIARJIAsgB0lqIgQgAygCGGoiB2siCjYCGCAAIAEgByAESSAJIAdJaiIEIAMoAhxqIgdrIgw2AhwgByAESUF/QQAgASAHSRtHBEAgACABNgIcIAAgCTYCGCAAIAs2AhQgACAONgIQIAAgBjYCDCAAIAg2AgggACACNgIEIAAgFDYCAAwDCyAFIBUgAygCACINayIUNgIAIAUgECADKAIEIgEgFSANSWoiBmsiAjYCBCAFIBEgBiABSSAQIAZJaiIBIAMoAghqIgZrIgg2AgggBSASIAYgAUkgESAGSWoiASADKAIMaiIEayIGNgIMIAUgDyAEIAFJIBIgBElqIgEgAygCEGoiBGsiDjYCECAFIBMgBCABSSAPIARJaiIBIAMoAhRqIgRrIgs2AhQgBSAKIAQgAUkgEyAESWoiASADKAIYaiIEayIJNgIYIAUgDCAEIAFJIAogBElqIgQgAygCHGoiB2siATYCHCAHIARJQX9BACAMIAdJG0YNAAsMAQtBAEEAIAAgBUEJIANBCBAdCyAFQTBqJAALCgAgACABIAIQPwsJACAAIAEQqQELigICAX8CfiAAIAKtIgUgATUCAH4iBD4CACAAIARCIIinIgIgATUCBCAFfiIEp2oiAzYCBCAAIARCIIinIAMgAklqIgIgATUCCCAFfiIEp2oiAzYCCCAAIARCIIinIAMgAklqIgIgATUCDCAFfiIEp2oiAzYCDCAAIARCIIinIAMgAklqIgIgATUCECAFfiIEp2oiAzYCECAAIARCIIinIAMgAklqIgIgATUCFCAFfiIEp2oiAzYCFCAAIARCIIinIAMgAklqIgIgATUCGCAFfiIEp2oiAzYCGCAAIARCIIinIAMgAklqIgIgATUCHCAFfiIFp2oiATYCHCAAIAVCIIinIAEgAklqNgIgCxIAQQBBACAAIAFBCSACQQgQHQuQBAENfyAAIAEgAhBvIQQgACgCICIBIAMoAgAiAkkhBSAEBEAgACABIAJrNgIgIAAgACgCJCICIAUgAygCBCIFaiIBazYCJCAAIAAoAigiBCABIAVJIAIgAUlqIgIgAygCCGoiAWs2AiggACAAKAIsIgUgASACSSAEIAFJaiICIAMoAgxqIgFrNgIsIAAgACgCMCIEIAEgAkkgBSABSWoiAiADKAIQaiIBazYCMCAA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NQIUIAhCIIh8fCIJPgIUIAAgAjUCGCABNQIYIAlCIIh8fCIKPgIYIAAgAjUCHCABNQIcIApCIIh8fCILPgIcIAAgAjUCICABNQIgIAtCIIh8fCIMPgIgIAAgAjUCJCABNQIkIAxCIIh8fCINPgIkIAAgAjUCKCABNQIoIA1CIIh8fCIOPgIoIAAgDkIgiKcgAigCLCABKAIsamoiATYCLCABrSADNQIsfSAOQv////8PgyADNQIofSANQv////8PgyADNQIkfSAMQv////8PgyADNQIgfSALQv////8PgyADNQIcfSAKQv////8PgyADNQIYfSAJQv////8PgyADNQIUfSAIQv////8PgyADNQIQfSAHQv////8PgyADNQIMfSAGQv////8PgyADNQIIfSAFQv////8PgyADNQIEfSAEQv////8PgyADNQIAfSIEQj+HfCIFQj+HfCIGQj+HfCIHQj+HfCIIQj+HfCIJQj+HfCIKQj+HfCILQj+HfCIMQj+HfCINQj+HfCIOQj+HfCIPQgBZBEAgACAPPgIsIAAgDj4CKCAAIA0+AiQgACAMPgIgIAAgCz4CHCAAIAo+AhggACAJPgIUIAAgCD4CECAAIAc+AgwgACAGPgIIIAAgBT4CBCAAIAQ+AgALC+gEAQx+IAAgATUCACACNQIAfSIEPgIAIAAgATUCBCACNQIEfSAEQj+HfCIFPgIEIAAgATUCCCACNQIIfSAFQj+HfCIGPgIIIAAgATUCDCACNQIMfSAGQj+HfCIHPgIMIAAgATUCECACNQIQfSAHQj+HfCIIPgIQIAAgATUCFCACNQIUfSAIQj+HfCIJPgIUIAAgATUCGCACNQIYfSAJQj+HfCIKPgIYIAAgATUCHCACNQIcfSAKQj+HfCILPgIcIAAgATUCICACNQIgfSALQj+HfCIMPgIgIAAgATUCJCACNQIkfSAMQj+HfCINPgIkIAAgATUCKCACNQIofSANQj+HfCIOPgIoIAAgATUCLCACNQIsfSAOQj+HfCIPPgIsIA9Cf1cEQCAAIAM1AgAgBEL/////D4N8IgQ+AgAgACADNQIEIAVC/////w+DIARCIIh8fCIEPgIEIAAgAzUCCCAGQv////8Pg3wgBEIgiHwiBD4CCCAAIAM1AgwgB0L/////D4N8IARCIIh8IgQ+AgwgACADNQIQ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ACADNgIYCwJAIARBD00EQCABIAQgBWoiAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAwBCyABIAVBA3I2AgQgCyAEQQFyNgIEIAQgC2ogBDYCACAIBEAgCEEDdiIDQQN0QdyCAmohAEHIggIoAgAhAgJ/QQEgA3QiAyAHcUUEQEG0ggIgAyAHcjYCACAADAELIAAoAggLIQMgACACNgIIIAMgAjYCDCACIAA2AgwgAiADNgIIC0HIggIgCzYCAEG8ggIgBDYCAAsgAUEIaiEACyAMQRBqJAAgAAsyAQF/IwBBEGsiASQAIAEgACgCBDYCCCABKAIIQQE6AAAgACgCCEEBOgAAIAFBEGokAAsuAQF/AkAgACgCCCIALQAAIgFBAUcEfyABQQJxDQEgAEECOgAAQQEFQQALDwsACzYBAn8jAEEQayIBJAACfyABIAAoAgQ2AgggASgCCC0AAEULBEAgABDhASECCyABQRBqJAAgAgsuAQF/IwBB4ABrIgQkACAEIAEgAhA+QQBBACAAIARBGCADQQwQHSAEQeAAaiQAC4URAQd/IwBBwBZrIgUkAAJAAkACQANAIAMiBkUNASACIAZBf2oiA0ECdGoiCCgCAEUNAAsCQCAEDQAgBkEBRw0AAkACQAJAAkAgAigCAEF/ag4EAAECAwQLIAAgAUGoxQEoAgARAgAgAEEwaiABQTBqQajFASgCABECACAAQeAAaiABQeAAakGoxQEoAgARAgAgAEGQAWogAUGQAWpBqMUBKAIAEQIAIABBwAFqIAFBwAFqQajFASgCABECACAAQfABaiABQfABakGoxQEoAgARAgAgAEGgAmogAUGgAmpBqMUBKAIAEQIAIABB0AJqIAFB0AJqQajFASgCABECACAAQYADaiABQYADakGoxQEoAgARAgAgAEGwA2ogAUGwA2pBqMUBKAIAEQIAIABB4ANqIAFB4ANqQajFASgCABECACAAQZAEaiABQZAEakGoxQEoAgARAgAMBgsgACABQZoBEQIADAULIAAgAUGaARECACAAIAAgAUGZAREBAAwECyAAIAFBmgERAgAgACAAQZoBEQIADAMLIAVBwARqIAFBqMUBKAIAEQIAIAVB8ARqIAFBMGpBqMUBKAIAEQIAIAVBoAVqIAFB4ABqQajFASgCABECACAFQdAFaiABQZABakGoxQEoAgARAgAgBUGABmogAUHAAWpBqMUBKAIAEQIAIAVBsAZqIAFB8AFqQajFASgCABECACAFQeAGaiABQaACakGoxQEoAgARAgAgBUGQB2ogAUHQAmpBqMUBKAIAEQIAIAVBwAdqIAFBgANqQajFASgCABECACAFQfAHaiABQbADakGoxQEoAgARAgAgBUGgCGogAUHgA2pBqMUBKAIAEQIAIAVB0AhqIAFBkARqQajFASgCABECACAFQYAJaiIKIAVBwARqQajFASgCABECACAFQbAJaiAFQfAEakGoxQEoAgARAgAgBUHgCWogBUGgBWpBqMUBKAIAEQIAIAVBkApqIAVB0AVqQajFASgCABECACAFQcAKaiAFQYAGakGoxQEoAgARAgAgBUHwCmogBUGwBmpBqMUBKAIAEQIAIAVBoAtqIAVB4AZqQajFASgCABECACAFQdALaiAFQZAHakGoxQEoAgARAgAgBUGADGogBUHAB2pBqMUBKAIAEQIAIAVBsAxqIAVB8AdqQajFASgCABECACAFQeAMaiAFQaAIakGoxQEoAgARAgAgBUGQDWogBUHQCGpBqMUBKAIAEQIAIAVBwA1qIgYgCkGaARECACAFQYASaiAGIAFBmQERAQACQCAIKAIAIgZnQR9zIghBAXEEQCAAIAVBwARqIAYgCEF/aiIBdkEDcUHABGxqIgZBqMUBKAIAEQIAIABBMGogBkEwakGoxQEoAgARAgAgAEHgAGogBkHgAGpBqMUBKAIAEQIAIABBkAFqIAZBkAFqQajFASgCABECACAAQcABaiAGQcABakGoxQEoAgARAgAgAEHwAWogBkHwAWpBqMUBKAIAEQIAIABBoAJqIAZBoAJqQajFASgCABECACAAQdACaiAGQdACakGoxQEoAgARAgAgAEGAA2ogBkGAA2pBqMUBKAIAEQIAIABBsANqIAZBsANqQajFASgCABECACAAQeADaiAGQeADakGoxQEoAgARAgAgAEGQBGogBkGQBGpBqMUBKAIAEQIADAELIAAgAUGoxQEoAgARAgAgAEEwaiABQTBqQajFASgCABECACAAQeAAaiABQeAAakGoxQEoAgARAgAgAEGQAWogAUGQAWpBqMUBKAIAEQIAIABBwAFqIAFBwAFqQajFASgCABECACAAQfABaiABQfABakGoxQEoAgARAgAgAEGgAmogAUGgAmpBqMUBKAIAEQIAIABB0AJqIAFB0AJqQajFASgCABECACAAQYADaiABQYADakGoxQEoAgARAgAgAEGwA2ogAUGwA2pBqMUBKAIAEQIAIABB4ANqIAFB4ANqQajFASgCABECACAAQZAEaiABQZAEakGoxQEoAgARAgAgCCEBCwJAIANBAEgNACAERQRAIAMhBgNAIAFBAUoEQCACIAZBAnRqKAIAIQoDQCAAIABBmgERAgAgACAAQZoBEQIAIAogAUF+aiIHdkEDcSIJBEAgACAAIAVBwARqIAlBwARsakGZAREBAAsgAUEDSiEJIAchASAJDQALCyAGQQBKIQdBICEBIAZBf2ohBiAHDQALDAELIAMhBgNAIAFBAUoEQCACIAZBAnRqKAIAIQkDQCAAIABBmgERAgAgACAAQZoBEQIAAkAgCSABQX5qIgd2QQNxIgtFBEAgBUHABGogBUHABGogCkGZAREBAAwBCyAAIAAgBUHABGogC0HABGxqQZkBEQEACyABQQNKIQsgByEBIAsNAAsLIAZBAEohB0EgIQEgBkF/aiEGIAcNAAsLIARFDQIgA0EFdEEBciAIaiEBDAELQQEhASAERQ0BCyAFIABBqMUBKAIAEQIAIAVBMGogAEEwakGoxQEoAgARAgAgBUHgAGogAEHgAGpBqMUBKAIAEQIAIAVBkAFqIABBkAFqQajFASgCABECACAFQcABaiAAQcABakGoxQEoAgARAgAgBUHwAWogAEHwAWpBqMUBKAIAEQIAIAVBoAJqIABBoAJqQajFASgCABECACAFQdACaiAAQdACakGoxQEoAgARAgAgBUGAA2ogAEGAA2pBqMUBKAIAEQIAIAVBsANqIABBsANqQajFASgCABECACAFQeADaiAAQeADakGoxQEoAgARAgAgBUGQBGogAEGQBGpBqMUBKAIAEQIAIAEgBE8NACAFQYAJaiEAA0AgBSAFQZoBEQIAIAUgBUGaARECACAFIAUgAEGZAREBACABQQJqIgEgBEkNAAsLIAVBwBZqJAAL3AMBBX8jAEHAAWsiAiQAIAAgARAFAkBBtLcBKAIAQQFGDQAgAEEwaiIBIAFBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACAAQZABaiIBIAFBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACAAQfABaiIBIAFBmLYBQbDFASgCABEBAAsgAiAAQdCwAUGIxQEoAgARAQAgACACQZi2AUHsxQEoAgARAQAgAEEwaiIBIAJB4ABqIgNBmLYBQezFASgCABEBACACIABB4ABqIgRBsLEBQYjFASgCABEBACAEIAJBmLYBQezFASgCABEBACAAQZABaiIFIANBmLYBQezFASgCABEBAAJAQbS3ASgCAEEBRg0AIAEgAUGYtgFBsMUBKAIAEQEAQbS3ASgCAEEBRg0AIAUgBUGYtgFBsMUBKAIAEQEAQbS3ASgCAEEBRg0AIABB8AFqIgYgBkGYtgFBsMUBKAIAEQEACyACIABB0LABQYjFASgCABEBACAAIAJBmLYBQezFASgCABEBACABIANBmLYBQezFASgCABEBACACIARBsLEBQYjFASgCABEBACAEIAJBmLYBQezFASgCABEBACAFIANBmLYBQezFASgCABEBACACQcABaiQAC6kJAQR/IwBBoAhrIgIkAEHYgwEoAgAhAwJAAkACQAJ/QdyDAS0AAARAIANBAUdB+IIBKAIAQQBHcgwBCyADQQFGDQEgA0ULIQUgA0UNAQsCQAJAA0AgAyIERQ0BIARBf2oiA0ECdEGUggFqKAJkRQ0ACyAEQQFLDQELQQEhBCACQcAEaiABQfiCASgCACAFEFANAgsgAkHABGogAUH4ggEgBCAFEEcMAQsgAkHABGpBpMUBKAIAEQMAIAJB8ARqQaTFASgCABEDACACQaAFakGkxQEoAgARAwAgAkHQBWpBpMUBKAIAEQMAIAJBgAZqQaTFASgCABEDACACQbAGakGkxQEoAgARAwALAkACQAJAAkACQEGYggIoAgAiAw4DAAECBAsgAkGgAmogAkHABGoQEQwCCyACQaACaiACQcAEahAQDAELIAJBoAJqIAJBwARqEBQLQZiCAigCACEDCwJAAkACQAJAIAMOAwABAgMLIAJBoAJqIAJBoAJqIAJBwARqEAsMAgsgAkGgAmogAkGgAmogAkHABGoQCgwBCyACQaACaiACQaACaiACQcAEahAJCwJAQbS3ASgCAEEBRg0AIAJB0AJqIgMgA0GYtgFBsMUBKAIAEQEAQbS3ASgCAEEBRg0AIAJBsANqIgMgA0GYtgFBsMUBKAIAEQEAQbS3ASgCAEEBRg0AIAJBkARqIgMgA0GYtgFBsMUBKAIAEQEACyACIAJBoAJqQdCwAUGIxQEoAgARAQAgAkGgAmogAkGYtgFB7MUBKAIAEQEAIAJB0AJqIAJB4ABqIgNBmLYBQezFASgCABEBACACIAJBgANqIgRBsLEBQYjFASgCABEBACAEIAJBmLYBQezFASgCABEBACACQbADaiADQZi2AUHsxQEoAgARAQAgAiACQcAEahAFAkBBtLcBKAIAQQFGDQAgAkEwaiIEIARBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACACQZABaiIEIARBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACACQfABaiIEIARBmLYBQbDFASgCABEBAAsgAkHgBmogAkHQsAFBiMUBKAIAEQEAIAIgAkHgBmpBmLYBQezFASgCABEBACACQTBqIAJBwAdqIgRBmLYBQezFASgCABEBACACQeAGaiADQbCxAUGIxQEoAgARAQAgAyACQeAGakGYtgFB7MUBKAIAEQEAIAJBkAFqIARBmLYBQezFASgCABEBAAJAAkACQAJAAkBBmIICKAIAIgMOAwABAgQLIAJBwARqIAJBwARqIAJBoAJqEAsMAgsgAkHABGogAkHABGogAkGgAmoQCgwBCyACQcAEaiACQcAEaiACQaACahAJC0GYggIoAgAhAwsCQAJAAkACQCADDgMAAQIDCyACQcAEaiACQcAEaiACEAsMAgsgAkHABGogAkHABGogAhAKDAELIAJBwARqIAJBwARqIAIQCQsgAiABEOUBAkACQAJAAkBBmIICKAIADgMAAQIDCyAAIAJBwARqIAIQCwwCCyAAIAJBwARqIAIQCgwBCyAAIAJBwARqIAIQCQsgAkGgCGokAAvLDwEIfyMAQbAFayICJAAgAkHwA2ogAUHUxQEoAgARAgAgAkGwAmogAUEwaiIDQdTFASgCABECACACQfADaiACQfADaiACQbACakH4xQEoAgARBQAaIAJB0AFqIAJB8ANqQZi2AUHsxQEoAgARAQAgAkEPaiACQdABahB3IQkCQCACLQAPRQ0AIAFBoMUBKAIAEQQABEAgA0GgxQEoAgARBAANAQsgAkHwA2ogAUEwaiIDQZi2AUHExQEoAgARAQAgAkHwA2ogAkHwA2ogAUGYtgFBvMUBKAIAEQAAIAJBsAJqIAEgA0GYtgFBtMUBKAIAEQAAIAJB0AFqIAEgA0GYtgFBuMUBKAIAEQAAIAJBEGogAkGwAmogAkHQAWpBmLYBQbzFASgCABEAACACQUBrIgQgAkHwA2pBqMUBKAIAEQIAIAJBEGogAkEQakGg2gFBmLYBQbTFASgCABEAACAEIARB0NoBQZi2AUG0xQEoAgARAAAgAkEQaiACQRBqQYjDAUGYtgFBtMUBKAIAEQAAIAJBEGpBoMUBKAIAEQQABEAgBEGgxQEoAgARBAANAQsgAkHwA2ogAkEQakHUxQEoAgARAgAgAkGwAmogBEHUxQEoAgARAgAgAkHwA2ogAkHwA2ogAkGwAmpB+MUBKAIAEQUAGiACQdABaiACQfADakGYtgFB7MUBKAIAEQEAIAJB0AFqIAJB0AFqQZS2AUHIxQEoAgARAQAgAkEQaiACQRBqIAJB0AFqQZi2AUG8xQEoAgARAAAgBCAEIAJB0AFqQZi2AUG8xQEoAgARAAAgBCAEQZi2AUGwxQEoAgARAQAgAkEQaiACQRBqQZSCAUGYtgFBvMUBKAIAEQAAIAQgBEGUggFBmLYBQbzFASgCABEAACACQfADaiACQRBqIAFBiMUBKAIAEQEAIAJBEGogAkHwA2pBmLYBQezFASgCABEBACAEIAJB0ARqIgdBmLYBQezFASgCABEBACACQaABaiEGIAJB4AJqIQUgAkGAAmohAwNAAkACQAJAAkAgCA4DAAECAwsgAkHwA2ogASACQRBqQYjFASgCABEBACACQdABaiACQfADakGYtgFB7MUBKAIAEQEAIAMgB0GYtgFB7MUBKAIAEQEAIAJB0AFqIAJB0AFqQZi2AUGwxQEoAgARAQAgAyADQZi2AUGwxQEoAgARAQAgAkHQAWogAkHQAWpBxIIBQZi2AUG0xQEoAgARAAAMAgsgAkHQAWogAkHQAWpBmLYBQbDFASgCABEBACADIANBmLYBQbDFASgCABEBACACQdABaiACQdABakGIwwFBmLYBQbjFASgCABEAAAwBCyACQfADaiAEQZi2AUHExQEoAgARAQAgAkHwA2ogAkHwA2ogAkEQakGYtgFBvMUBKAIAEQAAIAJBsAJqIAJBEGogBEGYtgFBtMUBKAIAEQAAIAJBwANqIAJBEGogBEGYtgFBuMUBKAIAEQAAIAJB0AFqIAJBsAJqIAJBwANqQZi2AUG8xQEoAgARAAAgAyACQfADakGoxQEoAgARAgAgAkHwA2ogAkHQAWpB1MUBKAIAEQIAIAJBsAJqIANB1MUBKAIAEQIAIAJB8ANqIAJB8ANqIAJBsAJqQfjFASgCABEFABogAkHAA2ogAkHwA2pBmLYBQezFASgCABEBACACQcADaiACQcADakGUtgFByMUBKAIAEQEAIAJB0AFqIAJB0AFqIAJBwANqQZi2AUG8xQEoAgARAAAgAyADIAJBwANqQZi2AUG8xQEoAgARAAAgAyADQZi2AUGwxQEoAgARAQAgAkHQAWogAkHQAWpBiMMBQZi2AUG0xQEoAgARAAALIAJB8ANqIANBmLYBQcTFASgCABEBACACQfADaiACQfADaiACQdABakGYtgFBvMUBKAIAEQAAIAJBwANqIAJB0AFqIANBmLYBQbTFASgCABEAACACQZADaiACQdABaiADQZi2AUG4xQEoAgARAAAgAkGwAmogAkHAA2ogAkGQA2pBmLYBQbzFASgCABEAACAFIAJB8ANqQajFASgCABECACACQbACaiACQbACakGcxgFBmLYBQbTFASgCABEAACAFIAVBzMYBQZi2AUG0xQEoAgARAAAgAkHwA2ogAkGwAmogAkHQAWpBiMUBKAIAEQEAIAJBsAJqIAJB8ANqQZi2AUHsxQEoAgARAQAgBSAHQZi2AUHsxQEoAgARAQAgAkHwAGogAkGwAmpBoNoBQZi2AUG0xQEoAgARAAAgBiAFQdDaAUGYtgFBtMUBKAIAEQAAIAJB8ABqIAJB8ABqEFEEQCAJQX9MBEAgAkHwAGogAkHwAGpBmLYBQbDFASgCABEBACAGIAZBmLYBQbDFASgCABEBAAsgACACQdABakGoxQEoAgARAgAgAEEwaiADQajFASgCABECACAAQeAAaiACQfAAakGoxQEoAgARAgAgAEGQAWogAkGgAWpBqMUBKAIAEQIAIAJB8ANqQYjDAUGoxQEoAgARAgAgAkGgBGoiAUGkxQEoAgARAwAgAEHAAWogAkHwA2pBqMUBKAIAEQIAIABB8AFqIAFBqMUBKAIAEQIAQQEhBSACQQE6AA8MAgsgCEEBaiIIQQNHDQALQQAhBQsgAkGwBWokACAFC+cEAQR/IwBBwARrIgIkACACQeAAaiABQajFASgCABECACACQZABaiIDIAFBMGpBqMUBKAIAEQIAIAJBMGohBCACQeADaiEFIAJB8AFqIQEDQCACQYADaiADQZi2AUHExQEoAgARAQAgAkGAA2ogAkGAA2ogAkHgAGpBmLYBQbzFASgCABEAACACQdACaiACQeAAaiADQZi2AUG0xQEoAgARAAAgAkGgAmogAkHgAGogA0GYtgFBuMUBKAIAEQAAIAJBwAFqIAJB0AJqIAJBoAJqQZi2AUG8xQEoAgARAAAgASACQYADakGoxQEoAgARAgAgAkHAAWogAkHAAWpBnMYBQZi2AUG0xQEoAgARAAAgASABQczGAUGYtgFBtMUBKAIAEQAAIAJBgANqIAJBwAFqIAJB4ABqQYjFASgCABEBACACQcABaiACQYADakGYtgFB7MUBKAIAEQEAIAEgBUGYtgFB7MUBKAIAEQEAIAIgAkHAAWpBoNoBQZi2AUG0xQEoAgARAAAgBCABQdDaAUGYtgFBtMUBKAIAEQAAIAIgAhBRRQRAIAJB4ABqIAJB4ABqQYjDAUGYtgFBtMUBKAIAEQAADAELCyAAIAJB4ABqQajFASgCABECACAAQTBqIANBqMUBKAIAEQIAIABB4ABqIAJBqMUBKAIAEQIAIABBkAFqIAJBMGpBqMUBKAIAEQIAIAJBgANqQYjDAUGoxQEoAgARAgAgAkGwA2oiAUGkxQEoAgARAwAgAEHAAWogAkGAA2pBqMUBKAIAEQIAIABB8AFqIAFBqMUBKAIAEQIAIAJBwARqJAALLQEBfyMAQeAAayIDJAAgAyABEKYBQQBBACAAIANBGCACQQwQHSADQeAAaiQAC5gSAQt/IwBB4A9rIgIkAAJAIAEQjwEEQCACQdAIakGIwwFBqMUBKAIAEQIAIAJBgAlqIgFBpMUBKAIAEQMAIAJBsAlqIgNBpMUBKAIAEQMAIAJB4AlqIgRBpMUBKAIAEQMAIAJBkApqIgVBpMUBKAIAEQMAIAJBwApqIgdBpMUBKAIAEQMAIAJB8ApqIgZBpMUBKAIAEQMAIAJBoAtqIghBpMUBKAIAEQMAIAJB0AtqIglBpMUBKAIAEQMAIAJBgAxqIgpBpMUBKAIAEQMAIAJBsAxqIgtBpMUBKAIAEQMAIAJB4AxqIgxBpMUBKAIAEQMAIAAgAkHQCGpBqMUBKAIAEQIAIABBMGogAUGoxQEoAgARAgAgAEHgAGogA0GoxQEoAgARAgAgAEGQAWogBEGoxQEoAgARAgAgAEHAAWogBUGoxQEoAgARAgAgAEHwAWogB0GoxQEoAgARAgAgAEGgAmogBkGoxQEoAgARAgAgAEHQAmogCEGoxQEoAgARAgAgAEGAA2ogCUGoxQEoAgARAgAgAEGwA2ogCkGoxQEoAgARAgAgAEHgA2ogC0GoxQEoAgARAgAgAEGQBGogDEGoxQEoAgARAgAMAQsgAkHQCGogAUGoxQEoAgARAgAgAkGACWogAUEwakGoxQEoAgARAgAgAkGwCWogAUHgAGoiA0GoxQEoAgARAgAgAkHgCWogAUGQAWoiBEGoxQEoAgARAgAgAkGQCmogAUHAAWoiBUGoxQEoAgARAgAgAkHACmogAUHwAWoiB0GoxQEoAgARAgAgAkHwCmogAUGgAmoiBkGoxQEoAgARAgAgAkGgC2ogAUHQAmoiCEGoxQEoAgARAgAgAkHQC2ogAUGAA2pBqMUBKAIAEQIAIAJBgAxqIAFBsANqQajFASgCABECACACQbAMaiABQeADaiIJQajFASgCABECACACQeAMaiABQZAEaiIBQajFASgCABECACACIABB4ANqNgKMASACIABB4ABqNgKIASACIABBwAFqNgKEASACIABBoAJqIgo2AoABIAIgAEGAA2o2AnwgAiAANgJ4IAogBkGoxQEoAgARAgAgAEHQAmogCEGoxQEoAgARAgAgAigChAEiBiAFQajFASgCABECACAGQTBqIAdBqMUBKAIAEQIAIAIoAogBIgUgA0GoxQEoAgARAgAgBUEwaiAEQajFASgCABECACACKAKMASIDIAlBqMUBKAIAEQIAIANBMGogAUGoxQEoAgARAgAgAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAahAPIAJB+ABqEA8gAkH4AGoQDyACQfgAaiACQbADaiACQdACahB5IAIgAkHwB2oiATYCdCACIAJB8ARqIgM2AnAgAiACQdAFaiIENgJsIAIgAkGwBmoiBTYCaCACIAJBkAdqNgJkIAIgAkGQBGo2AmAgBSACKAKAASIFQajFASgCABECACACQeAGaiAFQTBqQajFASgCABECACAEIAIoAoQBIgRBqMUBKAIAEQIAIAJBgAZqIARBMGpBqMUBKAIAEQIAIAMgAigCiAEiA0GoxQEoAgARAgAgAkGgBWogA0EwakGoxQEoAgARAgAgASACKAKMASIBQajFASgCABECACACQaAIaiABQTBqQajFASgCABECACACQeAAahAPIAJB4ABqEA8gAkHgAGoQDyACQeAAahAPIAJB4ABqEA8gAkHgAGoQDyACQeAAahAPIAJB4ABqIAJB8AFqIAJBkAFqEHkgAkGgDmogAkHQAmogAkGQAWpBiMUBKAIAEQEAIAIgAkGgDmpBmLYBQezFASgCABEBACACQTBqIgEgAkGAD2oiA0GYtgFB7MUBKAIAEQEAIAJBoA5qIAJB1MUBKAIAEQIAIAJBwA1qIAFB1MUBKAIAEQIAIAJBoA5qIAJBoA5qIAJBwA1qQfjFASgCABEFABogAkGQDWogAkGgDmpBmLYBQezFASgCABEBACACQZANaiACQZANakGUtgFByMUBKAIAEQEAIAIgAiACQZANakGYtgFBvMUBKAIAEQAAIAEgASACQZANakGYtgFBvMUBKAIAEQAAIAEgAUGYtgFBsMUBKAIAEQEAIAJBoA5qIAIgAkGQAWpBiMUBKAIAEQEAIAJBwA1qIAJBoA5qQZi2AUHsxQEoAgARAQAgAkHwDWoiBCADQZi2AUHsxQEoAgARAQAgAigCfCEBIAJBoA5qIAJBsANqIAJBwA1qQYjFASgCABEBACABIAJBoA5qQZi2AUHsxQEoAgARAQAgAUEwaiADQZi2AUHsxQEoAgARAQAgAkH4AGoQeCACQaAOaiACIAJB0AJqQYjFASgCABEBACACQcANaiACQaAOakGYtgFB7MUBKAIAEQEAIAQgA0GYtgFB7MUBKAIAEQEAIAIoAmQhASACQaAOaiACQfABaiACQcANakGIxQEoAgARAQAgASACQaAOakGYtgFB7MUBKAIAEQEAIAFBMGogA0GYtgFB7MUBKAIAEQEAIAJB4ABqEHggACAAIAJB0AhqEAcgACAAIAJBkARqEAcLIAJB4A9qJAAL+woBBH8jAEHAAWsiAiQAAkBBtLcBKAIAQQFGBEAgACABRg0BIAAgAUGoxQEoAgARAgAgAEEwaiABQTBqQajFASgCABECAAwBCyAAIAFHBEAgACABQajFASgCABECAAsgAEEwaiABQTBqQZi2AUGwxQEoAgARAQALIAJB4ABqIQQCQAJAAkAgACABRwRAQbS3ASgCACEFIABB4ABqIgMgAUHgAGpBqMUBKAIAEQIAIAVBAUcNASAAQZABaiABQZABakGoxQEoAgARAgAMAgtBtLcBKAIAQQFHBEAgAEGQAWogAUGQAWpBmLYBQbDFASgCABEBAAsgAiAAQeAAaiIDQZDpAUGIxQEoAgARAQAgAyACQZi2AUHsxQEoAgARAQAgAEGQAWogBEGYtgFB7MUBKAIAEQEAQbS3ASgCAEEBRwRAIABB8AFqIAFB8AFqQZi2AUGwxQEoAgARAQALIAIgAEHAAWoiA0Hw6QFBiMUBKAIAEQEAIAMgAkGYtgFB7MUBKAIAEQEAIABB8AFqIARBmLYBQezFASgCABEBAEG0twEoAgBBAUcEQCAAQdACaiABQdACakGYtgFBsMUBKAIAEQEACyACIABBoAJqIgNB0OoBQYjFASgCABEBACADIAJBmLYBQezFASgCABEBACAAQdACaiAEQZi2AUHsxQEoAgARAQBBtLcBKAIAQQFHBEAgAEGwA2ogAUGwA2pBmLYBQbDFASgCABEBAAsgAiAAQYADaiIDQbDrAUGIxQEoAgARAQAgAyACQZi2AUHsxQEoAgARAQAgAEGwA2ogBEGYtgFB7MUBKAIAEQEAQbS3ASgCAEEBRwRAIABBkARqIAFBkARqQZi2AUGwxQEoAgARAQALIAIgAEHgA2oiAUGQ7AFBiMUBKAIAEQEAIAEgAkGYtgFB7MUBKAIAEQEADAILIABBkAFqIAFBkAFqQZi2AUGwxQEoAgARAQALIAIgA0GQ6QFBiMUBKAIAEQEAIAMgAkGYtgFB7MUBKAIAEQEAIABBkAFqIARBmLYBQezFASgCABEBAEG0twEoAgAhBSAAQcABaiIDIAFBwAFqQajFASgCABECAAJAIAVBAUcEQCAAQfABaiABQfABakGYtgFBsMUBKAIAEQEADAELIABB8AFqIAFB8AFqQajFASgCABECAAsgAiADQfDpAUGIxQEoAgARAQAgAyACQZi2AUHsxQEoAgARAQAgAEHwAWogBEGYtgFB7MUBKAIAEQEAQbS3ASgCACEFIABBoAJqIgMgAUGgAmpBqMUBKAIAEQIAAkAgBUEBRwRAIABB0AJqIAFB0AJqQZi2AUGwxQEoAgARAQAMAQsgAEHQAmogAUHQAmpBqMUBKAIAEQIACyACIANB0OoBQYjFASgCABEBACADIAJBmLYBQezFASgCABEBACAAQdACaiAEQZi2AUHsxQEoAgARAQBBtLcBKAIAIQUgAEGAA2oiAyABQYADakGoxQEoAgARAgACQCAFQQFHBEAgAEGwA2ogAUGwA2pBmLYBQbDFASgCABEBAAwBCyAAQbADaiABQbADakGoxQEoAgARAgALIAIgA0Gw6wFBiMUBKAIAEQEAIAMgAkGYtgFB7MUBKAIAEQEAIABBsANqIARBmLYBQezFASgCABEBAEG0twEoAgAhBSAAQeADaiIDIAFB4ANqQajFASgCABECAAJAIAVBAUcEQCAAQZAEaiABQZAEakGYtgFBsMUBKAIAEQEADAELIABBkARqIAFBkARqQajFASgCABECAAsgAiADQZDsAUGIxQEoAgARAQAgAyACQZi2AUHsxQEoAgARAQALIABBkARqIARBmLYBQezFASgCABEBACACQcABaiQACxIAQQBBACAAIAFBGCACQQwQHQuOAwEEfyMAQaACayIDJAAgAEHwkgFBqMUBKAIAEQIAIABBMGoiBEGgkwFBqMUBKAIAEQIAIANB4ABqIAAgAUGIxQEoAgARAQAgACADQeAAakGYtgFB7MUBKAIAEQEAIAQgA0HAAWoiBUGYtgFB7MUBKAIAEQEAIANB4ABqIAJBkJIBQYjFASgCABEBACADIANB4ABqQZi2AUHsxQEoAgARAQAgA0EwaiIGIAVBmLYBQezFASgCABEBACAAIAAgA0GYtgFBtMUBKAIAEQAAIAQgBCAGQZi2AUG0xQEoAgARAAAgA0HgAGogACABQYjFASgCABEBACAAIANB4ABqQZi2AUHsxQEoAgARAQAgBCAFQZi2AUHsxQEoAgARAQAgA0HgAGogAkHgAGpBsJEBQYjFASgCABEBACADIANB4ABqQZi2AUHsxQEoAgARAQAgBiAFQZi2AUHsxQEoAgARAQAgACAAIANBmLYBQbTFASgCABEAACAEIAQgBkGYtgFBtMUBKAIAEQAAIANBoAJqJAALyRcBCX8jAEGgBWsiAiQAAkACQCABQcABaiIHQaDFASgCABEEAEUNACABQfABakGgxQEoAgARBABFDQAgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwAgAEHgAGpBpMUBKAIAEQMAIABBkAFqQaTFASgCABEDACAAQcABakGkxQEoAgARAwAgAEHwAWpBpMUBKAIAEQMADAELAkACQEGYxQEoAgAiBUUNACAHKAIAQYjDASgCAEcNAUEBIQYDQCAGIgQgBUYNASAEQQFqIQYgASAEQQJ0IgNqKALAASADQYjDAWooAgBGDQALIAQgBUkNAQsgAUHwAWpBoMUBKAIAEQQAIQkLIAJB4ANqIAFBMGoiA0GYtgFBxMUBKAIAEQEAIAJB4ANqIAJB4ANqIAFBmLYBQbzFASgCABEAACACQcABaiABIANBmLYBQbTFASgCABEAACACQeAAaiABIANBmLYBQbjFASgCABEAACACQaACaiACQcABaiACQeAAakGYtgFBvMUBKAIAEQAAIAJB0AJqIgUgAkHgA2pBqMUBKAIAEQIAIAJB4ANqIAFBkAFqIgRBmLYBQcTFASgCABEBACACQeADaiACQeADaiABQeAAaiIKQZi2AUG8xQEoAgARAAAgAkHgAGogCiAEQZi2AUG0xQEoAgARAAAgAiAKIARBmLYBQbjFASgCABEAACACQcABaiACQeAAaiACQZi2AUG8xQEoAgARAAAgAkHwAWoiBiACQeADakGoxQEoAgARAgAgAkHgAGogASACQcABakGYtgFBtMUBKAIAEQAAIAJBkAFqIgQgAyAGQZi2AUG0xQEoAgARAAAgAkHgA2ogBkGYtgFBxMUBKAIAEQEAIAJB4ANqIAJB4ANqIAJBwAFqQZi2AUG8xQEoAgARAAAgAiACQcABaiAGQZi2AUG0xQEoAgARAAAgAkGwA2ogAkHAAWogBkGYtgFBuMUBKAIAEQAAIAJBwAFqIAIgAkGwA2pBmLYBQbzFASgCABEAACAGIAJB4ANqQajFASgCABECACACQeADaiAEQZi2AUHExQEoAgARAQAgAkHgA2ogAkHgA2ogAkHgAGpBmLYBQbzFASgCABEAACACIAJB4ABqIARBmLYBQbTFASgCABEAACACQbADaiACQeAAaiAEQZi2AUG4xQEoAgARAAAgAkHgAGogAiACQbADakGYtgFBvMUBKAIAEQAAIAQgAkHgA2pBqMUBKAIAEQIAIAJB4ABqIAJB4ABqIAJBoAJqQZi2AUG4xQEoAgARAAAgBCAEIAVBmLYBQbjFASgCABEAACACQeAAaiACQeAAaiACQcABakGYtgFBuMUBKAIAEQAAIAQgBCAGQZi2AUG4xQEoAgARAAAgAkHgAGogAkHgAGogAkHgAGpBmLYBQbTFASgCABEAACAEIAQgBEGYtgFBtMUBKAIAEQAAAkACQAJAAkBB9IECKAIADgIAAQILIAIgAkGgAmpBmLYBQcTFASgCABEBACACQTBqIgMgBUGYtgFBxMUBKAIAEQEAIAJBoAJqIAJBoAJqIAJBmLYBQbTFASgCABEAACAFIAUgA0GYtgFBtMUBKAIAEQAADAILAkAgCQRAIAJBoAJqIAJBoAJqIAdBmLYBQbjFASgCABEAACACQdACaiIDIAMgAUHwAWpBmLYBQbjFASgCABEAAAwBCyACQeADaiABQfABaiIDQZi2AUHExQEoAgARAQAgAkHgA2ogAkHgA2ogB0GYtgFBvMUBKAIAEQAAIAJBsANqIAcgA0GYtgFBtMUBKAIAEQAAIAJBgANqIAcgA0GYtgFBuMUBKAIAEQAAIAIgAkGwA2ogAkGAA2pBmLYBQbzFASgCABEAACACQTBqIgMgAkHgA2pBqMUBKAIAEQIAIAJB4ANqIANBmLYBQcTFASgCABEBACACQeADaiACQeADaiACQZi2AUG8xQEoAgARAAAgAkGwA2ogAiADQZi2AUG0xQEoAgARAAAgAkGAA2ogAiADQZi2AUG4xQEoAgARAAAgAiACQbADaiACQYADakGYtgFBvMUBKAIAEQAAIAMgAkHgA2pBqMUBKAIAEQIAIAJBoAJqIAJBoAJqIAJBmLYBQbjFASgCABEAACACQdACaiIIIAggA0GYtgFBuMUBKAIAEQAACyACIAJBoAJqQZi2AUHExQEoAgARAQAgAkEwaiIDIAVBmLYBQcTFASgCABEBACACQaACaiACQaACaiACQZi2AUG0xQEoAgARAAAgAkHQAmoiCCAIIANBmLYBQbTFASgCABEAAAwBCwJAIAkEQCACQfDXAUGoxQEoAgARAgAgAkEwakGg2AFBqMUBKAIAEQIADAELIAJB4ANqIAFB8AFqIgNBmLYBQcTFASgCABEBACACQeADaiACQeADaiAHQZi2AUG8xQEoAgARAAAgAkGwA2ogByADQZi2AUG0xQEoAgARAAAgAkGAA2ogByADQZi2AUG4xQEoAgARAAAgAiACQbADaiACQYADakGYtgFBvMUBKAIAEQAAIAJBMGoiAyACQeADakGoxQEoAgARAgAgAkHgA2ogA0GYtgFBxMUBKAIAEQEAIAJB4ANqIAJB4ANqIAJBmLYBQbzFASgCABEAACACQbADaiACIANBmLYBQbTFASgCABEAACACQYADaiACIANBmLYBQbjFASgCABEAACACIAJBsANqIAJBgANqQZi2AUG8xQEoAgARAAAgAyACQeADakGoxQEoAgARAgAgAkHgA2ogAkHw1wFBiMUBKAIAEQEAIAIgAkHgA2pBmLYBQezFASgCABEBACADIAJBwARqQZi2AUHsxQEoAgARAQALIAIgAiACQaACakGYtgFBtMUBKAIAEQAAIAJBMGoiAyADIAVBmLYBQbTFASgCABEAACACQaACaiACQaACakGYtgFBxMUBKAIAEQEAIAUgBUGYtgFBxMUBKAIAEQEAIAJBoAJqIAJBoAJqIAJBmLYBQbTFASgCABEAACACQdACaiIIIAggA0GYtgFBtMUBKAIAEQAACyACQeADaiAFQZi2AUHExQEoAgARAQAgAkHgA2ogAkHgA2ogAkGgAmpBmLYBQbzFASgCABEAACACQbADaiACQaACaiAFQZi2AUG0xQEoAgARAAAgAkGAA2ogAkGgAmogBUGYtgFBuMUBKAIAEQAAIAAgAkGwA2ogAkGAA2pBmLYBQbzFASgCABEAACAAQTBqIgUgAkHgA2pBqMUBKAIAEQIAIAAgACACQeAAakGYtgFBuMUBKAIAEQAAIAUgBSAEQZi2AUG4xQEoAgARAAAgACAAIAJB4ABqQZi2AUG4xQEoAgARAAAgBSAFIARBmLYBQbjFASgCABEAAAJAIAkEQCAAQcABaiAKQajFASgCABECACAAQfABaiABQZABakGoxQEoAgARAgAMAQsgAkHgA2ogCiAHQYjFASgCABEBACAAQcABaiACQeADakGYtgFB7MUBKAIAEQEAIABB8AFqIAJBwARqQZi2AUHsxQEoAgARAQALIABBwAFqIgEgAUGYtgFBxMUBKAIAEQEAIABB8AFqIgEgAUGYtgFBxMUBKAIAEQEAIABB4ABqIgEgAkHgAGogAEGYtgFBuMUBKAIAEQAAIABBkAFqIgAgBCAFQZi2AUG4xQEoAgARAAAgAkHgA2ogASACQaACakGIxQEoAgARAQAgASACQeADakGYtgFB7MUBKAIAEQEAIAAgAkHABGpBmLYBQezFASgCABEBACACQcABaiACQcABakGYtgFBxMUBKAIAEQEAIAYgBkGYtgFBxMUBKAIAEQEAIAJBwAFqIAJBwAFqQZi2AUHExQEoAgARAQAgBiAGQZi2AUHExQEoAgARAQAgAkHAAWogAkHAAWpBmLYBQcTFASgCABEBACAGIAZBmLYBQcTFASgCABEBACABIAEgAkHAAWpBmLYBQbjFASgCABEAACAAIAAgBkGYtgFBuMUBKAIAEQAACyACQaAFaiQAC7YDACAAQbCjAUGoxQEoAgARAgAgACAAIAFBmLYBQbzFASgCABEAACAAIABBgKMBQZi2AUG0xQEoAgARAAAgACAAIAFBmLYBQbzFASgCABEAACAAIABB0KIBQZi2AUG0xQEoAgARAAAgACAAIAFBmLYBQbzFASgCABEAACAAIABBoKIBQZi2AUG0xQEoAgARAAAgACAAIAFBmLYBQbzFASgCABEAACAAIABB8KEBQZi2AUG0xQEoAgARAAAgACAAIAFBmLYBQbzFASgCABEAACAAIABBwKEBQZi2AUG0xQEoAgARAAAgACAAIAFBmLYBQbzFASgCABEAACAAIABBkKEBQZi2AUG0xQEoAgARAAAgACAAIAFBmLYBQbzFASgCABEAACAA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IABB4ABqIAJB4ABqQajFASgCABECAAwBCyACQeAAakGgxQEoAgARBAAEQCAAIAFBqMUBKAIAEQIAIABBMGogAUEwakGoxQEoAgARAgAgAEHgAGogBEGoxQEoAgARAgAMAQsgAUHgAGohBwJ/QZjFASgCACIFRQRAQQEhBkEBDAELQYjDASgCACIJIAcoAgBGBEBBASEIA0ACQCAFIAgiBEYEQCAFIQQMAQsgBEEBaiEIIAEgBEECdCIGaigCYCAGQYjDAWooAgBGDQELCyAEIAVPIQYLQQAgAigCYCAJRw0AGkEBIQgDQAJAIAUgCCIERgRAIAUhBAwBCyAEQQFqIQggAiAEQQJ0IglqKAJgIAlBiMMBaigCAEYNAQsLIAQgBU8LIQQgBkUEQCADQcABaiAHQZi2AUHAxQEoAgARAQALIAJB4ABqIQUCQCAEBEAgA0GQAWogAUGoxQEoAgARAgACQCAGBEAgA0EwaiACQajFASgCABECAAwBCyADQTBqIAIgA0HAAWpBmLYBQbzFASgCABEAAAsgA0EwaiADQTBqIANBkAFqQZi2AUG4xQEoAgARAAAgA0HgAGogAUEwakGoxQEoAgARAgAMAQsgA0HgAGogBUGYtgFBwMUBKAIAEQEAIANBkAFqIAEgA0HgAGpBmLYBQbzFASgCABEAAAJAIAYEQCADQTBqIAJBqMUBKAIAEQIADAELIANBMGogAiADQcABakGYtgFBvMUBKAIAEQAACyADQTBqIANBMGogA0GQAWpBmLYBQbjFASgCABEAACADQeAAaiADQeAAaiAFQZi2AUG8xQEoAgARAAAgA0HgAGogA0HgAGogAUEwakGYtgFBvMUBKAIAEQAACwJAIAYEQCADQcABaiACQTBqQajFASgCABECAAwBCyADQcABaiADQcABaiAHQZi2AUG8xQEoAgARAAAgA0HAAWogA0HAAWogAkEwakGYtgFBvMUBKAIAEQAACyADQcABaiADQcABaiADQeAAakGYtgFBuMUBKAIAEQAAIANBMGpBoMUBKAIAEQQABEAgA0HAAWpBoMUBKAIAEQQABEAgACABEPEBDAILIABBpMUBKAIAEQMAIABBMGpBpMUBKAIAEQMAIABB4ABqQaTFASgCABEDAAwBCwJAIAYEQCAEBEAgAEHgAGogA0EwakGoxQEoAgARAgAMAgsgAEHgAGogA0EwaiAFQZi2AUG8xQEoAgARAAAMAQsgAEHgAGohAUG8xQEoAgAhAiAEBEAgASAHIANBMGpBmLYBIAIRAAAMAQsgASAHIAVBmLYBIAIRAAAgASABIANBMGpBmLYBQbzFASgCABEAAAsgAyADQTBqQZi2AUHAxQEoAgARAQAgAEEwaiIBIANBwAFqQZi2AUHAxQEoAgARAQAgA0GQAWogA0GQAWogA0GYtgFBvMUBKAIAEQAAIAMgAyADQTBqQZi2AUG8xQEoAgARAAAgASABIANBkAFqQZi2AUG4xQEoAgARAAAgASABIANBkAFqQZi2AUG4xQEoAgARAAAgACABIANBmLYBQbjFASgCABEAACADQZABaiADQZABaiAAQZi2AUG4xQEoAgARAAAgA0GQAWogA0GQAWogA0HAAWpBmLYBQbzFASgCABEAACADIAMgA0HgAGpBmLYBQbzFASgCABEAACABIANBkAFqIANBmLYBQbjFASgCABEAAAsgA0HwAWokAAuhAgECfyMAQYADayIDJAAgAyADQfABaiIEIANB0AJqIAEQZSADQZABaiADIARBmLYBQbzFASgCABEAACADQcABaiIBIARBmLYBQcDFASgCABEBACABIAEgBEGYtgFBvMUBKAIAEQAAIAEgASADQdACakGYtgFBvMUBKAIAEQAAIAIEQCADQdACaiADQeAAaiIEIANBoAJqIAIQZSADIANB0AJqIARBmLYBQbzFASgCABEAACADQTBqIgEgBEGYtgFBwMUBKAIAEQEAIAEgASAEQZi2AUG8xQEoAgARAAAgASABIANBoAJqQZi2AUG8xQEoAgARAAAgA0GQAWogA0GQAWogAxD1AQsgACADQZABahCGASAAIAAQ9AEgA0GAA2okAAvRJAEQfyMAQdCmAmsiAyQAIANBADoA5AQgA0EAOgDQBSADQQE2AuAEIANBADoAvAYgA0EBNgLMBSADQQE2ArgGIANBATYC9AMgA0IBNwOQAyADQQA6APgDIANCATcC/AMgA0IBNwPoBCADQgE3AtQFIANBATYChAMgA0IBNwOgAiADQQA6AIgDQcjMASADQaACaiACEFIgAygChAMhAgJAAkAgAy0AiAMEQCACQQFHDQEgAygCpAJFDQIMAQsCQCACDgIBAAILA0AgAkUNAiACQX9q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DAELAkAgAg4CAQACCwNAIAJFDQIgAkF/aiICQQJ0IANqKAKkAkUNAAsMAQsgA0GgAmogA0GgAmpBtMcBEB4LIANBkANqIANBoAJqEEMgAygC9AMhAgJAAkAgAy0A+AMiBARAQQEhEiACQQFHDQEgAygClANFDQIMAQtBASESAkAgAg4CAQACCwNAIAJFDQIgAkF/aiICQQJ0IANqKAKUA0UNAAsMAQsgAyAEQQFzOgD4A0EAIRILIANBwAZqQaTFASgCABEDACADQfAGakGkxQEoAgARAwAgA0GgB2pBpMUBKAIAEQMAIANB0AdqQaTFASgCABEDACADQYAIakGkxQEoAgARAwAgA0GwCGpBpMUBKAIAEQMAIAMoAuAEIQICQAJAIAMtAOQEIgQEQEEBIRMgAkEBRw0BIAMoAoAERQ0CDAELQQEhEwJAIAIOAgEAAgsDQCACRQ0CIAJBf2oiAkECdCADaigCgARFDQALDAELIAMgBEEBczoA5ARBACETCyADQcAqakGkxQEoAgARAwAgA0HwKmpBpMUBKAIAEQMAIANBoCtqQaTFASgCABEDACADQdArakGkxQEoAgARAwAgA0GALGpBpMUBKAIAEQMAIANBsCxqQaTFASgCABEDACADKALMBSECAkACQCADLQDQBSIEBEBBASEUIAJBAUcNASADKALsBEUNAgwBC0EBIRQCQCACDgIBAAILA0AgAkUNAiACQX9qIgJBAnQgA2ooAuwERQ0ACwwBCyADIARBAXM6ANAFQQAhFAsgA0HAzgBqQaTFASgCABEDACADQfDOAGpBpMUBKAIAEQMAIANBoM8AakGkxQEoAgARAwAgA0HQzwBqQaTFASgCABEDACADQYDQAGpBpMUBKAIAEQMAIANBsNAAakGkxQEoAgARAwAgAygCuAYhAgJAAkAgAy0AvAYiBARAQQEhFSACQQFHDQEgAygC2AVFDQIMAQtBASEVAkAgAg4CAQACCwNAIAJFDQIgAkF/aiICQQJ0IANqKALYBUUNAAsMAQsgAyAEQQFzOgC8BkEAIRULIANBwPIAakGkxQEoAgARAwAgA0Hw8gBqQaTFASgCABEDACADQaDzAGpBpMUBKAIAEQMAIANB0PMAakGkxQEoAgARAwAgA0GA9ABqQaTFASgCABEDACADQbD0AGpBpMUBKAIAEQMAIANB4AhqIhAgAUGoxQEoAgARAgAgA0GQCWogAUEwakGoxQEoAgARAgAgA0HACWogAUHgAGpBqMUBKAIAEQIAIANB8AlqIAFBkAFqQajFASgCABECACADQaAKaiABQcABakGoxQEoAgARAgAgA0HQCmogAUHwAWpBqMUBKAIAEQIAIANBgAtqIQICQAJAAkACQAJAQZiCAigCACIHDgMCAQAECyACIBAgARAJDAILIAIgECABEAoMAQsgAiAQIAEQCwtBmIICKAIAIQcLIANBoA1qIQQCQAJAAkACQCAHDgMCAQADCyAEIAIgARAJDAILIAQgAiABEAoMAQsgBCACIAEQCwsgA0HAD2ohBwJAAkACQAJAAkBBmIICKAIAIgUOAwIBAAQLIAcgBCABEAkMAgsgByAEIAEQCgwBCyAHIAQgARALC0GYggIoAgAhBQsgA0HgEWohCgJAAkACQAJAIAUOAwIBAAMLIAogByABEAkMAgsgCiAHIAEQCgwBCyAKIAcgARALCyADQYAUaiEFAkACQAJAAkACQEGYggIoAgAiDA4DAgEABAsgBSAKIAEQCQwCCyAFIAogARAKDAELIAUgCiABEAsLQZiCAigCACEMCyADQaAWaiEJAkACQAJAAkAgDA4DAgEAAwsgCSAFIAEQCQwCCyAJIAUgARAKDAELIAkgBSABEAsLIANBwBhqIQYCQAJAAkACQAJAQZiCAigCACIIDgMCAQAECyAGIAkgARAJDAILIAYgCSABEAoMAQsgBiAJIAEQCwtBmIICKAIAIQgLIANB4BpqIQwCQAJAAkACQCAIDgMCAQADCyAMIAYgARAJDAILIAwgBiABEAoMAQsgDCAGIAEQCwsgA0GAHWohCAJAAkACQAJAAkBBmIICKAIAIgsOAwIBAAQLIAggDCABEAkMAgsgCCAMIAEQCgwBCyAIIAwgARALC0GYggIoAgAhCwsgA0GgH2ohDQJAAkACQAJAIAsOAwIBAAMLIA0gCCABEAkMAgsgDSAIIAEQCgwBCyANIAggARALCyADQcAhaiELAkACQAJAAkACQEGYggIoAgAiDw4DAgEABAsgCyANIAEQCQwCCyALIA0gARAKDAELIAsgDSABEAsLQZiCAigCACEPCyADQeAjaiEOAkACQAJAAkAgDw4DAgEAAwsgDiALIAEQCQwCCyAOIAsgARAK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JAAgAiABIAFB4ABqIgNBmLYBQeTFASgCABEAACAAIAEgA0GYtgFB6MUBKAIAEQAAQZjFASgCACIBQf////8HcQRAIABB4ABqIAIgAUEDdBADGgsgAkHgAGokAAuuAwETfyAAIAEgAhA5GgJAIAAoAiwiASADKAIsIgJJDQAgASACSwRAIAAgACADEC4aDwsgAygCBCICIAAoAgAiDSADKAIAIg5JaiIBIAJJIAAoAgQiDyABSWoiBCADKAIIaiICIARJIAAoAggiECACSWoiBSADKAIMaiIEIAVJIAAoAgwiESAESWoiBiADKAIQaiIFIAZJIAAoAhAiEiAFSWoiByADKAIUaiIGIAdJIAAoAhQiEyAGSWoiCCADKAIYaiIHIAhJIAAoAhgiFCAHSWoiCSADKAIcaiIIIAlJIAAoAhwiFSAISWoiCiADKAIgaiIJIApJIAAoAiAiFiAJSWoiCyADKAIkaiIKIAtJIAAoAiQiCyAKSWoiDCADKAIoaiIDIAxJQX9BACAAKAIoIgwgA0kbRw0AIABBADYCLCAAIAwgA2s2AiggACALIAprNgIkIAAgFiAJazYCICAAIBUgCGs2AhwgACAUIAdrNgIYIAAgEyAGazYCFCAAIBIgBWs2AhAgACARIARrNgIMIAAgECACazYCCCAAIA8gAWs2AgQgACANIA5rNgIACwuxAQECfyMAQcABayICJAAgAkHgAGogAUGoxQEoAgARAgAgAkGQAWoiAyABQTBqQajFASgCABECACACQTBqIAMgA0HwxQEoAgARBQAaIAIgAkHgAGogA0HwxQEoAgARBQAaIABB4ABqIAJBMGogAkHgAGpB0MUBKAIAEQEAIAJBMGogAkHgAGogA0GYtgFBuMUBKAIAEQAAIAAgAkEwaiACQdDFASgCABEBACACQcABaiQAC5gCAQJ/IwBBgANrIgMkACADQaACaiABQajFASgCABECACADQdACaiIEIAFBMGpBqMUBKAIAEQIAIANBwAFqIAJBqMUBKAIAEQIAIANB8AFqIgEgAkEwakGoxQEoAgARAgAgA0EwaiADQaACaiAEQfDFASgCABEFABogAyADQcABaiABQfDFASgCABEFABogAEHgAGoiAiADQTBqIANB0MUBKAIAEQEAIAAgA0GgAmogA0HAAWpB0MUBKAIAEQEAIANB4ABqIAQgAUHQxQEoAgARAQAgAiACIABB/MUBKAIAEQUAGiACIAIgA0HgAGpB/MUBKAIAEQUAGiAAIAAgA0HgAGpBmLYBQejFASgCABEAACADQYADaiQAC6IBAQR/IwBBMGsiAiQAIAIgAUGAxgEoAgAiAxBYRQRAIAIgASADQZi2AUHMxQEoAgARAAALIAIgAiABQTBqIgRBmLYBQbjFASgCABEAACAAQTBqIgMgBEGAxgEoAgAiBRBYRQRAIAMgBCAFQZi2AUHMxQEoAgARAAALIAMgAyABQZi2AUG0xQEoAgARAAAgACACQajFASgCABECACACQTBqJAALUgECfyMAQTBrIgIkACACIAEgAUEwaiIDQZi2AUG0xQEoAgARAAAgACABIANBmLYBQbjFASgCABEAACAAQTBqIAJBqMUBKAIAEQIAIAJBMGokAAutFQERfyMAQeCtEmsiBCQAIARB3K0SakEANgIAIARBlK0SakEANgIAIARBzKwSakEANgIAIARBhKwSakEANgIAIARBvKsSakEANgIAIARB9KoSakEANgIAIARBrKoSakEANgIAIARB5KkSakEANgIAIARBnKkSakEANgIAIARB1KgSakEANgIAIARBjKgSakEANgIAIARBxKcSakEANgIAIARB/KYSakEANgIAIARBtKYSakEANgIAIARB7KUSakEANgIAIARBpKUSakEANgIAIARB3KQSakEANgIAIARBlKQSakEANgIAIARBzKMSakEANgIAIARBhKMSakEANgIAIARBvKISakEANgIAIARB9KESakEANgIAIARBrKESakEANgIAIARB5KASakEANgIAIARBnKASakEANgIAIARB1J8SakEANgIAIARBjJ8SakEANgIAIARBxJ4SakEANgIAIARB/J0SakEANgIAIARBtJ0SakEANgIAIARB7JwSakEANgIAIARBpJwSakEANgIAIARB3JsSakEANgIAIARBlJsSakEANgIAIARBzJoSakEANgIAIARBhJoSakEANgIAIARBvJkSakEANgIAIARB9JgSakEANgIAIARBrJgSakEANgIAIARB5JcSakEANgIAIARBnJcSakEANgIAIARB1JYSakEANgIAIARBjJYSakEANgIAIARBxJUSakEANgIAIARB/JQSakEANgIAIARBtJQSakEANgIAIARB7JMSakEANgIAIARBpJMSakEANgIAIARB3JISakEANgIAIARBlJISakEANgIAIARBzJESakEANgIAIARBhJESakEANgIAIARBvJASakEANgIAIARB9I8SakEANgIAIARBrI8SakEANgIAIARB5I4SakEANgIAIARBnI4SakEANgIAIARB1I0SakEANgIAIARBjI0SakEANgIAIARBxIwSakEANgIAIARB/IsSakEANgIAIARBtIsSakEANgIAIARB7IoSakEANgIAIARBADYCpIoSIARBADoA9AcgBEHgCGpBADoAACAEQQE2AvAHIARBzAlqQQA6AAAgBEHcCGpBATYCACAEQcgJakEBNgIAIARBATYChAcgBEIBNwOgBiAEQQA6AIgHIARCATcCjAcgBEIBNwP4ByAEQgE3AuQIIARBATYClAYgBEIBNwOwBSAEQQA6AJgGAkAgA0EQIANBEEkbIgtFBEAgABAvDAELIARBsAVqQQRyIRAgBEHoCGohESAEQfwHaiESIARBkAdqIRMgBEGgBmpBBHIhFCAEQcAEakEEciEKA0AgBCACIAZB7ABsaiIDKAIAIgU2ArAFIAUEQCAQIANBBGogBUECdBADGgsgBCADKAJkNgKUBiAEIAMtAGg6AJgGIARBsAVqIARBsAVqQbTHARAaIAQoApQGIQMCQAJAIAQtAJgGBEAgA0EBRw0BIAQoArQFDQEMAgsgAw0BCyAEQbAFaiAEQbAFakG0xwEQHgsgBEGgBmogBEGwBWoQQyAEIAQoAqAGIgM2AsAEIAMEQCAKIBQgA0ECdBADGgsgBCAEKAKEBzYCpAUgBCAELQCIBzoAqAUgBEHfCWogBEHgiRJqIAZBoAJsaiIDIARBwARqECMgAygCRCEMIAQgBCgCjAciBTYCwAQgBQRAIAogEyAFQQJ0EAMaCyAEIAQoAvAHNgKkBSAEIAQtAPQHOgCoBSAEQd8JaiADQcgAaiAEQcAEahAjIAMoAowBIQ0gBCAEKAL4ByIFNgLABCAFBEAgCiASIAVBAnQQAxoLIAQgBCgC3Ag2AqQFIAQgBC0A4Ag6AKgFIARB3wlqIANBkAFqIARBwARqECMgAygC1AEhDiAEIAQoAuQIIgU2AsAEIAUEQCAKIBEgBUECdBADGgsgBCAEKALICTYCpAUgBCAELQDMCToAqAUgBEHfCWogA0HYAWogBEHABGoQIyADKAKcAiEPIAQgASAGQcAEbGoiBRAlIARB4AlqIAZBgJABbGoiAyAFQajFASgCABECACADQTBqIAVBMGpBqMUBKAIAEQIAIANB4ABqIAVB4ABqQajFASgCABECACADQZABaiAFQZABakGoxQEoAgARAgAgA0HAAWogBUHAAWpBqMUBKAIAEQIAIANB8AFqIAVB8AFqQajFASgCABECACADQaACaiAFQaACakGoxQEoAgARAgAgA0HQAmogBUHQAmpBqMUBKAIAEQIAIANBgANqIAVBgANqQajFASgCABECACADQbADaiAFQbADakGoxQEoAgARAgAgA0HgA2ogBUHgA2pBqMUBKAIAEQIAIANBkARqIAVBkARqQajFASgCABECACADQYAkaiIFIAMQBiADQYDIAGoiByAFEAYgA0GA7ABqIAcQBiADQcAEaiIFIAMgBBAHIANBwChqIgcgBRAGIANBwMwAaiIIIAcQBiADQcDwAGogCBAGIANBgAlqIgcgBSAEEAcgA0GALWoiBSAHEAYgA0GA0QBqIgggBRAGIANBgPUAaiAIEAYgA0HADWoiBSAHIAQQByADQcAxaiIHIAUQBiADQcDVAGoiCCAHEAYgA0HA+QBqIAgQBiADQYASaiIHIAUgBBAHIANBgDZqIgUgBxAGIANBgNoAaiIIIAUQBiADQYD+AGogCBAGIANBwBZqIgUgByAEEAcgA0HAOmoiByAFEAYgA0HA3gBqIgggBxAGIANBwIIBaiAIEAYgA0GAG2oiByAFIAQQByADQYA/aiIFIAcQBiADQYDjAGoiCCAFEAYgA0GAhwFqIAgQBiADQcAfaiIFIAcgBBAHIANBwMMAaiIHIAUQBiADQcDnAGoiBSAHEAYgA0HAiwFqIAUQBiAPIA4gDSAMIAkgDCAJSxsiAyANIANLGyIDIA4gA0sbIgMgDyADSxshCSAGQQFqIgYgC0cNAAsgABAvIAlFDQBBACEDA0AgACAAECUgCSADQX9zaiEBQQAhBgNAAkAgBEHgiRJqIAZBoAJsaiICKAJEIAFNDQAgASACaiwAACIFQQBMBEAgBUF/Sg0BIAAgACAEQeAJaiAGQYCQAWxqIAVBAXVBf3NBwARsahAyDAELIAAgACAEQeAJaiAGQYCQAWxqIAVBf2pBAXVB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BCgC5AIhAgJAAkAgBC0A6AIEQCACQQFHDQEgBCgChAINAQwCCyACDQELIARBgAJqIARBgAJqQbTHARAeCyAEQfACaiAEQYACahBjIAQgBCgC8AIiAjYCkAEgBEGQAWpBBHIhAyACBEAgAyAEQfACakEEciACQQJ0EAMaCyAEIAQoAtQDNgL0ASAEIAQtANgDOgD4ASAEQc8EaiAEQdAWaiAEQZABahBZIAQgBCgC3AMiAjYCkAEgBCgC1BchBSACBEAgAyAEQeADaiACQQJ0EAMaCyABQeAAaiEHIAFBMGohCCAEQbAOaiEJIARBgA5qIQogBEHQDWohCyAEQbAFaiECIARBgAVqIQMgBCAEKALABDYC9AEgBCAELQDEBDoA+AEgBEHPBGogBEHYF2ogBEGQAWoQWSAEKALcGCEGAkACQAJAAkBB7IECKAIADgMAAQIDCyAEIAEQEwwCCyAEIAEQEgwBCyAEIAEQFQsgBEHQBGogAUGoxQEoAgARAgAgAyAIQajFASgCABECACACIAdBqMUBKAIAEQIAIAsgBEHQBGpBhNsBQZi2AUG8xQEoAgARAAAgCiADQajFASgCABECACAJIAJBqMUBKAIAEQIAIARB4AVqIQECQAJAAkACQEHsgQIoAgAOAwABAgMLIAEgBEHQBGogBBAODAILIAEgBEHQBGogBBANDAELIAEgBEHQBGogBBAMCyAEQeAOaiABQYTbAUGYtgFBvMUBKAIAEQAAIARBkA9qIARBkAZqQajFASgCABECACAEQcAPaiAEQcAGakGoxQEoAgARAgAgBEHwBmohAgJAAkACQAJAQeyBAigCAA4DAgEAAwsgAiABIAQQDAwCCyACIAEgBBANDAELIAIgASAEEA4LIARB8A9qIAJBhNsBQZi2AUG8xQEoAgARAAAgBEGgEGogBEGgB2pBqMUBKAIAEQIAIARB0BBqIARB0AdqQajFASgCABECACAEQYAIaiEBAkACQAJAAkBB7IECKAIADgMCAQADCyABIAIgBBAMDAILIAEgAiAEEA0MAQsgASACIAQQDgsgBEGAEWogAUGE2wFBmLYBQbzFASgCABEAACAEQbARaiAEQbAIakGoxQEoAgARAgAgBEHgEWogBEHgCGpBqMUBKAIAEQIAIARBkAlqIQICQAJAAkACQEHsgQIoAgAOAwIBAAMLIAIgASAEEAwMAgsgAiABIAQQDQwBCyACIAEgBBAOCyAEQZASaiACQYTbAUGYtgFBvMUBKAIAEQAAIARBwBJqIARBwAlqQajFASgCABECACAEQfASaiAEQfAJakGoxQEoAgARAgAgBEGgCmohAQJAAkACQAJAQeyBAigCAA4DAgEAAwsgASACIAQQDAwCCyABIAIgBBANDAELIAEgAiAEEA4LIAYgBUshAyAEQaATaiABQYTbAUGYtgFBvMUBKAIAEQAAIARB0BNqIARB0ApqQajFASgCABECACAEQYAUaiAEQYALakGoxQEoAgARAgAgBEGwC2ohAgJAAkACQAJAQeyBAigCAA4DAgEAAwsgAiABIAQQDAwCCyACIAEgBBANDAELIAIgASAEEA4LIAYgBSADGyEDIARBsBRqIAJBhNsBQZi2AUG8xQEoAgARAAAgBEHgFGogBEHgC2pBqMUBKAIAEQIAIARBkBVqIARBkAxqQajFASgCABECACAEQcAMaiEBAkACQAJAAkBB7IECKAIADgMCAQADCyABIAIgBBAMDAILIAEgAiAEEA0MAQsgASACIAQQDgtBACECIARBwBVqIAFBhNsBQZi2AUG8xQEoAgARAAAgBEHwFWogBEHwDGpBqMUBKAIAEQIAIARBoBZqIARBoA1qQajFASgCABECACAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwAgA0UNAANAIAMgAkF/c2ohAQJAAkACQAJAQeyBAigCAA4DAAECAwsgACAAEBMMAgsgACAAEBIMAQsgACAAEBULAkAgBCgC1BcgAU0NACAEQdAWaiABaiwAACIFQQFOBEAgBEHQBGogBUF/akEBdUGQAWxqIQUCQAJAAkBB7IECKAIADgMAAQIECyAAIAAgBRAODAMLIAAgACAFEA0MAgsgACAAIAUQDAwBCyAFQX9KDQAgACAEQdAEaiAFQQF1QX9zQZABbGoQRAsCQCAEKALcGCABTQ0AIAEgBGpB2BdqLAAAIgFBAEwEQCABQX9KDQEgACABQQF1QX9zQZABbCAEakHQDWoQRAwBCyABQX9qQQF1QZABbCAEakHQDWohAQJAAkACQEHsgQIoAgAOAwIBAAMLIAAgACABEAwMAgsgACAAIAEQDQwBCyAAIAAgARAOCyACQQFqIgIgA0cNAAsLIARB4BhqJAAL+EACB38BfiMAQcAKayIBJABB1O4BQeD+ACgCACIDNgIAIAMEQANAIAJBAnQiBEHY7gFqIARB4P4AaigCBDYCACACQQFqIgIgA0cNAAsLQbjvAUHE/wAoAgA2AgBBvO8BQcj/AC0AADoAAEHE/wAoAgAhAwJAAkACQEHI/wAtAAAiBQRAIANBAUcNAkEBIQNB5P4AKAIARQ0BDAILAkAgAyICDgICAAELA0AgAkUNASACQX9qIgJBAnRB4P4AaigCBEUNAAsLIAFB4P4AKAIAIgI2AtAJIAIEQCABQdAJakEEckHk/gAgAkECdBADGgsgASAFOgC4CiABIAM2ArQKDAELIAFBATYCtAogAUEANgLUCSABQQA6ALgKIAFB4P4AKAIAIgI2AtAJIAIEQCABQdAJakEEckHk/gAgAkECdBADGgsgASADNgK0CiABIAVBAXMiBToAuAoLQcTvASACNgIAIAIEQEHI7wEgAUHQCWpBBHIgAkECdBADGgtBrPABIAU6AABBqPABIAM2AgBBoIICIAA6AABBpIICQYjWASgCAEEfakFgcTYCACABQgE3A9AJIAFBADoAuAogAUEBNgK0CgJAAkBBxP8AKAIAIgBBAWoiBEEZTwRAIAFBATYCtAogAUIBNwPQCQwBCyABIAQ2AtAJQQAhAgJAIABFBEBBACEDDAELQQAhAwNAIAEgAkECdCIFakHUCWogAyAFQeD+AGooAgQiBUEBdCIGaiIDNgIAIAVBH3YgAyAGSWohAyACQQFqIgIgAEcNAAsLIABBAnQgAWpB1AlqIAM2AgAgAUHI/wAtAAAiAzoAuAoCQANAIAQiAEECSA0BIABBf2oiBEECdCABakHUCWooAgBFDQALIAEgADYCtAoMAgsgAUEBNgK0CiABKALUCQ0BC0EAIQMgAUEAOgC4CgtBACECIAFBADoAyAkgASADOgC4CiABQQE2AsQJIAFCATcD4AggAUHgCGogAUHQCWpBAUEAEBggAUEBNgK0CiABQgE3A9AJIAFBADoAuAogAUHQCWpB4P4AQQFBABAYQcDwASABKALQCSIANgIAIAAEQEHE8AEgAUHQCWpBBHIgAEECdBADGgtBpPEBIAEoArQKNgIAQajxASABLQC4CjoAAEGs8QFB4P4AKAIAIgA2AgAgAARAA0AgAkECdCIDQbDxAWogA0Hg/gBqKAIENgIAIAJBAWoiAiAARw0ACwtBACECQZDyAUHE/wAoAgA2AgBBlPIBQcj/AC0AADoAAEGY8gFB4P4AKAIAIgA2AgAgAARAA0AgAkECdCIDQZzyAWogA0Hg/gBqKAIENgIAIAJBAWoiAiAARw0ACwtBACEAQfzyAUHE/wAoAgA2AgBBgPMBQcj/AC0AADoAACABQQA6ALgKQQEhBSABQQE2ArQKIAFCATcD0AkgAUEBNgLUCCABQoGAgIAgNwPwByABQQE6ANgIIAFB0AlqQQRyIQQCQAJAQcT/ACgCACICQQFqIgNBGU8EQEGE8wFBATYCACABQQE2ArQKIAFCATcD0AkgAUEAOgC4CkEBIQIMAQsgASADNgLQCSAEIAFB8AdqQQRyQQFB5P4AIAIQCCABQcj/AC0AACABLQDYCHMiADoAuAoCQAJAA0AgAyICQQJIDQEgAkF/aiIDQQJ0IAFqQdQJaigCAEUNAAsgASACNgK0CgwBC0EBIQIgAUEBNgK0CiABKALUCQ0AQQAhACABQQA6ALgKC0GE8wEgASgC0AkiBTYCACAFRQ0BC0GI8wEgBCAFQQJ0EAMaCyABQeAIakEEciEFQezzASAAOgAAQejzASACNgIAQfDzASABKALgCCIANgIAIAAEQEH08wEgBSAAQQJ0EAMaC0HU9AEgASgCxAk2AgBB2PQBIAEtAMgJOgAAIAFBATYCtAogAUEANgLUCSABQQA6ALgKIAFB4P4AKAIAIgA2AtAJAkAgAEUEQCABQcT/ACgCACIDNgK0CkHI/wAtAAAhAkHc9AEgADYCACABIAJBAXMiAjoAuAoMAQsgAUHQCWpBBHJB5P4AIABBAnQiBBADIQYgAUHE/wAoAgAiAzYCtApByP8ALQAAIQJB3PQBIAA2AgAgASACQQFzIgI6ALgKQeD0ASAGIAQQAxoLQcT1ASACOgAAQcD1ASADNgIAIAFBATYC1AggAUIBNwPwByABQQA6ANgIIAFB8AdqQeD+AEEBQQAQGCABQQE2ArQKIAFBADYC1AkgAUEAOgC4CiABIAEoAvAHIgA2AtAJAkAgAEUEQCABIAEoAtQIIgI2ArQKQcj1AUEANgIAIAEgAS0A2AhBAXMiAzoAuAoMAQsgAUHQCWpBBHIgAUHwB2pBBHIgAEECdCIEEAMhBkHI9QEgADYCACABIAEoAtQIIgI2ArQKIAEgAS0A2AhBAXMiAzoAuApBzPUBIAYgBBADGgtBsPYBIAM6AABBrPYBIAI2AgAgAUEBNgK0CiABQQA2AtQJIAFBADoAuAogAUHg/gAoAgAiADYC0AkCQCAARQRAIAFBxP8AKAIAIgM2ArQKQcj/AC0AACECQbT2ASAANgIAIAEgAkEBcyICOgC4CgwBCyABQdAJakEEckHk/gAgAEECdCIEEAMhBiABQcT/ACgCACIDNgK0CkHI/wAtAAAhAkG09gEgADYCACABIAJBAXMiAjoAuApBuPYBIAYgBBADGgtBACEEQZz3ASACOgAAQZj3ASADNgIAIAFBADoAuApBASEAIAFBATYCtAogAUIBNwPQCSABQQE2AtQIIAFCgYCAgCA3A/AHIAFBADoA2AggAUHQCWpBBHIhBgJAAkBBxP8AKAIAIgJBAWoiA0EZTwRAQaD3AUEBNgIAIAFBATYCtAogAUIBNwPQCSABQQA6ALgKQQEhAgwBCyABIAM2AtAJIAYgAUHwB2pBBHJBAUHk/gAgAhAIIAFByP8ALQAAIAEtANgIcyIEOgC4CgJAAkADQCADIgJBAkgNASACQX9qIgNBAnQgAWpB1AlqKAIARQ0ACyABIAI2ArQKDAELQQEhAiABQQE2ArQKIAEoAtQJDQBBACEEIAFBADoAuAoLQaD3ASABKALQCSIANgIAIABFDQELQaT3ASAGIABBAnQQAxoLQYj4ASAEOgAAQYT4ASACNgIAQYz4ASABKALgCCICNgIAAkAgAkUEQEHw+AEgASgCxAkiAzYCAEHk+QEgAjYCAEHg+QEgAS0AyAkiADoAAEHc+QEgAzYCAEH0+AEgADoAAEH4+AFBADYCAAwBC0GQ+AEgBSACQQJ0IgQQAxpB+PgBIAI2AgBB8PgBIAEoAsQJIgM2AgBB9PgBIAEtAMgJIgA6AABB/PgBIAUgBBADGkHk+QEgAjYCAEHg+QEgADoAAEHc+QEgAzYCAEHo+QEgBSAEEAMaC0HM+gEgADoAAEHI+gEgAzYCACABQQE2ArQKIAFCATcD0AkgAUEAOgC4CiABQdAJakHg/gBBAUEBEBhB0PoBIAEoAtAJIgI2AgAgAUHQCWpBBHIhACACBEBB1PoBIAAgAkECdBADGgtBtPsBIAEoArQKNgIAQbj7ASABLQC4CjoAACABQQA6ALgKIAFBATYCtAogAUIBNwPQCSABQQE2AtQIIAFCgYCAgCA3A/AHIAFBADoA2AgCQAJAIAEoAsQJIgJBAWoiA0EZTwRAQQEhA0EAIQVBvPsBQQE2AgAgAUEBNgK0CiABQgE3A9AJIAFBADoAuApBASECDAELIAEgAzYC0AkgACABQfAHakEEckEBIAUgAhAIIAEgAS0AyAkgAS0A2AhzIgU6ALgKAkACQANAIAMiAkECSA0BIAJBf2oiA0ECdCABakHUCWooAgBFDQALIAEgAjYCtAoMAQtBASECIAFBATYCtAogASgC1AkNAEEAIQUgAUEAOgC4CgtBvPsBIAEoAtAJIgM2AgAgA0UNAQtBwPsBIAAgA0ECdBADGgtBpPwBIAU6AABBoPwBIAI2AgAgAUEAOgDYCCABQQE2AtQIIAFCATcD8AcgAUEBNgLkByABQoGAgIAgNwOAByABQQE6AOgHAkBBxP8AKAIAIgBBAWoiAkEZTwRAIAFBATYC1AggAUIBNwPwByABQQA6ANgIDAELIAEgAjYC8AcgAUHwB2pBBHIgAUGAB2pBBHJBAUHk/gAgABAIIAFByP8ALQAAIAEtAOgHczoA2AgCQANAIAIiAEECSA0BIABBf2oiAkECdCABaigC9AdFDQALIAEgADYC1AgMAQsgAUEBNgLUCCABKAL0Bw0AIAFBADoA2AgLIAFBATYCtAogAUIBNwPQCSABQQA6ALgKIAFB0AlqIAFB8AdqQQFBABAYQaj8ASABKALQCSIANgIAIAFB0AlqQQRyIQIgAARAQaz8ASACIABBAnQQAxoLQYz9ASABKAK0CjYCAEGQ/QEgAS0AuAo6AAAgAUEBNgK0CiABQgE3A9AJIAFBADoAuAogAUHQCWpB4P4AQQFBARAYQZT9ASABKALQCSIANgIAIAAEQEGY/QEgAiAAQQJ0EAMaC0H4/QEgASgCtAo2AgBB/P0BIAEtALgKOgAAIAFBATYC1AggAUIYNwPwByABQQA6ANgIAkAgAUHYCGogAUHwB2pBBHJBGEHN+gBBEUEQEB8iAkUNAAJAA0AgAiIAQQJIDQEgAEF/aiICQQJ0IAFqKAL0B0UNAAsgASAANgLUCAwBCyABQQE2AtQIIAEoAvQHDQAgAUEAOgDYCAtBxP8AKAIAIQACQAJAAkACfwJAAkBByP8ALQAAIgUgAS0A2AhHBEAgAEEBRw0FIAEoAtQIQQFGDQFBASEADAULIAAgASgC1AgiAkcNASAAIQIDQEEAIAJBAUgNAxogAkF/aiICQQJ0IgNB4P4AaigCBCIEIAEgA2ooAvQHIgNGDQALQQFBfyAEIANLGwwCC0EBIQAgASgC9AdB5P4AKAIAckUNAgwDC0EBQX8gACACSxsLIgIgAiAFGw0BC0GQ/gFBGDYCAEH4/gFBADoAAAJAQfj+AUGU/gFBGEGA/gAoAgAiACAAECJBEBAfIgBFDQACQANAIAAiAkECSA0BIAJBf2oiAEECdEGU/gFqKAIARQ0AC0H0/gEgAjYCAAwBC0H0/gFBATYCAEGU/gEoAgANAEH4/gFBADoAAAtB/P4BQRg2AgBB5P8BQQA6AAACQEHk/wFBgP8BQRhBhP4AKAIAIgAgABAiQRAQHyIARQ0AA0AgACICQQFMBEBB4P8BQQE2AgBBgP8BKAIADQJB5P8BQQA6AAAMAgsgAkF/aiIAQQJ0QYD/AWooAgBFDQALQeD/ASACNgIAC0Ho/wFBGDYCAEHQgAJBADoAAAJAQdCAAkHs/wFBGEGI/gAoAgAiACAAECJBEBAfIgBFDQADQCAAIgJBAUwEQEHMgAJBATYCAEHs/wEoAgANAkHQgAJBADoAAAwCCyACQX9qIgBBAnRB7P8BaigCAEUNAAtBzIACIAI2AgALQdSAAkEYNgIAQbyBAkEAOgAAQbyBAkHYgAJBGEGM/gAoAgAiACAAECJBEBAfIgBFDQEDQCAAIgJBAUwEQEG4gQJBATYCAEHYgAIoAgANA0G8gQJBADoAAAwDCyACQX9qIgBBAnRB2IACaigCAEUNAAtBuIECIAI2AgAMAQsgAUEBNgKUBSABQoGAgIAQNwOwBEEAIQIgAUEAOgCYBSABQQE2AsQCIAFCgYCAgDA3A+ABIAFBADoAyAIgAUEBNgLUASABQgE3A3AgAUEAOgDYAQJAAkAgAEEBaiIEQRlPBEAgAUEBNgLUASABQgE3A3AMAQsgASAENgJwAkAgAEUEQEEAIQMMAQtBACEDA0AgASACQQJ0IgZqIAMgBkHg/gBqKAIEIgZBAXQiB2oiAzYCdCAGQR92IAMgB0lqIQMgAkEBaiICIABHDQALCyAAQQJ0IAFqIAM2AnQgASAFOgDYAQJAA0AgBCIAQQJIDQEgAEF/aiIEQQJ0IAFqKAJ0RQ0ACyABIAA2AtQBDAILIAFBATYC1AEgASgCdA0BC0EAIQUgAUEAOgDYAQsgAUEAOgC4AyABIAU6ANgBIAFBATYCtAMgAUIBNwPQAiABQdACaiABQeABaiABQfAAahAeIAFBATYCpAQgAUIBNwPAAyABQQA6AKgEAkAgASgCtAMiAEHE/wAoAgAiA2oiAkEZTwRAIAFBATYCpAQgAUIBNwPAAyABQQA6AKgEDAELIAEgAjYCwAMgAUHAA2pBBHJB5P4AIAMgAUHQAmpBBHIgABAIIAEgAS0AuANByP8ALQAAczoAqAQCQANAIAIiAEECSA0BIABBf2oiAkECdCABaigCxANFDQALIAEgADYCpAQMAQsgAUEBNgKkBCABKALEAw0AIAFBADoAqAQLIAFBATYChAYgAUIBNwOgBSABQQA6AIgGIAFBoAVqIAFBsARqIAFBwANqEB4gASABKAKgBSIANgKQBkGkggIoAgAhAiAABEAgAUGQBmpBBHIgAUGgBWpBBHIgAEECdBADGgsgASABKAKEBjYC9AYgASABLQCIBjoA+AYgAUGQBmogAUGQBmogAhAtIAFBATYC5AcgAUIBNwOAByABQQA6AOgHIAFBATYCtAogAUIBNwPQCSABQQA6ALgKQZzIAS0AACECIAEtAPgGIQMgAUGAB2ogAUHQCWogAUGQBmogASgC9AZBtMcBQZjIASgCABAqQZD+ASABKAKAByIANgIAIAEgAiADcyIDOgDoByAABEBBlP4BIAFBgAdqQQRyIABBAnQQAxoLQQAhAkH4/gEgAzoAAEH0/gEgASgC5Ac2AgAgAUEBNgKkBCABQoGAgIAQNwPAAyABQQA6AKgEIAFBATYC1AEgAUKBgICAgAE3A3AgAUEAOgDYASABQQE2AmQgAUIBNwMAIAFBADoAaAJAAkBBxP8AKAIAIgRBAWoiAEEZTwRAIAFBATYCZCABQgE3AwAMAQsgASAANgIAAkAgBEUEQEEAIQMMAQtBACEDA0AgASACQQJ0IgVqIAMgBUHg/gBqNQIEQgx+IginaiIFNgIEIAhCIIinIAUgA0lqIQMgAkEBaiICIARHDQALCyABIARBAnRqIAM2AgQgAUHI/wAtAAAiAzoAaAJAA0AgACICQQJIDQEgASACQX9qIgBBAnRqKAIERQ0ACyABIAI2AmQMAgsgAUEBNgJkIAEoAgQNAQtBACEDIAFBADoAaAsgAUEAOgDIAiABIAM6AGggAUEBNgLEAiABQgE3A+ABIAFB4AFqIAFB8ABqIAEQHiABQQE2ArQDIAFCATcD0AIgAUEAOgC4AwJAIAEoAsQCIgBBxP8AKAIAIgNqIgJBGU8EQCABQQE2ArQDIAFCATcD0AIgAUEAOgC4AwwBCyABIAI2AtACIAFB0AJqQQRyQeT+ACADIAFB4AFqQQRyIAAQCCABIAEtAMgCQcj/AC0AAHM6ALgDAkADQCACIgBBAkgNASAAQX9qIgJBAnQgAWooAtQCRQ0ACyABIAA2ArQDDAELIAFBATYCtAMgASgC1AINACABQQA6ALgDC0EBIQIgAUEBNgKUBSABQgE3A7AEQQAhBSABQQA6AJgFIAFBsARqIAFBwANqIAFB0AJqEB4gAUEBNgKEBiABQgE3A6AFIAFBADoAiAYgAUGgBWpBBHIhAAJAAkAgASgClAUiBEHE/wAoAgAiBmoiA0EZTwRAIAFBATYChAYgAUIBNwOgBSABQQA6AIgGIAFBATYCkAZBpIICKAIAIQRBASEDDAELIAEgAzYCoAUgAEHk/gAgBiABQbAEakEEciAEEAggASABLQCYBUHI/wAtAABzIgU6AIgGAkACQANAIAMiAkECSA0BIAJBf2oiA0ECdCABaigCpAVFDQALIAEgAjYChAYMAQtBASECIAFBATYChAYgASgCpAUNAEEAIQUgAUEAOgCIBgsgASABKAKgBSIDNgKQBkGkggIoAgAhBCADRQ0BCyABQZAGakEEciAAIANBAnQQAxoLIAEgBToA+AYgASACNgL0BiABQZAGaiABQZAGaiAEEC0gAUEBNgLkByABQgE3A4AHIAFBADoA6AcgAUEBNgK0CiABQgE3A9AJIAFBADoAuApBnMgBLQAAIQIgAS0A+AYhAyABQYAHaiABQdAJaiABQZAGaiABKAL0BkG0xwFBmMgBKAIAECpB/P4BIAEoAoAHIgA2AgAgASACIANzIgI6AOgHIAAEQEGA/wEgAUGAB2pBBHIgAEECdBADGgtB5P8BIAI6AABB4P8BIAEoAuQHNgIAIAFBATYCpAQgAUKBgICAEDcDwAMgAUEAOgCoBCABQQE2AtQBIAFCgYCAgMAANwNwIAFBADoA2AEgAUEBNgJkIAFCATcDACABQQA6AGgCQAJAQcT/ACgCACIEQQFqIgBBGU8EQCABQQE2AmQgAUIBNwMADAELIAEgADYCAEEAIQMCQCAERQRAQQAhAgwBC0EAIQIDQCABIANBAnQiBWogAiAFQeD+AGo1AgRCBn4iCKdqIgU2AgQgCEIgiKcgBSACSWohAiADQQFqIgMgBEcNAAsLIAEgBEECdGogAjYCBCABQcj/AC0AACIDOgBoAkADQCAAIgJBAkgNASABIAJBf2oiAEECdGooAgRFDQALIAEgAjYCZAwCCyABQQE2AmQgASgCBA0BC0EAIQMgAUEAOgBoCyABQQA6AMgCIAEgAzoAaCABQQE2AsQCIAFCATcD4AEgAUHgAWogAUHwAGogARAeIAFBATYCtAMgAUIBNwPQAiABQQA6ALgDAkAgASgCxAIiAEHE/wAoAgAiA2oiAkEZTwRAIAFBATYCtAMgAUIBNwPQAiABQQA6ALgDDAELIAEgAjYC0AIgAUHQAmpBBHJB5P4AIAMgAUHgAWpBBHIgABAIIAEgAS0AyAJByP8ALQAAczoAuAMCQANAIAIiAEECSA0BIABBf2oiAkECdCABaigC1AJFDQALIAEgADYCtAMMAQsgAUEBNgK0AyABKALUAg0AIAFBADoAuAMLQQEhAiABQQE2ApQFIAFCATcDsARBACEFIAFBADoAmAUgAUGwBGogAUHAA2ogAUHQAmoQHiABQQE2AoQGIAFCATcDoAUgAUEAOgCIBiABQaAFakEEciEAAkACQCABKAKUBSIEQcT/ACgCACIGaiIDQRlPBEAgAUEBNgKEBiABQgE3A6AFIAFBADoAiAYgAUEBNgKQBkGkggIoAgAhBEEBIQMMAQsgASADNgKgBSAAQeT+ACAGIAFBsARqQQRyIAQQCCABIAEtAJgFQcj/AC0AAHMiBToAiAYCQAJAA0AgAyICQQJIDQEgAkF/aiIDQQJ0IAFqKAKkBUUNAAsgASACNgKEBgwBC0EBIQIgAUEBNgKEBiABKAKkBQ0AQQAhBSABQQA6AIgGCyABIAEoAqAFIgM2ApAGQaSCAigCACEEIANFDQELIAFBkAZqQQRyIAAgA0ECdBADGgsgASAFOgD4BiABIAI2AvQGIAFBkAZqIAFBkAZqIAQQLSABQQE2AuQHIAFCATcDgAcgAUEAOgDoByABQQE2ArQKIAFCATcD0AkgAUEAOgC4CkGcyAEtAAAhAiABLQD4BiEDIAFBgAdqIAFB0AlqIAFBkAZqIAEoAvQGQbTHAUGYyAEoAgAQKkHo/wEgASgCgAciADYCACABIAIgA3MiAjoA6AcgAARAQez/ASABQYAHakEEciAAQQJ0EAMaC0HQgAIgAjoAAEHMgAIgASgC5Ac2AgAgAUEBNgK0AyABQoGAgIAQNwPQAiABQQA6ALgDIAFBATYCxAIgAUIBNwPgASABQQA6AMgCAkACQEHE/wAoAgAiAEEBaiIEQRlPBEAgAUEBNgLEAiABQgE3A+ABDAELIAEgBDYC4AFBACECAkAgAEUEQEEAIQMMAQtBACEDA0AgASACQQJ0IgVqIAMgBUHg/gBqKAIEIgVBAXQiBmoiAzYC5AEgBUEfdiADIAZJaiEDIAJBAWoiAiAARw0ACwsgAEECdCABaiADNgLkASABQcj/AC0AACIDOgDIAgJAA0AgBCIAQQJIDQEgAEF/aiIEQQJ0IAFqKALkAUUNAAsgASAANgLEAgwCCyABQQE2AsQCIAEoAuQBDQELQQAhAyABQQA6AMgCC0EAIQUgAUEAOgCoBCABIAM6AMgCQQEhAiABQQE2AqQEIAFCATcDwAMgAUHAA2ogAUHQAmogAUHgAWoQHiABQQE2ApQFIAFCATcDsAQgAUEAOgCYBSABQbAEakEEciEEAkACQCABKAKkBCIAQcT/ACgCACIGaiIDQRlPBEAgAUEBNgKUBSABQgE3A7AEIAFBADoAmAUgAUEBNgKgBUGkggIoAgAhA0EBIQAMAQsgASADNgKwBCAEQeT+ACAGIAFBwANqQQRyIAAQCCABIAEtAKgEQcj/AC0AAHMiBToAmAUCQAJAA0AgAyICQQJIDQEgAkF/aiIDQQJ0IAFqKAK0BEUNAAsgASACNgKUBQwBC0EBIQIgAUEBNgKUBSABKAK0BA0AQQAhBSABQQA6AJgFCyABIAEoArAEIgA2AqAFQaSCAigCACEDIABFDQELIAFBoAVqQQRyIAQgAEECdBADGgsgASAFOgCIBiABIAI2AoQGIAFBoAVqIAFBoAVqIAMQLSABQQE2AvQGIAFBADYClAYgAUEAOgD4BiABIAEoAqAFIgA2ApAGIAAEQCABQZAGakEEciABQaAFakEEciAAQQJ0EAMaCyABIAEoAoQGIgA2AvQGIAFBADoA6AcgAUEBNgLkByABQgE3A4AHIAEgAS0AiAZBAXMiAjoA+AYgAUEBNgK0CiABQgE3A9AJIAFBADoAuApBnMgBLQAAIQMgAUGAB2ogAUHQCWogAUGQBmogAEG0xwFBmMgBKAIAECpB1IACIAEoAoAHIgA2AgAgASACIANzIgI6AOgHIAAEQEHYgAIgAUGAB2pBBHIgAEECdBADGgtBvIECIAI6AABBuIECIAEoAuQHNgIACyABQcAKaiQAC7IfAQN/IwBBkAZrIgIkACABEPsBRQRAIAJBoAVqQaTFASgCABEDACACQgM3A6AFIAJBoAVqIAJBoAVqQZi2AUGwxQEoAgARAQBBlcYBLQAABEAgAkGgBWogAkGgBWpB6MMBQZi2AUG8xQEoAgARAAALQYTbASACQaAFahAkGiACQaAFakGIwwFBqMUBKAIAEQIAIAJBwANqQYTbASACQaAFakGYtgFBtMUBKAIAEQAAIAJBsARqIAJBwANqQZi2AUGwxQEoAgARAQAgAkHQAmpBpMUBKAIAEQMAIAJCAjcD0AJBlcYBLQAABEAgAkHQAmogAkHQAmpB6MMBQZi2AUG8xQEoAgARAAALIAJBoAVqIAJB0AJqQZS2AUHIxQEoAgARAQAgAkGgBWogAkGgBWogAkGwBGpBmLYBQbzFASgCABEAAEGE2wEgAkGgBWpBqMUBKAIAEQIAQZyCAkGI1gEoAgBBH2pBYHE2AgACfyAABEBBASEAIAJBATYCpAQgAkIBNwPAAyACQQA6AKgEIAJBwANqQQRyIQQCQCACQaD7AEYEQEHE/wAoAgAhA0EBIQEMAQsgAkHg/gAoAgAiADYCwAMgAARAIARB5P4AIABBAnQQAxoLIAJBxP8AKAIAIgM2AqQEIAJByP8ALQAAIgA6AKgEIABBAXMhASADIQALIAJBADoAmAUgAiABOgCoBCACQQE2ApQFIAJCATcDsAQCQCAAIANqIgFBGU8EQCACQQE2ApQFIAJCATcDsAQgAkEAOgCYBQwBCyACIAE2ArAEIAJBsARqQQRyIAQgAEHk/gAgAxAIIAJByP8ALQAAIAItAKgEczoAmAUCQANAIAEiAEECSA0BIABBf2oiAUECdCACaigCtARFDQALIAIgADYClAUMAQsgAkEBNgKUBSACKAK0BA0AIAJBADoAmAULIAJBATYChAYgAkIBNwOgBSACQQA6AIgGIAJBoAVqIAJBsARqQQFBABAYQaDdASACKAKgBSIANgIAIAJBoAVqQQRyIQQgAARAQaTdASAEIABBAnQQAxoLQYTeASACKAKEBjYCAEGI3gEgAi0AiAY6AABB8N4BQQE2AgBBjN4BQoGAgIAQNwIAQdzfAUEBNgIAQfjeAUKBgICAEDcDAEH03gFBADoAAEHg3wFBADoAACACQQE2AoQGIAJCATcDoAUgAkEAOgCIBgJ/AkBBxP8AKAIAIgBBAXQiAUEZTwRAQQEhAEHk3wFBATYCACACQQE2AoQGIAJCATcDoAUgAkEAOgCIBkEBIQMMAQsgAiABNgKgBSAEQeT+ACAAQeT+ACAAEAggAkEAOgCIBgJAAkADQCABIgNBAkgNASADQX9qIgFBAnQgAmooAqQFRQ0ACyACIAM2AoQGDAELQQEhAyACQQE2AoQGIAIoAqQFDQAgAkEAOgCIBgtB5N8BIAIoAqAFIgA2AgBBACAARQ0BGgtB6N8BIAQgAEECdBADGiAACyEBQcjgASADNgIAQczgAUEAOgAAQQEMAQsgAkEAOgCoBEEBIQEgAkEBNgKkBCACQgE3A8ADIAJBATYCtAMgAkKBgICA4AA3A9ACIAJBADoAuAMgAkHAA2pBBHIhAwJAQcT/ACgCACIEQQFqIgBBGU8EQCACQQE2AqQEIAJCATcDwAMgAkEAOgCoBAwBCyACIAA2AsADIAMgAkHQAmpBBHJBAUHk/gAgBBAIIAJByP8ALQAAIAItALgDczoAqAQCQANAIAAiAUECSA0BIAFBf2oiAEECdCACaigCxANFDQALIAIgATYCpAQMAQtBASEBIAJBATYCpAQgAigCxAMNACACQQA6AKgECyACQQE2ApQFIAJCATcDsAQgAkEAOgCYBQJAQcT/ACgCACIEIAFqIgBBGU8EQCACQQE2ApQFIAJCATcDsAQgAkEAOgCYBQwBCyACIAA2ArAEIAJBsARqQQRyIAMgAUHk/gAgBBAIIAJByP8ALQAAIAItAKgEczoAmAUCQANAIAAiAUECSA0BIAFBf2oiAEECdCACaigCtARFDQALIAIgATYClAUMAQsgAkEBNgKUBSACKAK0BA0AIAJBADoAmAULIAJBADoAyAIgAkEBNgLEAiACQgE3A+ABIAJBATYC1AEgAkKBgICAIDcDcCACQQA6ANgBAkBBxP8AKAIAIgBBAWoiAUEZTwRAIAJBATYCxAIgAkIBNwPgASACQQA6AMgCDAELIAIgATYC4AEgAkHgAWpBBHIgAkHwAGpBBHJBAUHk/gAgABAIIAJByP8ALQAAIAItANgBczoAyAICQANAIAEiAEECSA0BIABBf2oiAUECdCACaigC5AFFDQALIAIgADYCxAIMAQsgAkEBNgLEAiACKALkAQ0AIAJBADoAyAILIAJBATYChAYgAkIBNwOgBSACQQA6AIgGIAJBoAVqIAJBsARqIAJB4AFqEB5BoN0BIAIoAqAFIgA2AgAgAARAQaTdASACQaAFakEEciAAQQJ0EAMaC0GE3gEgAigChAY2AgBBiN4BIAItAIgGOgAAIAJBADoAmAUgAkEBNgKUBSACQgE3A7AEIAJBATYCpAQgAkKBgICAIDcDwAMgAkEBOgCoBAJAQcT/ACgCACIAQQFqIgFBGU8EQCACQQE2ApQFIAJCATcDsAQgAkEAOgCYBQwBCyACIAE2ArAEIAJBsARqQQRyIAJBwANqQQRyQQFB5P4AIAAQCCACQcj/AC0AACACLQCoBHM6AJgFAkADQCABIgBBAkgNASAAQX9qIgFBAnQgAmooArQERQ0ACyACIAA2ApQFDAELIAJBATYClAUgAigCtAQNACACQQA6AJgFCyACQQE2AoQGIAJCATcDoAUgAkEAOgCIBiACQaAFaiACQbAEakEBQQEQGEGM3gEgAigCoAUiADYCACAABEBBkN4BIAJBoAVqQQRyIABBAnQQAxoLQfDeASACKAKEBjYCAEH03gEgAi0AiAY6AAAgAkEAOgCYBSACQQE2ApQFIAJCATcDsAQgAkEBNgKkBCACQoGAgIAgNwPAAyACQQE6AKgEAkBBxP8AKAIAIgBBAWoiAUEZTwRAIAJBATYClAUgAkIBNwOwBCACQQA6AJgFDAELIAIgATYCsAQgAkGwBGpBBHIgAkHAA2pBBHJBAUHk/gAgABAIIAJByP8ALQAAIAItAKgEczoAmAUCQANAIAEiAEECSA0BIABBf2oiAUECdCACaigCtARFDQALIAIgADYClAUMAQsgAkEBNgKUBSACKAK0BA0AIAJBADoAmAULIAJBATYChAYgAkIBNwOgBSACQQA6AIgGIAJBoAVqIAJBsARqQQFBARAYQfjeASACKAKgBSIANgIAIAAEQEH83gEgAkGgBWpBBHIgAEECdBADGgtB3N8BIAIoAoQGNgIAQeDfASACLQCIBjoAACACQQA6ALgDIAJBATYCtAMgAkIBNwPQAiACQQE2AsQCIAJCgYCAgOAANwPgASACQQE6AMgCIAJB0AJqQQRyIQMCQEHE/wAoAgAiAUEBaiIAQRlPBEBBASEBIAJBATYCtAMgAkIBNwPQAiACQQA6ALgDDAELIAIgADYC0AIgAyACQeABakEEckEBQeT+ACABEAggAkHI/wAtAAAgAi0AyAJzOgC4AwJAA0AgACIBQQJIDQEgAUF/aiIAQQJ0IAJqKALUAkUNAAsgAiABNgK0AwwBC0EBIQEgAkEBNgK0AyACKALUAg0AIAJBADoAuAMLIAJBATYCpAQgAkIBNwPAAyACQQA6AKgEAkBBxP8AKAIAIgQgAWoiAEEZTwRAIAJBATYCpAQgAkIBNwPAAyACQQA6AKgEDAELIAIgADYCwAMgAkHAA2pBBHIgAyABQeT+ACAEEAggAkHI/wAtAAAgAi0AuANzOgCoBAJAA0AgACIBQQJIDQEgAUF/aiIAQQJ0IAJqKALEA0UNAAsgAiABNgKkBAwBCyACQQE2AqQEIAIoAsQDDQAgAkEAOgCoBAsgAkEAOgDYASACQQE2AtQBIAJCATcDcCACQQE2AmQgAkKBgICAwAA3AwAgAkEAOgBoAkBBxP8AKAIAIgBBAWoiAUEZTwRAIAJBATYC1AEgAkIBNwNwIAJBADoA2AEMAQsgAiABNgJwIAJB8ABqQQRyIAJBBHJBAUHk/gAgABAIIAJByP8ALQAAIAItAGhzOgDYAQJAA0AgASIAQQJIDQEgAEF/aiIBQQJ0IAJqKAJ0RQ0ACyACIAA2AtQBDAELIAJBATYC1AEgAigCdA0AIAJBADoA2AELIAJBATYClAUgAkIBNwOwBCACQQA6AJgFIAJBsARqIAJBwANqIAJB8ABqECkgAkEBNgKEBiACQgE3A6AFIAJBADoAiAYgAkGgBWogAkGwBGpBAUEBEBhB5N8BIAIoAqAFIgE2AgAgAQRAQejfASACQaAFakEEciABQQJ0EAMaC0HI4AEgAigChAYiAzYCAEHM4AEgAi0AiAYiADoAACAAQQFzCyEAIAJBATYCsAMgAkEANgLQAiACQQA6ALQDAkAgAUUEQCACIAA6ALQDIAIgAzYCsAMgAiABNgLAA0GcggIoAgAhAQwBCyACQdACakHo3wEgAUECdCIEEAMaIAIgADoAtAMgAiADNgKwAyACIAE2AsADQZyCAigCACEBIAJBwANqQQRyIAJB0AJqIAQQAxoLIAIgADoAqAQgAiADNgKkBCACQcADaiACQcADaiABEC0gAkEBNgKUBSACQgE3A7AEIAJBADoAmAUgAkEBNgKEBiACQgE3A6AFIAJBADoAiAZBnMgBLQAAIQEgAi0AqAQhAyACQbAEaiACQaAFaiACQcADaiACKAKkBEG0xwFBmMgBKAIAECpBuNsBIAIoArAEIgA2AgAgAiABIANzIgE6AJgFIAAEQEG82wEgAkGwBGpBBHIgAEECdBADGgtBoNwBIAE6AABBnNwBIAIoApQFNgIAIAJB+N4BKAIAIgA2AsADQZyCAigCACEBIAAEQCACQcADakEEckH83gEgAEECdBADGgsgAkHc3wEoAgA2AqQEIAJB4N8BLQAAOgCoBCACQcADaiACQcADaiABEC0gAkEBNgKUBSACQgE3A7AEIAJBADoAmAUgAkEBNgKEBiACQgE3A6AFIAJBADoAiAZBnMgBLQAAIQEgAi0AqAQhAyACQbAEaiACQaAFaiACQcADaiACKAKkBEG0xwFBmMgBKAIAECpBqNwBIAIoArAEIgA2AgAgAiABIANzIgE6AJgFIAAEQEGs3AEgAkGwBGpBBHIgAEECdBADGgtBkN0BIAE6AABBjN0BIAIoApQFNgIACyACQZAGaiQAC9wDAQR/IwBB4ABrIgEkAEGcxgEgAEGoxQEoAgARAgBBzMYBIABBMGpBqMUBKAIAEQIAQaDaAUGQsgFBqMUBKAIAEQIAQdDaAUHAsgFBqMUBKAIAEQIAAkBBnMYBQaDFASgCABEEAARAQczGAUGgxQEoAgARBAANAQsgAUGkxQEoAgARAwAgAUIDNwMAIAEgAUGYtgFBsMUBKAIAEQEAQZXGAS0AAARAIAEgAUHowwFBmLYBQbzFASgCABEAAAsgAUEwakGkxQEoAgARAwBBmMUBKAIAIgRFBEBBASECDAELAkBBnMYBKAIAIAEoAgBHDQBBASEAAkADQCAAIgMgBEYNASADQQFqIQAgA0ECdCICQZzGAWooAgAgASACaigCAEYNAAsgAyAESQ0BC0HMxgEoAgAgASgCMEcNAEEBIQADQCAEIAAiA0YEQEEBIQIMAwsgA0EBaiEAIANBAnQiAkHMxgFqKAIAIAEgAmooAjBGDQALQQEhAiADIARPDQELQQIhAgtBkIICIAI2AgBByO4BQQE2AgBB5O0BQgE3AgBBmIICQQA2AgBBiIICQQA2AgBBlIICQQA6AABBzO4BQQA6AABB+IECQQA2AgBB/IECQQA2AgAgAUHgAGokAAuYDQIIfwJ+IwBB8ANrIgEkAAJAQZjFASgCAEECdEGUtgFqKAIAQYCAgIAETwRAIABBADoAAAwBC0GIxgEoAgBFBEBBiMYBQZsBQZwBQYDGASgCAEEBRhs2AgALQYjFASgCAEUEQEGIxQFBnQE2AgALQYzFASgCAEUEQEGMxQFBngE2AgALQYDGASgCACECQZDFASgCAEUEQEGQxQFBnwFBoAEgAkEBRhs2AgALAkAgAkEBRgRAIAFB0AFqQYjDAUGoxQEoAgARAgAMAQsgAUHQAWpBpMUBKAIAEQMAIAJFDQAgASACrCIJIAlCP4ciCXwgCYU3A9ABIAJBf0wEQCABQdABaiABQdABakGYtgFBsMUBKAIAEQEAC0GVxgEtAABFDQAgAUHQAWogAUHQAWpB6MMBQZi2AUG8xQEoAgARAAALIAFBgAJqQYjDAUGoxQEoAgARAgBBASEDIAFBATYCxAEgAUIBNwNgIAFBADoAyAEgAUHgAGpByLYBQQFBARAYIAFBATYClAMgAUIBNwOwAiABIAEtAMgBIgY6AJgDIAFBsAJqQQRyIQcCQAJAAkAgASgCxAEiBUEYTQRAIAEgBTYCsAIgBQRAQgAhCSAFIQIDQCABIAJBf2oiA0ECdCIEaiABIARqNQJkIAlCIIaEIglCBoAiCj4CtAIgCSAKQgZ+fSEJIAJBAUohBCADIQIgBA0ACwsCQANAIAUiAkECSA0BIAJBf2oiBUECdCABaigCtAJFDQALIAEgAjYClAMMAgtBASECIAFBATYClAMgASgCtAINAUEAIQQgAUEAOgCYA0EBIQMMAgsgAUEBNgKUAyABQgE3A7ACIAFBADoAmAMMAQsCQCAGBEBBASEDIAJBAUcNAUEAIQQgASgCtAINAQwCC0EBIQNBACEEIAJBAUYNAQsgBkEARyEEIAJBAkkEQCACIQMMAQtBjIICKAIAIgNFBEAgAiEDDAELQbDhASABQdABaiAHIAIgBEEAIAMRCAAMAQtBsOEBIAFB0AFqIAcgAyAEEH8LIAFBsAJqQbDhAUGw4QFBiMUBKAIAEQEAIAFB4ABqIAFBsAJqQZi2AUHsxQEoAgARAQAgAUGQAWoiAiABQZADaiIDQZi2AUHsxQEoAgARAQBBkOIBIAFB4ABqQajFASgCABECAEHA4gEgAkGoxQEoAgARAgAgAUGwAmpBkOIBQbDhAUGIxQEoAgARAQAgAUHgAGogAUGwAmpBmLYBQezFASgCABEBACACIANBmLYBQezFASgCABEBAEHw4gEgAUHgAGpBqMUBKAIAEQIAQaDjASACQajFASgCABECACABQbACakHw4gFBsOEBQYjFASgCABEBACABQeAAaiABQbACakGYtgFB7MUBKAIAEQEAIAIgA0GYtgFB7MUBKAIAEQEAQdDjASABQeAAakGoxQEoAgARAgBBgOQBIAJBqMUBKAIAEQIAIAFBsAJqQdDjAUGw4QFBiMUBKAIAEQEAIAFB4ABqIAFBsAJqQZi2AUHsxQEoAgARAQAgAiADQZi2AUHsxQEoAgARAQBBsOQBIAFB4ABqQajFASgCABECAEHg5AEgAkGoxQEoAgARAgAgAUGwAmpBsOEBQajFASgCABECACABQeACaiIFQeDhAUGoxQEoAgARAgBBsOEBQZDiAUGoxQEoAgARAgBB4OEBQcDiAUGoxQEoAgARAgBBkOIBQdDjAUGoxQEoAgARAgBBwOIBQYDkAUGoxQEoAgARAgBB0OMBQfDiAUGoxQEoAgARAgBBgOQBQaDjAUGoxQEoAgARAgBB8OIBIAFBsAJqQajFASgCABECAEGg4wEgBUGoxQEoAgARAgAgAUEwaiEGQQAhBANAIAFB4ABqIARB4ABsIgVBsOEBaiIHQajFASgCABECACACIAVB4OEBakGoxQEoAgARAgBBtLcBKAIAQQNGBEAgAiACQZi2AUGwxQEoAgARAQALIAFBsAJqIAFB4ABqIAdBiMUBKAIAEQEAIAVBoOUBaiIIIAFBsAJqQZi2AUHsxQEoAgARAQAgBUHQ5QFqIANBmLYBQezFASgCABEBACABQbACaiAHIAhBiMUBKAIAEQEAIAEgAUGwAmpBmLYBQezFASgCABEBACAGIANBmLYBQezFASgCABEBACAFQZDpAWogAUGoxQEoAgARAgAgBUHA6QFqIAZBqMUBKAIAEQIAIARBAWoiBEEFRw0ACyAAQQE6AAALIAFB8ANqJAALlw8BAX8jAEEgayIAJAAgAELiADcCFCAAQcDNADYCEEGQmwEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBo84ANgIQQcCbASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEGGzwA2AhBB8JsBIABBD2ogAEEQakEAEAQgAELiADcCFCAAQejPADYCEEGgnAEgAEEPaiAAQRBqQQAQBCAAQuEANwIUIABBy9AANgIQQdCcASAAQQ9qIABBEGpBABAEIABC4gA3AhQgAEGt0QA2AhBBgJ0BIABBD2ogAEEQakEAEAQgAELhADcCFCAAQZDSADYCEEGwnQEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABB8tIANgIQQeCdASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEHV0wA2AhBBkJ4BIABBD2ogAEEQakEAEAQgAELiADcCFCAAQbfUADYCEEHAngEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBmtUANgIQQfCeASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEH91QA2AhBBoJ8BIABBD2ogAEEQakEAEAQgAELhADcCFCAAQd/WADYCEEHQnwEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBwdcANgIQQYCgASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEGk2AA2AhBBsKABIABBD2ogAEEQakEAEAQgAELhADcCFCAAQYbZADYCEEHgoAEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABB6NkANgIQQZChASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEHL2gA2AhBBwKEBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQa3bADYCEEHwoQEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBj9wANgIQQaCiASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEHy3AA2AhBB0KIBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQdTdADYCEEGAowEgAEEPaiAAQRBqQQAQBCAAQgM3AhQgAEG23gA2AhBBsKMBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQbreADYCEEHgowEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBnN8ANgIQQZCkASAAQQ9qIABBEGpBABAEIABC4AA3AhQgAEH/3wA2AhBBwKQBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQeDgADYCEEHwpAEgAEEPaiAAQRBqQQAQBCAAQuEANwIUIABBwuEANgIQQaClASAAQQ9qIABBEGpBABAEIABC4gA3AhQgAEGk4gA2AhBB0KUBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQYfjADYCEEGApgEgAEEPaiAAQRBqQQAQBCAAQuEANwIUIABB6eMANgIQQbCmASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEHL5AA2AhBB4KYBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQa3lADYCEEGQpwEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBj+YANgIQQcCnASAAQQ9qIABBEGpBABAEIABC4gA3AhQgAEHy5gA2AhBB8KcBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQdXnADYCEEGgqAEgAEEPaiAAQRBqQQAQBCAAQuEANwIUIABBt+gANgIQQdCoASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEGZ6QA2AhBBgKkBIABBD2ogAEEQakEAEAQgAELiADcCFCAAQfvpADYCEEGwqQEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABB3uoANgIQQeCpASAAQQ9qIABBEGpBABAEIABC4gA3AhQgAEHB6wA2AhBBkKoBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQaTsADYCEEHAqgEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBhu0ANgIQQfCqASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEHp7QA2AhBBoKsBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQcvuADYCEEHQqwEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBre8ANgIQQYCsASAAQQ9qIABBEGpBABAEIABC4gA3AhQgAEGQ8AA2AhBBsKwBIABBD2ogAEEQakEAEAQgAELiADcCFCAAQfPwADYCEEHgrAEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABB1vEANgIQQZCtASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEG58gA2AhBBwK0BIABBD2ogAEEQakEAEAQgAELhADcCFCAAQZvzADYCEEHwrQEgAEEPaiAAQRBqQQAQBCAAQuEANwIUIABB/fMANgIQQaCuASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEHf9AA2AhBB0K4BIABBD2ogAEEQakEAEAQgAELhADcCFCAAQcH1ADYCEEGArwEgAEEPaiAAQRBqQQAQBCAAQgM3AhQgAEG23gA2AhBBsK8BIABBD2ogAEEQakEAEAQgAEEgaiQAC+EGAQF/IwBBIGsiACQAIABC4QA3AhQgAEH3wQA2AhBBsI4BIABBD2ogAEEQakEAEARB4I4BQbCOAUGoxQEoAgARAgBBkI8BQaTFASgCABEDACAAQuIANwIUIABB2cIANgIQQcCPASAAQQ9qIABBEGpBABAEIABC4gA3AhQgAEG8wwA2AhBB8I8BIABBD2ogAEEQakEAEAQgAELhADcCFCAAQZ/EADYCEEGgkAEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBgcUANgIQQdCQASAAQQ9qIABBEGpBABAEQYCRAUGkxQEoAgARAwBBsJEBQaTFASgCABEDACAAQuIANwIUIABB5MUANgIQQeCRASAAQQ9qIABBEGpBABAEQZCSAUGkxQEoAgARAwBBkJIBQgw3AgBBlcYBLQAABEBBkJIBQZCSAUHowwFBmLYBQbzFASgCABEAAAsgAELiADcCFCAAQcfGADYCEEHAkgEgAEEPaiAAQRBqQQAQBEHwkgFBiMMBQajFASgCABECAEGgkwFBpMUBKAIAEQMAIABC4gA3AhQgAEGqxwA2AhBB0JMBIABBD2ogAEEQakEAEARBgJQBQdCTAUGoxQEoAgARAgBBsJQBQaTFASgCABEDACAAQuEANwIUIABBjcgANgIQQeCUASAAQQ9qIABBEGpBABAEIABC4gA3AhQgAEHvyAA2AhBBkJUBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQdLJADYCEEHAlQEgAEEPaiAAQRBqQQAQBCAAQuIANwIUIABBtMoANgIQQfCVASAAQQ9qIABBEGpBABAEQaCWAUGkxQEoAgARAwAgAELiADcCFCAAQZfLADYCEEHQlgEgAEEPaiAAQRBqQQAQBEGAlwFB0JYBQajFASgCABECAEGwlwFBpMUBKAIAEQMAIABC4gA3AhQgAEH6ywA2AhBB4JcBIABBD2ogAEEQakEAEARBkJgBQaTFASgCABEDAEGQmAFCEjcCAEGVxgEtAAAEQEGQmAFBkJgBQejDAUGYtgFBvMUBKAIAEQAACyAAQuIANwIUIABB3cwANgIQQcCYASAAQQ9qIABBEGpBABAEQfCYAUGIwwFBqMUBKAIAEQIAQaCZAUGkxQEoAgARAwAgAEEgaiQAC9YFAQ1/IwBBMGsiBCABKAIsQQF0IAEoAigiBUEfdnI2AiwgBCAFQQF0IAEoAiQiBUEfdnI2AiggBCAFQQF0IAEoAiAiBUEfdnI2AiQgBCAFQQF0IAEoAhwiBUEfdnI2AiAgBCAFQQF0IAEoAhgiBUEfdnI2AhwgBCAFQQF0IAEoAhQiBUEfdnI2AhggBCAFQQF0IAEoAhAiB0EfdnIiBTYCFCAEIAdBAXQgASgCDCIIQR92ciIHNgIQIAQgCEEBdCABKAIIIglBH3ZyIgg2AgwgBCAJQQF0IAEoAgQiCkEfdnIiCTYCCCAEIAEoAgAiA0EBdCIBNgIAIAQgCkEBdCADQR92ciIKNgIEIAAgASACKAIAIgNrNgIAIAAgCiACKAIEIgYgASADSWoiA2s2AgQgACAJIAMgBkkgCiADSWoiBiACKAIIaiIDazYCCCAAIAggAyAGSSAJIANJaiIGIAIoAgxqIgNrNgIMIAAgByADIAZJIAggA0lqIgYgAigCEGoiA2s2AhAgACAFIAMgBkkgByADSWoiCyACKAIUaiIDazYCFCAAIAQoAhgiBiADIAtJIAUgA0lqIgwgAigCGGoiA2s2AhggACAEKAIcIgsgAyAMSSAGIANJaiINIAIoAhxqIgNrNgIcIAAgBCgCICIMIAMgDUkgCyADSWoiDiACKAIgaiIDazYCICAAIAQoAiQiDSADIA5JIAwgA0lqIg8gAigCJGoiA2s2AiQgACAEKAIoIg4gAyAPSSANIANJaiIPIAIoAihqIgNrNgIoIAAgBCgCLCIEIAMgD0kgDiADSWoiAyACKAIsaiICazYCLCACIANJQX9BACAEIAJJG0cEQCAAIAQ2AiwgACAONgIoIAAgDTYCJCAAIAw2AiAgACALNgIcIAAgBjYCGCAAIAU2AhQgACAHNgIQIAAgCDYCDCAAIAk2AgggACAKNgIEIAAgATYCAAsLlgwCBX8CfiMAQSBrIgAkAEHwhgFBpMUBKAIAEQMAQaCHAUGkxQEoAgARAwBBoIcBQvABNwIAQZXGAS0AAARAQaCHAUGghwFB6MMBQZi2AUG8xQEoAgARAAALQdCHAUGkxQEoAgARAwBB0IcBQvQHNwIAQZXGAS0AAARAQdCHAUHQhwFB6MMBQZi2AUG8xQEoAgARAAALQYCIAUGkxQEoAgARAwBBgIgBQvQHNwIAQZXGAS0AAARAQYCIAUGAiAFB6MMBQZi2AUG8xQEoAgARAAALQYjXAUGkxQEoAgARAwBBvNcBQaTFASgCABEDAEG81wFCBDcCAEGVxgEtAAAEQEG81wFBvNcBQejDAUGYtgFBvMUBKAIAEQAAC0HwgQJBADYCAEHw1wFBpMUBKAIAEQMAQaDYAUGkxQEoAgARAwBB1NgBQaTFASgCABEDAEHU2AFCBDcCAEGVxgEtAAAEQEHU2AFB1NgBQejDAUGYtgFBvMUBKAIAEQAAC0GE2QFBpMUBKAIAEQMAQYTZAUIENwIAQZXGAS0AAARAQYTZAUGE2QFB6MMBQZi2AUG8xQEoAgARAAALQfSBAkEANgIAQYSGAUHItgEoAgAiATYCACABBEADQCACQQJ0IgNBhIYBaiADQcy2AWooAgA2AgQgAkEBaiICIAFHDQALC0HohgFBrLcBKAIAIgE2AgBB7IYBQbC3AS0AADoAAAJAIAFBAXQiAkEZTwRAQeiGAUEBNgIAQYSGAUIBNwIAQeyGAUEAOgAADAELQYSGASACNgIAQYiGAUGIhgEgAUGIhgEgARAIQeyGAUEAOgAAAkADQCACIgFBAkgNASABQX9qIgJBAnRBhIYBaigCBEUNAAtB6IYBIAE2AgAMAQtB6IYBQQE2AgBBiIYBKAIADQBB7IYBQQA6AAALQYSGAUGEhgFBCUEBEBgCQEHohgEoAgAiAUEYTQRAQYSGASABNgIAIAEEQCABIQIDQCACQX9qIgNBAnRBhIYBaiIEIAQ1AgQiBSAGQiCGhEIEiD4CBCAFQg+DIQYgAkEBSiEEIAMhAiAEDQALCwJAA0AgASICQQJIDQEgAkF/aiIBQQJ0QYSGAWooAgRFDQALQeiGASACNgIADAILQeiGAUEBNgIAQYiGASgCAA0BQeyGAUEAOgAADAELQeiGAUEBNgIAQYSGAUIBNwIAQeyGAUEAOgAAC0GwiAFBiMMBQajFASgCABECAEHgiAFBpMUBKAIAEQMAQZCJAUGkxQEoAgARAwBBwIkBQYjDAUGoxQEoAgARAgAgAELhADcCFCAAQfQ6NgIQQfCJASAAQQ9qIABBEGpBABAEQaCKAUHwiQFBqMUBKAIAEQIAQdCKAUHwiQFBqMUBKAIAEQIAQYCLAUHQigFBmLYBQbDFASgCABEBACAAQuEANwIUIABB1js2AhBBsIsBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQbg8NgIQQeCLASAAQQ9qIABBEGpBABAEQZCMAUHgiwFBmLYBQbDFASgCABEBAEHAjAFBsIsBQajFASgCABECACAAQuEANwIUIABBmj02AhBB8IwBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQfw9NgIQQaCNASAAQQ9qIABBEGpBABAEQdCNAUGgjQFBmLYBQbDFASgCABEBAEGAjgFB8IwBQajFASgCABECABCNAiAAQuAANwIUIABB3j42AhBB0JkBIABBD2ogAEEQakEAEAQgAELiADcCFCAAQb8/NgIQQYCaASAAQQ9qIABBEGpBABAEIABC4QA3AhQgAEGiwAA2AhBBsJoBIABBD2ogAEEQakEAEAQgAELhADcCFCAAQYTBADYCEEHgmgEgAEEPaiAAQRBqQQAQBEHIsAFBADoAAEHgrwFBGDYCAEHMsAFBCzYCAAJAQciwAUHkrwFBGEHmwQBBEEEQEB8iAkUNAAJAA0AgAiIBQQJIDQEgAUF/aiICQQJ0QeSvAWooAgBFDQALQcSwASABNgIADAELQcSwAUEBNgIAQeSvASgCAA0AQciwAUEAOgAACxCMAiAAQSBqJAALzQIBAn8gAigCICEDIABBATYCZCAAQQE2AgAgACADQR92OgBoIAAgAyADQR91IgRqIARzNgIEIAAgARA0IAAgACACKAIcIgMgA0EfdSIEaiAEcyADQR92EBggACABEDQgACAAIAIoAhgiAyADQR91IgRqIARzIANBH3YQGCAAIAEQNCAAIAAgAigCFCIDIANBH3UiBGogBHMgA0EfdhAYIAAgARA0IAAgACACKAIQIgMgA0EfdSIEaiAEcyADQR92EBggACABEDQgACAAIAIoAgwiAyADQR91IgRqIARzIANBH3YQGCAAIAEQNCAAIAAgAigCCCIDIANBH3UiBGogBHMgA0EfdhAYIAAgARA0IAAgACACKAIEIgMgA0EfdSIEaiAEcyADQR92EBggACABEDQgACAAIAIoAgAiACAAQR91IgFqIAFzIABBH3YQGAuHBAECfyMAQaABayIDJAAgARAiIQQgA0EANgJ4IAMgBDYCdCADIAE2AnAgA0E4aiADQQhqIANB8ABqQQAQBCAAIAMoAnhBACADLQAIGyIBQQBHIAEgBEZxIgE6AAACQCABRQ0AIAIQIiEBIANBADYCeCADIAE2AnQgAyACNgJwIANBCGogA0HvAGogA0HwAGpBABAEIAAgAygCeEEAIAMtAG8bIgBBAEcgACABRnEiADoAACAARQ0AQbjZASADQThqQajFASgCABECAEHs2QEgA0EIakGoxQEoAgARAgBB2IECAn9BAEG42QFBoMUBKAIAEQQADQAaIANB8ABqQaTFASgCABEDACADQgM3A3AgA0HwAGogA0HwAGpBmLYBQbDFASgCABEBAEGVxgEtAAAEQCADQfAAaiADQfAAakHowwFBmLYBQbzFASgCABEAAAtBAUGYxQEoAgAiAkUNABpBuNkBKAIAIAMoAnBGBEBBASEAA0BBASACIAAiAUYNAhogAUEBaiEAIAFBAnQiBEG42QFqKAIAIANB8ABqIARqKAIARg0AC0EBIAEgAk8NARoLQQILNgIAQdjtAUEBNgIAQfTsAUIBNwIAQeyBAkEANgIAQdyBAkEANgIAQeCBAkEAOgAAQdztAUEAOgAAQeSBAkEANgIAQeiBAkEANgIACyADQaABaiQAC7ACAEHEgQItAABBAXFFBEBBxP8AQQE2AgBB4P4AQgE3AgBBsIABQQE2AgBBzP8AQgE3AgBBoIEBQQE2AgBBvIABQgE3AgBBjIIBQQE2AgBBqIEBQgE3AgBB2IMBQQE2AgBB9IIBQgE3AgBBxIQBQQE2AgBB4IMBQgE3AgBBtIABQQA6AABByP8AQQA6AABBpIEBQQA6AABBkIIBQQA6AABB3IMBQQA6AABByIQBQQA6AABBtIUBQQA6AABBsIUBQQE2AgBBzIQBQgE3AgBB+IUBQgA3AgBB6IYBQQE2AgBBhIYBQgE3AgBBxLABQQE2AgBB4K8BQgE3AgBBxIECQQE2AgBB7IYBQQA6AABBgIYBQQA6AABByLABQQA6AABB9LMBQQA2AgBBgLUBQQA2AgALC4UBAEHAgQItAABBAXFFBEBB9P4BQQE2AgBBkP4BQgE3AwBB4P8BQQE2AgBB/P4BQgE3AgBBzIACQQE2AgBB6P8BQgE3AwBBuIECQQE2AgBB1IACQgE3AgBBwIECQQE2AgBB5P8BQQA6AABB+P4BQQA6AABB0IACQQA6AABBvIECQQA6AAALC/gBAQJ/IAAgASgCBCICQR90IAEoAgBBAXZyNgIAIAAgASgCCCIDQR90IAJBAXZyNgIEIAAgASgCDCICQR90IANBAXZyNgIIIAAgASgCECIDQR90IAJBAXZyNgIMIAAgASgCFCICQR90IANBAXZyNgIQIAAgASgCGCIDQR90IAJBAXZyNgIUIAAgASgCHCICQR90IANBAXZyNgIYIAAgASgCICIDQR90IAJBAXZyNgIcIAAgASgCJCICQR90IANBAXZyNgIgIAAgASgCKCIDQR90IAJBAXZyNgIkIAAgASgCLCIBQQF2NgIsIAAgAUEfdCADQQF2cjYCKAvJAwBBgP4BLQAAQQFxRQRAQaTxAUEBNgIAQcDwAUIBNwMAQZDyAUEBNgIAQazxAUIBNwIAQfzyAUEBNgIAQZjyAUIBNwMAQejzAUEBNgIAQYTzAUIBNwIAQdT0AUEBNgIAQfDzAUIBNwMAQcD1AUEBNgIAQdz0AUIBNwIAQZTyAUEAOgAAQajxAUEAOgAAQYDzAUEAOgAAQezzAUEAOgAAQdj0AUEAOgAAQcT1AUEAOgAAQbD2AUEAOgAAQaz2AUEBNgIAQcj1AUIBNwMAQZj3AUEBNgIAQbT2AUIBNwIAQYT4AUEBNgIAQaD3AUIBNwMAQfD4AUEBNgIAQYz4AUIBNwIAQdz5AUEBNgIAQfj4AUIBNwMAQcj6AUEBNgIAQeT5AUIBNwIAQZz3AUEAOgAAQYj4AUEAOgAAQfT4AUEAOgAAQeD5AUEAOgAAQcz6AUEAOgAAQbj7AUEAOgAAQbT7AUEBNgIAQdD6AUIBNwMAQaT8AUEAOgAAQaD8AUEBNgIAQbz7AUIBNwIAQZD9AUEAOgAAQYz9AUEBNgIAQaj8AUIBNwMAQfz9AUEAOgAAQfj9AUEBNgIAQZT9AUIBNwIAQYD+AUEBNgIACwuFAQBB0OABLQAAQQFxRQRAQYTeAUEBNgIAQaDdAUIBNwMAQfDeAUEBNgIAQYzeAUIBNwIAQdzfAUEBNgIAQfjeAUIBNwMAQcjgAUEBNgIAQeTfAUIBNwIAQdDgAUEBNgIAQfTeAUEAOgAAQYjeAUEAOgAAQeDfAUEAOgAAQczgAUEAOgAACwuOAwBBhNcBLQAAQQFxRQRAQazNAUEBNgIAQcjMAUIBNwIAQZjOAUEBNgIAQbTNAUIBNwIAQYzPAUIANwIAQYTPAUEBNgIAQaDOAUIBNwIAQZzOAUEAOgAAQbDNAUEAOgAAQYjPAUEAOgAAQZTPAUEAOgAAQZjPAUEAQawEEBZBgMcBQgA3AgBBiMcBQgA3AgBBkMcBQgA3AgBBmMcBQgA3AgBBoMcBQgA3AgBBqMcBQgA3AgBBmMgBQQE2AgBBtMcBQgE3AgBBjMkBQQE2AgBBqMgBQgE3AgBB+MkBQQE2AgBBlMkBQgE3AgBBnMgBQQA6AABBsMcBQQA2AgBBkMkBQQA6AABBpMgBQQA7AQBBoMgBQQA2AgBB/MkBQQA6AABBgMoBQQA2AgBB7MoBQQA6AABB6MoBQQE2AgBBhMoBQgE3AgBB1MsBQQE2AgBB8MoBQgE3AgBBwMwBQQE2AgBB3MsBQgE3AgBB2MsBQQA6AABBxMwBQQA6AABBxNMBQQBBvwMQFkGE1wFBATYCAAsLjgMAQZjGAS0AAEEBcUUEQEHAvAFBATYCAEHcuwFCATcCAEGsvQFBATYCAEHIvAFCATcCAEGgvgFCADcCAEGYvgFBATYCAEG0vQFCATcCAEGwvQFBADoAAEHEvAFBADoAAEGcvgFBADoAAEGovgFBADoAAEGsvgFBAEGsBBAWQZS2AUIANwIAQZy2AUIANwIAQaS2AUIANwIAQay2AUIANwIAQbS2AUIANwIAQby2AUIANwIAQay3AUEBNgIAQci2AUIBNwIAQaC4AUEBNgIAQby3AUIBNwIAQYy5AUEBNgIAQai4AUIBNwIAQbC3AUEAOgAAQcS2AUEANgIAQaS4AUEAOgAAQbi3AUEAOwEAQbS3AUEANgIAQZC5AUEAOgAAQZS5AUEANgIAQYC6AUEAOgAAQfy5AUEBNgIAQZi5AUIBNwIAQei6AUEBNgIAQYS6AUIBNwIAQdS7AUEBNgIAQfC6AUIBNwIAQey6AUEAOgAAQdi7AUEAOgAAQdjCAUEAQb8DEBZBmMYBQQE2AgALCzsAIABBhLUBQajFASgCABECACAAQTBqQbS1AUGoxQEoAgARAgAgAEHgAGpB5LUBQajFASgCABECAEEACw8AQQAgACABEJMBQQFzawtwAQV/AkACQEGYxQEoAgAiA0UNACAAKAIAQYjDASgCAEcNAUEBIQQDQCAEIgEgA0YNASABQQFqIQQgACABQQJ0IgVqKAIAIAVBiMMBaigCAEYNAAsgASADSQ0BCyAAQTBqQaDFASgCABEEACECCyACCyUBAX8gAEGgxQEoAgARBAAEfyAAQTBqQaDFASgCABEEAAVBAAsLrAEBBX9BmMUBKAIAIgNFBEBBAQ8LAkAgACgCACABKAIARw0AQQEhBAJAA0AgBCICIANGDQEgAkEBaiEEIAAgAkECdCIGaigCACABIAZqKAIARg0ACyACIANJDQELIAAoAjAgASgCMEcNAEEBIQQDQAJAIAMgBCICRgRAIAMhAgwBCyACQQFqIQQgACACQQJ0IgVqKAIwIAEgBWooAjBGDQELCyACIANPIQULIAULHQAgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwALlQEAAkAgASgCAA0AIAEoAgQNACABKAIIDQAgASgCDA0AIAEoAhANACABKAIUDQAgASgCGA0AIAEoAhwNACABKAIgDQAgASgCJA0AIAEoAigNACABKAIsDQAgACABRwRAIABCADcCACAAQgA3AiggAEIANwIgIABCADcCGCAAQgA3AhAgAEIANwIICw8LIAAgAiABEC4aC3oBAn8jAEEgayIDJAAgA0EANgIYIAMgATYCFCADIAA2AhAgAkEwaiIAIAJBzIECLQAAIgEbIANBD2ogA0EQakGABBAXIAMtAA8EQCACIAAgARsgA0EPaiADQRBqQYAEEBcgAygCGEEAIAMtAA8bIQQLIANBIGokACAEC3oBAn8jAEEgayIDJAAgA0EANgIYIAMgAjYCFCADIAE2AhAgAEEwaiIBIABBzIECLQAAIgIbIANBD2ogA0EQakGABBAEIAMtAA8EQCAAIAEgAhsgA0EPaiADQRBqQYAEEAQgAygCGEEAIAMtAA8bIQQLIANBIGokACAEC84BAQN/AkACQEH4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f2oiA0ECdGooAgBFDQALIAdBAUsNAQtBASEHIAVBCGogBUEIaiAGKAIAQQAQPQ0CDAELIAdBAnRBCUkNAEHkgQIoAgAiA0UNACAFQQhqIAVBCGogBiAHQQBBACADEQgADAELIAVBCGogBUEIaiAGIAdBABA3CyACIAhBkAFsaiEDAkACQAJAAkBB7IECKAIADgMAAQIDCyAFQQhqIAVBCGogAxAODAILIAVBCGogBUEIaiADEA0MAQsgBUEIaiAFQQhqIAMQDAsgCEF/aiEDIAhBAEoNAAsLIAEgBUEIakGoxQEoAgARAgAgAUEwaiAJQajFASgCABECACABQeAAaiAKQajFASgCABECACAAQQE6AAAMAQsgAEEAOgAACyAFQdABaiQACzkBAX8jAEEQayIEJAAgBEEPaiAAIAEgAiADEL0CIAQtAA8hACAEQRBqJAAgAEEYdEGAgIB4akEYdQu5AQEDfyMAQSBrIgQkAEF/IQUCQAJAAkAgAg4CAgEAC0EAIQUgBCACQQV0IAFqQWBqQZTWASgCABECACACQQJOBEAgAkF+aiECA0AgBCAEIANBhMcBQajWASgCABEAACAEIAQgASACQQV0akGExwFBoNYBKAIAEQAAIAJBAEohBiACQX9qIQIgBg0ACwsgACAEQZTWASgCABECAAwBC0EAIQUgACABQZTWASgCABECAAsgBEEgaiQAIAULrAYBCX8jAEGgBWsiBSQAAkACQAJAAkAgBA4CAAECCyAAQQA6AAAMAgsgASADQajFASgCABECACABQTBqIANBMGpBqMUBKAIAEQIAIAFB4ABqIANB4ABqQajFASgCABECACABQZABaiADQZABakGoxQEoAgARAgAgAUHAAWogA0HAAWpBqMUBKAIAEQIAIAFB8AFqIANB8AFqQajFASgCABECACAAQQE6AAAMAQsgBUGABWogAkGU1gEoAgARAgBBASEGA0AgBUGABWogBUGABWogAiAGQQV0akGExwFBqNYBKAIAEQAAIAZBAWoiBiAERw0ACyAFQYAFakGM1gEoAgARBAAEQCAAQQA6AAAMAQsgBUHgAmpBpMUBKAIAEQMAIAVBkANqIghBpMUBKAIAEQMAIAVBwANqIglBpMUBKAIAEQMAIAVB8ANqIgpBpMUBKAIAEQMAIAVBoARqIgtBpMUBKAIAEQMAIAVB0ARqIgxBpMUBKAIAEQMAAkAgBARAA0AgBUHAAmogAiAHQQV0aiINQZTWASgCABECAEEAIQYDQCAGIAdHBEAgBUEgaiACIAZBBXRqIA1BhMcBQaTWASgCABEAACAFQSBqQYzWASgCABEEAA0EIAVBwAJqIAVBwAJqIAVBIGpBhMcBQajWASgCABEAAAsgBkEBaiIGIARHDQALIAUgBUHAAmpBgMcBQbTWASgCABEBACAFIAUgBUGABWpBhMcBQajWASgCABEAACAFQSBqIAMgB0GgAmxqIAUQXAJAAkACQAJAQZiCAigCAA4DAgEAAwsgBUHgAmogBUHgAmogBUEgahAJDAILIAVB4AJqIAVB4AJqIAVBIGoQCgwBCyAFQeACaiAFQeACaiAFQSBqEAsLIAdBAWoiByAERw0ACwsgASAFQeACakGoxQEoAgARAgAgAUEwaiAIQajFASgCABECACABQeAAaiAJQajFASgCABECACABQZABaiAKQajFASgCABECACABQcABaiALQajFASgCABECACABQfABaiAMQajFASgCABECACAAQQE6AAAMAQsgAEEAOgAACyAFQaAFaiQACzkBAX8jAEEQayIEJAAgBEEPaiAAIAEgAiADEMACIAQtAA8hACAEQRBqJAAgAEEYdEGAgIB4akEYdQuWBwELfyMAQcADayIFJAACQAJAAkACQCAEDgIAAQILIABBADoAAAwCCyABIANBqMUBKAIAEQIAIAFBMGogA0EwakGoxQEoAgARAgAgAUHgAGogA0HgAGpBqMUBKAIAEQIAIABBAToAAAwBCyAFQegCaiACQZTWASgCABECAEEBIQYDQCAFQegCaiAFQegCaiACIAZBBXRqQYTHAUGo1gEoAgARAAAgBkEBaiIGIARHDQALIAVB6AJqQYzWASgCABEEAARAIABBADoAAAwBCyAFQdgBakGkxQEoAgARAwAgBUGIAmoiDEGkxQEoAgARAwAgBUG4AmoiDUGkxQEoAgARAwAgBARAIAVBiAFqIQ4gBUHYAGohDyAFQZADaiELA0AgBUG4AWogAiAIQQV0aiIHQZTWASgCABECAEEAIQYCQAJAAkADQCAGIAhHBEAgBUEoaiACIAZBBXRqIAdBhMcBQaTWASgCABEAACAFQShqQYzWASgCABEEAA0CIAVBuAFqIAVB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+JuRo7Pw2wA3A9ABIARC6/qG2r+19sEfNwPIASAEQp/Y+dnCkdqCm383A8ABIARC0YWa7/rPlIfRADcDuAEgBELx7fT4paf9p6V/NwOwASAEQqvw0/Sv7ry3PDcDqAEgBEK7zqqm2NDrs7t/NwOgASAEQoiS853/zPmE6gA3A5gBIARBADYCECAEQgA3AwggBEHgCDYC2AEgBEEIaiAAIAEgAiADEPMBIQAgBEHgAWokACAACzkBAX8jAEEQayIEJAAgBEEPaiAAIAEgAiADEMQCIAQtAA8hACAEQRBqJAAgAEEYdEGAgIB4akEYdQvnIAEifyMAQeAeayIFJAAgBUGQHGogAUGoxQEoAgARAgAgBUHAHGoiByABQTBqQajFASgCABECACAFQfAcaiABQeAAakGoxQEoAgARAgAgBUGAG2ogA0GoxQEoAgARAgAgBUGwG2oiCSADQTBqQajFASgCABECACAFQeAbaiADQeAAakGoxQEoAgARAgAgBUHgGGogAkGoxQEoAgARAgAgBUGQGWoiCCACQTBqQajFASgCABECACAFQcAZaiIKIAJB4ABqQajFASgCABECACAFQfAZaiIPIAJBkAFqQajFASgCABECACAFQaAaaiIQIAJBwAFqQajFASgCABECACAFQdAaaiIGIAJB8AFqQajFASgCABECACAFQZAcahAwIAVBgBtqEDACQAJAAkBBmIICKAIADgIAAQILIAVB4BhqEEYMAQsgBUHgGGoQRQsCQAJAIBBBoMUBKAIAEQQARQ0AIAZBoMUBKAIAEQQARQ0AIAAgAyAEEIgBDAELIAVBwBZqIAVB4BhqQajFASgCABECACAFQfAWaiIUIAhBqMUBKAIAEQIAIAVBoBdqIhUgCkGoxQEoAgARAgAgBUHQF2oiICAPQajFASgCABECACAFQYAYaiIRIBBBqMUBKAIAEQIAIAVBsBhqIhIgBkGoxQEoAgARAgACQEH8swEtAABFDQACQCAQQaDFASgCABEEAEUNACAGQaDFASgCABEEAEUNACAFQaAUakGkxQEoAgARAwAgBUHQFGpBpMUBKAIAEQMAIAVBgBVqQaTFASgCABEDACAFQbAVakGkxQEoAgARAwAgBUHgFWpBpMUBKAIAEQMAIAVBkBZqQaTFASgCABEDAAwBCyAFQaAUaiAFQeAYakGoxQEo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Ag4CAQACCwNAIAJFDQIgAkF/aiICQQJ0QeT+AGooAgBFDQALDAELAkACQCARQaDFASgCABEEAEUNACASQaDFASgCABEEAEUNACAFQcAWakGkxQEoAgARAwAgFEGkxQEoAgARAwAgFUGkxQEoAgARAwAgIEGkxQEoAgARAwAgEUGkxQEoAgARAwAgEkGkxQEoAgARAwAMAQsgBUHAFmogBUHAFmpBqMUBKAIAEQIAIBQgFEGoxQEoAgARAgAgFSAVQZi2AUGwxQEoAgARAQAgBUHQF2oiASABQZi2AUGwxQEoAgARAQAgESARQajFASgCABECACASIBJBqMUBKAIAEQIACyAAQaACaiIBIAFBmLYBQbDFASgCABEBACAAQdACaiIBIAFBmLYBQbDFASgCABEBACAAQYADaiIBIAFBmLYBQbDFASgCABEBACAAQbADaiIBIAFBmLYBQbDFASgCABEBACAAQeADaiIBIAFBmLYBQbDFASgCABEBACAAQZAEaiIBIAFBmLYBQbDFASgCABEBAAtBuYABLQAADQACQEG0twEoAgBBAUYNACAIIAhBmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACAPIA9BmLYBQbDFASgCABEBAEG0twEoAgBBAUYNACAGIAZBmLYBQbDFASgCABEBAAsgBUGgHWogBUHgGGpB0LABQYjFASgCABEBACAFQeAYaiAFQaAdakGYtgFB7MUBKAIAEQEAIAggBUGAHmoiAkGYtgFB7MUBKAIAEQEAIAVBoB1qIApBsLEBQYjFASgCABEBACAKIAVBoB1qQZi2AUHsxQEoAgARAQAgDyACQZi2AUHsxQEoAgARAQAgBUHgD2ogBUHAFmogBUHgGGoQISAWIBYgB0GYtgFBvMUBKAIAEQAAIBcgFyAHQZi2AUG8xQEoAgARAAAgGCAYIAVBkBxqQZi2AUG8xQEoAgARAAAgGSAZIAVBkBxqQZi2AUG8xQEoAgARAAAgBUHADWogBCADQaACbGoiAUGoxQEoAgARAgAgISABQTBqQajFASgCABECACAiIAFBwAFqIAVBgBtqQZi2AUG8xQEoAgARAAAgIyABQfABaiAFQYAbakGYtgFBvMUBKAIAEQAAICQgAUHgAGogCUGYtgFBvMUBKAIAEQAAICUgAUGQAWogCUGYtgFBvMUBKAIAEQAA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kAFqIAdBmLYBQbzFASgCABEAACAFQcAEaiAFQeAPahAgAkBB2P4ALQAABEAgBUHABGogBUGgC2oQHAwBCyAFQcAEaiAFQaALahAbCyAFIAVBwA1qECACQEHY/gAtAAAEQCAFIAVBgAlqEBwMAQsgBSAFQYAJahAbCyAAIAAgBUHABGoQByAAIAAgBRAHCyAFQcAWaiQACw8AIAAgASACIAMgBBDKAgsLACAAIAEgAhCIAQulEAEOfyMAQaAIayICJAAgAkHABGogAUGoxQEoAgARAgAgAkHwBGoiBCABQTBqQajFASgCABECACACQaAFaiIHIAFB4ABqQajFASgCABECACACQdAFaiIIIAFBkAFqQajFASgCABECACACQYAGaiIJIAFBwAFqQajFASgCABECACACQbAGaiIDIAFB8AFqQajFASgCABECAAJAAkACQEGYggIoAgAOAgABAgsgAkHABGoQRgwBCyACQcAEahBFCwJAAkAgCUGgxQEoAgARBABFDQAgA0GgxQEoAgARBABFDQBB+LMBKAIARQ0BIAJBkARqIQUgAkHgA2ohAyACQbADaiEEIAJBgANqIQcgAkHQAmohCANAIAJBoAJqQYjDAUGoxQEoAgARAgAgCEGkxQEoAgARAwAgB0GkxQEoAgARAwAgBEGkxQEoAgARAwAgA0GkxQEoAgARAwAgBUGkxQEoAgARAwAgACAGQaACbGoiASACQaACakGoxQEoAgARAgAgAUEwaiAIQajFASgCABECACABQeAAaiAHQajFASgCABECACABQZABaiAEQajFASgCABECACABQcABaiADQajFASgCABECACABQfABaiAFQajFASgCABECACAGQQFqIgZB+LMBKAIASQ0ACwwBCyACQaACaiACQcAEakGoxQEoAgARAgAgAkHQAmoiDCAEQajFASgCABECACACQYADaiINIAdBqMUBKAIAEQIAIAJBsANqIg4gCEGoxQEoAgARAgAgAkHgA2oiCiAJQajFASgCABECACACQZAEaiILIANBqMUBKAIAEQIAAkBB/LMBLQAARQ0AAkAgCUGgxQEoAgARBABFDQAgA0GgxQEoAgARBABFDQAgAkGkxQEoAgARAwAgAkEwakGkxQEoAgARAwAgAkHgAGpBpMUBKAIAEQMAIAJBkAFqQaTFASgCABEDACAC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DEEfdiAEIAJJayACIANJa0F/TARAIAAgBDYCHCAAIAU2AhggACAGNgIUIAAgBzYCECAAIAg2AgwgACAJNgIIIAAgCjYCBCAAIAE2AgALC1oBAn8gACABIAIgA0EQIANBEEkbIgRBARCJASADQRFPBEADQCAAIAEgBEGQAWxqIAIgBEGgAmxqIAMgBGsiBUEQIAVBEEkbQQAQiQEgBEEQaiIEIANJDQALCwsLACAAIAEgAhCLAQvbBQECfyMAQYASayICJAAgAkGACWogARAxIAJBgAlqIAJBgAlqEE4gAkHADWogAkGACWoQTiACQcANaiACQcANaiACQYAJahAHIAJBwARqIAJBwA1qEDEgAkHADWogAkHADWogAkHABGoQByACIAJBwARqEE4gAiACEDEgAkHADWogAkHADWogAhAHIAJBoAtqIgMgA0GYtgFBsMUBKAIAEQEAIAJB0AtqIgMgA0GYtgFBsMUBKAIAEQEAIAJBgAxqIgMgA0GYtgFBsMUBKAIAEQEAIAJBsAxqIgMgA0GYtgFBsMUBKAIAEQEAIAJB4AxqIgMgA0GYtgFBsMUBKAIAEQEAIAJBkA1qIgMgA0GYtgFBsMUBKAIAEQEAIAJBgAlqIAJBgAlqIAJBwA1qEAcgAkHABGogAkHABGogAkHADWoQByACQcANaiACQcANahBmIAJBwA1qIAJBwA1qIAJBwARqEAcgAkHADWogAkHADWogARAHIAAgAUcEQCAAIAFBqMUBKAIAEQIAIABBMGogAUEwakGoxQEoAgARAgAgAEHgAGogAUHgAGpBqMUBKAIAEQIAIABBkAFqIAFBkAFqQajFASgCABECACAAQcABaiABQcABakGoxQEoAgARAgAgAEHwAWogAUHwAWpBqMUBKAIAEQIACyAAQaACaiABQaACakGYtgFBsMUBKAIAEQEAIABB0AJqIAFB0AJqQZi2AUGwxQEoAgARAQAgAEGAA2ogAUGAA2pBmLYBQbDFASgCABEBACAAQbADaiABQbADakGYtgFBsMUBKAIAEQEAIABB4ANqIAFB4ANqQZi2AUGwxQEoAgARAQAgAEGQBGogAUGQBGpBmLYBQbDFASgCABEBACAAIAAgAkGACWoQByACQYAJaiACQYAJahAGIAJBwA1qIAJBwA1qIAJBgAlqEAcgACAAEOsBIAAgACACQcANahAHIAJBgBJqJAALnQYBB38jAEHADWsiAiQAIAJBgAlqIAEQMSABIAJBwARqRwRAIAJBwARqIAFBqMUBKAIAEQIAIAJB8ARqIAFBMGpBqMUBKAIAEQIAIAJBoAVqIAFB4ABqQajFASgCABECACACQdAFaiABQZABakGoxQEoAgARAgAgAkGABmogAUHAAWpBqMUBKAIAEQIAIAJBsAZqIAFB8AFqQajFASgCABECAAsgAkHgBmogAUGgAmpBmLYBQbDFASgCABEBACACQZAHaiABQdACakGYtgFBsMUBKAIAEQEAIAJBwAdqIAFBgANqQZi2AUGwxQEoAgARAQAgAkHwB2ogAUGwA2pBmLYBQbDFASgCABEBACACQaAIaiABQeADakGYtgFBsMUBKAIAEQEAIAJB0AhqIAFBkARqQZi2AUGwxQEoAgARAQAgAkGACWogAkGACWogAkHABGoQByACQcAEaiACQYAJahAxIAJBoAtqIgMgA0GYtgFBsMUBKAIAEQEAIAJB0AtqIgQgBEGYtgFBsMUBKAIAEQEAIAJBgAxqIgUgBUGYtgFBsMUBKAIAEQEAIAJBsAxqIgYgBkGYtgFBsMUBKAIAEQEAIAJB4AxqIgcgB0GYtgFBsMUBKAIAEQEAIAJBkA1qIgggCEGYtgFBsMUBKAIAEQEAIAJBgAlqIAJBgAlqIAJBwARqEAcgAkHABGogAkGACWoQMSACQYAJaiACQYAJahAGIAJBgAlqIAJBgAlqIAJBwARqEAcgAkHABGogAkGACWoQMSACQcAEaiACQcAEahAxIAIgAkGACWoQZiADIANBmLYBQbDFASgCABEBACAEIARBmLYBQbDFASgCABEBACAFIAVBmLYBQbDFASgCABEBACAGIAZBmLYBQbDFASgCABEBACAHIAdBmLYBQbDFASgCABEBACAIIAhBmLYBQbDFASgCABEBACACQYAJaiACQYAJaiACQcAEahAHIAJBgAlqIAJBgAlqIAIQByACQcAEaiABEE4gAkHABGogAkHABGogARAHIAAgAkGACWogAkHABGoQByACQcANaiQAC7AFAQx/IAAgAigCACIEIAEoAgBqIgw2AgAgACABKAIEIgYgDCAESWoiCiACKAIEaiIENgIEIAAgBCAKSSAKIAZJaiIHIAEoAghqIgYgAigCCGoiCjYCCCAAIAogBkkgBiAHSWoiCCABKAIMaiIHIAIoAgxqIgY2AgwgACAGIAdJIAcgCElqIgkgASgCEGoiCCACKAIQaiIHNgIQIAAgByAISSAIIAlJaiIFIAEoAhRqIgkgAigCFGoiCDYCFCAAIAggCUkgCSAFSWoiCyABKAIYaiIFIAIoAhhqIgk2AhggACACKAIcIAEoAhxqIAUgC0lqIAkgBUlqIgE2AhwCQCABIAMoAhwiC0kNACAMIAMoAgAiAkkhBSABIAtLBEAgACAMIAJrNgIAIAAgBCADKAIEIgwgBWoiAms2AgQgACAKIAIgDEkgBCACSWoiBCADKAIIaiICazYCCCAAIAYgAiAESSAKIAJJaiIEIAMoAgxqIgJrNgIMIAAgByACIARJIAYgAklqIgQgAygCEGoiAms2AhAgACAIIAIgBEkgByACSWoiBCADKAIUaiICazYCFCAAIAkgAiAESSAIIAJJaiIEIAMoAhhqIgJrNgIYIAAgASADKAIcayAJIAJJayACIARJazYCHA8LIAUgAygCBCIFaiIBIAVJIAQgAUlqIgsgAygCCGoiBSALSSAKIAVJaiINIAMoAgxqIgsgDUkgBiALSWoiDiADKAIQaiINIA5JIAcgDUlqIg8gAygCFGoiDiAPSSAIIA5JaiIPIAMoAhhqIgMgD0lBf0EAIAkgA0kbRw0AIABBADYCHCAAIAkgA2s2AhggACAIIA5rNgIUIAAgByANazYCECAAIAYgC2s2AgwgACAKIAVrNgIIIAAgBCABazYCBCAAIAwgAms2AgALCwkAIAAgARCKAQsSACAAIAEgAhCLASAAIAAQigEL0AoBF38jAEHAFmsiBCQAIARBgBJqQaTFASgCABEDACAEQbASaiIPQaTFASgCABEDACAEQeASaiIQQaTFASgCABEDACAEQZATaiIRQaTFASgCABEDACAEQcATaiISQaTFASgCABEDACAEQfATaiITQaTFASgCABEDACAEQaAUaiIUQaTFASgCABEDACAEQdAUaiIVQaTFASgCABEDACAEQYAVaiIWQaTFASgCABEDACAEQbAVaiIXQaTFASgCABEDACAEQeAVaiIYQaTFASgCABEDACAEQZAWaiIZQaTFASgCABEDACAEQYASakGIwwFBqMUBKAIAEQIAIARBADoAlAYgBEEAOgCAByAEQQE2ApAGIARBADoA7AcgBEEBNgL8BiAEQdgIakEAOgAAIARBATYC6AcgBEHECWpBADoAACAEQdQIakEBNgIAIARBwAlqQQE2AgAgBEGwCmpBADoAACAEQQE2AqQFIARCATcDwAQgBEEAOgCoBSAEQgE3AqwFIARCATcDmAYgBEIBNwKEByAEQgE3A/AHIARCATcC3AggBEGcC2pBADoAACAEQawKakEBNgIAIARBmAtqQQE2AgAgBEGIDGpBADoAACAEQYQMakEBNgIAIARB9AxqQQA6AAAgBEHwDGpBATYCACAEQeANakEAOgAAIARB3A1qQQE2AgAgBEHMDmpBADoAACAEQcgOakEBNgIAIARBuA9qQQA6AAAgBEIBNwPICSAEQgE3ArQKIARCATcDoAsgBEIBNwKMDCAEQgE3A/gMIARCATcC5A0gBEGkEGpBADoAACAEQbQPakEBNgIAIARBkBFqQQA6AAAgBEGgEGpBATYCACAEQfwRakEAOgAAIARBjBFqQQE2AgAgBEH4EWpBATYCACAEQgE3A9AOIARCATcCvA8gBEIBNwOoECAEQgE3ApQRIAMEQCAEQQhqIQwDQCADQRAgA0EQSRsiDUEBIA1BAUsbIRpBACEKA0AgBEGE1gEoAgAiCDYCBCACIApBBXRqIQdBgdcBLQAABEAgDCAHQaTUAUGExwFBqNYBKAIAEQAAIAQoAgQhCCAMIQcLIAQgBzYCACAEQcAEaiAKQewAbGoiBUEAOgBoAkAgCEUEQCAFQQA6AGggBUEBNgIAIAVBATYCZCAFQQA2AgQMAQsgCEH/////A3EiBkEYSw0AIAUgBjYCAAJAIAZFDQBBACELQQAhCSAGQQJ0IAhBAnRJDQADQEEAIQ4gCSAISQRAIAcgCUECdGooAgAhDiAJQQFqIQkLIAUgC0ECdGogDjYCBCALQQFqIgsgBkcNAAsLAkADQCAGIgdBAkgNASAFIAdBf2oiBkECdGooAgRFDQALIAUgBzYCZAwBCyAFQQE2AmQgBSgCBA0AIAVBADoAaAsgCkEBaiIKIBpHDQALIAIgBCABIARBwARqIA1BhIICKAIAEQYAIgZBBXRqIQIgASAGQcAEbGohASAEQYASaiAEQYASaiAEEAcgAyAGayIDDQALCyAAIARBgBJqQajFASgCABECACAAQTBqIA9BqMUBKAIAEQIAIABB4ABqIBBBqMUBKAIAEQIAIABBkAFqIBFBqMUBKAIAEQIAIABBwAFqIBJBqMUBKAIAEQIAIABB8AFqIBNBqMUBKAIAEQIAIABBoAJqIBRBqMUBKAIAEQIAIABB0AJqIBVBqMUBKAIAEQIAIABBgANqIBZBqMUBKAIAEQIAIABBsANqIBdBqMUBKAIAEQIAIABB4ANqIBhBqMUBKAIAEQIAIABBkARqIBlBqMUBKAIAEQIAIARBwBZqJAALDQAgACABIAIgAxDYAgvoDgENfyMAQYCGBmsiBCQAIARB/IUGakEANgIAIARB9P8FakEANgIAIARB7PkFakEANgIAIARB5PMFakEANgIAIARB3O0FakEANgIAIARB1OcFakEANgIAIARBzOEFakEANgIAIARBxNsFakEANgIAIARBvNUFakEANgIAIARBtM8FakEANgIAIARBrMkFakEANgIAIARBpMMFakEANgIAIARBnL0FakEANgIAIARBlLcFakEANgIAIARBjLEFakEANgIAIARBhKsFakEANgIAIARB/KQFakEANgIAIARB9J4FakEANgIAIARB7JgFakEANgIAIARB5JIFakEANgIAIARB3IwFakEANgIAIARB1IYFakEANgIAIARBzIAFakEANgIAIARBxPoEakEANgIAIARBvPQEakEANgIAIARBtO4EakEANgIAIARBrOgEakEANgIAIARBpOIEakEANgIAIARBnNwEakEANgIAIARBlNYEakEANgIAIARBjNAEakEANgIAIARBADYChMoEIARBATYC9AMgBEIBNwOQAyAEQQA6APgDIANBICADQSBJGyINBEAgBEGQA2pBBHIhDyAEQaACakEEciEQIARBCGohDkEBIQhBASEMA0AgBEGE1gEoAgAiCzYCBCACIApBBXRqIQZBgdcBLQAABEAgDiAGQaTUAUGExwFBqNYBKAIAEQAAIAQoAgQhCyAOIQYLIAQgBjYCAAJAAkAgC0UEQEEBIQwgBEEBOgCPAyAEQQA2ApQDIARBATYCoAIgBEGAxARqIApBiAZsaiEDQQEhCAwBCwJAIAtB/////wNxIgVBGU8EQCAEQQA6AI8DDAELIARBAToAjwMCQCAFRQ0AQQAhA0EAIQggBUECdCALQQJ0SQ0AA0BBACEHIAggC0kEQCAGIAhB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QCAFQQA6AGggBUEBNgIAIAVBATYCZCAFQQA2AgQMAQsgCEH/////A3EiBkEYSw0AIAUgBjYCAAJAIAZFDQBBACEMQQAhCiAGQQJ0IAhBAnRJDQADQEEAIQ0gCiAISQRAIAcgCkECdGooAgAhDSAKQQFqIQoLIAUgDEECdGogDTYCBCAMQQFqIgwgBkcNAAsLAkADQCAGIgdBAkgNASAFIAdBf2oiBkECdGooAgRFDQALIAUgBzYCZAwBCyAFQQE2AmQgBSgCBA0AIAVBADoAaAsgCUEBaiIJIANHDQALCyAAIAEgBEGgAmogA0H8gQIoAgARBgAaDAELIARBoAJqQaTFASgCABEDACAEQdACaiIHQaTFASgCABEDACAEQYADaiILQaTFASgCABEDACAEQbADaiIFQaTFASgCABEDACAEQeADaiIIQaTFASgCABEDACAEQZAEaiIJQaTFASgCABEDACADBEADQCAEIAEgAiADENoCIQYCQAJAAkACQEGYggIoAgAOAwABAgMLIARBoAJqIARBoAJqIAQQCwwCCyAEQaACaiAEQaACaiAEEAoMAQsgBEGgAmogBEGgAmogBBAJCyACIAZBBXRqIQIgASAGQaACbGohASADIAZrIgMNAAsLIAAgBEGgAmpBqMUBKAIAEQIAIABBMGogB0GoxQEoAgARAgAgAEHgAGogC0GoxQEoAgARAgAgAEGQAWogBUGoxQEoAgARAgAgAEHAAWogCEGoxQEoAgARAgAgAEHwAWogCUGoxQEoAgARAgALIARB4A9qJAALDQAgACABIAIgAxDbAgv2DgENfyMAQfCEA2siBCQAIARB7IQDakEANgIAIARB5IEDakEANgIAIARB3P4CakEANgIAIARB1PsCakEANgIAIARBzPgCakEANgIAIARBxPUCakEANgIAIARBvPICakEANgIAIARBtO8CakEANgIAIARBrOwCakEANgIAIARBpOkCakEANgIAIARBnOYCakEANgIAIARBlOMCakEANgIAIARBjOACakEANgIAIARBhN0CakEANgIAIARB/NkCakEANgIAIARB9NYCakEANgIAIARB7NMCakEANgIAIARB5NACakEANgIAIARB3M0CakEANgIAIARB1MoCakEANgIAIARBzMcCakEANgIAIARBxMQCakEANgIAIARBvMEC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ABEBACACQZAEaiADQZi2AUHsxQEoAgARAQAgAkGgAmogAkHACmpBkMUBKAIAEQIAIAJBoAJqIAJBoAJqIAJBgAlqQZi2AUHoxQEoAgARAAAgAyADIAJB4AlqQZi2AUHoxQEoAgARAAAgAkHABGoiBiACQaACakGYtgFB7MUBKAIAEQEAIAJB8ARqIANBmLYBQezFASgCABEBACACQaACaiACQYAMaiACQYAGakGYtgFB6MUBKAIAEQAAIAMgAkHgDGogAkHgBmpBmLYBQejFASgCABEAACACQaAFaiIHIAJBoAJqQZi2AUHsxQEoAgARAQAgAkHQBWogA0GYtgFB7MUBKAIAEQEAIAJBoAJqIAYgBUGIxQEoAgARAQAgAkHgAGogByAEQYjFASgCABEBACACQaACaiACQaACaiACQeAAakGYtgFB5MUBKAIAEQAAIAMgAyACQcABaiIEQZi2AUHkxQEoAgARAAAgAkGgAmogAkGgAmpBkMUBKAIAEQIAIAJB4ABqIAJB4ANqIAFBiMUBKAIAEQEAIAJBoAJqIAJBoAJqIAJB4ABqQfjFASgCABEFABogAyADIARB+MUBKAIAEQUAGiACIAJBoAJqQZi2AUHsxQEoAgARAQAgAkEwaiIBIANBmLYBQezFASgCABEBACACQZAQaiACQdTFASgCABECACACQbAPaiABQdTFASgCABECACACQZAQaiACQZAQaiACQbAPakH4xQEoAgARBQAaIAJBgA9qIAJBkBBqQZi2AUHsxQEoAgARAQAgAkGAD2ogAkGAD2pBlLYBQcjFASgCABEBACACIAIgAkGAD2pBmLYBQbzFASgCABEAACABIAEgAkGAD2pBmLYBQbzFASgCABEAACABIAFBmLYBQbDFASgCABEBACACQZAQaiACQeADaiACQYjFASgCABEBACAAIAJBkBBqQZi2AUHsxQEoAgARAQAgAEEwaiACQfAQaiIBQZi2AUHsxQEoAgARAQAgAkGQEGogBiACQYjFASgCABEBACAAQeAAaiACQZAQakGYtgFB7MUBKAIAEQEAIABBkAFqIAFBmLYBQezFASgCABEBACACQZAQaiAHIAJBiMUBKAIAEQEAIABBwAFqIAJBkBBqQZi2AUHsxQEoAgARAQAgAEHwAWogAUGYtgFB7MUBKAIAEQEAIAJB0BFqJAAL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IgQgASgCGGoiA2s2AhggACACKAIcIAEoAhxrIAUgA0lrIAMgBElrNgIcC28BAX8jAEEgayIEJAAgBEEANgIYIAQgAjYCFCAEIAE2AhAgACAEQQ9qIARBEGogAxBbAn9BfyAELQAPRQ0AGiAAQaACaiAEQQ9qIARBEGogAxBbQQAgBC0AD0UgBCgCGEVyawshACAEQSBqJAAgAAu9AQAgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwAgAEHgAGpBpMUBKAIAEQMAIABBkAFqQaTFASgCABEDACAAQcABakGkxQEoAgARAwAgAEHwAWpBpMUBKAIAEQMAIABBoAJqQaTFASgCABEDACAAQdACakGkxQEoAgARAwAgAEGAA2pBpMUBKAIAEQMAIABBsANqQaTFASgCABEDACAAQeADakGkxQEoAgARAwAgAEGQBGpBpMUBKAIAEQMAC5kBAQN/IwBBQGoiAyQAIANBhNYBKAIAIgQ2AgwCQEGB1wEtAAAEQCADQRBqIgUgAkGk1AFBhMcBQajWASgCABEAACADKAIMIQQMAQsgAiEFCyADIAU2AggCQAJAIARBAnRBCUkNAEH4gQIoAgAiAkUNACAAIAEgBSAEQQBBASACEQgADAELIAAgASAFIARBABBHCyADQUBrJAALCgAgACABIAIQXAsKACAAIAEgAhA8Cz8AAkAgACgCAA0AIAAoAgQNACAAKAIIDQAgACgCDA0AIAAoAhANACAAKAIUDQAgACgCGA0AIAAoAhxFDwtBAAs1AAJAAkACQAJAQZiCAigCAA4DAAECAwsgACABIAIQCw8LIAAgASACEAoPCyAAIAEgAhAJCwuaAQAgACABQajFASgCABECACAAQTBqIAFBMGpBqMUBKAIAEQIAIABB4ABqIAFB4ABqQajFASgCABECACAAQZABaiABQZABakGoxQEoAgARAgAgAEHAAWogAUHAAWpBqMUBKAIAEQIAIABB8AFqIAFB8AFqQajFASgCABECAAJAAkACQEGYggIoAgAOAgABAgsgABBGDwsgABBFCwsvAAJAAkACQAJAQZiCAigCAA4DAAECAwsgACABEBEPCyAAIAEQEA8LIAAgARAUCwuJAgEBfwJAIAFBwAFqIgJBoMUBKAIAEQQARQ0AIAFB8AFqQaDFASgCABEEAEUNACAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwAgAEGQAWpBpMUBKAIAEQMAIABBwAFqQaTFASgCABEDACAAQfABakGkxQEoAgARAwAPCyAAIAFBqMUBKAIAEQIAIABBMGogAUEwakGoxQEoAgARAgAgAEHgAGogAUHgAGpBmLYBQbDFASgCABEBACAAQZABaiABQZABakGYtgFBsMUBKAIAEQEAIABBwAFqIAJBqMUBKAIAEQIAIABB8AFqIAFB8AFqQajFASgCABECAAseACAAQgA3AgAgAEIANwIYIABCADcCECAAQgA3AggLUAEBfyMAQSBrIgMkACADIAE2AhQgAyAANgIQIANBADYCGCACIANBD2ogA0EQakGABBCSASADLQAPIQAgAygCGCEBIANBIGokACABQQAgABsLaQECfyMAQSBrIgQkACAEQQA2AhggBCAANgIQIAQgATYCFCACIARBD2ogBEEQaiADEJIBAkAgBCgCGEEAIAQtAA8bIgJFDQAgAiABQX9qRg0AIAAgAmpBADoAACACIQULIARBIGokACAFC8AZAQl/IwBBgAZrIgMkAAJAAkAgAUHAAWoiBEGgxQEoAgARBABFDQAgAUHwAWpBoMUBKAIAEQQARQ0AIAAgAkGoxQEoAgARAgAgAEEwaiACQTBqQajFASgCABECACAAQeAAaiACQeAAakGoxQEoAgARAgAgAEGQAWogAkGQAWpBqMUBKAIAEQIAIABBwAFqIAJBwAFqQajFASgCABECACAAQfABaiACQfABakGoxQEoAgARAgAMAQsCQCACQcABakGgxQEoAgARBABFDQAgAkHwAWpBoMUBKAIAEQQARQ0AIAAgAUGoxQEoAgARAgAgAEEwaiABQTBqQajFASgCABECACAAQeAAaiABQeAAakGoxQEoAgARAgAgAEGQAWogAUGQAWpBqMUBKAIAEQIAIABBwAFqIARBqMUBKAIAEQIAIABB8AFqIAFB8AFqQajFASgCABECAAwBCyABQcABaiEGAkACQAJAAkBBmMUBKAIAIglFDQAgBigCAEGIwwEoAgBGBEBBASEEA0AgBCIFIAlGDQIgBUEBaiEEIAEgBUECdCIHaigCwAEgB0GIwwFqKAIARg0ACyAFIAlPDQELIAJBwAFqIQcMAQsgAkHAAWohByABQfABakGgxQEoAgARBAAhCEGYxQEoAgAiCUUNAQsgAigCwAFBiMMBKAIARw0BQQEhBANAIAQiBSAJRg0BIAVBAWohBCACIAVBAnQiC2ooAsABIAtBiMMBaigCAEYNAAsgBSAJSQ0BCyACQfABakGgxQEoAgARBAAhCgsgCEUEQCADQcAEaiABQfABaiIEQZi2AUHExQEoAgARAQAgA0HABGogA0HABGogBkGYtgFBvMUBKAIAEQAAIANBoAJqIAYgBEGYtgFBtMUBKAIAEQAAIANBwAFqIAYgBEGYtgFBuMUBKAIAEQAAIANBgANqIANBoAJqIANBwAFqQZi2AUG8xQEoAgARAAAgA0GwA2ogA0HABGpBqMUBKAIAEQIACwJAIAoEQCADQaACaiABQajFASgCABECACADQdACaiABQTBqQajFASgCABECAAJAIAgEQCADQeAAaiACQajFASgCABECACADQZABaiACQTBqQajFASgCABECAAwBCyADQcAEaiACIANBgANqQYjFASgCABEBACADQeAAaiADQcAEakGYtgFB7MUBKAIAEQEAIANBkAFqIANBoAVqQZi2AUHsxQEoAgARAQALIANB4ABqIANB4ABqIANBoAJqQZi2AUG4xQEoAgARAAAgA0GQAWoiBCAEIANB0AJqQZi2AUG4xQEoAgARAAAgA0HAAWogAUHgAGpBqMUBKAIAEQIAIANB8AFqIAFBkAFqQajFASgCABECAAwBCyADQcAEaiACQfABaiIEQZi2AUHExQEoAgARAQAgA0HABGogA0HABGogB0GYtgFBvMUBKAIAEQAAIANBoAJqIAcgBEGYtgFBtMUBKAIAEQAAIANB4ABqIAcgBEGYtgFBuMUBKAIAEQAAIANBwAFqIANBoAJqIANB4ABqQZi2AUG8xQEoAgARAAAgA0HwAWogA0HABGpBqMUBKAIAEQIAIANBwARqIAEgA0HAAWpBiMUBKAIAEQEAIANBoAJqIANBwARqQZi2AUHsxQEoAgARAQAgA0HQAmoiBCADQaAFaiIFQZi2AUHsxQEoAgARAQACQCAIBEAgA0HgAGogAkGoxQEoAgARAgAgA0GQAWogAkEwakGoxQEoAgARAgAMAQsgA0HABGogAiADQYADakGIxQEoAgARAQAgA0HgAGogA0HABGpBmLYBQezFASgCABEBACADQZABaiAFQZi2AUHsxQEoAgARAQALIANB4ABqIANB4ABqIANBoAJqQZi2AUG4xQEoAgARAAAgA0GQAWoiBSAFIARBmLYBQbjFASgCABEAACADQcAEaiADQcABaiAHQYjFASgCABEBACADQcABaiADQcAEakGYtgFB7MUBKAIAEQEAIANB8AFqIgQgA0GgBWoiBUGYtgFB7MUBKAIAEQEAIANBwARqIANBwAFqIAFB4ABqQYjFASgCABEBACADQcABaiADQcAEakGYtgFB7MUBKAIAEQEAIAQgBUGYtgFB7MUBKAIAEQEACwJAIAgEQCADQYADaiACQeAAakGoxQEoAgARAgAgA0GwA2ogAkGQAWpBqMUBKAIAEQIADAELIANBwARqIANBgANqIAZBiMUBKAIAEQEAIANBgANqIANBwARqQZi2AUHsxQEoAgARAQAgA0GwA2oiBCADQaAFaiIFQZi2AUHsxQEoAgARAQAgA0HABGogA0GAA2ogAkHgAGpBiMUBKAIAEQEAIANBgANqIANBwARqQZi2AUHsxQEoAgARAQAgBCAFQZi2AUHsxQEoAgARAQALIANBgANqIANBgANqIANBwAFqQZi2AUG4xQEoAgARAAAgA0GwA2oiAiACIANB8AFqQZi2AUG4xQEoAgARAAACQCADQeAAakGgxQEoAgARBABFDQAgA0GQAWpBoMUBKAIAEQQARQ0AAkAgA0GAA2pBoMUBKAIAEQQARQ0AIAJBoMUBKAIAEQQARQ0AIAAgARDuAQwCCyAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwAgAEGQAWpBpMUBKAIAEQMAIABBwAFqQaTFASgCABEDACAAQfABakGkxQEoAgARAwAMAQsCQCAIBEAgCgRAIABBwAFqIANB4ABqQajFASgCABECACAAQfABaiADQZABakGoxQEoAgARAgAMAgsgA0HABGogA0HgAGogB0GIxQEoAgARAQAgAEHAAWogA0HABGpBmLYBQezFASgCABEBACAAQfABaiADQaAFakGYtgFB7MUBKAIAEQEADAELIABBwAFqIQEgCgRAIANBwARqIAYgA0HgAGpBiMUBKAIAEQEAIAEgA0HABGpBmLYBQezFASgCABEBACAAQfABaiADQaAFakGYtgFB7MUBKAIAEQEADAELIANBwARqIAYgB0GIxQEoAgARAQAgASADQcAEakGYtgFB7MUBKAIAEQEAIABB8AFqIgIgA0GgBWoiBEGYtgFB7MUBKAIAEQEAIANBwARqIAEgA0HgAGpBiMUBKAIAEQEAIAEgA0HABGpBmLYBQezFASgCABEBACACIARBmLYBQezFASgCABEBAAsgA0HABGogA0GQAWoiAUGYtgFBxMUBKAIAEQEAIANBwARqIANBwARqIANB4ABqQZi2AUG8xQEoAgARAAAgA0GQBGogA0HgAGogAUGYtgFBtMUBKAIAEQAAIANB4ANqIANB4ABqIAFBmLYBQbjFASgCABEAACADIANBkARqIANB4ANqQZi2AUG8xQEoAgARAAAgA0EwaiIFIANBwARqQajFASgCABECACADQcAEaiADQbADaiIBQZi2AUHExQEoAgARAQAgA0HABGogA0HABGogA0GAA2pBmLYBQbzFASgCABEAACADQZAEaiADQYADaiABQZi2AUG0xQEoAgARAAAgA0HgA2ogA0GAA2ogAUGYtgFBuMUBKAIAEQAAIABB4ABqIgEgA0GQBGogA0HgA2pBmLYBQbzFASgCABEAACAAQZABaiICIANBwARqQajFASgCABECACADQcAEaiADQaACaiADQYjFASgCABEBACADQaACaiADQcAEakGYtgFB7MUBKAIAEQEAIANB0AJqIgQgA0GgBWoiBkGYtgFB7MUBKAIAEQEAIANBwARqIAMgA0HgAGpBiMUBKAIAEQEAIAMgA0HABGpBmLYBQezFASgCABEBACAFIAZBmLYBQezFASgCABEBACABIAEgA0GgAmpBmLYBQbjFASgCABEAACACIAIgBEGYtgFBuMUBKAIAEQAAIAEgASADQaACakGYtgFBuMUBKAIAEQAAIAIgAiAEQZi2AUG4xQEoAgARAAAgACABIANBmLYBQbjFASgCABEAACAAQTBqIgcgAiAFQZi2AUG4xQEoAgARAAAgA0GgAmogA0GgAmogAEGYtgFBuMUBKAIAEQAAIAQgBCAHQZi2AUG4xQEoAgARAAAgA0HABGogA0GgAmogA0GAA2pBiMUBKAIAEQEAIANBoAJqIANBwARqQZi2AUHsxQEoAgARAQAgBCAGQZi2AUHsxQEoAgARAQAgA0HABGogAyADQcABakGIxQEoAgARAQAgAyADQcAEakGYtgFB7MUBKAIAEQEAIAUgBkGYtgFB7MUBKAIAEQEAIAEgA0GgAmogA0GYtgFBuMUBKAIAEQAAIAIgBCAFQZi2AUG4xQEoAgARAAALIANBgAZqJAALqgIBAX8jAEHQAmsiAyQAIANBEGpBgAIgASACQbP8ABByQQAhAQNAIAMgAWsgA0EQaiABai0AADoAzwIgAUEBaiIBQcAARw0ACyAAIANBD2ogA0GQAmpBwAAQNSADQdAAaiECQQAhAQNAIAMgAWsgASACai0AADoAzwIgAUEBaiIBQcAARw0ACyAAQTBqIANBD2ogA0GQAmpBwAAQNSADQZABaiECQQAhAQNAIAMgAWsgASACai0AADoAzwIgAUEBaiIBQcAARw0ACyAAQeAAaiADQQ9qIANBkAJqQcAAEDUgA0HQAWohAkEAIQEDQCADIAFrIAEgAmotAAA6AM8CIAFBAWoiAUHAAEcNAAsgAEGQAWogA0EPaiADQZACakHAABA1IANB0AJqJAALsgEBAX8jAEGABmsiAyQAAkBB/IUBKAIAQQNOBEAgAyABIAIQggMgA0HgA2ogAxBpIANBwAFqIANB4ABqEGkgA0HgA2ogA0HgA2ogA0HAAWoQgQMgACADQeADahCUASAAIAAQaAwBCyADQeADaiADQcABaiADQcABakHAACABIAJBjMYBKAIAEQYAEF4gA0GQBGpBpMUBKAIAEQMAIAAgA0HgA2oQkwEaCyADQYAGaiQAQQALUgAgACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggACABKAIMNgIMIAAgASgCEDYCECAAIAEoAhQ2AhQgACABKAIYNgIYIAAgASgCHDYCHAsGACAAEF0LKgEBfyAAQcABakGgxQEoAgARBAAEfyAAQfABakGgxQEoAgARBAAFQQALC9gFAQt/IwBBgANrIgIkACAAQcABaiIJQaDFASgCABEEAARAIABB8AFqQaDFASgCABEEACEECwJAAn8gAUHAAWoiCkGgxQEoAgARBAAEQCABQfABakGgxQEoAgARBAAhAwsgAyAEcgsEQCADIARxIQUMAQsgAkHAAWogACAKQYjFASgCABEBACACQeAAaiACQcABakGYtgFB7MUBKAIAEQEAIAJBkAFqIgsgAkGgAmoiB0GYtgFB7MUBKAIAEQEAIAJBwAFqIAEgCUGIxQEoAgARAQAgAiACQcABakGYtgFB7MUBKAIAEQEAIAJBMGoiDCAHQZi2AUHsxQEoAgARAQACQEGYxQEoAgAiBkUNACACKAJgIAIoAgBHDQFBASEEAkADQCAEIgMgBkYNASADQQFqIQQgA0ECdCIIIAJB4ABqaigCACACIAhqKAIARg0ACyADIAZJDQILIAIoApABIAIoAjBHDQFBASEEA0AgBCIDIAZGDQEgA0EBaiEEIAIgA0ECdCIIaigCkAEgAiAIaigCMEYNAAsgAyAGSQ0BCyACQcABaiAAQeAAaiAKQYjFASgCABEBACACQeAAaiACQcABakGYtgFB7MUBKAIAEQEAIAsgB0GYtgFB7MUBKAIAEQEAIAJBwAFqIAFB4ABqIAlBiMUBKAIAEQEAIAIgAkHAAWpBmLYBQezFASgCABEBACAMIAdBmLYBQezFASgCABEBAEGYxQEoAgAiAEUEQEEBIQUMAQsgAigCYCACKAIARw0AQQEhBAJAA0AgBCIBIABGDQEgAUEBaiEEIAFBAnQiAyACQeAAamooAgAgAiADaigCAEYNAAsgASAASQ0BCyACKAKQASACKAIwRw0AQQEhBANAAkAgACAEIgNGBEAgACEDDAELIANBAWohBCACIANBAnQiAWooApABIAEgAmooAjBGDQELCyADIABPIQULIAJBgANqJAAgBQucCQELfyMAQcAEayICJAAgAEHAAWoiB0GgxQEoAgARBAAEQCAAQfABakGgxQEoAgARBAAhAwsCQAJ/IAFBwAFqIghBoMUBKAIAEQQABEAgAUHwAWpBoMUBKAIAEQQAIQQLIAMgBHILBEAgAyAEcSEFDAELIAJBgANqIABB8AFqIgNBmLYBQcTFASgCABEBACACQYADaiACQYADaiAHQZi2AUG8xQEoAgARAAAgAkHAAWogByADQZi2AUG0xQEoAgARAAAgAkHgAGogByADQZi2AUG4xQEoAgARAAAgAkGgAmogAkHAAWogAkHgAGpBmLYBQbzFASgCABEAACACQdACaiACQYADakGoxQEoAgARAgAgAkGAA2ogAUHwAWoiA0GYtgFBxMUBKAIAEQEAIAJBgANqIAJBgANqIAhBmLYBQbzFASgCABEAACACQeAAaiAIIANBmLYBQbTFASgCABEAACACIAggA0GYtgFBuMUBKAIAEQAAIAJBwAFqIAJB4ABqIAJBmLYBQbzFASgCABEAACACQfABaiACQYADakGoxQEoAgARAgAgAkGAA2ogACACQcABakGIxQEoAgARAQAgAkHgAGogAkGAA2pBmLYBQezFASgCABEBACACQZABaiILIAJB4ANqIgZBmLYBQezFASgCABEBACACQYADaiABIAJBoAJqQYjFASgCABEBACACIAJBgANqQZi2AUHsxQEoAgARAQAgAkEwaiIMIAZBmLYBQezFASgCABEBAAJAQZjFASgCACIJRQ0AIAIoAmAgAigCAEcNAUEBIQMCQANAIAMiBCAJRg0BIARBAWohAyAEQQJ0IgogAkHgAGpqKAIAIAIgCmooAgBGDQALIAQgCUkNAgsgAigCkAEgAigCMEcNAUEBIQMDQCADIgQgCUYNASAEQQFqIQMgAiAEQQJ0IgpqKAKQASACIApqKAIwRg0ACyAEIAlJDQELIAJBgANqIABB4ABqIAJBwAFqQYjFASgCABEBACACQeAAaiACQYADakGYtgFB7MUBKAIAEQEAIAsgBkGYtgFB7MUBKAIAEQEAIAJBgANqIAFB4ABqIAJBoAJqQYjFASgCABEBACACIAJBgANqQZi2AUHsxQEoAgARAQAgDCAGQZi2AUHsxQEoAgARAQAgAkGAA2ogAkHgAGogCEGIxQEoAgARAQAgAkHgAGogAkGAA2pBmLYBQezFASgCABEBACALIAZBmLYBQezFASgCABEBACACQYADaiACIAdBiMUBKAIAEQEAIAIgAkGAA2pBmLYBQezFASgCABEBACAMIAZBmLYBQezFASgCABEBAEGYxQEoAgAiAEUEQEEBIQUMAQsgAigCYCACKAIARw0AQQEhAwJAA0AgAyIBIABGDQEgAUEBaiEDIAFBAnQiBCACQeAAamooAgAgAiAEaigCAEYNAAsgASAASQ0BCyACKAKQASACKAIwRw0AQQEhAwNAAkAgACADIgRGBEAgACEEDAELIARBAWohAyACIARBAnQiAWooApABIAEgAmooAjBGDQELCyAEIABPIQULIAJBwARqJAAgBQv1AwEFfwJAAkACQEGYggIoAgAOAgABAgsgACABEIgDDwsgACABEIcDDwtBmMUBKAIAIgRFBEBBAQ8LAkAgACgCACABKAIARw0AQQEhAwJAA0AgAyICIARGDQEgAkEBaiEDIAAgAkECdCIFaigCACABIAVqKAIARg0ACyACIARJDQELIAAoAjAgASgCMEcNAEEBIQMCQANAIAMiAiAERg0BIAJBAWohAyAAIAJBAnQiBWooAjAgASAFaigCMEYNAAsgAiAESQ0BCyAAKAJgIAEoAmBHDQBBASEDAkADQCADIgIgBEYNASACQQFqIQMgACACQQJ0IgVqKAJgIAEgBWooAmBGDQALIAIgBEkNAQsgACgCkAEgASgCkAFHDQBBASEDAkADQCADIgIgBEYNASACQQFqIQMgACACQQJ0IgVqKAKQASABIAVqKAKQAUYNAAsgAiAESQ0BCyAAKALAASABKALAAUcNAEEBIQMCQANAIAMiAiAERg0BIAJBAWohAyAAIAJBAnQiBWooAsABIAEgBWooAsABRg0ACyACIARJDQELIAAoAvABIAEoAvABRw0AQQEhAwNAAkAgBCADIgJGBEAgBCECDAELIAJBAWohAyAAIAJBAnQiBmooAvABIAEgBmooAvABRg0BCwsgAiAETyEGCyAGCwkAIAAgARCJAwvqBAEMfyAAIAIoAgAiBCABKAIAaiILNgIAIAAgASgCBCIFIAsgBElqIgogAigCBGoiBDYCBCAAIAQgCkkgCiAFSWoiBiABKAIIaiIFIAIoAghqIgo2AgggACAKIAVJIAUgBklqIgcgASgCDGoiBiACKAIMaiIFNgIMIAAgBSAGSSAGIAdJaiIIIAEoAhBqIgcgAigCEGoiBjYCECAAIAYgB0kgByAISWoiCSABKAIUaiIIIAIoAhRqIgc2AhQgACAHIAhJIAggCUlqIgwgASgCGGoiCCACKAIYaiIBNgIYIAsgAygCACICSSEJAkAgAAJ/QQAgCCAMSWsgASAISUcEQCAAIAsgAms2AgAgACAEIAMoAgQiCyAJaiICazYCBCAAIAogAiALSSAEIAJJaiIEIAMoAghqIgJrNgIIIAAgBSACIARJIAogAklqIgQgAygCDGoiAms2AgwgACAGIAIgBEkgBSACSWoiBCADKAIQaiICazYCECAAIAcgAiAESSAGIAJJaiIEIAMoAhRqIgJrNgIUIAEgAygCGGsgByACSWsgAiAESWsMAQsgCSADKAIEIglqIgggCUkgBCAISWoiDCADKAIIaiIJIAxJIAogCUlqIg0gAygCDGoiDCANSSAFIAxJaiIOIAMoAhBqIg0gDkkgBiANSWoiDyADKAIUaiIOIA9JIAcgDklqIg8gAygCGGoiAyAPSUF/QQAgASADSRtHDQEgACAHIA5rNgIUIAAgBiANazYCECAAIAUgDGs2AgwgACAKIAlrNgIIIAAgBCAIazYCBCAAIAsgAms2AgAgASADaws2AhgLC3wBAX8CQAJAAkACQAJAQZiCAigCAA4DAAECAwsgABCWAQ0CDAMLIAAQlQENAQwCCyAAQcABakGgxQEoAgARBAAEQEEBIQEgAEHwAWpBoMUBKAIAEQQADQILQQAhASAAEGpFDQELQZSCAi0AAEUEQEEBDwsgABBdIQELIAELUAEBfyMAQSBrIgMkACADIAI2AhQgAyABNgIQIANBADYCGCAAIANBD2ogA0EQakGABBCXASADLQAPIQAgAygCGCEBIANBIGokACABQQAgABsLUgEBfyMAQSBrIgQkACAEIAI2AhQgBCABNgIQIARBADYCGCAAIARBD2ogBEEQaiADEJcBIAQoAhghACAELQAPIQEgBEEgaiQAQQAgAUUgAEVyawtdACAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwAgAEGQAWpBpMUBKAIAEQMAIABBwAFqQaTFASgCABEDACAAQfABakGkxQEoAgARAwALmQEBA38jAEFAaiIDJAAgA0GE1gEoAgAiBDYCDAJAQYHXAS0AAARAIANBEGoiBSACQaTUAUGExwFBqNYBKAIAEQAAIAMoAgwhBAwBCyACIQULIAMgBTYCCAJAAkAgBEECdEEJSQ0AQeSBAigCACICRQ0AIAAgASAFIARBAEEBIAIRCAAMAQsgACABIAUgBEEAEDcLIANBQGskAAuKAgEDfyMAQUBqIgUkACAFQYTWASgCACIDNgIMAkBBgdcBLQAABEAgBUEQaiIEIAJBpNQBQYTHAUGo1gEoAgARAAAgBSgCDCEDDAELIAIhBAsgBSAENgIIAkACQCADBEACQAJAA0AgAyICRQ0BIAQgAkF/aiIDQQJ0aigCAEUNAAsgAkEBSw0BC0EBIQIgACABIAQoAgBBABA9DQMMAgsgAkECdEEJSQ0BQeSBAigCACIDRQ0BIAAgASAEIAJBAEEAIAMRCAAMAgsgAEGkxQEoAgARAwAgAEEwakGkxQEoAgARAwAgAEHgAGpBpMUBKAIAEQMADAELIAAgASAEIAJBABA3CyAFQUBrJAALyAEBAn8jAEGQAWsiAyQAAkAgAkHgAGoiBEGgxQEoAgARBAAEQCADQaTFASgCABEDACADQTBqQaTFASgCABEDACADQeAAakGkxQEoAgARAwAMAQsgAyACQajFASgCABECACADQTBqIAJBMGpBmLYBQbDFASgCABEBACADQeAAaiAEQajFASgCABECAAsCQAJAAkACQEHsgQIoAgAOAwABAgMLIAAgASADEA4MAgsgACABIAMQDQwBCyAAIAEgAxAMCyADQZABaiQAC6YDAQl/IwBBIGsiBCABKAIYIgtBAXQgASgCFCIGQR92cjYCGCAEIAZBAXQgASgCECIHQR92ciIGNgIUIAQgB0EBdCABKAIMIghBH3ZyIgc2AhAgBCAIQQF0IAEoAggiCUEfdnIiCDYCDCAEIAlBAXQgASgCBCIKQR92ciIJNgIIIAQgASgCACIDQQF0IgE2AgAgBCAKQQF0IANBH3ZyIgo2AgQgACABIAIoAgAiA2s2AgAgACAKIAIoAgQiBSABIANJaiIDazYCBCAAIAkgAyAFSSAKIANJaiIFIAIoAghqIgNrNgIIIAAgCCADIAVJIAkgA0lqIgUgAigCDGoiA2s2AgwgACAHIAMgBUkgCCADSWoiBSACKAIQaiIDazYCECAAIAYgAyAFSSAHIANJaiIFIAIoAhRqIgNrNgIUIAAgBCgCGCIEIAMgBUkgBiADSWoiAyACKAIYaiICazYCGCALQR92IAQgAklrIAIgA0lrQX9MBEAgACAENgIYIAAgBjYCFCAAIAc2AhAgACAINgIMIAAgCTYCCCAAIAo2AgQgACABNgIACws1AAJAAkACQAJAQeyBAigCAA4DAAECAwsgACABIAIQDg8LIAAgASACEA0PCyAAIAEgAhAMCws+ACAAIAFBqMUBKAIAEQIAIABBMGogAUEwakGoxQEoAgARAgAgAEHgAGogAUHgAGpBqMUBKAIAEQIAIAAQMAsvAAJAAkACQAJAQeyBAigCAA4DAAECAwsgACABEBMPCyAAIAEQEg8LIAAgARAVCwvUBAEKfyAAIAIoAgAiBCABKAIAaiILNgIAIAAgASgCBCIGIAsgBElqIgkgAigCBGoiBDYCBCAAIAQgCUkgCSAGSWoiByABKAIIaiIGIAIoAghqIgk2AgggACAJIAZJIAYgB0lqIgggASgCDGoiByACKAIMaiIGNgIMIAAgBiAHSSAHIAhJaiIFIAEoAhBqIgggAigCEGoiBzYCECAAIAcgCEkgCCAFSWoiCiABKAIUaiIFIAIoAhRqIgg2AhQgACACKAIYIAEoAhhqIAUgCklqIAggBUlqIgE2AhgCQCABIAMoAhgiCkkNACALIAMoAgAiAkkhBSABIApLBEAgACALIAJrNgIAIAAgBCADKAIEIgsgBWoiAms2AgQgACAJIAIgC0kgBCACSWoiBCADKAIIaiICazYCCCAAIAYgAiAESSAJIAJJaiIEIAMoAgxqIgJrNgIMIAAgByACIARJIAYgAklqIgQgAygCEGoiAms2AhAgACAIIAIgBEkgByACSWoiBCADKAIUaiICazYCFCAAIAEgAygCGGsgCCACSWsgAiAESWs2AhgPCyAFIAMoAgQiBWoiASAFSSAEIAFJaiIKIAMoAghqIgUgCkkgCSAFSWoiDCADKAIMaiIKIAxJIAYgCklqIg0gAygCEGoiDCANSSAHIAxJaiINIAMoAhRqIgMgDUlBf0EAIAggA0kbRw0AIABBADYCGCAAIAggA2s2AhQgACAHIAxrNgIQIAAgBiAKazYCDCAAIAkgBWs2AgggACAEIAFrNgIEIAAgCyACazYCAAsLfQEBfyABQeAAaiICQaDFASgCABEEAARAIABBpMUBKAIAEQMAIABBMGpBpMUBKAIAEQMAIABB4ABqQaTFASgCABEDAA8LIAAgAUGoxQEoAgARAgAgAEEwaiABQTBqQZi2AUGwxQEoAgARAQAgAEHgAGogAkGoxQEoAgARAgALUAEBfyMAQSBrIgMkACADIAE2AhQgAyAANgIQIANBADYCGCACIANBD2ogA0EQakGABBCYASADLQAPIQAgAygCGCEBIANBIGokACABQQAgABsLaQECfyMAQSBrIgQkACAEQQA2AhggBCAANgIQIAQgATYCFCACIARBD2ogBEEQaiADEJgBAkAgBCgCGEEAIAQtAA8bIgJFDQAgAiABQX9qRg0AIAAgAmpBADoAACACIQULIARBIGokACAFC7cBAQF/IwBBsAJrIgMkACADQfAAakGAASABIAJBh/wAEHJBACEB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NgJ0IAJCATcDECACQQA6AHggAkEAOgDoASACQQA6AA8CQEGE1gEoAgAiBUUEQCACQQE2AuQBIAJCATcDgAEgAkEAOgDoASACQQE6AA8MAQsgBUH/////A3EiA0EZTwRAIAJBADoAD0EADAILIAJBAToADyACIAM2AoABAkAgA0UNACADQQJ0IAVBAnRJDQADQEEAIQcgBCAFSQRAIAEgBEECdGooAgAhByAEQQFqIQQLIAZBAnQgAmogBzYChAEgBkEBaiIGIANHDQALCwJAA0AgAyIBQQJIDQEgAUF/aiIDQQJ0IAJqKAKEAUUNAAsgAiABNgLkAQwBCyACQQE2AuQBIAIoAoQBDQAgAkEAOgDoAQsgAkGkyAEgAkEQaiACQYABahCeASIBOgAPQQAgAUUNABogACACQQ9qIAJBEGoQayACLQAPQQBHCyEDIAJB8AFqJAAgAwsPAEEAIAAgARCvA0EBc2sLiwIBAn8jAEHQAmsiAyQAIAMgAkHUxQEoAgARAgAgA0HwAWogAkEwaiIEQdTFASgCABECACADIAMgA0HwAWpB+MUBKAIAEQUAGiADQcABaiADQZi2AUHsxQEoAgARAQAgA0HAAWogA0HAAWpBlLYBQcjFASgCABEBACADQfABaiACIANBwAFqQZi2AUG8xQEoAgARAAAgA0GgAmoiAiAEIANBwAFqQZi2AUG8xQEoAgARAAAgAiACQZi2AUGwxQEoAgARAQAgAyABIANB8AFqQYjFASgCABEBACAAIANBmLYBQezFASgCABEBACAAQTBqIANB4ABqQZi2AUHsxQEoAgARAQAgA0HQAmokAAtRAQF/IwBBwAFrIgMkACADIAEgAkGIxQEoAgARAQAgACADQZi2AUHsxQEoAgARAQAgAEEwaiADQeAAakGYtgFB7MUBKAIAEQEAIANBwAFqJAALMwAgACABIAJBmLYBQbjFASgCABEAACAAQTBqIAFBMGogAkEwakGYtgFBuMUBKAIAEQAACzMAIAAgASACQZi2AUG0xQEoAgARAAAgAEEwaiABQTBqIAJBMGpBmLYBQbTFASgCABEAAAuuAgEEfwJAIAEoAgAiAw0AIAEoAgQNACABKAIIDQAgASgCDA0AIAEoAhANACABKAIUDQAgASgCGA0AIAAgAUcEQCAAQgA3AgAgAEEANgIYIABCADcC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CyAAIQILIAEgAjYCCCACKAIAIQAgAUFAayQAIABBAXELSAAgACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggACABKAIMNgIMIAAgASgCEDYCECAAIAEoAhQ2AhQgACABKAIYNgIYC2cBBH9BhNYBKAIAIgJFBEBBAQ8LIAAoAgBB9NMBKAIARgR/QQEhAwNAAkAgAiADIgFGBEAgAiEBDAELIAFBAWohAyAAIAFBAnQiBGooAgAgBEH00wFqKAIARg0BCwsgASACTwVBAAsLDgAgAEGM1gEoAgARBAALYwEEf0GE1gEoAgAiA0UEQEEBDwsgACgCACABKAIARgR/QQEhBANAAkAgAyAEIgJGBEAgAyECDAELIAJBAWohBCAAIAJBAnQiBWooAgAgASAFaigCAEYNAQsLIAIgA08FQQALC0wBBH9BhNYBKAIAIQICQANAIAIiA0UNASAAIANBf2oiAkECdCIBaigCACIEIAFBhMcBaigCACIBRg0ACyAEIAFJIQELIAEgA0EAR3ELUAEBfyMAQSBrIgMkACADIAI2AhQgAyABNgIQIANBADYCGCAAIANBD2ogA0EQakGABBCiASADLQAPIQAgAygCGCEBIANBIGokACABQQAgABsLNwEBfyMAQRBrIgMkACAAIANBD2ogASACEKABIAMtAA8hACADQRBqJAAgAEEYdEGAgIB4akEYdQu1AgEHfyMAQUBqIgUkACAFQYTWASgCACIGNgIMAkBBgdcBLQAABEAgBUEQaiIHIABBpNQBQYTHAUGo1gEoAgARAAAgBSgCDCEGDAELIAAhBwsgBSAHNgIIIAUgBkECdCIDQQ9qQXBxayIEJAACQCAGRQ0AQQAhAANAIAAgBGogByAIQQJ0aigCACIJOgAAIAQgAEEBcmogCUEIdjoAACAEIABBAnJqIAlBEHY6AAAgBCAAQQNyaiAJQRh2OgAAIABBBGohACAIQQFqIgggBkcNAAsgAyAATQ0AIAAgBGpBACADIABrEBYLA0ACQCADIgBFBEBBASEADAELIAQgAEF/aiIDai0AAEUNAQsLQQAhAyAAIAJNBEAgASAEIABBASAAQQFLGxADGiAAIQMLIAVBQGskACADCwsAIAIgACABENsDC44EAQp/IAAgAigCACIEIAEoAgBqIgo2AgAgACABKAIEIgUgCiAE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AgsgBiAFIAQQDQwBCyAGIAUgBBAOCyADQaALaiAGQYTbAUGYtgFBvMUBKAIAEQAAIANB0AtqIANB0AJqQajFASgCABECACADQYAMaiADQYADakGoxQEoAgARAgAgA0GwA2ohBQJAAkACQAJAQeyBAigCAA4DAgEAAwsgBSAGIAQQDAwCCyAFIAYgBBANDAELIAUgBiAEEA4LIANBsAxqIAVBhNsBQZi2AUG8xQEoAgARAAAgA0HgDGogA0HgA2pBqMUBKAIAEQIAIANBkA1qIANBkARqQajFASgCABECACADQcAEaiEGAkACQAJAAkBB7IECKAIADgMCAQADCyAGIAUgBBAMDAILIAYgBSAEEA0MAQsgBiAFIAQQDgsgCiAHSyELIANBwA1qIAZBhNsBQZi2AUG8xQEoAgARAAAgA0HwDWogA0HwBGpBqMUBKAIAEQIAIANBoA5qIANBoAVqQajFASgCABECACADQdAFaiEFAkACQAJAAkBB7IECKAIADgMCAQADCyAFIAYgBBAMDAILIAUgBiAEEA0MAQsgBSAGIAQQDgsgCiAHIAsbIQYgA0HQDmogBUGE2wFBmLYBQbzFASgCABEAACADQYAPaiADQYAGakGoxQEoAgARAgAgA0GwD2ogA0GwBmpBqMUBKAIAEQIAIANB4AZqIQcCQAJAAkACQEHsgQIoAgAOAwIBAAMLIAcgBSAEEAwMAgsgByAFIAQQDQwBCyAHIAUgBBAOCyANIAZLIQogA0HgD2ogB0GE2wFBmLYBQbzFASgCABEAACADQZAQaiADQZAHakGoxQEoAgARAgAgA0HAEGogA0HAB2pBqMUBKAIAEQIAIANB8AdqIQUCQAJAAkACQEHsgQIoAgAOAwIBAAMLIAUgByAEEAwMAgsgBSAHIAQQDQwBCyAFIAcgBBAOCyANIAYgChshByADQfAQaiAFQYTbAUGYtgFBvMUBKAIAEQAAIANBoBFqIANBoAhqQajFASgCABECACADQdARaiADQdAIakGoxQEoAgARAgAgCEEBaiIIIAlHDQALCyAAQaTFASgCABEDACAAQTBqQaTFASgCABEDACAAQeAAakGkxQEoAgARAwACQCAHRQ0AQQAhASAJBEADQCABQX9zIQICQAJAAkACQEHsgQIoAgAOAwIBAAMLIAAgABAVDAILIAAgABASDAEL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IAIgA6wiCSAJQj+HIgl8IAmFNwNwIANBf0wEQCACQfAAaiACQfAAakGYtgFBsMUBKAIAEQEAC0GVxgEtAABFDQAgAkHwAGogAkHwAGpB6MMBQZi2AUG8xQEoAgARAAALIAJBoAFqIgRBiMMBQajFASgCABECAEHQsAFBsOEBQajFASgCABECAEGAsQFB4OEBQajFASgCABECAEGwsQFB0OMBQajFASgCABECAEHgsQFBgOQBQajFASgCABECAAJAAkAgAS0ADEUNACACQbAEakHQsAFB1MUBKAIAEQIAIAJBwANqQYCxAUHUxQEoAgARAgAgAkGwBGogAkGwBGogAkHAA2pB+MUBKAIAEQUAGiACQdACaiACQbAEakGYtgFB7MUBKAIAEQEAIAJB0AJqIAJB0AJqQZS2AUHIxQEoAgARAQBB0LABQdCwASACQdACakGYtgFBvMUBKAIAEQAAQYCxAUGAsQEgAkHQAmpBmLYBQbzFASgCABEAAEGAsQFBgLEBQZi2AUGwxQEoAgARAQAgAkGwBGpBsLEBQdTFASgCABECACACQcADakHgsQFB1MUBKAIAEQIAIAJBsARqIAJBsARqIAJBwANqQfjFASgCABEFABogAkHQAmogAkGwBGpBmLYBQezFASgCABEBACACQdACaiACQdACakGUtgFByMUBKAIAEQEAQbCxAUGwsQEgAkHQAmpBmLYBQbzFASgCABEAAEHgsQFB4LEBIAJB0AJqQZi2AUG8xQEoAgARAABB4LEBQeCxAUGYtgFBsMUBKAIAEQEAIAEtAAxFDQACQCABKAIEIgNBAUYEQCACQdACakGIwwFBqMUBKAIAEQIADAELIAJB0AJqQaTFASgCABEDACADRQ0AIAIgA6wiCSAJQj+HIgl8IAmFNwPQAiADQX9MBEAgAkHQAmogAkHQAmpBmLYBQbDFASgCABEBAAtBlcYBLQAARQ0AIAJB0AJqIAJB0AJqQejDAUGYtgFBvMUBKAIAEQAACyACQYADakGkxQEoAgARAwAgAkGwBGogAkHQAmogAkHwAGpBiMUBKAIAEQEAIAJBwANqIAJBsARqQZi2AUHsxQEoAgARAQAgAkHwA2oiAyACQZAFakGYtgFB7MUBKAIAEQEAQZCyASACQcADakGoxQEoAgARAgAMAQsCQCABKAIEIgNBAkcNACABKAIIQQFHDQAgAkGwBGpBiMMBQajFASgCABECACACQeAEaiIDQaTFASgCABEDACACQgE3A+AEIAMgA0GYtgFBsMUBKAIAEQEAQZXGAS0AAARAIAMgA0HowwFBmLYBQbzFASgCABEAAAtBkLIBIAJBsARqQajFASgCABECAAwBCwJAIANBAUYEQCACQdACakGIwwFBqMUBKAIAEQIADAELIAJB0AJqQaTFASgCABEDACADRQ0AIAIgA6wiCSAJQj+HIgl8IAmFNwPQAiADQX9MBEAgAkHQAmogAkHQAmpBmLYBQbDFASgCABEBAAtBlcYBLQAARQ0AIAJB0AJqIAJB0AJqQejDAUGYtgFBvMUBKAIAEQAACyACQYADakGkxQEoAgARAwAgAkGwBGogAkHwAGpB1MUBKAIAEQIAIAJBwANqIARB1MUBKAIAEQIAIAJBsARqIAJBsARqIAJBwANqQfjFASgCABEFABogAkHgAWogAkGwBGpBmLYBQezFASgCABEBACACQeABaiACQeABakGUtgFByMUBKAIAEQEAIAJBwANqIAJB8ABqIAJB4AFqQZi2AUG8xQEoAgARAAAgAkHwA2oiAyAEIAJB4AFqQZi2AUG8xQEoAgARAAAgAyADQZi2AUGwxQEoAgARAQAgAkGwBGogAkHAA2ogAkHQAmpBiMUBKAIAEQEAIAJBwANqIAJBsARqQZi2AUHsxQEoAgARAQAgAyACQZAFakGYtgFB7MUBKAIAEQEAQZCyASACQcADakGoxQEoAgARAgALQcCyASADQajFASgCABECACACQbAEakGIwwFBqMUBKAIAEQIAIAJB4ARqIgNBpMUBKAIAEQMAIAJCATcD4AQgAyADQZi2AUGwxQEoAgARAQBBlcYBLQAABEAgAyADQejDAUGYtgFBvMUBKAIAEQAAC0HwsgECf0EBQZjFASgCACIFRQ0AGgJAQZCyASgCACACKAKwBEcNAEEBIQMCQANAIAMiBCAFRg0BIARBAWohAyAEQQJ0IgZBkLIBaigCACACQbAEaiAGaigCAEYNAAsgBCAFSQ0BC0HAsgEoAgAgAigC4ARHDQBBASEDA0BBASAFIAMiBEYNAhogBEEBaiEDIARBAnQiBkHAsgFqKAIAIAIgBmooAuAERg0AC0EBIAQgBU8NARoLIAJBsARqQYjDAUGoxQEo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MDAwMDFiYTM0NGQ4MDAwMDAwMDA3ZmY5ZjgwMDAwMDAwMDAxMGExMDAwMDAwMDAwMDAwMGQAOTQ4ZDkyMDkwMDAwMDAwNmU4ZDEzNjAwMDAwMDAwMWZmZTdlMDAwMDAwMDAwMDQyODQwMDAwMDAwMDAwMDAzADkzNjZjNDgwMDAwMDAwMDU1NTE1MDAwMDAwMDAwMDEyMjQwMDAwMDAwMDAwMDAxNQA0YTQ2YzkwNDgwMDAwMDAzNzQ2ODliMDAwMDAwMDAwZmZmM2YwMDAwMDAwMDAwMjE0MjAwMDAwMDAwMDAwMDIAMWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiAGQwMDg4ZjUxY2JmZjM0ZDI1OGRkM2RiMjFhNWQ2NmJiMjNiYTVjMjc5YzI4OTVmYjM5ODY5NTA3YjU4N2IxMjBmNTVmZmZmNThhOWZmZmZkY2ZmN2ZmZmZmZmZkNTU1ADFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYQA2ODA0NDdhOGU1ZmY5YTY5MmM2ZTllZDkwZDJlYjM1ZDkxZGQyZTEzY2UxNDRhZmQ5Y2MzNGE4M2RhYzNkODkwN2FhZmZmZmFjNTRmZmZmZWU3ZmJmZmZmZmZmZWFhYgA3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxADUANzNlZGE3NTMyOTlkN2Q0ODMzMzlkODA4MDlhMWQ4MDU1M2JkYTQwMmZmZmU1YmZlZmZmZmZmZmYAMjEyZDc5ZTViNDE2YjZmMGZkNTZkYzhkMTY4ZDZjMGM0MDI0ZmYyNzBiM2UwOTQxYjc4OGY1MDBiOTEyZjFmADM5ZjZkM2E5OTRjZWJlYTQxOTljZWMwNDA0ZDBlYzAyYTlkZWQyMDE3ZmZmMmRmZjgwMDAwMDAwAHtNb2R1bGUuY3J5cHRvR2V0UmFuZG9tVmFsdWVzKCQwLCAkMSl9AGlpAHsAAABsAAAAewAAAHsAAAB7AAAAfAAAAGsAAAB8AAAAfAAAAHwAAAB9AAAAagAAAH0AAAB9AAAAfQAAAH4AAABsAAAAfgAAAH4AAAB+AAAAfwAAAGsAAAB/AAAAfwAAAH8AAACAAAAAagAAAIAAAACAAAAAgAAAAIEAAABdAAAAgQAAAIEAAACBAAAAggAAAFwAAACCAAAAggAAAIIAAACDAAAAWwAAAIMAAACDAAAAgwAAAIQAAABdAAAAhAAAAIQAAACEAAAAhQAAAFwAAACFAAAAhQAAAIUAAACGAAAAWwAAAIYAAACGAAAAhgAAAIcAAABHAAAAhwAAAIcAAACHAAAAiAAAAEYAAACIAAAAiAAAAIgAAACJAAAARQAAAIkAAACJAAAAiQAAAIoAAABHAAAAigAAAIoAAACKAAAAiwAAAEYAAACLAAAAiwAAAIsAAACMAAAARQAAAIwAAACMAAAAjAAAAI0AAAAxAAAAjQAAAI0AAACNAAAAjgAAADAAAACOAAAAjgAAAI4AAACPAAAALwAAAI8AAACPAAAAjwAAAJAAAAAxAAAAkAAAAJAAAACQAAAAkQAAADAAAACRAAAAkQAAAJEAAACSAAAALwAAAJIAAACSAAAAkgAAACAQAAAqEAAAXRAAAF8QAABhEAAAlBAAAMcQAADAAAAAZAAAAPoQAAAEEQAAXRAAAD8RAABBEQAAfBEAALcRAADgAAAAZQAAAPMRAAD9EQAAXRAAAEASAABCEgAAhRIAAMgSAAAAAQAAZgAAAAsTAAAVEwAAeBMAAHsTAADeEwAAQRQAAKQUAACAAQAAZwAAAAcVAAARFQAAeBMAAJcVAAAcFgAAoRYAACcXAAAJAgAAaAAAAK0XAAC3FwAAeBMAAOoXAAAdGAAAUBgAAIMYAADAAAAAaQAAALYYAADAGAAAeBMAAPsYAAA2GQAAcRkAAKwZAADgAAAAagAAAOcZAADxGQAAeBMAADQaAAB3GgAAuhoAAP0aAAAAAQAAawAAAEAbAABKGwAAXRAAAEASAAB1GwAAoBsAAMsbAACgAAAAbAAAAPcbAAD+GwAAKhwAAC0cAABfHAAAYRwAAJMcAAChAAAAbQAAAHNlY3AxOTJrMQAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZWUzNwAwADMAMHhkYjRmZjEwZWMwNTdlOWFlMjZiMDdkMDI4MGI3ZjQzNDFkYTVkMWIxZWFlMDZjN2QAMHg5YjJmMmY2ZDljNTYyOGE3ODQ0MTYzZDAxNWJlODYzNDQwODJhYTg4ZDk1ZTJmOWQAMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUyNmYyZmMxNzBmNjk0NjZhNzRkZWZkOGQAc2VjcDIyNGsxADB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmU1NmQANQAweGExNDU1YjMzNGRmMDk5ZGYzMGZjMjhhMTY5YTQ2N2U5ZTQ3MDc1YTkwZjdlNjUwZWI2YjdhNDVjADB4N2UwODlmZWQ3ZmJhMzQ0MjgyY2FmYmQ2ZjdlMzE5ZjdjMGIwYmQ1OWUyY2E0YmRiNTU2ZDYxYTUAMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWRjZThkMmVjNjE4NGNhZjBhOTcxNzY5ZmIxZjcAc2VjcDI1NmsxADB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZgA3ADB4NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OAAweDQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgAMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxAHNlY3AzODRyMQAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmZmZjAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZgAtMwAweGIzMzEyZmE3ZTIzZWU3ZTQ5ODhlMDU2YmUzZjgyZDE5MTgxZDljNmVmZTgxNDExMjAzMTQwODhmNTAxMzg3NWFjNjU2Mzk4ZDhhMmVkMTlkMmE4NWM4ZWRkM2VjMmFlZgAweGFhODdjYTIyYmU4YjA1Mzc4ZWIxYzcxZWYzMjBhZDc0NmUxZDNiNjI4YmE3OWI5ODU5Zjc0MWUwODI1NDJhMzg1NTAyZjI1ZGJmNTUyOTZjM2E1NDVlMzg3Mjc2MGFiNwAweDM2MTdkZTRhOTYyNjJjNmY1ZDllOThiZjkyOTJkYzI5ZjhmNDFkYmQyODlhMTQ3Y2U5ZGEzMTEzYjVmMGI4YzAwYTYwYjFjZTFkN2U4MTlkN2E0MzFkN2M5MGVhMGU1ZgAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmM3NjM0ZDgxZjQzNzJkZGY1ODFhMGRiMjQ4YjBhNzdhZWNlYzE5NmFjY2M1Mjk3MwBzZWNwNTIxcjEAMHgxZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZgAweDUxOTUzZWI5NjE4ZTFjOWExZjkyOWEyMWEwYjY4NTQwZWVhMmRhNzI1Yjk5YjMxNWYzYjhiNDg5OTE4ZWYxMDllMTU2MTkzOTUxZWM3ZTkzN2IxNjUyYzBiZDNiYjFiZjA3MzU3M2RmODgzZDJjMzRmMWVmNDUxZmQ0NmI1MDNmMDAAMHhjNjg1OGUwNmI3MDQwNGU5Y2Q5ZTNlY2I2NjIzOTViNDQyOWM2NDgxMzkwNTNmYjUyMWY4MjhhZjYwNmI0ZDNkYmFhMTRiNWU3N2VmZTc1OTI4ZmUxZGMxMjdhMmZmYThkZTMzNDhiM2MxODU2YTQyOWJmOTdlN2UzMWMyZTViZDY2ADB4MTE4MzkyOTZhNzg5YTNiYzAwNDVjOGE1ZmI0MmM3ZDFiZDk5OGY1NDQ0OTU3OWI0NDY4MTdhZmJkMTcyNzNlNjYyYzk3ZWU3Mjk5NWVmNDI2NDBjNTUwYjkwMTNmYWQwNzYxMzUzYzcwODZhMjcyYzI0MDg4YmU5NDc2OWZkMTY2NTAAMHgxZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZhNTE4Njg3ODNiZjJmOTY2YjdmY2MwMTQ4ZjcwOWE1ZDAzYmI1YzliODg5OWM0N2FlYmI2ZmI3MWU5MTM4NjQwOQBOSVNUX1AxOTIAMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmZmZmZmZmZmZmZmYAMHg2NDIxMDUxOWU1OWM4MGU3MGZhN2U5YWI3MjI0MzA0OWZlYjhkZWVjYzE0NmI5YjEAMHgxODhkYTgwZWIwMzA5MGY2N2NiZjIwZWI0M2ExODgwMGY0ZmYwYWZkODJmZjEwMTIAMHgwNzE5MmI5NWZmYzhkYTc4NjMxMDExZWQ2YjI0Y2RkNTczZjk3N2ExMWU3OTQ4MTEAMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY5OWRlZjgzNjE0NmJjOWIxYjRkMjI4MzEATklTVF9QMjI0ADB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEAMHhiNDA1MGE4NTBjMDRiM2FiZjU0MTMyNTY1MDQ0YjBiN2Q3YmZkOGJhMjcwYjM5NDMyMzU1ZmZiNAAweGI3MGUwY2JkNmJiNGJmN2YzMjEzOTBiOTRhMDNjMWQzNTZjMjExMjIzNDMyODBkNjExNWMxZDIxADB4YmQzNzYzODhiNWY3MjNmYjRjMjJkZmU2Y2Q0Mzc1YTA1YTA3NDc2NDQ0ZDU4MTk5ODUwMDdlMzQAMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmMTZhMmUwYjhmMDNlMTNkZDI5NDU1YzVjMmEzZABOSVNUX1AyNTYAMHhmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmADB4NWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0YgAweDZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTYAMHg0ZmUzNDJlMmZlMWE3ZjliOGVlN2ViNGE3YzBmOWUxNjJiY2UzMzU3NmIzMTVlY2VjYmI2NDA2ODM3YmY1MWY1ADB4ZmZmZmZmZmYwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZiY2U2ZmFhZGE3MTc5ZTg0ZjNiOWNhYzJmYzYzMjU1MQBzZWNwMTYwazEAMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZhYzczADB4M2I0YzM4MmNlMzdhYTE5MmE0MDE5ZTc2MzAzNmY0ZjVkZDRkN2ViYgAweDkzOGNmOTM1MzE4ZmRjZWQ2YmMyODI4NjUzMTczM2MzZjAzYzRmZWUAMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDFiOGZhMTZkZmFiOWFjYTE2YjZiMwBwMTYwXzEAMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNwAxMAAxMzQzNjMyNzYyMTUwMDkyNDk5NzAxNjM3NDM4OTcwNzY0ODE4NTI4MDc1NTY1MDc4ADEAMTIzNjYxMjM4OTk1MTQ2MjE1MTY2MTE1NjczMTUzNTMxNjEzODQzOTk4MzU3OTI4NAAxNDYxNTAxNjM3MzMwOTAyOTE4MjAzNjgzNTE4MjE4MTI2ODEyNzExMTM3MDAyNTYxADI1MjM2NDgyNDAwMDAwMDEyNmNkODkwMDAwMDAwMDAzY2YwZjAwMDAwMDAwMDAwNjBjMDAwMDAwMDAwMDAwMDQAMjUyMzY0ODI0MDAwMDAwMTcwODBlYjQwMDAwMDAwMDYxODE4MDAwMDAwMDAwMDBjZDk4MDAwMDAwMDAwMDAwYgBB0DoL3TsNAAAA/P////z///8GAAAA/P///wAAAAAFAAAA/P///wEAAAAweDZhZjBlMDQzN2ZmNDAwYjY4MzFlMzZkNmJkMTdmZmU0ODM5NWRhYmMyZDM0MzVlNzdmNzZlMTcwMDkyNDFjNWVlNjc5OTJmNzJlYzA1ZjRjODEwODRmYmVkZTNjYzA5ADB4Njk5YmUzYjhjNjg3MDk2NWU1YmY4OTJhZDVkMmNjN2IwZTg1YTExNzQwMmRmZDgzYjdmNGE5NDdlMDJkOTc4NDk4MjU1YTJhYWVjMGFjNjI3YjVhZmJkZjFiZjFjOTAAMHg4MTU3Y2Q4MzA0NjQ1M2Y1ZGQwOTcyYjZlMzk0OWU0Mjg4MDIwYjViOGE5Y2M5OWNhMDdlMjcwODlhMmNlMjQzNmQ5NjUwMjZhZGFkM2VmN2JhYmEzN2YyMTgzZTliNQAweGFiMWMyZmZkZDZjMjUzY2ExNTUyMzFlYjNlNzFiYTA0NGZkNTYyZjZmNzJiYzViYWQ1ZWM0NmEwYjdhM2IwMjQ3Y2YwOGNlNmM2MzE3ZjQwZWRiYzY1M2E3MmRlZTE3ADB4YWE0MDQ4NjY3MDY3MjI4NjQ0ODA4ODVkNjhhZDBjY2FjMTk2N2M3NTQ0YjQ0Nzg3M2NjMzdlMDE4MTI3MWUwMDZkZjcyMTYyYTNkM2UwMjg3YmY1OTdmYmY3ZjhmYzEAMHgxNDQ2OThhM2I4ZTk0MzNkNjkzYTAyYzk2ZDQ5ODJiMGVhOTg1MzgzZWU2NmE4ZDhlODk4MWFlZmQ4ODFhYzk4OTM2ZjhkYTBlMGY5N2Y1Y2Y0MjgwODJkNTg0YzFkADB4MTJlMjkwOGQxMTY4ODAzMDAxOGIxMmU4NzUzZWVlM2IyMDE2YzFmMGYyNGY0MDcwYTBiOWMxNGZjZWYzNWVmNTVhMjMyMTVhMzE2Y2VhYTVkMWNjNDhlOThlMTcyYmUwADB4NjgwNDQ3YThlNWZmOWE2OTJjNmU5ZWQ5MGQyZWIzNWQ5MWRkMmUxM2NlMTQ0YWZkOWNjMzRhODNkYWMzZDg5MDdhYWZmZmZhYzU0ZmZmZmVlN2ZiZmZmZmZmZmVhYWEAMHgzZDY4OWQxZTBlNzYyY2VmOWYyYmVjNjEzMDMxNjgwNmI0YzgwZWRhNmZjMTBjZTc3YWU4M2VhYjFlYThiOGI4YTQwN2M5YzZkYjE5NWUwNmYyZGJlYWJjMmJhZWZmNQBkMjAxMDAwMDAwMDEwMDAxADB4NWM3NTk1MDdlOGUzMzNlYmI1YjdhOWE0N2Q3ZWQ4NTMyYzUyZDM5ZmQzYTA0MmE4OGI1ODQyM2M1MGFlMTVkNWMyNjM4ZTM0M2Q5YzcxYzYyMzhhYWFhYWFhYTk3ZDYAMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWEAMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWUAMHg4YWIwNWY4YmRkNTRjZGUxOTA5MzdlNzZiYzNlNDQ3Y2MyN2MzZDZmYmQ3MDYzZmNkMTA0NjM1YTc5MDUyMGMwYTM5NTU1NGU1YzZhYWFhOTM1NGZmZmZmZmZmZTM4ZAAweDE3MWQ2NTQxZmEzOGNjZmFlZDZkZWE2OTFmNWZiNjE0Y2IxNGI0ZTdmNGU4MTBhYTIyZDYxMDhmMTQyYjg1NzU3MDk4ZTM4ZDBmNjcxYzcxODhlMmFhYWFhYWFhNWVkMQAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWE2MwAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWE5ZgAweDE1MzA0NzdjN2FiNDExM2I1OWE0YzE4YjA3NmQxMTkzMGY3ZGE1ZDRhMDdmNjQ5YmY1NDQzOWQ4N2QyN2U1MDBmYzhjMjVlYmY4YzkyZjY4MTJjZmM3MWM3MWM2ZDcwNgAweDVjNzU5NTA3ZThlMzMzZWJiNWI3YTlhNDdkN2VkODUzMmM1MmQzOWZkM2EwNDJhODhiNTg0MjNjNTBhZTE1ZDVjMjYzOGUzNDNkOWM3MWM2MjM4YWFhYWFhYWE5N2JlADB4MTE1NjBiZjE3YmFhOTliYzMyMTI2ZmNlZDc4N2M4OGY5ODRmODdhZGY3YWUwYzdmOWEyMDhjNmI0ZjIwYTQxODE0NzJhYWE5Y2I4ZDU1NTUyNmE5ZmZmZmZmZmZjNzFjADB4OGFiMDVmOGJkZDU0Y2RlMTkwOTM3ZTc2YmMzZTQ0N2NjMjdjM2Q2ZmJkNzA2M2ZjZDEwNDYzNWE3OTA1MjBjMGEzOTU1NTRlNWM2YWFhYTkzNTRmZmZmZmZmZmUzOGYAMHgxMjRjOWFkNDNiNmNmNzliZmJmNzA0M2RlMzgxMWFkMDc2MWIwZjM3YTFlMjYyODZiMGU5NzdjNjlhYTI3NDUyNGU3OTA5N2E1NmRjNGJkOWUxYjM3MWM3MWM3MThiMTAAMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmE4ZmIAMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmE5ZDMAMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhOTkAMHgxMWEwNWYyYjFlODMzMzQwYjgwOTEwMWRkOTk4MTU4NTZiMzAzZTg4YTJkNzAwNWZmMjYyN2I1NmNkYjRlMmM4NTYxMGMyZDVmMmU2MmQ2ZWFlYWMxNjYyNzM0NjQ5YjcAMHgxNzI5NGVkM2U5NDNhYjJmMDU4OGJhYjIyMTQ3YTgxYzdjMTdlNzViMmY2YTg0MTdmNTY1ZTMzYzcwZDFlODZiNDgzOGYyYTZmMzE4YzM1NmU4MzRlZWYxYjNjYjgzYmIAMHhkNTQwMDVkYjk3Njc4ZWMxZDEwNDhjNWQxMGE5YTFiY2UwMzI0NzMyOTU5ODNlNTY4NzhlNTAxZWM2OGUyNWM5NThjM2UzZDJhMDk3MjlmZTAxNzlmOWRhYzllZGNiMAAweDE3NzhlNzE2NmZjYzZkYjc0ZTA2MDlkMzA3ZTU1NDEyZDdmNWU0NjU2YThkYmYyNWYxYjMzMjg5ZjFiMzMwODM1MzM2ZTI1Y2UzMTA3MTkzYzViMzg4NjQxZDliNjg2MQAweGU5OTcyNmEzMTk5ZjQ0MzY2NDJiNGIzZTQxMThlNTQ5OWRiOTk1YTEyNTdmYjNmMDg2ZWViNjU5ODJmYWMxODk4NWEyODZmMzAxZTc3YzQ1MTE1NGNlOWFjODg5NWQ5ADB4MTYzMGMzMjUwZDczMTNmZjAxZDEyMDFiZjdhNzRhYjVkYjNjYjE3ZGQ5NTI3OTliOWVkM2FiOTA5N2U2OGY5MGEwODcwZDJkY2FlNzNkMTljZDEzYzFjNjZmNjUyOTgzADB4ZDZlZDY1NTNmZTQ0ZDI5NmEzNzI2YzM4YWU2NTJiZmIxMTU4NjI2NGYwZjhjZTE5MDA4ZTIxOGY5Yzg2YjJhOGRhMjUxMjhjMTA1MmVjYWRkZDdmMjI1YTEzOWVkODQAMHgxN2I4MWU3NzAxYWJkYmUyZTg3NDM4ODRkMTExN2U1MzM1NmRlNWFiMjc1YjRkYjFhNjgyYzYyZWYwZjI3NTMzMzliN2M4ZjhjOGY0NzVhZjljY2I1NjE4ZTNmMGM4OGUAMHg4MGQzY2YxZjlhNzhmYzQ3YjkwYjMzNTYzYmU5OTBkYzQzYjc1NmNlNzlmNTU3NGEyYzU5NmM5MjhjNWQxZGU0ZmEyOTVmMjk2Yjc0ZTk1NmQ3MTk4NmE4NDk3ZTMxNwAweDE2OWIxZjhlMWJjZmE3YzQyZTBjMzc1MTVkMTM4ZjIyZGQyZWNiODAzYTBjNWM5OTY3NjMxNGJhZjRiYjFiN2ZhMzE5MGIyZWRjMDMyNzc5N2YyNDEwNjdiZTM5MGM5ZQAweDEwMzIxZGEwNzljZTA3ZTI3MmQ4ZWMwOWQyNTY1YjBkZmE3ZGNjZGRlNjc4N2Y5NmQ1MGFmMzYwMDNiMTQ4NjZmNjliNzcxZjhjMjg1ZGVjY2E2N2RmM2YxNjA1ZmI3YgAweDZlMDhjMjQ4ZTI2MGU3MGJkMWU5NjIzODFlZGVlM2QzMWQ3OWQ3ZTIyYzgzN2JjMjNjMGJmMWJjMjRjNmI2OGMyNGIxYjgwYjY0ZDM5MWZhOWM4YmEyZThiYTJkMjI5ADB4OGNhOGQ1NDhjZmYxOWFlMThiMmU2MmY0YmQzZmE2ZjAxZDVlZjRiYTM1YjQ4YmE5Yzk1ODg2MTdmYzhhYzYyYjU1OGQ2ODFiZTM0M2RmODk5M2NmOWZhNDBkMjFiMWMAMHgxMjU2MWE1ZGViNTU5YzQzNDhiNDcxMTI5OGU1MzYzNjcwNDFlOGNhMGNmMDgwMGMwMTI2YzI1ODhjNDhiZjU3MTNkYWE4ODQ2Y2IwMjZlOWU1YzgyNzZlYzgyYjNiZmYAMHhiMjk2MmZlNTdhMzIyNWU4MTM3ZTYyOWJmZjI5OTFmNmY4OTQxNmY1YTcxOGNkMWZjYTY0ZTAwYjExYWNlYWNkNmEzZDA5NjdjOTRmZWRjZmNjMjM5YmE1Y2I4M2UxOQAweDM0MjU1ODFhNThhZTJmZWM4M2FhZmVmN2M0MGViNTQ1YjA4MjQzZjE2YjE2NTUxNTRjY2E4YWJjMjhkNmZkMDQ5NzZkNTI0M2VlY2Y1YzQxMzBkZTg5MzhkYzYyY2Q4ADB4MTNhOGUxNjIwMjI5MTRhODBhNmYxZDVmNDNlN2EwN2RmZmRmYzc1OWExMjA2MmJiOGQ2YjQ0ZTgzM2IzMDZkYTliZDI5YmE4MWYzNTc4MWQ1MzlkMzk1YjM1MzJhMjFlADB4ZTczNTVmOGU0ZTY2N2I5NTUzOTBmN2YwNTA2YzZlOTM5NTczNWU5Y2U5Y2FkNGQwYTQzYmNlZjI0Yjg5ODJmNzQwMGQyNGJjNDIyOGYxMWMwMmRmOWEyOWY2MzA0YTUAMHg3NzJjYWFjZjE2OTM2MTkwZjNlMGM2M2UwNTk2NzIxNTcwZjU3OTlhZjUzYTE4OTRlMmUwNzMwNjJhZWRlOWNlYTczYjM1MzhmMGRlMDZjZWMyNTc0NDk2ZWU4NGEzYQAweDE0YTdhYzJhOWQ2NGE4YjIzMGIzZjViMDc0Y2YwMTk5NmU3ZjYzYzIxYmNhNjhhODE5OTZlMWNkZjk4MjJjNTgwZmE1Yjk0ODlkMTFlMmQzMTFmN2Q5OWJiZGNjNWE1ZQAweGExMGVjZjZhZGE1NGY4MjVlOTIwYjNkYWZjN2EzY2NlMDdmOGQxZDcxNjEzNjZiNzQxMDBkYTY3ZjM5ODgzNTAzODI2NjkyYWJiYTQzNzA0Nzc2ZWMzYTc5YTFkNjQxADB4OTVmYzEzYWI5ZTkyYWQ0NDc2ZDZlM2ViM2E1NjY4MGY2ODJiNGVlOTZmN2QwMzc3NmRmNTMzOTc4ZjMxYzE1OTMxNzRlNGI0Yjc4NjUwMDJkNjM4NGQxNjhlY2RkMGEAMHgxADB4OTBkOTdjODFiYTI0ZWUwMjU5ZDFmMDk0OTgwZGNmYTExYWQxMzhlNDhhODY5NTIyYjUyYWY2Yzk1NjU0M2QzY2QwYzdhZWU5YjNiYTNjMmJlOTg0NTcxOTcwN2JiMzMAMHgxMzQ5OTZhMTA0ZWU1ODExZDUxMDM2ZDc3NmZiNDY4MzEyMjNlOTZjMjU0ZjM4M2QwZjkwNjM0M2ViNjdhZDM0ZDZjNTY3MTE5NjJmYThiZmUwOTdlNzVhMmU0MWM2OTYAMHhjYzc4NmJhYTk2NmU2NmY0YTM4NGM4NmEzYjQ5OTQyNTUyZTJkNjU4YTMxY2UyYzM0NGJlNGI5MTQwMGRhN2QyNmQ1MjE2MjhiMDA1MjNiOGRmZTI0MGM3MmRlMWY2ADB4MWY4NjM3NmU4OTgxYzIxNzg5ODc1MWFkODc0Njc1N2Q0MmFhN2I5MGVlYjc5MWMwOWU0YTNlYzAzMjUxY2Y5ZGU0MDVhYmE5ZWM2MWRlY2E2MzU1Yzc3YjBlNWY0Y2IAMHg4Y2MwM2ZkZWZlMGZmMTM1Y2FmNGZlMmEyMTUyOWM0MTk1NTM2ZmJlM2NlNTBiODc5ODMzZmQyMjEzNTFhZGMyZWU3ZjhkYzA5OTA0MGE4NDFiNmRhZWNmMmU4ZmVkYgAweDE2NjAzZmNhNDA2MzRiNmEyMjExZTExZGI4ZjBhNmEwNzRhN2QwZDRhZmFkYjdiZDc2NTA1YzNkM2FkNTU0NGUyMDNmNjMyNmM5NWE4MDcyOTliMjNhYjEzNjMzYTVmMAAweDRhYjBiOWJjZmFjMWJiY2IyYzk3N2QwMjc3OTZiM2NlNzViYjhjYTJiZTE4NGNiNTIzMTQxM2M0ZDYzNGYzNzQ3YTg3YWMyNDYwZjQxNWVjOTYxZjg4NTVmZTlkNmYyADB4OTg3YzhkNTMzM2FiODZmZGU5OTI2YmQyY2E2YzY3NDE3MGEwNWJmZTNiZGQ4MWZmZDAzOGRhNmMyNmM4NDI2NDJmNjQ1NTBmZWRmZTkzNWExNWU0Y2EzMTg3MGZiMjkAMHg5ZmM0MDE4YmQ5NjY4NGJlODhjOWUyMjFlNGRhMWJiOGYzYWJkMTY2NzlkYzI2YzFlOGI2ZTZhMWYyMGNhYmU2OWQ2NTIwMWM3ODYwN2EzNjAzNzBlNTc3YmRiYTU4NwAweGUxYmJhN2ExMTg2YmRiNTIyM2FiZGU3YWRhMTRhMjNjNDJhMGNhNzkxNWFmNmZlMDY5ODVlN2VkMWU0ZDQzYjliM2Y3MDU1ZGQ0ZWJhNmYyYmFmYWFlYmNhNzMxYzMwADB4MTk3MTNlNDc5MzdjZDFiZTBkZmQwYjhmMWQ0M2ZiOTNjZDJmY2JjYjZjYWY0OTNmZDExODNlNDE2Mzg5ZTYxMDMxYmYzYTVjY2UzZmJhZmNlODEzNzExYWQwMTFjMTMyADB4MThiNDZhOTA4ZjM2ZjZkZWI5MThjMTQzZmVkMmVkY2M1MjM1NTliOGFhZjBjMjQ2MmU2YmZlN2Y5MTFmNjQzMjQ5ZDljZGY0MWI0NGQ2MDZjZTA3YzhhNGQwMDc0ZDhlADB4YjE4MmNhYzEwMWI5Mzk5ZDE1NTA5NjAwNGY1M2Y0NDdhYTdiMTJhMzQyNmIwOGVjMDI3MTBlODA3YjQ2MzNmMDZjODUxYzE5MTkyMTFmMjBkNGMwNGYwMGI5NzFlZjgAMHgyNDVhMzk0YWQxZWNhOWI3MmZjMDBhZTdiZTMxNWRjNzU3YjNiMDgwZDRjMTU4MDEzZTY2MzJkM2M0MDY1OWNjNmNmOTBhZDFjMjMyYTY0NDJkOWQzZjVkYjk4MDEzMwAweDVjMTI5NjQ1ZTQ0Y2YxMTAyYTE1OWY3NDhjNGEzZmM1ZTY3M2Q4MWQ3ZTg2NTY4ZDlhYjBmNWQzOTZhN2NlNDZiYTEwNDliNjU3OWFmYjc4NjZiMWU3MTU0NzUyMjRiADB4MTVlNmJlNGU5OTBmMDNjZTRlYTUwYjNiNDJkZjJlYjVjYjE4MWQ4Zjg0OTY1YTM5NTdhZGQ0ZmE5NWFmMDFiMmI2NjUwMjdlZmVjMDFjNzcwNGI0NTZiZTY5YzhiNjA0ADB4MTYxMTJjNGMzYTljOThiMjUyMTgxMTQwZmFkMGVhZTk2MDFhNmRlNTc4OTgwYmU2ZWVjMzIzMmI1YmU3MmU3YTA3ZjM2ODhlZjYwYzIwNmQwMTQ3OTI1M2IwMzY2M2MxADB4MTk2MmQ3NWMyMzgxMjAxZTFhMGNiZDZjNDNjMzQ4Yjg4NWM4NGZmNzMxYzRkNTljYTRhMTAzNTZmNDUzZTAxZjc4YTQyNjA3NjM1MjllMzUzMmY2MTAyYzJlNDlhMDNkADB4NThkZjMzMDY2NDBkYTI3NmZhYWFlN2Q2ZThlYjE1Nzc4YzQ4NTU1NTFhZTdmMzEwYzM1YTVkZDI3OWNkMmVjYTY3NTdjZDYzNmY5NmY4OTFlMjUzOGI1M2RiZjY3ZjIAMHgxNmI3ZDI4ODc5OGU1Mzk1ZjIwZDIzYmY4OWVkYjRkMWQxMTVjNWRiZGRiY2QzMGUxMjNkYTQ4OWU3MjZhZjQxNzI3MzY0ZjJjMjgyOTdhZGE4ZDI2ZDk4NDQ1ZjU0MTYAMHhiZTBlMDc5NTQ1ZjQzZTRiMDBjYzkxMmY4MjI4ZGRjYzZkMTljOWYwZjY5YmJiMDU0MmVkYTBmYzlkZWM5MTZhMjBiMTVkYzBmZDJlZGVkZGEzOTE0MjMxMWE1MDAxZAAweDhkOWU1Mjk3MTg2ZGIyZDlmYjI2NmVhYWM3ODMxODJiNzAxNTJjNjU1NTBkODgxYzVlY2Q4N2I2ZjBmNWE2NDQ5ZjM4ZGI5ZGZhOWNjZTIwMmM2NDc3ZmFhZjliN2FjADB4MTY2MDA3YzA4YTk5ZGIyZmMzYmE4NzM0YWNlOTgyNGI1ZWVjZmRmYThkMGNmOGVmNWRkMzY1YmM0MDBhMDA1MWQ1ZmE5YzAxYTU4YjFmYjkzZDFhMTM5OTEyNmE3NzVjADB4MTZhM2VmMDhiZTNlYTdlYTAzYmNkZGZhYmJhNmZmNmVlNWE0Mzc1ZWZhMWY0ZmQ3ZmViMzRmZDIwNjM1NzEzMmI5MjBmNWIwMDgwMWRlZTQ2MGVlNDE1YTE1ODEyZWQ5ADB4MTg2NmM4ZWQzMzZjNjEyMzFhMWJlNTRmZDFkNzRjYzRmOWZiMGNlNGM2YWY1OTIwYWJjNTc1MGM0YmYzOWI0ODUyY2ZlMmY3YmI5MjQ4ODM2YjIzM2Q5ZDU1NTM1ZDRhADB4MTY3YTU1Y2RhNzBhNmUxY2VhODIwNTk3ZDk0YTg0OTAzMjE2Zjc2M2UxM2Q4N2JiNTMwODU5MmU3ZWE3ZDRmYmM3Mzg1ZWEzZDUyOWIzNWUzNDZlZjQ4YmI4OTEzZjU1ADB4NGQyZjI1OWVlYTQwNWJkNDhmMDEwYTAxYWQyOTExZDljNmRkMDM5YmI2MWE2MjkwZTU5MWIzNmU2MzZhNWM4NzFhNWMyOWY0ZjgzMDYwNDAwZjhiNDljYmE4ZjZhYTgAMHhhY2NiYjY3NDgxZDAzM2ZmNTg1MmMxZTQ4YzUwYzQ3N2Y5NGZmOGFlZmNlNDJkMjhjMGY5YTg4Y2VhNzkxMzUxNmY5Njg5ODZmN2ViYmVhOTY4NGI1MjllMjU2MTA5MgAweGFkNmI5NTE0Yzc2N2ZlM2MzNjEzMTQ0YjQ1ZjE0OTY1NDMzNDZkOThhZGYwMjI2N2Q1Y2VlZjlhMDBkOWI4NjkzMDAwNzYzZTNiOTBhYzExZTk5YjEzODU3MzM0NWNjADB4MjY2MDQwMGViMmU0ZjNiNjI4YmRkMGQ1M2NkNzZmMmJmNTY1Yjk0ZTcyOTI3YzFjYjc0OGRmMjc5NDI0ODBlNDIwNTE3YmQ4NzE0Y2M4MGQxZmFkYzEzMjZlZDA2ZjcAMHhlMGZhMWQ4MTZkZGMwM2U2YjI0MjU1ZTBkNzgxOWMxNzFjNDBmNjVlMjczYjg1MzMyNGVmY2Q2MzU2Y2FhMjA1Y2EyZjU3MGYxMzQ5NzgwNDQxNTQ3M2ExZDYzNGI4ZgAAsDsAAAIAAAABAEG49gALmALEOwAAAgAAAAEAAAAAAAAAAQAAAOA7AAACAAAAAQAAAAAAAAACAAAA/DsAAAUAAAACAAAAAAAAAAMAAAAcPAAAAwAAAAkAAAAAAAAABAAAADA8AAAEAAAAAQAAAAEAAAAFAAAARDwAAAMAAAAEAAAAAAAAAAYAAAAtMHg0MDgwMDAwMDAwMDAwMDAxAC0weDQwMDAxMTAwMDAwMDAwMDAwMDAwMDAwMQAtMHg0MDAwNDAwOTAwMDEwMDAwMDAwMDAwMDEAMHg0MDAxZmZmZmZmZmZmZmZmZmZmZmZmZmZmYmZmZgA0OTY1NjYxMzY3MTkyODQ4ODgxAC0weGQyMDEwMDAwMDAwMTAwMDAAMHg0MDAwMDAwMDMxAEHg+AALEQEAAAAGAAAAGAAAACQAAAAkAEGA+QAL/QQBAAAABgAAABIAAAAkAAAAJAAAADQ5YjM2MjQwMDAwMDAwMDI0OTA5MDAwMDAwMDAwMDA2Y2Q4MDAwMDAwMDAwMDAwNwAyYTAxZmFiN2UwNGEwMTdiOWMwZWIzMWZmMzZiZjMzNTcAMzc5MzdjYTY4OGE2YjQ5MDQANjE4MTgwMDAwMDAwMDAwMjg1MDAwMDAwMDAwMDAwMDQAODEwMDAwMDAwMDAwMDAwMQAtNjE4MTgwMDAwMDAwMDAwMjA0MDAwMDAwMDAwMDAwMDMALTQwODAwMDAwMDAwMDAwMDEAZTAwYThlN2Y1NmUwMDdlNWIwOWZlN2ZkZjQzYmE5OTgALTE1MmFmZjU2YTgwNTRhYmY5ZGE3NWRiMmRhM2Q2ODg1MTAxZTVmZDM5OTdkNDFjYjEALWE5NTdmYWI1NDAyYTU1ZmNlZDNhZWQ5NmQxZWI0NDI5NWY0MGYxMzZlZTg0ZTA5YgAtZTAwYThlN2Y1NmUwMDdlOTI5ZDdiMjY2N2VhNmYyOWMAQkxTX1NJR19CTFMxMjM4MUcxX1hNRDpTSEEtMjU2X1NTV1VfUk9fUE9QXwBCTFNfU0lHX0JMUzEyMzgxRzJfWE1EOlNIQS0yNTZfU1NXVV9ST19QT1BfADAxMjM0NTY3ODlhYmNkZWYAMDEyMzQ1Njc4OUFCQ0RFRgAAAAC4DgAA3A4AAAAPAAAkDwAASA8AAGwPAACQDwAAtA8AANgPAAD8DwAAJDsAADg7AABMOwAAYDsAAHQ7AACIOwAAnDsAAF9fY3hhX2d1YXJkX2FjcXVpcmUgZGV0ZWN0ZWQgcmVjdXJzaXZlIGluaXRpYWxpemF0aW9uAEGA/gALI189AACAPQAAsz0AAOU9AABfPgAAcD4AAF8+AABwPgAAMINQ";

  if (!isDataURI(wasmBinaryFile)) {
   wasmBinaryFile = locateFile(wasmBinaryFile);
  }

  function getBinary() {
   try {
    if (wasmBinary) {
     return new Uint8Array(wasmBinary);
    }
    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
     return binary;
    }
    if (readBinary) {
     return readBinary(wasmBinaryFile);
    } else {
     throw "both async and sync fetching of the wasm failed";
    }
   } catch (err) {
    abort(err);
   }
  }

  function getBinaryPromise() {
   if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
    return fetch(wasmBinaryFile, {
     credentials: "same-origin"
    }).then(function(response) {
     if (!response["ok"]) {
      throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
     }
     return response["arrayBuffer"]();
    }).catch(function() {
     return getBinary();
    });
   }
   return Promise.resolve().then(getBinary);
  }

  function createWasm() {
   var info = {
    "a": asmLibraryArg
   };
   function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module["asm"] = exports;
    wasmTable = Module["asm"]["e"];
    removeRunDependency();
   }
   addRunDependency();
   function receiveInstantiatedSource(output) {
    receiveInstance(output["instance"]);
   }
   function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
     return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
     err("failed to asynchronously prepare wasm: " + reason);
     abort(reason);
    });
   }
   function instantiateAsync() {
    if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
     fetch(wasmBinaryFile, {
      credentials: "same-origin"
     }).then(function(response) {
      var result = WebAssembly.instantiateStreaming(response, info);
      return result.then(receiveInstantiatedSource, function(reason) {
       err("wasm streaming compile failed: " + reason);
       err("falling back to ArrayBuffer instantiation");
       return instantiateArrayBuffer(receiveInstantiatedSource);
      });
     });
    } else {
     return instantiateArrayBuffer(receiveInstantiatedSource);
    }
   }
   if (Module["instantiateWasm"]) {
    try {
     var exports = Module["instantiateWasm"](info, receiveInstance);
     return exports;
    } catch (e) {
     err("Module.instantiateWasm callback failed with error: " + e);
     return false;
    }
   }
   instantiateAsync();
   return {};
  }

  var ASM_CONSTS = {
   3246: function($0, $1) {
    Module.cryptoGetRandomValues($0, $1);
   }
  };

  function callRuntimeCallbacks(callbacks) {
   while (callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == "function") {
     callback(Module);
     continue;
    }
    var func = callback.func;
    if (typeof func === "number") {
     if (callback.arg === undefined) {
      wasmTable.get(func)();
     } else {
      wasmTable.get(func)(callback.arg);
     }
    } else {
     func(callback.arg === undefined ? null : callback.arg);
    }
   }
  }

  function _emscripten_asm_const_int(code, sigPtr, argbuf) {
   var args = readAsmConstArgs(sigPtr, argbuf);
   return ASM_CONSTS[code].apply(null, args);
  }

  function _emscripten_memcpy_big(dest, src, num) {
   HEAPU8.copyWithin(dest, src, src + num);
  }

  function _emscripten_resize_heap(requestedSize) {
   return false;
  }

  var readAsmConstArgsArray = [];

  function readAsmConstArgs(sigPtr, buf) {
   readAsmConstArgsArray.length = 0;
   var ch;
   buf >>= 2;
   while (ch = HEAPU8[sigPtr++]) {
    var double = ch < 105;
    if (double && buf & 1) buf++;
    readAsmConstArgsArray.push(double ? HEAPF64[buf++ >> 1] : HEAP32[buf]);
    ++buf;
   }
   return readAsmConstArgsArray;
  }

  function intArrayToString(array) {
   var ret = [];
   for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 255) {
     chr &= 255;
    }
    ret.push(String.fromCharCode(chr));
   }
   return ret.join("");
  }

  var decodeBase64 = typeof atob === "function" ? atob : function(input) {
   var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
   var output = "";
   var chr1, chr2, chr3;
   var enc1, enc2, enc3, enc4;
   var i = 0;
   input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
   do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output = output + String.fromCharCode(chr1);
    if (enc3 !== 64) {
     output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
     output = output + String.fromCharCode(chr3);
    }
   } while (i < input.length);
   return output;
  };

  function intArrayFromBase64(s) {
   if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
     buf = Buffer$8.from(s, "base64");
    } catch (_) {
     buf = new Buffer$8(s, "base64");
    }
    return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
   }
   try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0; i < decoded.length; ++i) {
     bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
   } catch (_) {
    throw new Error("Converting base64 string to bytes failed.");
   }
  }

  function tryParseAsDataURI(filename) {
   if (!isDataURI(filename)) {
    return;
   }
   return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }

  __ATINIT__.push({
   func: function() {
    ___wasm_call_ctors();
   }
  });

  var asmLibraryArg = {
   "d": _emscripten_asm_const_int,
   "b": _emscripten_memcpy_big,
   "c": _emscripten_resize_heap,
   "a": wasmMemory
  };

  createWasm();

  var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
   return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["f"]).apply(null, arguments);
  };

  Module["_mclBnMalloc"] = function() {
   return (Module["_mclBnMalloc"] = Module["asm"]["g"]).apply(null, arguments);
  };

  Module["_mclBnFree"] = function() {
   return (Module["_mclBnFree"] = Module["asm"]["h"]).apply(null, arguments);
  };

  Module["_mclBn_getVersion"] = function() {
   return (Module["_mclBn_getVersion"] = Module["asm"]["i"]).apply(null, arguments);
  };

  Module["_mclBn_init"] = function() {
   return (Module["_mclBn_init"] = Module["asm"]["j"]).apply(null, arguments);
  };

  Module["_mclBn_getCurveType"] = function() {
   return (Module["_mclBn_getCurveType"] = Module["asm"]["k"]).apply(null, arguments);
  };

  Module["_mclBn_getOpUnitSize"] = function() {
   return (Module["_mclBn_getOpUnitSize"] = Module["asm"]["l"]).apply(null, arguments);
  };

  Module["_mclBn_getG1ByteSize"] = function() {
   return (Module["_mclBn_getG1ByteSize"] = Module["asm"]["m"]).apply(null, arguments);
  };

  Module["_mclBn_getFpByteSize"] = function() {
   return (Module["_mclBn_getFpByteSize"] = Module["asm"]["n"]).apply(null, arguments);
  };

  Module["_mclBn_getFrByteSize"] = function() {
   return (Module["_mclBn_getFrByteSize"] = Module["asm"]["o"]).apply(null, arguments);
  };

  Module["_mclBn_getCurveOrder"] = function() {
   return (Module["_mclBn_getCurveOrder"] = Module["asm"]["p"]).apply(null, arguments);
  };

  Module["_mclBn_getFieldOrder"] = function() {
   return (Module["_mclBn_getFieldOrder"] = Module["asm"]["q"]).apply(null, arguments);
  };

  Module["_mclBn_setETHserialization"] = function() {
   return (Module["_mclBn_setETHserialization"] = Module["asm"]["r"]).apply(null, arguments);
  };

  Module["_mclBn_getETHserialization"] = function() {
   return (Module["_mclBn_getETHserialization"] = Module["asm"]["s"]).apply(null, arguments);
  };

  Module["_mclBn_setMapToMode"] = function() {
   return (Module["_mclBn_setMapToMode"] = Module["asm"]["t"]).apply(null, arguments);
  };

  Module["_mclBnFr_clear"] = function() {
   return (Module["_mclBnFr_clear"] = Module["asm"]["u"]).apply(null, arguments);
  };

  Module["_mclBnFr_setInt"] = function() {
   return (Module["_mclBnFr_setInt"] = Module["asm"]["v"]).apply(null, arguments);
  };

  Module["_mclBnFr_setInt32"] = function() {
   return (Module["_mclBnFr_setInt32"] = Module["asm"]["w"]).apply(null, arguments);
  };

  Module["_mclBnFr_setStr"] = function() {
   return (Module["_mclBnFr_setStr"] = Module["asm"]["x"]).apply(null, arguments);
  };

  Module["_mclBnFr_setLittleEndian"] = function() {
   return (Module["_mclBnFr_setLittleEndian"] = Module["asm"]["y"]).apply(null, arguments);
  };

  Module["_mclBnFr_setBigEndianMod"] = function() {
   return (Module["_mclBnFr_setBigEndianMod"] = Module["asm"]["z"]).apply(null, arguments);
  };

  Module["_mclBnFr_getLittleEndian"] = function() {
   return (Module["_mclBnFr_getLittleEndian"] = Module["asm"]["A"]).apply(null, arguments);
  };

  Module["_mclBnFr_setLittleEndianMod"] = function() {
   return (Module["_mclBnFr_setLittleEndianMod"] = Module["asm"]["B"]).apply(null, arguments);
  };

  Module["_mclBnFr_deserialize"] = function() {
   return (Module["_mclBnFr_deserialize"] = Module["asm"]["C"]).apply(null, arguments);
  };

  Module["_mclBnFr_isValid"] = function() {
   return (Module["_mclBnFr_isValid"] = Module["asm"]["D"]).apply(null, arguments);
  };

  Module["_mclBnFr_isEqual"] = function() {
   return (Module["_mclBnFr_isEqual"] = Module["asm"]["E"]).apply(null, arguments);
  };

  Module["_mclBnFr_isZero"] = function() {
   return (Module["_mclBnFr_isZero"] = Module["asm"]["F"]).apply(null, arguments);
  };

  Module["_mclBnFr_isOne"] = function() {
   return (Module["_mclBnFr_isOne"] = Module["asm"]["G"]).apply(null, arguments);
  };

  Module["_mclBnFr_isOdd"] = function() {
   return (Module["_mclBnFr_isOdd"] = Module["asm"]["H"]).apply(null, arguments);
  };

  Module["_mclBnFr_isNegative"] = function() {
   return (Module["_mclBnFr_isNegative"] = Module["asm"]["I"]).apply(null, arguments);
  };

  Module["_mclBnFr_setByCSPRNG"] = function() {
   return (Module["_mclBnFr_setByCSPRNG"] = Module["asm"]["J"]).apply(null, arguments);
  };

  Module["_mclBnFp_setByCSPRNG"] = function() {
   return (Module["_mclBnFp_setByCSPRNG"] = Module["asm"]["K"]).apply(null, arguments);
  };

  Module["_mclBn_setRandFunc"] = function() {
   return (Module["_mclBn_setRandFunc"] = Module["asm"]["L"]).apply(null, arguments);
  };

  Module["_mclBnFr_setHashOf"] = function() {
   return (Module["_mclBnFr_setHashOf"] = Module["asm"]["M"]).apply(null, arguments);
  };

  Module["_mclBnFr_getStr"] = function() {
   return (Module["_mclBnFr_getStr"] = Module["asm"]["N"]).apply(null, arguments);
  };

  Module["_mclBnFr_serialize"] = function() {
   return (Module["_mclBnFr_serialize"] = Module["asm"]["O"]).apply(null, arguments);
  };

  Module["_mclBnFr_neg"] = function() {
   return (Module["_mclBnFr_neg"] = Module["asm"]["P"]).apply(null, arguments);
  };

  Module["_mclBnFr_inv"] = function() {
   return (Module["_mclBnFr_inv"] = Module["asm"]["Q"]).apply(null, arguments);
  };

  Module["_mclBnFr_sqr"] = function() {
   return (Module["_mclBnFr_sqr"] = Module["asm"]["R"]).apply(null, arguments);
  };

  Module["_mclBnFr_add"] = function() {
   return (Module["_mclBnFr_add"] = Module["asm"]["S"]).apply(null, arguments);
  };

  Module["_mclBnFr_sub"] = function() {
   return (Module["_mclBnFr_sub"] = Module["asm"]["T"]).apply(null, arguments);
  };

  Module["_mclBnFr_mul"] = function() {
   return (Module["_mclBnFr_mul"] = Module["asm"]["U"]).apply(null, arguments);
  };

  Module["_mclBnFr_div"] = function() {
   return (Module["_mclBnFr_div"] = Module["asm"]["V"]).apply(null, arguments);
  };

  Module["_mclBnFp_neg"] = function() {
   return (Module["_mclBnFp_neg"] = Module["asm"]["W"]).apply(null, arguments);
  };

  Module["_mclBnFp_inv"] = function() {
   return (Module["_mclBnFp_inv"] = Module["asm"]["X"]).apply(null, arguments);
  };

  Module["_mclBnFp_sqr"] = function() {
   return (Module["_mclBnFp_sqr"] = Module["asm"]["Y"]).apply(null, arguments);
  };

  Module["_mclBnFp_add"] = function() {
   return (Module["_mclBnFp_add"] = Module["asm"]["Z"]).apply(null, arguments);
  };

  Module["_mclBnFp_sub"] = function() {
   return (Module["_mclBnFp_sub"] = Module["asm"]["_"]).apply(null, arguments);
  };

  Module["_mclBnFp_mul"] = function() {
   return (Module["_mclBnFp_mul"] = Module["asm"]["$"]).apply(null, arguments);
  };

  Module["_mclBnFp_div"] = function() {
   return (Module["_mclBnFp_div"] = Module["asm"]["aa"]).apply(null, arguments);
  };

  Module["_mclBnFp2_neg"] = function() {
   return (Module["_mclBnFp2_neg"] = Module["asm"]["ba"]).apply(null, arguments);
  };

  Module["_mclBnFp2_inv"] = function() {
   return (Module["_mclBnFp2_inv"] = Module["asm"]["ca"]).apply(null, arguments);
  };

  Module["_mclBnFp2_sqr"] = function() {
   return (Module["_mclBnFp2_sqr"] = Module["asm"]["da"]).apply(null, arguments);
  };

  Module["_mclBnFp2_add"] = function() {
   return (Module["_mclBnFp2_add"] = Module["asm"]["ea"]).apply(null, arguments);
  };

  Module["_mclBnFp2_sub"] = function() {
   return (Module["_mclBnFp2_sub"] = Module["asm"]["fa"]).apply(null, arguments);
  };

  Module["_mclBnFp2_mul"] = function() {
   return (Module["_mclBnFp2_mul"] = Module["asm"]["ga"]).apply(null, arguments);
  };

  Module["_mclBnFp2_div"] = function() {
   return (Module["_mclBnFp2_div"] = Module["asm"]["ha"]).apply(null, arguments);
  };

  Module["_mclBnFr_squareRoot"] = function() {
   return (Module["_mclBnFr_squareRoot"] = Module["asm"]["ia"]).apply(null, arguments);
  };

  Module["_mclBnFp_squareRoot"] = function() {
   return (Module["_mclBnFp_squareRoot"] = Module["asm"]["ja"]).apply(null, arguments);
  };

  Module["_mclBnFp2_squareRoot"] = function() {
   return (Module["_mclBnFp2_squareRoot"] = Module["asm"]["ka"]).apply(null, arguments);
  };

  Module["_mclBnG1_clear"] = function() {
   return (Module["_mclBnG1_clear"] = Module["asm"]["la"]).apply(null, arguments);
  };

  Module["_mclBnG1_setStr"] = function() {
   return (Module["_mclBnG1_setStr"] = Module["asm"]["ma"]).apply(null, arguments);
  };

  Module["_mclBnG1_deserialize"] = function() {
   return (Module["_mclBnG1_deserialize"] = Module["asm"]["na"]).apply(null, arguments);
  };

  Module["_mclBnG1_isValid"] = function() {
   return (Module["_mclBnG1_isValid"] = Module["asm"]["oa"]).apply(null, arguments);
  };

  Module["_mclBnG1_isEqual"] = function() {
   return (Module["_mclBnG1_isEqual"] = Module["asm"]["pa"]).apply(null, arguments);
  };

  Module["_mclBnG1_isZero"] = function() {
   return (Module["_mclBnG1_isZero"] = Module["asm"]["qa"]).apply(null, arguments);
  };

  Module["_mclBnG1_isValidOrder"] = function() {
   return (Module["_mclBnG1_isValidOrder"] = Module["asm"]["ra"]).apply(null, arguments);
  };

  Module["_mclBnG1_hashAndMapTo"] = function() {
   return (Module["_mclBnG1_hashAndMapTo"] = Module["asm"]["sa"]).apply(null, arguments);
  };

  Module["_mclBnG1_getStr"] = function() {
   return (Module["_mclBnG1_getStr"] = Module["asm"]["ta"]).apply(null, arguments);
  };

  Module["_mclBnG1_serialize"] = function() {
   return (Module["_mclBnG1_serialize"] = Module["asm"]["ua"]).apply(null, arguments);
  };

  Module["_mclBnG1_neg"] = function() {
   return (Module["_mclBnG1_neg"] = Module["asm"]["va"]).apply(null, arguments);
  };

  Module["_mclBnG1_dbl"] = function() {
   return (Module["_mclBnG1_dbl"] = Module["asm"]["wa"]).apply(null, arguments);
  };

  Module["_mclBnG1_normalize"] = function() {
   return (Module["_mclBnG1_normalize"] = Module["asm"]["xa"]).apply(null, arguments);
  };

  Module["_mclBnG1_add"] = function() {
   return (Module["_mclBnG1_add"] = Module["asm"]["ya"]).apply(null, arguments);
  };

  Module["_mclBnG1_sub"] = function() {
   return (Module["_mclBnG1_sub"] = Module["asm"]["za"]).apply(null, arguments);
  };

  Module["_mclBnG1_mul"] = function() {
   return (Module["_mclBnG1_mul"] = Module["asm"]["Aa"]).apply(null, arguments);
  };

  Module["_mclBnG1_mulCT"] = function() {
   return (Module["_mclBnG1_mulCT"] = Module["asm"]["Ba"]).apply(null, arguments);
  };

  Module["_mclBnG2_clear"] = function() {
   return (Module["_mclBnG2_clear"] = Module["asm"]["Ca"]).apply(null, arguments);
  };

  Module["_mclBnG2_setStr"] = function() {
   return (Module["_mclBnG2_setStr"] = Module["asm"]["Da"]).apply(null, arguments);
  };

  Module["_mclBnG2_deserialize"] = function() {
   return (Module["_mclBnG2_deserialize"] = Module["asm"]["Ea"]).apply(null, arguments);
  };

  Module["_mclBnG2_isValid"] = function() {
   return (Module["_mclBnG2_isValid"] = Module["asm"]["Fa"]).apply(null, arguments);
  };

  Module["_mclBnG2_isEqual"] = function() {
   return (Module["_mclBnG2_isEqual"] = Module["asm"]["Ga"]).apply(null, arguments);
  };

  Module["_mclBnG2_isZero"] = function() {
   return (Module["_mclBnG2_isZero"] = Module["asm"]["Ha"]).apply(null, arguments);
  };

  Module["_mclBnG2_isValidOrder"] = function() {
   return (Module["_mclBnG2_isValidOrder"] = Module["asm"]["Ia"]).apply(null, arguments);
  };

  Module["_mclBnG2_hashAndMapTo"] = function() {
   return (Module["_mclBnG2_hashAndMapTo"] = Module["asm"]["Ja"]).apply(null, arguments);
  };

  Module["_mclBnG2_getStr"] = function() {
   return (Module["_mclBnG2_getStr"] = Module["asm"]["Ka"]).apply(null, arguments);
  };

  Module["_mclBnG2_serialize"] = function() {
   return (Module["_mclBnG2_serialize"] = Module["asm"]["La"]).apply(null, arguments);
  };

  Module["_mclBnG2_neg"] = function() {
   return (Module["_mclBnG2_neg"] = Module["asm"]["Ma"]).apply(null, arguments);
  };

  Module["_mclBnG2_dbl"] = function() {
   return (Module["_mclBnG2_dbl"] = Module["asm"]["Na"]).apply(null, arguments);
  };

  Module["_mclBnG2_normalize"] = function() {
   return (Module["_mclBnG2_normalize"] = Module["asm"]["Oa"]).apply(null, arguments);
  };

  Module["_mclBnG2_add"] = function() {
   return (Module["_mclBnG2_add"] = Module["asm"]["Pa"]).apply(null, arguments);
  };

  Module["_mclBnG2_sub"] = function() {
   return (Module["_mclBnG2_sub"] = Module["asm"]["Qa"]).apply(null, arguments);
  };

  Module["_mclBnG2_mul"] = function() {
   return (Module["_mclBnG2_mul"] = Module["asm"]["Ra"]).apply(null, arguments);
  };

  Module["_mclBnG2_mulCT"] = function() {
   return (Module["_mclBnG2_mulCT"] = Module["asm"]["Sa"]).apply(null, arguments);
  };

  Module["_mclBnGT_clear"] = function() {
   return (Module["_mclBnGT_clear"] = Module["asm"]["Ta"]).apply(null, arguments);
  };

  Module["_mclBnGT_setInt"] = function() {
   return (Module["_mclBnGT_setInt"] = Module["asm"]["Ua"]).apply(null, arguments);
  };

  Module["_mclBnGT_setInt32"] = function() {
   return (Module["_mclBnGT_setInt32"] = Module["asm"]["Va"]).apply(null, arguments);
  };

  Module["_mclBnGT_setStr"] = function() {
   return (Module["_mclBnGT_setStr"] = Module["asm"]["Wa"]).apply(null, arguments);
  };

  Module["_mclBnGT_deserialize"] = function() {
   return (Module["_mclBnGT_deserialize"] = Module["asm"]["Xa"]).apply(null, arguments);
  };

  Module["_mclBnGT_isEqual"] = function() {
   return (Module["_mclBnGT_isEqual"] = Module["asm"]["Ya"]).apply(null, arguments);
  };

  Module["_mclBnGT_isZero"] = function() {
   return (Module["_mclBnGT_isZero"] = Module["asm"]["Za"]).apply(null, arguments);
  };

  Module["_mclBnGT_isOne"] = function() {
   return (Module["_mclBnGT_isOne"] = Module["asm"]["_a"]).apply(null, arguments);
  };

  Module["_mclBnGT_getStr"] = function() {
   return (Module["_mclBnGT_getStr"] = Module["asm"]["$a"]).apply(null, arguments);
  };

  Module["_mclBnGT_serialize"] = function() {
   return (Module["_mclBnGT_serialize"] = Module["asm"]["ab"]).apply(null, arguments);
  };

  Module["_mclBnGT_neg"] = function() {
   return (Module["_mclBnGT_neg"] = Module["asm"]["bb"]).apply(null, arguments);
  };

  Module["_mclBnGT_inv"] = function() {
   return (Module["_mclBnGT_inv"] = Module["asm"]["cb"]).apply(null, arguments);
  };

  Module["_mclBnGT_invGeneric"] = function() {
   return (Module["_mclBnGT_invGeneric"] = Module["asm"]["db"]).apply(null, arguments);
  };

  Module["_mclBnGT_sqr"] = function() {
   return (Module["_mclBnGT_sqr"] = Module["asm"]["eb"]).apply(null, arguments);
  };

  Module["_mclBnGT_add"] = function() {
   return (Module["_mclBnGT_add"] = Module["asm"]["fb"]).apply(null, arguments);
  };

  Module["_mclBnGT_sub"] = function() {
   return (Module["_mclBnGT_sub"] = Module["asm"]["gb"]).apply(null, arguments);
  };

  Module["_mclBnGT_mul"] = function() {
   return (Module["_mclBnGT_mul"] = Module["asm"]["hb"]).apply(null, arguments);
  };

  Module["_mclBnGT_div"] = function() {
   return (Module["_mclBnGT_div"] = Module["asm"]["ib"]).apply(null, arguments);
  };

  Module["_mclBnGT_pow"] = function() {
   return (Module["_mclBnGT_pow"] = Module["asm"]["jb"]).apply(null, arguments);
  };

  Module["_mclBnGT_powGeneric"] = function() {
   return (Module["_mclBnGT_powGeneric"] = Module["asm"]["kb"]).apply(null, arguments);
  };

  Module["_mclBnG1_mulVec"] = function() {
   return (Module["_mclBnG1_mulVec"] = Module["asm"]["lb"]).apply(null, arguments);
  };

  Module["_mclBnG2_mulVec"] = function() {
   return (Module["_mclBnG2_mulVec"] = Module["asm"]["mb"]).apply(null, arguments);
  };

  Module["_mclBnGT_powVec"] = function() {
   return (Module["_mclBnGT_powVec"] = Module["asm"]["nb"]).apply(null, arguments);
  };

  Module["_mclBn_pairing"] = function() {
   return (Module["_mclBn_pairing"] = Module["asm"]["ob"]).apply(null, arguments);
  };

  Module["_mclBn_finalExp"] = function() {
   return (Module["_mclBn_finalExp"] = Module["asm"]["pb"]).apply(null, arguments);
  };

  Module["_mclBn_millerLoop"] = function() {
   return (Module["_mclBn_millerLoop"] = Module["asm"]["qb"]).apply(null, arguments);
  };

  Module["_mclBn_millerLoopVec"] = function() {
   return (Module["_mclBn_millerLoopVec"] = Module["asm"]["rb"]).apply(null, arguments);
  };

  Module["_mclBn_getUint64NumToPrecompute"] = function() {
   return (Module["_mclBn_getUint64NumToPrecompute"] = Module["asm"]["sb"]).apply(null, arguments);
  };

  Module["_mclBn_precomputeG2"] = function() {
   return (Module["_mclBn_precomputeG2"] = Module["asm"]["tb"]).apply(null, arguments);
  };

  Module["_mclBn_precomputedMillerLoop"] = function() {
   return (Module["_mclBn_precomputedMillerLoop"] = Module["asm"]["ub"]).apply(null, arguments);
  };

  Module["_mclBn_precomputedMillerLoop2"] = function() {
   return (Module["_mclBn_precomputedMillerLoop2"] = Module["asm"]["vb"]).apply(null, arguments);
  };

  Module["_mclBn_precomputedMillerLoop2mixed"] = function() {
   return (Module["_mclBn_precomputedMillerLoop2mixed"] = Module["asm"]["wb"]).apply(null, arguments);
  };

  Module["_mclBn_FrLagrangeInterpolation"] = function() {
   return (Module["_mclBn_FrLagrangeInterpolation"] = Module["asm"]["xb"]).apply(null, arguments);
  };

  Module["_mclBn_G1LagrangeInterpolation"] = function() {
   return (Module["_mclBn_G1LagrangeInterpolation"] = Module["asm"]["yb"]).apply(null, arguments);
  };

  Module["_mclBn_G2LagrangeInterpolation"] = function() {
   return (Module["_mclBn_G2LagrangeInterpolation"] = Module["asm"]["zb"]).apply(null, arguments);
  };

  Module["_mclBn_FrEvaluatePolynomial"] = function() {
   return (Module["_mclBn_FrEvaluatePolynomial"] = Module["asm"]["Ab"]).apply(null, arguments);
  };

  Module["_mclBn_G1EvaluatePolynomial"] = function() {
   return (Module["_mclBn_G1EvaluatePolynomial"] = Module["asm"]["Bb"]).apply(null, arguments);
  };

  Module["_mclBn_G2EvaluatePolynomial"] = function() {
   return (Module["_mclBn_G2EvaluatePolynomial"] = Module["asm"]["Cb"]).apply(null, arguments);
  };

  Module["_mclBn_verifyOrderG1"] = function() {
   return (Module["_mclBn_verifyOrderG1"] = Module["asm"]["Db"]).apply(null, arguments);
  };

  Module["_mclBn_verifyOrderG2"] = function() {
   return (Module["_mclBn_verifyOrderG2"] = Module["asm"]["Eb"]).apply(null, arguments);
  };

  Module["_mclBnFp_setInt"] = function() {
   return (Module["_mclBnFp_setInt"] = Module["asm"]["Fb"]).apply(null, arguments);
  };

  Module["_mclBnFp_setInt32"] = function() {
   return (Module["_mclBnFp_setInt32"] = Module["asm"]["Gb"]).apply(null, arguments);
  };

  Module["_mclBnFp_getStr"] = function() {
   return (Module["_mclBnFp_getStr"] = Module["asm"]["Hb"]).apply(null, arguments);
  };

  Module["_mclBnFp_setStr"] = function() {
   return (Module["_mclBnFp_setStr"] = Module["asm"]["Ib"]).apply(null, arguments);
  };

  Module["_mclBnFp_deserialize"] = function() {
   return (Module["_mclBnFp_deserialize"] = Module["asm"]["Jb"]).apply(null, arguments);
  };

  Module["_mclBnFp_serialize"] = function() {
   return (Module["_mclBnFp_serialize"] = Module["asm"]["Kb"]).apply(null, arguments);
  };

  Module["_mclBnFp_clear"] = function() {
   return (Module["_mclBnFp_clear"] = Module["asm"]["Lb"]).apply(null, arguments);
  };

  Module["_mclBnFp_setLittleEndian"] = function() {
   return (Module["_mclBnFp_setLittleEndian"] = Module["asm"]["Mb"]).apply(null, arguments);
  };

  Module["_mclBnFp_setLittleEndianMod"] = function() {
   return (Module["_mclBnFp_setLittleEndianMod"] = Module["asm"]["Nb"]).apply(null, arguments);
  };

  Module["_mclBnFp_setBigEndianMod"] = function() {
   return (Module["_mclBnFp_setBigEndianMod"] = Module["asm"]["Ob"]).apply(null, arguments);
  };

  Module["_mclBnFp_getLittleEndian"] = function() {
   return (Module["_mclBnFp_getLittleEndian"] = Module["asm"]["Pb"]).apply(null, arguments);
  };

  Module["_mclBnFp_isValid"] = function() {
   return (Module["_mclBnFp_isValid"] = Module["asm"]["Qb"]).apply(null, arguments);
  };

  Module["_mclBnFp_isEqual"] = function() {
   return (Module["_mclBnFp_isEqual"] = Module["asm"]["Rb"]).apply(null, arguments);
  };

  Module["_mclBnFp_isZero"] = function() {
   return (Module["_mclBnFp_isZero"] = Module["asm"]["Sb"]).apply(null, arguments);
  };

  Module["_mclBnFp_isOne"] = function() {
   return (Module["_mclBnFp_isOne"] = Module["asm"]["Tb"]).apply(null, arguments);
  };

  Module["_mclBnFp_isOdd"] = function() {
   return (Module["_mclBnFp_isOdd"] = Module["asm"]["Ub"]).apply(null, arguments);
  };

  Module["_mclBnFp_isNegative"] = function() {
   return (Module["_mclBnFp_isNegative"] = Module["asm"]["Vb"]).apply(null, arguments);
  };

  Module["_mclBnFp_setHashOf"] = function() {
   return (Module["_mclBnFp_setHashOf"] = Module["asm"]["Wb"]).apply(null, arguments);
  };

  Module["_mclBnFp_mapToG1"] = function() {
   return (Module["_mclBnFp_mapToG1"] = Module["asm"]["Xb"]).apply(null, arguments);
  };

  Module["_mclBnFp2_deserialize"] = function() {
   return (Module["_mclBnFp2_deserialize"] = Module["asm"]["Yb"]).apply(null, arguments);
  };

  Module["_mclBnFp2_serialize"] = function() {
   return (Module["_mclBnFp2_serialize"] = Module["asm"]["Zb"]).apply(null, arguments);
  };

  Module["_mclBnFp2_clear"] = function() {
   return (Module["_mclBnFp2_clear"] = Module["asm"]["_b"]).apply(null, arguments);
  };

  Module["_mclBnFp2_isEqual"] = function() {
   return (Module["_mclBnFp2_isEqual"] = Module["asm"]["$b"]).apply(null, arguments);
  };

  Module["_mclBnFp2_isZero"] = function() {
   return (Module["_mclBnFp2_isZero"] = Module["asm"]["ac"]).apply(null, arguments);
  };

  Module["_mclBnFp2_isOne"] = function() {
   return (Module["_mclBnFp2_isOne"] = Module["asm"]["bc"]).apply(null, arguments);
  };

  Module["_mclBnFp2_mapToG2"] = function() {
   return (Module["_mclBnFp2_mapToG2"] = Module["asm"]["cc"]).apply(null, arguments);
  };

  Module["_mclBnG1_getBasePoint"] = function() {
   return (Module["_mclBnG1_getBasePoint"] = Module["asm"]["dc"]).apply(null, arguments);
  };

  var calledRun;

  dependenciesFulfilled = function runCaller() {
   if (!calledRun) run();
   if (!calledRun) dependenciesFulfilled = runCaller;
  };

  function run(args) {
   if (runDependencies > 0) {
    return;
   }
   preRun();
   if (runDependencies > 0) return;
   function doRun() {
    if (calledRun) return;
    calledRun = true;
    Module["calledRun"] = true;
    if (ABORT) return;
    initRuntime();
    preMain();
    readyPromiseResolve(Module);
    if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
    postRun();
   }
   if (Module["setStatus"]) {
    Module["setStatus"]("Running...");
    setTimeout(function() {
     setTimeout(function() {
      Module["setStatus"]("");
     }, 1);
     doRun();
    }, 1);
   } else {
    doRun();
   }
  }

  Module["run"] = run;

  if (Module["preInit"]) {
   if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
   while (Module["preInit"].length > 0) {
    Module["preInit"].pop()();
   }
  }

  run();


    return Module.ready
  }
  );
  })();
  module.exports = Module;
  }(mcl_c));

  const _mclSetupFactory = (createModule, getRandomValues) => {
    const exports = {};
    /* eslint-disable */
    exports.BN254 = 0;
    exports.BN381_1 = 1;
    exports.BN381_2 = 2;
    exports.BN462 = 3;
    exports.BN_SNARK1 = 4;
    exports.BLS12_381 = 5;

    exports.SECP224K1 = 101;
    exports.SECP256K1 = 102;
    exports.SECP384R1 = 103;
    exports.NIST_P192 = 105;
    exports.NIST_P224 = 106;
    exports.NIST_P256 = 107;

    exports.IRTF = 5; /* MCL_MAP_TO_MODE_HASH_TO_CURVE_07 */
    exports.EC_PROJ = 1024; /* flag for G1/G2.getStr */

    const setup = (exports, curveType) => {
      const mod = exports.mod;
      const MCLBN_FP_UNIT_SIZE = 6;
      const MCLBN_FR_UNIT_SIZE = 4;
      const MCLBN_COMPILED_TIME_VAR = (MCLBN_FR_UNIT_SIZE * 10 + MCLBN_FP_UNIT_SIZE);
      const MCLBN_FP_SIZE = MCLBN_FP_UNIT_SIZE * 8;
      const MCLBN_FR_SIZE = MCLBN_FR_UNIT_SIZE * 8;
      const MCLBN_G1_SIZE = MCLBN_FP_SIZE * 3;
      const MCLBN_G2_SIZE = MCLBN_FP_SIZE * 6;
      const MCLBN_GT_SIZE = MCLBN_FP_SIZE * 12;

      const _malloc = size => {
        return mod._mclBnMalloc(size)
      };
      const _free = pos => {
        mod._mclBnFree(pos);
      };
      const ptrToAsciiStr = (pos, n) => {
        let s = '';
        for (let i = 0; i < n; i++) {
          s += String.fromCharCode(mod.HEAP8[pos + i]);
        }
        return s
      };
      const asciiStrToPtr = (pos, s) => {
        for (let i = 0; i < s.length; i++) {
          mod.HEAP8[pos + i] = s.charCodeAt(i);
        }
      };
      exports.toHex = (a, start, n) => {
        let s = '';
        for (let i = 0; i < n; i++) {
          s += ('0' + a[start + i].toString(16)).slice(-2);
        }
        return s
      };
      // Uint8Array to hex string
      exports.toHexStr = a => {
        return exports.toHex(a, 0, a.length)
      };
      // hex string to Uint8Array
      exports.fromHexStr = s => {
        if (s.length & 1) throw new Error('fromHexStr:length must be even ' + s.length)
        const n = s.length / 2;
        const a = new Uint8Array(n);
        for (let i = 0; i < n; i++) {
          a[i] = parseInt(s.slice(i * 2, i * 2 + 2), 16);
        }
        return a
      };

      const _wrapGetStr = (func, returnAsStr = true) => {
        return (x, ioMode = 0) => {
          const maxBufSize = 3096;
          const pos = _malloc(maxBufSize);
          const n = func(pos, maxBufSize, x, ioMode);
          if (n <= 0) {
            throw new Error('err gen_str:' + x)
          }
          let s = null;
          if (returnAsStr) {
            s = ptrToAsciiStr(pos, n);
          } else {
            s = new Uint8Array(mod.HEAP8.subarray(pos, pos + n));
          }
          _free(pos);
          return s
        }
      };
      const _wrapSerialize = func => {
        return _wrapGetStr(func, false)
      };
      const _wrapDeserialize = func => {
        return (x, buf) => {
          const pos = _malloc(buf.length);
          mod.HEAP8.set(buf, pos);
          const r = func(x, pos, buf.length);
          _free(pos);
          if (r === 0 || r !== buf.length) throw new Error('err _wrapDeserialize', buf)
        }
      };
      /*
        argNum : n
        func(x0, ..., x_(n-1), buf, ioMode)
        => func(x0, ..., x_(n-1), pos, buf.length, ioMode)
      */
      const _wrapInput = (func, argNum) => {
        return function () {
          const args = [...arguments];
          const buf = args[argNum];
          const typeStr = Object.prototype.toString.apply(buf);
          if (['[object String]', '[object Uint8Array]', '[object Array]'].indexOf(typeStr) < 0) {
            throw new Error(`err bad type:"${typeStr}". Use String or Uint8Array.`)
          }
          const ioMode = args[argNum + 1]; // may undefined
          const pos = _malloc(buf.length);
          if (typeStr === '[object String]') {
            asciiStrToPtr(pos, buf);
          } else {
            mod.HEAP8.set(buf, pos);
          }
          const r = func(...args.slice(0, argNum), pos, buf.length, ioMode);
          _free(pos);
          if (r) throw new Error('err _wrapInput ' + buf)
        }
      };
      const _mulVec = (func, xVec, yVec, Cstr) => {
        const n = xVec.length;
        if (n != yVec.length) throw new Error(`err _mulVec bad length ${n}, ${yVec.length}`)
        const xSize = xVec[0].a_.length;
        const ySize = yVec[0].a_.length;
        const z = new Cstr();
        const zPos = z._alloc();
        const xPos = _malloc(xSize * n * 4);
        const yPos = _malloc(ySize * n * 4);
        let pos = xPos / 4;
        for (let i = 0; i < n; i++) {
          mod.HEAP32.set(xVec[i].a_, pos);
          pos += xSize;
        }
        pos = yPos / 4;
        for (let i = 0; i < n; i++) {
          mod.HEAP32.set(yVec[i].a_, pos);
          pos += ySize;
        }
        func(zPos, xPos, yPos, n);
        _free(yPos);
        _free(xPos);
        z._saveAndFree(zPos);
        return z
      };
      mod.mclBnFr_malloc = () => {
        return _malloc(MCLBN_FR_SIZE)
      };
      exports.free = x => {
        _free(x);
      };
      mod.mclBnFr_setLittleEndian = _wrapInput(mod._mclBnFr_setLittleEndian, 1);
      mod.mclBnFr_setLittleEndianMod = _wrapInput(mod._mclBnFr_setLittleEndianMod, 1);
      mod.mclBnFr_setBigEndianMod = _wrapInput(mod._mclBnFr_setBigEndianMod, 1);
      mod.mclBnFr_setStr = _wrapInput(mod._mclBnFr_setStr, 1);
      mod.mclBnFr_getStr = _wrapGetStr(mod._mclBnFr_getStr);
      mod.mclBnFr_deserialize = _wrapDeserialize(mod._mclBnFr_deserialize);
      mod.mclBnFr_serialize = _wrapSerialize(mod._mclBnFr_serialize);
      mod.mclBnFr_setHashOf = _wrapInput(mod._mclBnFr_setHashOf, 1);
      /// ////////////////////////////////////////////////////////////
      mod.mclBnFp_malloc = () => {
        return _malloc(MCLBN_FP_SIZE)
      };
      mod.mclBnFp_setLittleEndian = _wrapInput(mod._mclBnFp_setLittleEndian, 1);
      mod.mclBnFp_setLittleEndianMod = _wrapInput(mod._mclBnFp_setLittleEndianMod, 1);
      mod.mclBnFp_setBigEndianMod = _wrapInput(mod._mclBnFp_setBigEndianMod, 1);
      mod.mclBnFp_setStr = _wrapInput(mod._mclBnFp_setStr, 1);
      mod.mclBnFp_getStr = _wrapGetStr(mod._mclBnFp_getStr);
      mod.mclBnFp_deserialize = _wrapDeserialize(mod._mclBnFp_deserialize);
      mod.mclBnFp_serialize = _wrapSerialize(mod._mclBnFp_serialize);
      mod.mclBnFp_setHashOf = _wrapInput(mod._mclBnFp_setHashOf, 1);

      mod.mclBnFp2_malloc = () => {
        return _malloc(MCLBN_FP_SIZE * 2)
      };
      mod.mclBnFp2_deserialize = _wrapDeserialize(mod._mclBnFp2_deserialize);
      mod.mclBnFp2_serialize = _wrapSerialize(mod._mclBnFp2_serialize);

      /// ////////////////////////////////////////////////////////////
      mod.mclBnG1_malloc = () => {
        return _malloc(MCLBN_G1_SIZE)
      };
      mod.mclBnG1_setStr = _wrapInput(mod._mclBnG1_setStr, 1);
      mod.mclBnG1_getStr = _wrapGetStr(mod._mclBnG1_getStr);
      mod.mclBnG1_deserialize = _wrapDeserialize(mod._mclBnG1_deserialize);
      mod.mclBnG1_serialize = _wrapSerialize(mod._mclBnG1_serialize);
      mod.mclBnG1_hashAndMapTo = _wrapInput(mod._mclBnG1_hashAndMapTo, 1);

      /// ////////////////////////////////////////////////////////////
      mod.mclBnG2_malloc = () => {
        return _malloc(MCLBN_G2_SIZE)
      };
      mod.mclBnG2_setStr = _wrapInput(mod._mclBnG2_setStr, 1);
      mod.mclBnG2_getStr = _wrapGetStr(mod._mclBnG2_getStr);
      mod.mclBnG2_deserialize = _wrapDeserialize(mod._mclBnG2_deserialize);
      mod.mclBnG2_serialize = _wrapSerialize(mod._mclBnG2_serialize);
      mod.mclBnG2_hashAndMapTo = _wrapInput(mod._mclBnG2_hashAndMapTo, 1);

      /// ////////////////////////////////////////////////////////////
      mod.mclBnGT_malloc = () => {
        return _malloc(MCLBN_GT_SIZE)
      };
      mod.mclBnGT_deserialize = _wrapDeserialize(mod._mclBnGT_deserialize);
      mod.mclBnGT_serialize = _wrapSerialize(mod._mclBnGT_serialize);
      mod.mclBnGT_setStr = _wrapInput(mod._mclBnGT_setStr, 1);
      mod.mclBnGT_getStr = _wrapGetStr(mod._mclBnGT_getStr);
      /// ////////////////////////////////////////////////////////////

      class Common {
        constructor (size) {
          this.a_ = new Uint32Array(size / 4);
        }
        deserializeHexStr (s) {
          this.deserialize(exports.fromHexStr(s));
        }
        serializeToHexStr () {
          return exports.toHexStr(this.serialize())
        }
        dump (msg = '') {
          console.log(msg + this.serializeToHexStr());
        }
        clear () {
          this.a_.fill(0);
        }
        // copy to allocated memory
        copyToMem (pos) {
          mod.HEAP32.set(this.a_, pos / 4);
        }
        // copy from allocated memory
        copyFromMem (pos) {
          this.a_.set(mod.HEAP32.subarray(pos / 4, pos / 4 + this.a_.length));
        }
        // alloc new array
        _alloc () {
          return _malloc(this.a_.length * 4)
        }
        // alloc and copy a_ to mod.HEAP32[pos / 4]
        _allocAndCopy () {
          const pos = this._alloc();
          mod.HEAP32.set(this.a_, pos / 4);
          return pos
        }
        // save pos to a_
        _save (pos) {
          this.a_.set(mod.HEAP32.subarray(pos / 4, pos / 4 + this.a_.length));
        }
        // save and free
        _saveAndFree(pos) {
          this._save(pos);
          _free(pos);
        }
        // set parameter (p1, p2 may be undefined)
        _setter (func, p1, p2) {
          const pos = this._alloc();
          const r = func(pos, p1, p2);
          this._saveAndFree(pos);
          if (r) throw new Error('_setter err')
        }
        // getter (p1, p2 may be undefined)
        _getter (func, p1, p2) {
          const pos = this._allocAndCopy();
          const s = func(pos, p1, p2);
          _free(pos);
          return s
        }
        _isEqual (func, rhs) {
          const xPos = this._allocAndCopy();
          const yPos = rhs._allocAndCopy();
          const r = func(xPos, yPos);
          _free(yPos);
          _free(xPos);
          return r === 1
        }
        // func(y, this) and return y
        _op1 (func) {
          const y = new this.constructor();
          const xPos = this._allocAndCopy();
          const yPos = y._alloc();
          func(yPos, xPos);
          y._saveAndFree(yPos);
          _free(xPos);
          return y
        }
        // func(z, this, y) and return z
        _op2 (func, y, Cstr = null) {
          const z = Cstr ? new Cstr() : new this.constructor();
          const xPos = this._allocAndCopy();
          const yPos = y._allocAndCopy();
          const zPos = z._alloc();
          func(zPos, xPos, yPos);
          z._saveAndFree(zPos);
          _free(yPos);
          _free(xPos);
          return z
        }
        // devide Uint32Array a into n and chose the idx-th
        _getSubArray (idx, n) {
          const d = this.a_.length / n;
          return new Uint32Array(this.a_.buffer, d * idx * 4, d)
        }
        // set array lhs to idx
        _setSubArray (lhs, idx, n) {
          const d = this.a_.length / n;
          this.a_.set(lhs.a_, d * idx);
        }
      }
      exports.Fr = class extends Common {
        constructor () {
          super(MCLBN_FR_SIZE);
        }
        setInt (x) {
          this._setter(mod._mclBnFr_setInt32, x);
        }
        deserialize (s) {
          this._setter(mod.mclBnFr_deserialize, s);
        }
        serialize () {
          return this._getter(mod.mclBnFr_serialize)
        }
        setStr (s, base = 0) {
          this._setter(mod.mclBnFr_setStr, s, base);
        }
        getStr (base = 0) {
          return this._getter(mod.mclBnFr_getStr, base)
        }
        isZero () {
          return this._getter(mod._mclBnFr_isZero) === 1
        }
        isOne () {
          return this._getter(mod._mclBnFr_isOne) === 1
        }
        isEqual (rhs) {
          return this._isEqual(mod._mclBnFr_isEqual, rhs)
        }
        setLittleEndian (s) {
          this._setter(mod.mclBnFr_setLittleEndian, s);
        }
        setLittleEndianMod (s) {
          this._setter(mod.mclBnFr_setLittleEndianMod, s);
        }
        setBigEndianMod (s) {
          this._setter(mod.mclBnFr_setBigEndianMod, s);
        }
        setByCSPRNG () {
          const a = new Uint8Array(MCLBN_FR_SIZE);
          exports.getRandomValues(a);
          this.setLittleEndian(a);
        }
        setHashOf (s) {
          this._setter(mod.mclBnFr_setHashOf, s);
        }
      };
      exports.deserializeHexStrToFr = s => {
        const r = new exports.Fr();
        r.deserializeHexStr(s);
        return r
      };
      exports.Fp = class extends Common {
        constructor () {
          super(MCLBN_FP_SIZE);
        }
        setInt (x) {
          this._setter(mod._mclBnFp_setInt32, x);
        }
        deserialize (s) {
          this._setter(mod.mclBnFp_deserialize, s);
        }
        serialize () {
          return this._getter(mod.mclBnFp_serialize)
        }
        setStr (s, base = 0) {
          this._setter(mod.mclBnFp_setStr, s, base);
        }
        getStr (base = 0) {
          return this._getter(mod.mclBnFp_getStr, base)
        }
        isEqual (rhs) {
          return this._isEqual(mod._mclBnFp_isEqual, rhs)
        }
        setLittleEndian (s) {
          this._setter(mod.mclBnFp_setLittleEndian, s);
        }
        setLittleEndianMod (s) {
          this._setter(mod.mclBnFp_setLittleEndianMod, s);
        }
        setBigEndianMod (s) {
          this._setter(mod.mclBnFp_setBigEndianMod, s);
        }
        setByCSPRNG () {
          const a = new Uint8Array(MCLBN_FP_SIZE);
          exports.getRandomValues(a);
          this.setLittleEndian(a);
        }
        setHashOf (s) {
          this._setter(mod.mclBnFp_setHashOf, s);
        }
        mapToG1 () {
          const y = new exports.G1();
          const xPos = this._allocAndCopy();
          const yPos = y._alloc();
          mod._mclBnFp_mapToG1(yPos, xPos);
          y._saveAndFree(yPos);
          _free(xPos);
         return y
        }
      };
      exports.deserializeHexStrToFp = s => {
        const r = new exports.Fp();
        r.deserializeHexStr(s);
        return r
      };
      exports.Fp2 = class extends Common {
        constructor () {
          super(MCLBN_FP_SIZE * 2);
        }
        setInt (x, y) {
          const v = new exports.Fp();
          v.setInt(x);
          this.set_a(v);
          v.setInt(y);
          this.set_b(v);
        }
        deserialize (s) {
          this._setter(mod.mclBnFp2_deserialize, s);
        }
        serialize () {
          return this._getter(mod.mclBnFp2_serialize)
        }
        isEqual (rhs) {
          return this._isEqual(mod._mclBnFp2_isEqual, rhs)
        }
        /*
          x = a + bi where a, b in Fp and i^2 = -1
        */
        get_a () {
          const r = new exports.Fp();
          r.a_ = this._getSubArray(0, 2);
          return r
        }
        get_b () {
          const r = new exports.Fp();
          r.a_ = this._getSubArray(1, 2);
          return r
        }
        set_a(v) {
          this._setSubArray(v, 0, 2);
        }
        set_b(v) {
          this._setSubArray(v, 1, 2);
        }
        mapToG2 () {
          const y = new exports.G2();
          const xPos = this._allocAndCopy();
          const yPos = y._alloc();
          mod._mclBnFp2_mapToG2(yPos, xPos);
          y._saveAndFree(yPos);
          _free(xPos);
         return y
        }
      };
      exports.deserializeHexStrToFp2 = s => {
        const r = new exports.Fp2();
        r.deserializeHexStr(s);
        return r
      };
      exports.G1 = class extends Common {
        constructor () {
          super(MCLBN_G1_SIZE);
        }
        deserialize (s) {
          this._setter(mod.mclBnG1_deserialize, s);
        }
        serialize () {
          return this._getter(mod.mclBnG1_serialize)
        }
        setStr (s, base = 0) {
          this._setter(mod.mclBnG1_setStr, s, base);
        }
        getStr (base = 0) {
          return this._getter(mod.mclBnG1_getStr, base)
        }
        normalize () {
          this.a_ = exports.normalize(this).a_;
        }
        getX () {
          const r = new exports.Fp();
          r.a_ = this._getSubArray(0, 3);
          return r
        }
        getY () {
          const r = new exports.Fp();
          r.a_ = this._getSubArray(1, 3);
          return r
        }
        getZ () {
          const r = new exports.Fp();
          r.a_ = this._getSubArray(2, 3);
          return r
        }
        setX (v) {
          this._setSubArray(v, 0, 3);
        }
        setY (v) {
          this._setSubArray(v, 1, 3);
        }
        setZ (v) {
          this._setSubArray(v, 2, 3);
        }
        isZero () {
          return this._getter(mod._mclBnG1_isZero) === 1
        }
        isValid () {
          return this._getter(mod._mclBnG1_isValid) === 1
        }
        isValidOrder () {
          return this._getter(mod._mclBnG1_isValidOrder) === 1
        }
        isEqual (rhs) {
          return this._isEqual(mod._mclBnG1_isEqual, rhs)
        }
        setHashOf (s) {
          this._setter(mod.mclBnG1_hashAndMapTo, s);
        }
      };
      exports.deserializeHexStrToG1 = s => {
        const r = new exports.G1();
        r.deserializeHexStr(s);
        return r
      };
      exports.setETHserialization = (ETHserialization) => {
        mod._mclBn_setETHserialization(ETHserialization ? 1 : 0);
      };
      // mode = mcl.IRTF for Ethereum 2.0 spec
      exports.setMapToMode = (mode) => {
        mod._mclBn_setMapToMode(mode);
      };
      exports.verifyOrderG1 = (doVerify) => {
        mod._mclBn_verifyOrderG1(doVerify ? 1 : 0);
      };
      exports.verifyOrderG2 = (doVerify) => {
        mod._mclBn_verifyOrderG2(doVerify ? 1 : 0);
      };
      exports.getBasePointG1 = () => {
        const x = new exports.G1();
        const xPos = x._alloc();
        mod._mclBnG1_getBasePoint(xPos);
        x._saveAndFree(xPos);
        if (x.isZero()) {
          throw new Error('not supported for pairing curves')
        }
        return x
      };
      exports.G2 = class extends Common {
        constructor () {
          super(MCLBN_G2_SIZE);
        }
        deserialize (s) {
          this._setter(mod.mclBnG2_deserialize, s);
        }
        serialize () {
          return this._getter(mod.mclBnG2_serialize)
        }
        setStr (s, base = 0) {
          this._setter(mod.mclBnG2_setStr, s, base);
        }
        getStr (base = 0) {
          return this._getter(mod.mclBnG2_getStr, base)
        }
        normalize () {
          this.a_ = exports.normalize(this).a_;
        }
        getX () {
          const r = new exports.Fp2();
          r.a_ = this._getSubArray(0, 3);
          return r
        }
        getY () {
          const r = new exports.Fp2();
          r.a_ = this._getSubArray(1, 3);
          return r
        }
        getZ () {
          const r = new exports.Fp2();
          r.a_ = this._getSubArray(2, 3);
          return r
        }
        setX (v) {
          this._setSubArray(v, 0, 3);
        }
        setY (v) {
          this._setSubArray(v, 1, 3);
        }
        setZ (v) {
          this._setSubArray(v, 2, 3);
        }
        isZero () {
          return this._getter(mod._mclBnG2_isZero) === 1
        }
        isValid () {
          return this._getter(mod._mclBnG2_isValid) === 1
        }
        isValidOrder () {
          return this._getter(mod._mclBnG2_isValidOrder) === 1
        }
        isEqual (rhs) {
          return this._isEqual(mod._mclBnG2_isEqual, rhs)
        }
        setHashOf (s) {
          this._setter(mod.mclBnG2_hashAndMapTo, s);
        }
      };
      exports.deserializeHexStrToG2 = s => {
        const r = new exports.G2();
        r.deserializeHexStr(s);
        return r
      };
      exports.GT = class extends Common {
        constructor () {
          super(MCLBN_GT_SIZE);
        }
        setInt (x) {
          this._setter(mod._mclBnGT_setInt32, x);
        }
        deserialize (s) {
          this._setter(mod.mclBnGT_deserialize, s);
        }
        serialize () {
          return this._getter(mod.mclBnGT_serialize)
        }
        setStr (s, base = 0) {
          this._setter(mod.mclBnGT_setStr, s, base);
        }
        getStr (base = 0) {
          return this._getter(mod.mclBnGT_getStr, base)
        }
        isZero () {
          return this._getter(mod._mclBnGT_isZero) === 1
        }
        isOne () {
          return this._getter(mod._mclBnGT_isOne) === 1
        }
        isEqual (rhs) {
          return this._isEqual(mod._mclBnGT_isEqual, rhs)
        }
      };
      exports.deserializeHexStrToGT = s => {
        const r = new exports.GT();
        r.deserializeHexStr(s);
        return r
      };
      exports.PrecomputedG2 = class {
        constructor (Q) {
          if (!(Q instanceof exports.G2)) throw new Error('PrecomputedG2:bad type')
          const byteSize = mod._mclBn_getUint64NumToPrecompute() * 8;
          this.p = _malloc(byteSize);
          const Qpos = Q._allocAndCopy();
          mod._mclBn_precomputeG2(this.p, Qpos);
          _free(Qpos);
        }
        /*
          call destroy if PrecomputedG2 is not necessary
          to avoid memory leak
        */
        destroy () {
          _free(this.p);
          this.p = null;
        }
      };
      exports.neg = x => {
        if (x instanceof exports.Fr) {
          return x._op1(mod._mclBnFr_neg)
        }
        if (x instanceof exports.Fp) {
          return x._op1(mod._mclBnFp_neg)
        }
        if (x instanceof exports.G1) {
          return x._op1(mod._mclBnG1_neg)
        }
        if (x instanceof exports.G2) {
          return x._op1(mod._mclBnG2_neg)
        }
        if (x instanceof exports.GT) {
          return x._op1(mod._mclBnGT_neg)
        }
        if (x instanceof exports.Fp2) {
          return x._op1(mod._mclBnFp2_neg)
        }
        throw new Error('neg:bad type')
      };
      exports.sqr = x => {
        if (x instanceof exports.Fp) {
          return x._op1(mod._mclBnFp_sqr)
        }
        if (x instanceof exports.Fr) {
          return x._op1(mod._mclBnFr_sqr)
        }
        if (x instanceof exports.GT) {
          return x._op1(mod._mclBnGT_sqr)
        }
        if (x instanceof exports.Fp2) {
          return x._op1(mod._mclBnFp2_sqr)
        }
        throw new Error('sqr:bad type')
      };
      exports.inv = x => {
        if (x instanceof exports.Fp) {
          return x._op1(mod._mclBnFp_inv)
        }
        if (x instanceof exports.Fr) {
          return x._op1(mod._mclBnFr_inv)
        }
        if (x instanceof exports.GT) {
          return x._op1(mod._mclBnGT_inv)
        }
        if (x instanceof exports.Fp2) {
          return x._op1(mod._mclBnFp2_inv)
        }
        throw new Error('inv:bad type')
      };
      exports.normalize = x => {
        if (x instanceof exports.G1) {
          return x._op1(mod._mclBnG1_normalize)
        }
        if (x instanceof exports.G2) {
          return x._op1(mod._mclBnG2_normalize)
        }
        throw new Error('normalize:bad type')
      };
      exports.add = (x, y) => {
        if (x.constructor !== y.constructor) throw new Error('add:mismatch type')
        if (x instanceof exports.Fp) {
          return x._op2(mod._mclBnFp_add, y)
        }
        if (x instanceof exports.Fr) {
          return x._op2(mod._mclBnFr_add, y)
        }
        if (x instanceof exports.G1) {
          return x._op2(mod._mclBnG1_add, y)
        }
        if (x instanceof exports.G2) {
          return x._op2(mod._mclBnG2_add, y)
        }
        if (x instanceof exports.GT) {
          return x._op2(mod._mclBnGT_add, y)
        }
        if (x instanceof exports.Fp2) {
          return x._op2(mod._mclBnFp2_add, y)
        }
        throw new Error('add:bad type')
      };
      exports.sub = (x, y) => {
        if (x.constructor !== y.constructor) throw new Error('sub:mismatch type')
        if (x instanceof exports.Fp) {
          return x._op2(mod._mclBnFp_sub, y)
        }
        if (x instanceof exports.Fr) {
          return x._op2(mod._mclBnFr_sub, y)
        }
        if (x instanceof exports.G1) {
          return x._op2(mod._mclBnG1_sub, y)
        }
        if (x instanceof exports.G2) {
          return x._op2(mod._mclBnG2_sub, y)
        }
        if (x instanceof exports.GT) {
          return x._op2(mod._mclBnGT_sub, y)
        }
        if (x instanceof exports.Fp2) {
          return x._op2(mod._mclBnFp2_sub, y)
        }
        throw new Error('sub:bad type')
      };
      /*
        Fr * Fr
        G1 * Fr ; scalar mul
        G2 * Fr ; scalar mul
        GT * GT
      */
      exports.mul = (x, y) => {
        if (x instanceof exports.Fp && y instanceof exports.Fp) {
          return x._op2(mod._mclBnFp_mul, y)
        }
        if (x instanceof exports.Fr && y instanceof exports.Fr) {
          return x._op2(mod._mclBnFr_mul, y)
        }
        if (x instanceof exports.G1 && y instanceof exports.Fr) {
          return x._op2(mod._mclBnG1_mul, y)
        }
        if (x instanceof exports.G2 && y instanceof exports.Fr) {
          return x._op2(mod._mclBnG2_mul, y)
        }
        if (x instanceof exports.GT && y instanceof exports.GT) {
          return x._op2(mod._mclBnGT_mul, y)
        }
        if (x instanceof exports.Fp2 && y instanceof exports.Fp2) {
          return x._op2(mod._mclBnFp2_mul, y)
        }
        throw new Error('mul:mismatch type')
      };
      /*
        sum G1 * Fr ; scalar mul
        sum G2 * Fr ; scalar mul
      */
      exports.mulVec = (xVec, yVec) => {
        if (xVec.length == 0) throw new Error('mulVec:zero array')
        if (xVec[0] instanceof exports.G1 && yVec[0] instanceof exports.Fr) {
          return _mulVec(mod._mclBnG1_mulVec, xVec, yVec, exports.G1)
        }
        if (xVec[0] instanceof exports.G2 && yVec[0] instanceof exports.Fr) {
          return _mulVec(mod._mclBnG2_mulVec, xVec, yVec, exports.G2)
        }
        throw new Error('mulVec:mismatch type')
      };
      exports.div = (x, y) => {
        if (x.constructor !== y.constructor) throw new Error('div:mismatch type')
        if (x instanceof exports.Fp) {
          return x._op2(mod._mclBnFp_div, y)
        }
        if (x instanceof exports.Fr) {
          return x._op2(mod._mclBnFr_div, y)
        }
        if (x instanceof exports.GT) {
          return x._op2(mod._mclBnGT_div, y)
        }
        if (x instanceof exports.Fp2) {
          return x._op2(mod._mclBnFp2_div, y)
        }
        throw new Error('div:bad type')
      };
      exports.dbl = x => {
        if (x instanceof exports.G1) {
          return x._op1(mod._mclBnG1_dbl)
        }
        if (x instanceof exports.G2) {
          return x._op1(mod._mclBnG2_dbl)
        }
        throw new Error('dbl:bad type')
      };
      exports.hashToFr = s => {
        const x = new exports.Fr();
        x.setHashOf(s);
        return x
      };
      exports.hashAndMapToG1 = s => {
        const x = new exports.G1();
        x.setHashOf(s);
        return x
      };
      exports.hashAndMapToG2 = s => {
        const x = new exports.G2();
        x.setHashOf(s);
        return x
      };
      // pow(GT x, Fr y)
      exports.pow = (x, y) => {
        if (x instanceof exports.GT && y instanceof exports.Fr) {
          return x._op2(mod._mclBnGT_pow, y)
        }
        throw new Error('pow:bad type')
      };
      // pairing(G1 P, G2 Q)
      exports.pairing = (P, Q) => {
        if (P instanceof exports.G1 && Q instanceof exports.G2) {
          return P._op2(mod._mclBn_pairing, Q, exports.GT)
        }
        throw new Error('exports.pairing:bad type')
      };
      // millerLoop(G1 P, G2 Q)
      exports.millerLoop = (P, Q) => {
        if (P instanceof exports.G1 && Q instanceof exports.G2) {
          return P._op2(mod._mclBn_millerLoop, Q, exports.GT)
        }
        throw new Error('exports.millerLoop:bad type')
      };
      exports.precomputedMillerLoop = (P, Qcoeff) => {
        if (!(P instanceof exports.G1 && Qcoeff instanceof exports.PrecomputedG2)) throw new Error('exports.precomputedMillerLoop:bad type')
        const e = new exports.GT();
        const PPos = P._allocAndCopy();
        const ePos = e._alloc();
        mod._mclBn_precomputedMillerLoop(ePos, PPos, Qcoeff.p);
        e._saveAndFree(ePos);
        _free(PPos);
        return e
      };
      // millerLoop(P1, Q1coeff) * millerLoop(P2, Q2coeff)
      exports.precomputedMillerLoop2 = (P1, Q1coeff, P2, Q2coeff) => {
        if (!(P1 instanceof exports.G1 && Q1coeff instanceof exports.PrecomputedG2 && P2 instanceof exports.G1 && Q2coeff instanceof exports.PrecomputedG2)) throw new Error('exports.precomputedMillerLoop2mixed:bad type')
        const e = new exports.GT();
        const P1Pos = P1._allocAndCopy();
        const P2Pos = P2._allocAndCopy();
        const ePos = e._alloc();
        mod._mclBn_precomputedMillerLoop2(ePos, P1Pos, Q1coeff.p, P2Pos, Q2coeff.p);
        e._saveAndFree(ePos);
        _free(P1Pos);
        _free(P2Pos);
        return e
      };
      // millerLoop(P1, Q1) * millerLoop(P2, Q2coeff)
      exports.precomputedMillerLoop2mixed = (P1, Q1, P2, Q2coeff) => {
        if (!(P1 instanceof exports.G1 && Q1 instanceof exports.G2 && P2 instanceof exports.G1 && Q2coeff instanceof exports.PrecomputedG2)) throw new Error('exports.precomputedMillerLoop2mixed:bad type')
        const e = new exports.GT();
        const P1Pos = P1._allocAndCopy();
        const Q1Pos = Q1._allocAndCopy();
        const P2Pos = P2._allocAndCopy();
        const ePos = e._alloc();
        mod._mclBn_precomputedMillerLoop2mixed(ePos, P1Pos, Q1Pos, P2Pos, Q2coeff.p);
        e._saveAndFree(ePos);
        _free(P1Pos);
        _free(Q1Pos);
        _free(P2Pos);
        return e
      };
      exports.finalExp = x => {
        if (x instanceof exports.GT) {
          return x._op1(mod._mclBn_finalExp)
        }
        throw new Error('finalExp:bad type')
      };
      const r = mod._mclBn_init(curveType, MCLBN_COMPILED_TIME_VAR);
      if (r) throw new Error('_mclBn_init err ' + r)
    }; // setup()
    const _cryptoGetRandomValues = function(p, n) {
      const a = new Uint8Array(n);
      exports.getRandomValues(a);
      for (let i = 0; i < n; i++) {
        exports.mod.HEAP8[p + i] = a[i];
      }
    };
    exports.init = async (curveType = exports.BN254) => {
      exports.curveType = curveType;
      exports.getRandomValues = getRandomValues;
      exports.mod = await createModule({
        cryptoGetRandomValues: _cryptoGetRandomValues,
      });
      setup(exports, curveType);
    };
    return exports
  };

  var mcl$2 = _mclSetupFactory;

  const crypto$1 = require$$2$2;
  const mclCreateModule = mcl_c.exports;
  const mclSetupFactory = mcl$2;

  const getRandomValues = crypto$1.randomFillSync;
  const mcl$1 = mclSetupFactory(mclCreateModule, getRandomValues);

  var src = mcl$1;

  Object.defineProperty(evm$1, "__esModule", { value: true });
  evm$1.EvmErrorResult = evm$1.INVALID_EOF_RESULT = evm$1.INVALID_BYTECODE_RESULT = evm$1.COOGResult = evm$1.OOGResult = evm$1.EVM = void 0;
  const util_1$L = util$6;
  const common_1$d = dist$8;
  const AsyncEventEmitter$1 = asyncEventemitter;
  const util_2$5 = dist$a;
  const debug_1$4 = src$1.exports;
  const eof_1 = eof;
  const exceptions_1$b = exceptions;
  const interpreter_1 = interpreter;
  const message_1 = message;
  const opcodes_1 = opcodes$1;
  const precompiles_1$1 = precompiles$1;
  const transientStorage_1 = transientStorage;
  const debug$4 = (0, debug_1$4.debug)('evm');
  const debugGas$1 = (0, debug_1$4.debug)('evm:gas');
  // very ugly way to detect if we are running in a browser
  const isBrowser = new Function('try {return this===window;}catch(e){ return false;}');
  let mcl;
  let mclInitPromise;
  if (isBrowser() === false) {
      mcl = src;
      mclInitPromise = mcl.init(mcl.BLS12_381);
  }
  /**
   * EVM is responsible for executing an EVM message fully
   * (including any nested calls and creates), processing the results
   * and storing them to state (or discarding changes in case of exceptions).
   * @ignore
   */
  class EVM extends AsyncEventEmitter$1 {
      constructor(opts) {
          super();
          this._isInitialized = false;
          /**
           * EVM is run in DEBUG mode (default: false)
           * Taken from DEBUG environment variable
           *
           * Safeguards on debug() calls are added for
           * performance reasons to avoid string literal evaluation
           * @hidden
           */
          this.DEBUG = false;
          this._optsCached = opts;
          this.eei = opts.eei;
          this._transientStorage = new transientStorage_1.TransientStorage();
          if (opts.common) {
              this._common = opts.common;
          }
          else {
              const DEFAULT_CHAIN = common_1$d.Chain.Mainnet;
              this._common = new common_1$d.Common({ chain: DEFAULT_CHAIN });
          }
          // Supported EIPs
          const supportedEIPs = [
              1153, 1559, 2315, 2537, 2565, 2718, 2929, 2930, 3074, 3198, 3529, 3540, 3541, 3607, 3651,
              3670, 3855, 3860, 4399, 5133,
          ];
          for (const eip of this._common.eips()) {
              if (!supportedEIPs.includes(eip)) {
                  throw new Error(`EIP-${eip} is not supported by the EVM`);
              }
          }
          const supportedHardforks = [
              common_1$d.Hardfork.Chainstart,
              common_1$d.Hardfork.Homestead,
              common_1$d.Hardfork.Dao,
              common_1$d.Hardfork.TangerineWhistle,
              common_1$d.Hardfork.SpuriousDragon,
              common_1$d.Hardfork.Byzantium,
              common_1$d.Hardfork.Constantinople,
              common_1$d.Hardfork.Petersburg,
              common_1$d.Hardfork.Istanbul,
              common_1$d.Hardfork.MuirGlacier,
              common_1$d.Hardfork.Berlin,
              common_1$d.Hardfork.London,
              common_1$d.Hardfork.ArrowGlacier,
              common_1$d.Hardfork.GrayGlacier,
              common_1$d.Hardfork.MergeForkIdTransition,
              common_1$d.Hardfork.Merge,
          ];
          if (!supportedHardforks.includes(this._common.hardfork())) {
              throw new Error(`Hardfork ${this._common.hardfork()} not set as supported in supportedHardforks`);
          }
          this._allowUnlimitedContractSize = opts.allowUnlimitedContractSize ?? false;
          this._customOpcodes = opts.customOpcodes;
          this._customPrecompiles = opts.customPrecompiles;
          this._common.on('hardforkChanged', () => {
              this.getActiveOpcodes();
              this._precompiles = (0, precompiles_1$1.getActivePrecompiles)(this._common, this._customPrecompiles);
          });
          // Initialize the opcode data
          this.getActiveOpcodes();
          this._precompiles = (0, precompiles_1$1.getActivePrecompiles)(this._common, this._customPrecompiles);
          if (this._common.isActivatedEIP(2537)) {
              if (isBrowser() === true) {
                  throw new Error('EIP-2537 is currently not supported in browsers');
              }
              else {
                  this._mcl = mcl;
              }
          }
          // Safeguard if "process" is not available (browser)
          if (typeof browser$1$1?.env.DEBUG !== 'undefined') {
              this.DEBUG = true;
          }
          // We cache this promisified function as it's called from the main execution loop, and
          // promisifying each time has a huge performance impact.
          this._emit = (0, util_1$L.promisify)(this.emit.bind(this));
      }
      get precompiles() {
          return this._precompiles;
      }
      get opcodes() {
          return this._opcodes;
      }
      /**
       * EVM async constructor. Creates engine instance and initializes it.
       *
       * @param opts EVM engine constructor options
       */
      static async create(opts) {
          const evm = new this(opts);
          await evm.init();
          return evm;
      }
      async init() {
          if (this._isInitialized) {
              return;
          }
          if (this._common.isActivatedEIP(2537)) {
              if (isBrowser() === true) {
                  throw new Error('EIP-2537 is currently not supported in browsers');
              }
              else {
                  const mcl = this._mcl;
                  await mclInitPromise; // ensure that mcl is initialized.
                  mcl.setMapToMode(mcl.IRTF); // set the right map mode; otherwise mapToG2 will return wrong values.
                  mcl.verifyOrderG1(1); // subgroup checks for G1
                  mcl.verifyOrderG2(1); // subgroup checks for G2
              }
          }
          this._isInitialized = true;
      }
      /**
       * Returns a list with the currently activated opcodes
       * available for EVM execution
       */
      getActiveOpcodes() {
          const data = (0, opcodes_1.getOpcodesForHF)(this._common, this._customOpcodes);
          this._opcodes = data.opcodes;
          this._dynamicGasHandlers = data.dynamicGasHandlers;
          this._handlers = data.handlers;
          return data.opcodes;
      }
      async _executeCall(message) {
          const account = await this.eei.getAccount(message.authcallOrigin ?? message.caller);
          let errorMessage;
          // Reduce tx value from sender
          if (!message.delegatecall) {
              try {
                  await this._reduceSenderBalance(account, message);
              }
              catch (e) {
                  errorMessage = e;
              }
          }
          // Load `to` account
          const toAccount = await this.eei.getAccount(message.to);
          // Add tx value to the `to` account
          if (!message.delegatecall) {
              try {
                  await this._addToBalance(toAccount, message);
              }
              catch (e) {
                  errorMessage = e;
              }
          }
          // Load code
          await this._loadCode(message);
          let exit = false;
          if (!message.code || message.code.length === 0) {
              exit = true;
              if (this.DEBUG) {
                  debug$4(`Exit early on no code`);
              }
          }
          if ((0, util_2$5.isTruthy)(errorMessage)) {
              exit = true;
              if (this.DEBUG) {
                  debug$4(`Exit early on value transfer overflowed`);
              }
          }
          if (exit) {
              return {
                  execResult: {
                      gasRefund: message.gasRefund,
                      executionGasUsed: BigInt(0),
                      exceptionError: errorMessage,
                      returnValue: Buffer$8.alloc(0),
                  },
              };
          }
          let result;
          if (message.isCompiled) {
              if (this.DEBUG) {
                  debug$4(`Run precompile`);
              }
              result = await this.runPrecompile(message.code, message.data, message.gasLimit);
              result.gasRefund = message.gasRefund;
          }
          else {
              if (this.DEBUG) {
                  debug$4(`Start bytecode processing...`);
              }
              result = await this.runInterpreter(message);
          }
          if (message.depth === 0) {
              this.postMessageCleanup();
          }
          return {
              execResult: result,
          };
      }
      async _executeCreate(message) {
          const account = await this.eei.getAccount(message.caller);
          // Reduce tx value from sender
          await this._reduceSenderBalance(account, message);
          if (this._common.isActivatedEIP(3860)) {
              if (message.data.length > Number(this._common.param('vm', 'maxInitCodeSize'))) {
                  return {
                      createdAddress: message.to,
                      execResult: {
                          returnValue: Buffer$8.alloc(0),
                          exceptionError: new exceptions_1$b.EvmError(exceptions_1$b.ERROR.INITCODE_SIZE_VIOLATION),
                          executionGasUsed: message.gasLimit,
                      },
                  };
              }
          }
          message.code = message.data;
          message.data = Buffer$8.alloc(0);
          message.to = await this._generateAddress(message);
          if (this.DEBUG) {
              debug$4(`Generated CREATE contract address ${message.to}`);
          }
          let toAccount = await this.eei.getAccount(message.to);
          // Check for collision
          if ((toAccount.nonce && toAccount.nonce > BigInt(0)) ||
              !toAccount.codeHash.equals(util_2$5.KECCAK256_NULL)) {
              if (this.DEBUG) {
                  debug$4(`Returning on address collision`);
              }
              return {
                  createdAddress: message.to,
                  execResult: {
                      returnValue: Buffer$8.alloc(0),
                      exceptionError: new exceptions_1$b.EvmError(exceptions_1$b.ERROR.CREATE_COLLISION),
                      executionGasUsed: message.gasLimit,
                  },
              };
          }
          await this.eei.clearContractStorage(message.to);
          const newContractEvent = {
              address: message.to,
              code: message.code,
          };
          await this._emit('newContract', newContractEvent);
          toAccount = await this.eei.getAccount(message.to);
          // EIP-161 on account creation and CREATE execution
          if (this._common.gteHardfork(common_1$d.Hardfork.SpuriousDragon)) {
              toAccount.nonce += BigInt(1);
          }
          // Add tx value to the `to` account
          let errorMessage;
          try {
              await this._addToBalance(toAccount, message);
          }
          catch (e) {
              errorMessage = e;
          }
          let exit = false;
          if ((0, util_2$5.isFalsy)(message.code) || message.code.length === 0) {
              exit = true;
              if (this.DEBUG) {
                  debug$4(`Exit early on no code`);
              }
          }
          if ((0, util_2$5.isTruthy)(errorMessage)) {
              exit = true;
              if (this.DEBUG) {
                  debug$4(`Exit early on value transfer overflowed`);
              }
          }
          if (exit) {
              return {
                  createdAddress: message.to,
                  execResult: {
                      executionGasUsed: BigInt(0),
                      gasRefund: message.gasRefund,
                      exceptionError: errorMessage,
                      returnValue: Buffer$8.alloc(0),
                  },
              };
          }
          if (this.DEBUG) {
              debug$4(`Start bytecode processing...`);
          }
          let result = await this.runInterpreter(message);
          // fee for size of the return value
          let totalGas = result.executionGasUsed;
          let returnFee = BigInt(0);
          if (!result.exceptionError) {
              returnFee =
                  BigInt(result.returnValue.length) * BigInt(this._common.param('gasPrices', 'createData'));
              totalGas = totalGas + returnFee;
              if (this.DEBUG) {
                  debugGas$1(`Add return value size fee (${returnFee} to gas used (-> ${totalGas}))`);
              }
          }
          // Check for SpuriousDragon EIP-170 code size limit
          let allowedCodeSize = true;
          if (!result.exceptionError &&
              this._common.gteHardfork(common_1$d.Hardfork.SpuriousDragon) &&
              result.returnValue.length > Number(this._common.param('vm', 'maxCodeSize'))) {
              allowedCodeSize = false;
          }
          // If enough gas and allowed code size
          let CodestoreOOG = false;
          if (totalGas <= message.gasLimit && (this._allowUnlimitedContractSize || allowedCodeSize)) {
              if (this._common.isActivatedEIP(3541) && result.returnValue[0] === eof_1.EOF.FORMAT) {
                  if (!this._common.isActivatedEIP(3540)) {
                      result = { ...result, ...INVALID_BYTECODE_RESULT(message.gasLimit) };
                  }
                  // Begin EOF1 contract code checks
                  // EIP-3540 EOF1 header check
                  const eof1CodeAnalysisResults = eof_1.EOF.codeAnalysis(result.returnValue);
                  if (typeof eof1CodeAnalysisResults?.code === 'undefined') {
                      result = {
                          ...result,
                          ...INVALID_EOF_RESULT(message.gasLimit),
                      };
                  }
                  else if (this._common.isActivatedEIP(3670)) {
                      // EIP-3670 EOF1 opcode check
                      const codeStart = eof1CodeAnalysisResults.data > 0 ? 10 : 7;
                      // The start of the code section of an EOF1 compliant contract will either be
                      // index 7 (if no data section is present) or index 10 (if a data section is present)
                      // in the bytecode of the contract
                      if (!eof_1.EOF.validOpcodes(result.returnValue.slice(codeStart, codeStart + eof1CodeAnalysisResults.code))) {
                          result = {
                              ...result,
                              ...INVALID_EOF_RESULT(message.gasLimit),
                          };
                      }
                      else {
                          result.executionGasUsed = totalGas;
                      }
                  }
              }
              else {
                  result.executionGasUsed = totalGas;
              }
          }
          else {
              if (this._common.gteHardfork(common_1$d.Hardfork.Homestead)) {
                  if (this.DEBUG) {
                      debug$4(`Not enough gas or code size not allowed (>= Homestead)`);
                  }
                  result = { ...result, ...OOGResult(message.gasLimit) };
              }
              else {
                  // we are in Frontier
                  if (this.DEBUG) {
                      debug$4(`Not enough gas or code size not allowed (Frontier)`);
                  }
                  if (totalGas - returnFee <= message.gasLimit) {
                      // we cannot pay the code deposit fee (but the deposit code actually did run)
                      result = { ...result, ...COOGResult(totalGas - returnFee) };
                      CodestoreOOG = true;
                  }
                  else {
                      result = { ...result, ...OOGResult(message.gasLimit) };
                  }
              }
          }
          // Save code if a new contract was created
          if (!result.exceptionError &&
              (0, util_2$5.isTruthy)(result.returnValue) &&
              result.returnValue.toString() !== '') {
              await this.eei.putContractCode(message.to, result.returnValue);
              if (this.DEBUG) {
                  debug$4(`Code saved on new contract creation`);
              }
          }
          else if (CodestoreOOG) {
              // This only happens at Frontier. But, let's do a sanity check;
              if (!this._common.gteHardfork(common_1$d.Hardfork.Homestead)) {
                  // Pre-Homestead behavior; put an empty contract.
                  // This contract would be considered "DEAD" in later hard forks.
                  // It is thus an unecessary default item, which we have to save to dik
                  // It does change the state root, but it only wastes storage.
                  //await this._state.putContractCode(message.to, result.returnValue)
                  const account = await this.eei.getAccount(message.to);
                  await this.eei.putAccount(message.to, account);
              }
          }
          return {
              createdAddress: message.to,
              execResult: result,
          };
      }
      /**
       * Starts the actual bytecode processing for a CALL or CREATE, providing
       * it with the {@link EEI}.
       */
      async runInterpreter(message, opts = {}) {
          const env = {
              address: message.to ?? util_2$5.Address.zero(),
              caller: message.caller ?? util_2$5.Address.zero(),
              callData: message.data ?? Buffer$8.from([0]),
              callValue: message.value ?? BigInt(0),
              code: message.code,
              isStatic: message.isStatic ?? false,
              depth: message.depth ?? 0,
              gasPrice: this._tx.gasPrice,
              origin: this._tx.origin ?? message.caller ?? util_2$5.Address.zero(),
              block: this._block ?? defaultBlock(),
              contract: await this.eei.getAccount(message.to ?? util_2$5.Address.zero()),
              codeAddress: message.codeAddress,
              gasRefund: message.gasRefund,
          };
          const interpreter = new interpreter_1.Interpreter(this, this.eei, env, message.gasLimit);
          if (message.selfdestruct) {
              interpreter._result.selfdestruct = message.selfdestruct;
          }
          const interpreterRes = await interpreter.run(message.code, opts);
          let result = interpreter._result;
          let gasUsed = message.gasLimit - interpreterRes.runState.gasLeft;
          if (interpreterRes.exceptionError) {
              if (interpreterRes.exceptionError.error !== exceptions_1$b.ERROR.REVERT &&
                  interpreterRes.exceptionError.error !== exceptions_1$b.ERROR.INVALID_EOF_FORMAT) {
                  gasUsed = message.gasLimit;
              }
              // Clear the result on error
              result = {
                  ...result,
                  logs: [],
                  selfdestruct: {},
              };
          }
          return {
              ...result,
              runState: {
                  ...interpreterRes.runState,
                  ...result,
                  ...interpreter._env,
              },
              exceptionError: interpreterRes.exceptionError,
              gas: interpreterRes.runState?.gasLeft,
              executionGasUsed: gasUsed,
              gasRefund: interpreterRes.runState.gasRefund,
              returnValue: result.returnValue ? result.returnValue : Buffer$8.alloc(0),
          };
      }
      /**
       * Executes an EVM message, determining whether it's a call or create
       * based on the `to` address. It checkpoints the state and reverts changes
       * if an exception happens during the message execution.
       */
      async runCall(opts) {
          let message = opts.message;
          if (!message) {
              this._block = opts.block ?? defaultBlock();
              this._tx = {
                  gasPrice: opts.gasPrice ?? BigInt(0),
                  origin: opts.origin ?? opts.caller ?? util_2$5.Address.zero(),
              };
              const caller = opts.caller ?? util_2$5.Address.zero();
              const value = opts.value ?? BigInt(0);
              if (opts.skipBalance === true) {
                  // if skipBalance, add `value` to caller balance to ensure sufficient funds
                  const callerAccount = await this.eei.getAccount(caller);
                  callerAccount.balance += value;
                  await this.eei.putAccount(caller, callerAccount);
              }
              message = new message_1.Message({
                  caller,
                  gasLimit: opts.gasLimit ?? BigInt(0xffffff),
                  to: opts.to,
                  value,
                  data: opts.data,
                  code: opts.code,
                  depth: opts.depth,
                  isCompiled: opts.isCompiled,
                  isStatic: opts.isStatic,
                  salt: opts.salt,
                  selfdestruct: opts.selfdestruct ?? {},
                  delegatecall: opts.delegatecall,
              });
          }
          await this._emit('beforeMessage', message);
          if (!message.to && this._common.isActivatedEIP(2929) === true) {
              message.code = message.data;
              this.eei.addWarmedAddress((await this._generateAddress(message)).buf);
          }
          await this.eei.checkpoint();
          this._transientStorage.checkpoint();
          if (this.DEBUG) {
              debug$4('-'.repeat(100));
              debug$4(`message checkpoint`);
          }
          let result;
          if (this.DEBUG) {
              const { caller, gasLimit, to, value, delegatecall } = message;
              debug$4(`New message caller=${caller} gasLimit=${gasLimit} to=${to?.toString() ?? 'none'} value=${value} delegatecall=${delegatecall ? 'yes' : 'no'}`);
          }
          if (message.to) {
              if (this.DEBUG) {
                  debug$4(`Message CALL execution (to: ${message.to})`);
              }
              result = await this._executeCall(message);
          }
          else {
              if (this.DEBUG) {
                  debug$4(`Message CREATE execution (to undefined)`);
              }
              result = await this._executeCreate(message);
          }
          if (this.DEBUG) {
              const { executionGasUsed, exceptionError, returnValue } = result.execResult;
              debug$4(`Received message execResult: [ gasUsed=${executionGasUsed} exceptionError=${exceptionError ? `'${exceptionError.error}'` : 'none'} returnValue=0x${(0, util_2$5.short)(returnValue)} gasRefund=${result.execResult.gasRefund ?? 0} ]`);
          }
          const err = result.execResult.exceptionError;
          // This clause captures any error which happened during execution
          // If that is the case, then all refunds are forfeited
          if (err) {
              result.execResult.selfdestruct = {};
              result.execResult.gasRefund = BigInt(0);
          }
          if (err) {
              if (this._common.gteHardfork(common_1$d.Hardfork.Homestead) || err.error != exceptions_1$b.ERROR.CODESTORE_OUT_OF_GAS) {
                  result.execResult.logs = [];
                  await this.eei.revert();
                  this._transientStorage.revert();
                  if (this.DEBUG) {
                      debug$4(`message checkpoint reverted`);
                  }
              }
              else {
                  // we are in chainstart and the error was the code deposit error
                  // we do like nothing happened.
                  await this.eei.commit();
                  this._transientStorage.commit();
                  if (this.DEBUG) {
                      debug$4(`message checkpoint committed`);
                  }
              }
          }
          else {
              await this.eei.commit();
              this._transientStorage.commit();
              if (this.DEBUG) {
                  debug$4(`message checkpoint committed`);
              }
          }
          await this._emit('afterMessage', result);
          return result;
      }
      /**
       * Bound to the global VM and therefore
       * shouldn't be used directly from the evm class
       */
      async runCode(opts) {
          this._block = opts.block ?? defaultBlock();
          this._tx = {
              gasPrice: opts.gasPrice ?? BigInt(0),
              origin: opts.origin ?? opts.caller ?? util_2$5.Address.zero(),
          };
          const message = new message_1.Message({
              code: opts.code,
              data: opts.data,
              gasLimit: opts.gasLimit,
              to: opts.address ?? util_2$5.Address.zero(),
              caller: opts.caller,
              value: opts.value,
              depth: opts.depth,
              selfdestruct: opts.selfdestruct ?? {},
              isStatic: opts.isStatic,
          });
          return this.runInterpreter(message, { pc: opts.pc });
      }
      /**
       * Returns code for precompile at the given address, or undefined
       * if no such precompile exists.
       */
      getPrecompile(address) {
          return this.precompiles.get(address.buf.toString('hex'));
      }
      /**
       * Executes a precompiled contract with given data and gas limit.
       */
      runPrecompile(code, data, gasLimit) {
          if (typeof code !== 'function') {
              throw new Error('Invalid precompile');
          }
          const opts = {
              data,
              gasLimit,
              _common: this._common,
              _EVM: this,
          };
          return code(opts);
      }
      async _loadCode(message) {
          if (!message.code) {
              const precompile = this.getPrecompile(message.codeAddress);
              if (precompile) {
                  message.code = precompile;
                  message.isCompiled = true;
              }
              else {
                  message.code = await this.eei.getContractCode(message.codeAddress);
                  message.isCompiled = false;
              }
          }
      }
      async _generateAddress(message) {
          let addr;
          if (message.salt) {
              addr = (0, util_2$5.generateAddress2)(message.caller.buf, message.salt, message.code);
          }
          else {
              const acc = await this.eei.getAccount(message.caller);
              let newNonce = acc.nonce;
              if (message.depth > 0) {
                  newNonce--;
              }
              addr = (0, util_2$5.generateAddress)(message.caller.buf, (0, util_2$5.bigIntToBuffer)(newNonce));
          }
          return new util_2$5.Address(addr);
      }
      async _reduceSenderBalance(account, message) {
          account.balance -= message.value;
          if (account.balance < BigInt(0)) {
              throw new exceptions_1$b.EvmError(exceptions_1$b.ERROR.INSUFFICIENT_BALANCE);
          }
          const result = this.eei.putAccount(message.authcallOrigin ?? message.caller, account);
          if (this.DEBUG) {
              debug$4(`Reduced sender (${message.caller}) balance (-> ${account.balance})`);
          }
          return result;
      }
      async _addToBalance(toAccount, message) {
          const newBalance = toAccount.balance + message.value;
          if (newBalance > util_2$5.MAX_INTEGER) {
              throw new exceptions_1$b.EvmError(exceptions_1$b.ERROR.VALUE_OVERFLOW);
          }
          toAccount.balance = newBalance;
          // putAccount as the nonce may have changed for contract creation
          const result = this.eei.putAccount(message.to, toAccount);
          if (this.DEBUG) {
              debug$4(`Added toAccount (${message.to}) balance (-> ${toAccount.balance})`);
          }
          return result;
      }
      async _touchAccount(address) {
          const account = await this.eei.getAccount(address);
          return this.eei.putAccount(address, account);
      }
      /**
       * Once the interpreter has finished depth 0, a post-message cleanup should be done
       */
      postMessageCleanup() {
          if (this._common.isActivatedEIP(1153))
              this._transientStorage.clear();
      }
      copy() {
          const opts = {
              ...this._optsCached,
              common: this._common.copy(),
              eei: this.eei.copy(),
          };
          return new EVM(opts);
      }
  }
  evm$1.EVM = EVM;
  function OOGResult(gasLimit) {
      return {
          returnValue: Buffer$8.alloc(0),
          executionGasUsed: gasLimit,
          exceptionError: new exceptions_1$b.EvmError(exceptions_1$b.ERROR.OUT_OF_GAS),
      };
  }
  evm$1.OOGResult = OOGResult;
  // CodeDeposit OOG Result
  function COOGResult(gasUsedCreateCode) {
      return {
          returnValue: Buffer$8.alloc(0),
          executionGasUsed: gasUsedCreateCode,
          exceptionError: new exceptions_1$b.EvmError(exceptions_1$b.ERROR.CODESTORE_OUT_OF_GAS),
      };
  }
  evm$1.COOGResult = COOGResult;
  function INVALID_BYTECODE_RESULT(gasLimit) {
      return {
          returnValue: Buffer$8.alloc(0),
          executionGasUsed: gasLimit,
          exceptionError: new exceptions_1$b.EvmError(exceptions_1$b.ERROR.INVALID_BYTECODE_RESULT),
      };
  }
  evm$1.INVALID_BYTECODE_RESULT = INVALID_BYTECODE_RESULT;
  function INVALID_EOF_RESULT(gasLimit) {
      return {
          returnValue: Buffer$8.alloc(0),
          executionGasUsed: gasLimit,
          exceptionError: new exceptions_1$b.EvmError(exceptions_1$b.ERROR.INVALID_EOF_FORMAT),
      };
  }
  evm$1.INVALID_EOF_RESULT = INVALID_EOF_RESULT;
  function EvmErrorResult(error, gasUsed) {
      return {
          returnValue: Buffer$8.alloc(0),
          executionGasUsed: gasUsed,
          exceptionError: error,
      };
  }
  evm$1.EvmErrorResult = EvmErrorResult;
  function defaultBlock() {
      return {
          header: {
              number: BigInt(0),
              cliqueSigner: () => util_2$5.Address.zero(),
              coinbase: util_2$5.Address.zero(),
              timestamp: BigInt(0),
              difficulty: BigInt(0),
              prevRandao: (0, util_2$5.zeros)(32),
              gasLimit: BigInt(0),
              baseFeePerGas: undefined,
          },
      };
  }

  Object.defineProperty(_01Ecrecover, "__esModule", { value: true });
  _01Ecrecover.precompile01 = void 0;
  const util_1$K = dist$a;
  const evm_1$i = evm$1;
  function precompile01(opts) {
      if ((0, util_1$K.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const gasUsed = opts._common.param('gasPrices', 'ecRecover');
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$i.OOGResult)(opts.gasLimit);
      }
      const data = (0, util_1$K.setLengthRight)(opts.data, 128);
      const msgHash = data.slice(0, 32);
      const v = data.slice(32, 64);
      const vBigInt = (0, util_1$K.bufferToBigInt)(v);
      // Guard against util's `ecrecover`: without providing chainId this will return
      // a signature in most of the cases in the cases that `v=0` or `v=1`
      // However, this should throw, only 27 and 28 is allowed as input
      if (vBigInt !== BigInt(27) && vBigInt !== BigInt(28)) {
          return {
              executionGasUsed: gasUsed,
              returnValue: Buffer$8.alloc(0),
          };
      }
      const r = data.slice(64, 96);
      const s = data.slice(96, 128);
      let publicKey;
      try {
          publicKey = (0, util_1$K.ecrecover)(msgHash, (0, util_1$K.bufferToBigInt)(v), r, s);
      }
      catch (e) {
          return {
              executionGasUsed: gasUsed,
              returnValue: Buffer$8.alloc(0),
          };
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: (0, util_1$K.setLengthLeft)((0, util_1$K.publicToAddress)(publicKey), 32),
      };
  }
  _01Ecrecover.precompile01 = precompile01;

  var _02Sha256 = {};

  var sha256 = {};

  Object.defineProperty(sha256, "__esModule", { value: true });
  sha256.sha256 = void 0;
  const sha256_1$1 = sha256$1;
  const utils_1$1 = utils.exports;
  sha256.sha256 = (0, utils_1$1.wrapHash)(sha256_1$1.sha256);

  Object.defineProperty(_02Sha256, "__esModule", { value: true });
  _02Sha256.precompile02 = void 0;
  const util_1$J = dist$a;
  const sha256_1 = sha256;
  const evm_1$h = evm$1;
  function precompile02(opts) {
      if ((0, util_1$J.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const data = opts.data;
      let gasUsed = opts._common.param('gasPrices', 'sha256');
      gasUsed += opts._common.param('gasPrices', 'sha256Word') * BigInt(Math.ceil(data.length / 32));
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$h.OOGResult)(opts.gasLimit);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: (0, util_1$J.toBuffer)((0, sha256_1.sha256)(data)),
      };
  }
  _02Sha256.precompile02 = precompile02;

  var _03Ripemd160 = {};

  var ripemd160$1 = {};

  var ripemd160 = {};

  Object.defineProperty(ripemd160, "__esModule", { value: true });
  ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
  const _sha2_js_1 = _sha2;
  const utils_js_1 = utils$1;
  // https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
  // https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
  const Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
  const Pi = Id.map((i) => (9 * i + 5) % 16);
  let idxL = [Id];
  let idxR = [Pi];
  for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
          j.push(j[i].map((k) => Rho[k]));
  const shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
  ].map((i) => new Uint8Array(i));
  const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
  const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
  const Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
  const Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
  // The rotate left (circular left shift) operation for uint32
  const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
  // It's called f() in spec.
  function f$1(group, x, y, z) {
      if (group === 0)
          return x ^ y ^ z;
      else if (group === 1)
          return (x & y) | (~x & z);
      else if (group === 2)
          return (x | ~y) ^ z;
      else if (group === 3)
          return (x & z) | (y & ~z);
      else
          return x ^ (y | ~z);
  }
  // Temporary buffer, not used to store anything between runs
  const BUF = new Uint32Array(16);
  class RIPEMD160 extends _sha2_js_1.SHA2 {
      constructor() {
          super(64, 20, 8, true);
          this.h0 = 0x67452301 | 0;
          this.h1 = 0xefcdab89 | 0;
          this.h2 = 0x98badcfe | 0;
          this.h3 = 0x10325476 | 0;
          this.h4 = 0xc3d2e1f0 | 0;
      }
      get() {
          const { h0, h1, h2, h3, h4 } = this;
          return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
          this.h0 = h0 | 0;
          this.h1 = h1 | 0;
          this.h2 = h2 | 0;
          this.h3 = h3 | 0;
          this.h4 = h4 | 0;
      }
      process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
              BUF[i] = view.getUint32(offset, true);
          // prettier-ignore
          let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
          // Instead of iterating 0 to 80, we split it into 5 groups
          // And use the groups in constants, functions, etc. Much simpler
          for (let group = 0; group < 5; group++) {
              const rGroup = 4 - group;
              const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
              const rl = idxL[group], rr = idxR[group]; // prettier-ignore
              const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
              for (let i = 0; i < 16; i++) {
                  const tl = (rotl(al + f$1(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                  al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
              }
              // 2 loops are 10% faster
              for (let i = 0; i < 16; i++) {
                  const tr = (rotl(ar + f$1(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                  ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
              }
          }
          // Add the compressed chunk to the current hash value
          this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
      }
      roundClean() {
          BUF.fill(0);
      }
      destroy() {
          this.destroyed = true;
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0);
      }
  }
  ripemd160.RIPEMD160 = RIPEMD160;
  /**
   * RIPEMD-160 - a hash function from 1990s.
   * @param message - msg that would be hashed
   */
  ripemd160.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());

  Object.defineProperty(ripemd160$1, "__esModule", { value: true });
  ripemd160$1.ripemd160 = void 0;
  const ripemd160_1$1 = ripemd160;
  const utils_1 = utils.exports;
  ripemd160$1.ripemd160 = (0, utils_1.wrapHash)(ripemd160_1$1.ripemd160);

  Object.defineProperty(_03Ripemd160, "__esModule", { value: true });
  _03Ripemd160.precompile03 = void 0;
  const util_1$I = dist$a;
  const ripemd160_1 = ripemd160$1;
  const evm_1$g = evm$1;
  function precompile03(opts) {
      if ((0, util_1$I.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const data = opts.data;
      let gasUsed = opts._common.param('gasPrices', 'ripemd160');
      gasUsed += opts._common.param('gasPrices', 'ripemd160Word') * BigInt(Math.ceil(data.length / 32));
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$g.OOGResult)(opts.gasLimit);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: (0, util_1$I.setLengthLeft)((0, util_1$I.toBuffer)((0, ripemd160_1.ripemd160)(data)), 32),
      };
  }
  _03Ripemd160.precompile03 = precompile03;

  var _04Identity = {};

  Object.defineProperty(_04Identity, "__esModule", { value: true });
  _04Identity.precompile04 = void 0;
  const util_1$H = dist$a;
  const evm_1$f = evm$1;
  function precompile04(opts) {
      if ((0, util_1$H.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const data = opts.data;
      let gasUsed = opts._common.param('gasPrices', 'identity');
      gasUsed += opts._common.param('gasPrices', 'identityWord') * BigInt(Math.ceil(data.length / 32));
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$f.OOGResult)(opts.gasLimit);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: data,
      };
  }
  _04Identity.precompile04 = precompile04;

  var _05Modexp = {};

  Object.defineProperty(_05Modexp, "__esModule", { value: true });
  _05Modexp.precompile05 = _05Modexp.expmod = void 0;
  const util_1$G = dist$a;
  const evm_1$e = evm$1;
  function multComplexity(x) {
      let fac1;
      let fac2;
      if (x <= BigInt(64)) {
          return x ** BigInt(2);
      }
      else if (x <= BigInt(1024)) {
          // return Math.floor(Math.pow(x, 2) / 4) + 96 * x - 3072
          fac1 = x ** BigInt(2) / BigInt(4);
          fac2 = x * BigInt(96);
          return fac1 + fac2 - BigInt(3072);
      }
      else {
          // return Math.floor(Math.pow(x, 2) / 16) + 480 * x - 199680
          fac1 = x ** BigInt(2) / BigInt(16);
          fac2 = x * BigInt(480);
          return fac1 + fac2 - BigInt(199680);
      }
  }
  function multComplexityEIP2565(x) {
      const words = (x + BigInt(7)) / BigInt(8);
      return words * words;
  }
  function getAdjustedExponentLength(data) {
      let expBytesStart;
      try {
          const baseLen = (0, util_1$G.bufferToBigInt)(data.slice(0, 32));
          expBytesStart = 96 + Number(baseLen); // 96 for base length, then exponent length, and modulus length, then baseLen for the base data, then exponent bytes start
      }
      catch (e) {
          expBytesStart = Number.MAX_SAFE_INTEGER - 32;
      }
      const expLen = (0, util_1$G.bufferToBigInt)(data.slice(32, 64));
      let firstExpBytes = Buffer$8.from(data.slice(expBytesStart, expBytesStart + 32)); // first word of the exponent data
      firstExpBytes = (0, util_1$G.setLengthRight)(firstExpBytes, 32); // reading past the data reads virtual zeros
      let firstExpBigInt = (0, util_1$G.bufferToBigInt)(firstExpBytes);
      let max32expLen = 0;
      if (expLen < BigInt(32)) {
          max32expLen = 32 - Number(expLen);
      }
      firstExpBigInt = firstExpBigInt >> (BigInt(8) * BigInt(Math.max(max32expLen, 0)));
      let bitLen = -1;
      while (firstExpBigInt > BigInt(0)) {
          bitLen = bitLen + 1;
          firstExpBigInt = firstExpBigInt >> BigInt(1);
      }
      let expLenMinus32OrZero = expLen - BigInt(32);
      if (expLenMinus32OrZero < BigInt(0)) {
          expLenMinus32OrZero = BigInt(0);
      }
      const eightTimesExpLenMinus32OrZero = expLenMinus32OrZero * BigInt(8);
      let adjustedExpLen = eightTimesExpLenMinus32OrZero;
      if (bitLen > 0) {
          adjustedExpLen += BigInt(bitLen);
      }
      return adjustedExpLen;
  }
  function expmod(a, power, modulo) {
      if (power === BigInt(0)) {
          return BigInt(1) % modulo;
      }
      let res = BigInt(1);
      while (power > BigInt(0)) {
          if (power & BigInt(1))
              res = (res * a) % modulo;
          a = (a * a) % modulo;
          power >>= BigInt(1);
      }
      return res;
  }
  _05Modexp.expmod = expmod;
  function precompile05(opts) {
      if ((0, util_1$G.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const data = opts.data;
      let adjustedELen = getAdjustedExponentLength(data);
      if (adjustedELen < BigInt(1)) {
          adjustedELen = BigInt(1);
      }
      const bLen = (0, util_1$G.bufferToBigInt)(data.slice(0, 32));
      const eLen = (0, util_1$G.bufferToBigInt)(data.slice(32, 64));
      const mLen = (0, util_1$G.bufferToBigInt)(data.slice(64, 96));
      let maxLen = bLen;
      if (maxLen < mLen) {
          maxLen = mLen;
      }
      const Gquaddivisor = opts._common.param('gasPrices', 'modexpGquaddivisor');
      let gasUsed;
      const bStart = BigInt(96);
      const bEnd = bStart + bLen;
      const eStart = bEnd;
      const eEnd = eStart + eLen;
      const mStart = eEnd;
      const mEnd = mStart + mLen;
      if (!opts._common.isActivatedEIP(2565)) {
          gasUsed = (adjustedELen * multComplexity(maxLen)) / Gquaddivisor;
      }
      else {
          gasUsed = (adjustedELen * multComplexityEIP2565(maxLen)) / Gquaddivisor;
          if (gasUsed < BigInt(200)) {
              gasUsed = BigInt(200);
          }
      }
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$e.OOGResult)(opts.gasLimit);
      }
      if (bLen === BigInt(0)) {
          return {
              executionGasUsed: gasUsed,
              returnValue: (0, util_1$G.setLengthLeft)((0, util_1$G.bigIntToBuffer)(BigInt(0)), Number(mLen)),
          };
      }
      if (mLen === BigInt(0)) {
          return {
              executionGasUsed: gasUsed,
              returnValue: Buffer$8.alloc(0),
          };
      }
      const maxInt = BigInt(Number.MAX_SAFE_INTEGER);
      const maxSize = BigInt(2147483647); // @ethereumjs/util setLengthRight limitation
      if (bLen > maxSize || eLen > maxSize || mLen > maxSize) {
          return (0, evm_1$e.OOGResult)(opts.gasLimit);
      }
      const B = (0, util_1$G.bufferToBigInt)((0, util_1$G.setLengthRight)(data.slice(Number(bStart), Number(bEnd)), Number(bLen)));
      const E = (0, util_1$G.bufferToBigInt)((0, util_1$G.setLengthRight)(data.slice(Number(eStart), Number(eEnd)), Number(eLen)));
      const M = (0, util_1$G.bufferToBigInt)((0, util_1$G.setLengthRight)(data.slice(Number(mStart), Number(mEnd)), Number(mLen)));
      if (mEnd > maxInt) {
          return (0, evm_1$e.OOGResult)(opts.gasLimit);
      }
      let R;
      if (M === BigInt(0)) {
          R = BigInt(0);
      }
      else {
          R = expmod(B, E, M);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: (0, util_1$G.setLengthLeft)((0, util_1$G.bigIntToBuffer)(R), Number(mLen)),
      };
  }
  _05Modexp.precompile05 = precompile05;

  var _06Ecadd = {};

  var index_asm = {exports: {}};

  var _polyfillNode_fs = {};

  var _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _polyfillNode_fs
  });

  var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs$1);

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  // resolves . and .. elements in a path array with directory names there
  // must be no slashes, empty elements, or device names (c:\) in the array
  // (so also no leading and trailing slashes - it does not distinguish
  // relative and absolute paths)
  function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift('..');
      }
    }

    return parts;
  }

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  function resolve() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : '/';

      // Skip empty and invalid entries
      if (typeof path !== 'string') {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  }
  // path.normalize(path)
  // posix version
  function normalize$1(path) {
    var isPathAbsolute = isAbsolute(path),
        trailingSlash = substr(path, -1) === '/';

    // Normalize the path
    path = normalizeArray(filter(path.split('/'), function(p) {
      return !!p;
    }), !isPathAbsolute).join('/');

    if (!path && !isPathAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isPathAbsolute ? '/' : '') + path;
  }
  // posix version
  function isAbsolute(path) {
    return path.charAt(0) === '/';
  }

  // posix version
  function join() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize$1(filter(paths, function(p, index) {
      if (typeof p !== 'string') {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }).join('/'));
  }


  // path.relative(from, to)
  // posix version
  function relative(from, to) {
    from = resolve(from).substr(1);
    to = resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  }

  var sep = '/';
  var delimiter = ':';

  function dirname(path) {
    var result = splitPath(path),
        root = result[0],
        dir = result[1];

    if (!root && !dir) {
      // No dirname whatsoever
      return '.';
    }

    if (dir) {
      // It has a dirname, strip trailing slash
      dir = dir.substr(0, dir.length - 1);
    }

    return root + dir;
  }

  function basename(path, ext) {
    var f = splitPath(path)[2];
    // TODO: make this comparison case-insensitive on windows?
    if (ext && f.substr(-1 * ext.length) === ext) {
      f = f.substr(0, f.length - ext.length);
    }
    return f;
  }


  function extname(path) {
    return splitPath(path)[3];
  }
  var _polyfillNode_path = {
    extname: extname,
    basename: basename,
    dirname: dirname,
    sep: sep,
    delimiter: delimiter,
    relative: relative,
    join: join,
    isAbsolute: isAbsolute,
    normalize: normalize$1,
    resolve: resolve
  };
  function filter (xs, f) {
      if (xs.filter) return xs.filter(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
          if (f(xs[i], i, xs)) res.push(xs[i]);
      }
      return res;
  }

  // String.prototype.substr - negative index don't work in IE8
  var substr = 'ab'.substr(-1) === 'b' ?
      function (str, start, len) { return str.substr(start, len) } :
      function (str, start, len) {
          if (start < 0) start = str.length + start;
          return str.substr(start, len);
      }
  ;

  var _polyfillNode_path$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    resolve: resolve,
    normalize: normalize$1,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    sep: sep,
    delimiter: delimiter,
    dirname: dirname,
    basename: basename,
    extname: extname,
    'default': _polyfillNode_path
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path$1);

  (function (module) {
  var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};for(var key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;if(Module["ENVIRONMENT"]){if(Module["ENVIRONMENT"]==="WEB"){ENVIRONMENT_IS_WEB=true;}else if(Module["ENVIRONMENT"]==="WORKER"){ENVIRONMENT_IS_WORKER=true;}else if(Module["ENVIRONMENT"]==="NODE"){ENVIRONMENT_IS_NODE=true;}else if(Module["ENVIRONMENT"]==="SHELL"){ENVIRONMENT_IS_SHELL=true;}else {throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.")}}else {ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof browser$1$1==="object"&&typeof commonjsRequire==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;}if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=console.log;if(!Module["printErr"])Module["printErr"]=console.warn;var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require$$0$2;if(!nodePath)nodePath=require$$1;filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename);}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret);}assert(ret.buffer);return ret};Module["load"]=function load(f){globalEval(read(f));};if(!Module["thisProgram"]){if(browser$1$1["argv"].length>1){Module["thisProgram"]=browser$1$1["argv"][1].replace(/\\/g,"/");}else {Module["thisProgram"]="unknown-program";}}Module["arguments"]=browser$1$1["argv"].slice(2);{module["exports"]=Module;}Module["inspect"]=(function(){return "[Emscripten Module object]"});}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)};}else {Module["read"]=function shell_read(){throw "no read() available"};}Module["readBinary"]=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs;}else if(typeof arguments!="undefined"){Module["arguments"]=arguments;}if(typeof quit==="function"){Module["quit"]=(function(status,toThrow){quit(status);});}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(f);if(data){return data}throw err}};}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror();};xhr.onerror=onerror;xhr.send(null);};if(typeof arguments!="undefined"){Module["arguments"]=arguments;}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function shell_print(x){console.log(x);};if(!Module["printErr"])Module["printErr"]=function shell_printErr(x){console.warn(x);};}else {var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x);}):(function(x){});}if(ENVIRONMENT_IS_WORKER){Module["load"]=importScripts;}if(typeof Module["setWindowTitle"]==="undefined"){Module["setWindowTitle"]=(function(title){document.title=title;});}}else {throw new Error("Unknown runtime environment. Where are we?")}function globalEval(x){eval.call(null,x);}if(!Module["load"]&&Module["read"]){Module["load"]=function load(f){globalEval(Module["read"](f));};}if(!Module["print"]){Module["print"]=(function(){});}if(!Module["printErr"]){Module["printErr"]=Module["print"];}if(!Module["arguments"]){Module["arguments"]=[];}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program";}if(!Module["quit"]){Module["quit"]=(function(status,toThrow){throw toThrow});}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(var key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=undefined;var Runtime={setTempRet0:(function(value){tempRet0=value;return value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop;}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else {return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,prepVararg:(function(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){assert((ptr&7)===4);ptr+=4;}}else {assert((ptr&3)===0);}return ptr}),getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){return Module["dynCall_"+sig].apply(null,[ptr].concat(args))}else {return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw "Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null;}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text);}}),funcWrappers:{},getFuncWrapper:(function(func,sig){if(!func)return;assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={};}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){if(sig.length===1){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func)};}else if(sig.length===2){sigCache[func]=function dynCall_wrapper(arg){return Runtime.dynCall(sig,func,[arg])};}else {sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,Array.prototype.slice.call(arguments))};}}return sigCache[func]}),getCompilerSetting:(function(name){throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=(ret+size+15|0)&-16;HEAP32[DYNAMICTOP_PTR>>2]=end;if(end>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){HEAP32[DYNAMICTOP_PTR>>2]=ret;return 0}}return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var ABORT=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text);}}function getCFunc(ident){var func=Module["_"+ident];if(!func){try{func=eval("_"+ident);}catch(e){}}assert(func,"Cannot call unknown function "+ident+" (perhaps LLVM optimizations or closure removed it?)");return func}var cwrap,ccall;((function(){var JSfuncs={"stackSave":(function(){Runtime.stackSave();}),"stackRestore":(function(){Runtime.stackRestore();}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=Runtime.stackAlloc(len);stringToUTF8(str,ret,len);}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};ccall=function ccallFunc(ident,returnType,argTypes,args,opts){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i]);}else {cArgs[i]=args[i];}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0){if(opts&&opts.async){EmterpreterAsync.asyncFinalizers.push((function(){Runtime.stackRestore(stack);}));return}Runtime.stackRestore(stack);}return ret};var sourceRegex=/^function\s*[a-zA-Z$_0-9]*\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;function parseJSFunc(jsfunc){var parsed=jsfunc.toString().match(sourceRegex).slice(1);return {arguments:parsed[0],body:parsed[1],returnValue:parsed[2]}}var JSsource=null;function ensureJSsource(){if(!JSsource){JSsource={};for(var fun in JSfuncs){if(JSfuncs.hasOwnProperty(fun)){JSsource[fun]=parseJSFunc(JSfuncs[fun]);}}}}cwrap=function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type==="number"}));var numericRet=returnType!=="string";if(numericRet&&numericArgs){return cfunc}var argNames=argTypes.map((function(x,i){return "$"+i}));var funcstr="(function("+argNames.join(",")+") {";var nargs=argTypes.length;if(!numericArgs){ensureJSsource();funcstr+="var stack = "+JSsource["stackSave"].body+";";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if(type==="number")continue;var convertCode=JSsource[type+"ToC"];funcstr+="var "+convertCode.arguments+" = "+arg+";";funcstr+=convertCode.body+";";funcstr+=arg+"=("+convertCode.returnValue+");";}}var cfuncname=parseJSFunc((function(){return cfunc})).returnValue;funcstr+="var ret = "+cfuncname+"("+argNames.join(",")+");";if(!numericRet){var strgfy=parseJSFunc((function(){return Pointer_stringify})).returnValue;funcstr+="ret = "+strgfy+"(ret);";}if(!numericArgs){ensureJSsource();funcstr+=JSsource["stackRestore"].body.replace("()","(stack)")+";";}funcstr+="return ret})";return eval(funcstr)};}))();Module["ccall"]=ccall;Module["cwrap"]=cwrap;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type);}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type);}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab;}else {zeroinit=false;size=slab.length;}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr;}else {ret=[typeof _malloc==="function"?_malloc:Runtime.staticAlloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length));}if(zeroinit){var ptr=ret,stop;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0;}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0;}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret);}else {HEAPU8.set(new Uint8Array(slab),ret);}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr);}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type;}i+=typeSize;}return ret}Module["allocate"]=allocate;function getMemory(size){if(!staticSealed)return Runtime.staticAlloc(size);if(!runtimeInitialized)return Runtime.dynamicAlloc(size);return _malloc(size)}Module["getMemory"]=getMemory;function Pointer_stringify(ptr,length){if(length===0||!ptr)return "";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK;}return ret}return Module["UTF8ToString"](ptr)}Module["Pointer_stringify"]=Pointer_stringify;function AsciiToString(ptr){var str="";while(1){var ch=HEAP8[ptr++>>0];if(!ch)return str;str+=String.fromCharCode(ch);}}Module["AsciiToString"]=AsciiToString;function stringToAscii(str,outPtr){return writeAsciiToMemory(str,outPtr,false)}Module["stringToAscii"]=stringToAscii;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else {var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3;}else {u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4;}else {u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5;}}}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}}Module["UTF8ArrayToString"]=UTF8ArrayToString;function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}Module["UTF8ToString"]=UTF8ToString;function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else {if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}Module["stringToUTF8Array"]=stringToUTF8Array;function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}Module["stringToUTF8"]=stringToUTF8;function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len;}else if(u<=2047){len+=2;}else if(u<=65535){len+=3;}else if(u<=2097151){len+=4;}else if(u<=67108863){len+=5;}else {len+=6;}}return len}Module["lengthBytesUTF8"]=lengthBytesUTF8;typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function demangle(func){var __cxa_demangle_func=Module["___cxa_demangle"]||Module["__cxa_demangle"];if(__cxa_demangle_func){try{var s=func.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret);}return func}Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e;}if(!err.stack){return "(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}Module["stackTrace"]=stackTrace;var HEAP,buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer);}var STATIC_BASE,STATICTOP,staticSealed;var STACK_BASE,STACKTOP,STACK_MAX;var DYNAMIC_BASE,DYNAMICTOP_PTR;STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0;staticSealed=false;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");}function enlargeMemory(){abortOnCannotGrowMemory();}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"];}else {{buffer=new ArrayBuffer(TOTAL_MEMORY);}}updateGlobalBufferViews();function getTotalMemory(){return TOTAL_MEMORY}HEAP32[0]=1668509029;HEAP16[1]=25459;if(HEAPU8[2]!==115||HEAPU8[3]!==99)throw "Runtime error: expected the system to be little-endian!";Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else {Module["dynCall_vi"](func,callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}Module["addOnPreRun"]=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb);}Module["addOnInit"]=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb);}Module["addOnPreMain"]=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb);}Module["addOnExit"]=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}Module["addOnPostRun"]=addOnPostRun;function writeStringToMemory(string,buffer,dontAddNull){Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var lastChar,end;if(dontAddNull){end=buffer+lengthBytesUTF8(string);lastChar=HEAP8[end];}stringToUTF8(string,buffer,Infinity);if(dontAddNull)HEAP8[end]=lastChar;}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer);}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i);}if(!dontAddNull)HEAP8[buffer>>0]=0;}Module["writeAsciiToMemory"]=writeAsciiToMemory;if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];if(!Math["clz32"])Math["clz32"]=(function(x){x=x>>>0;for(var i=0;i<32;i++){if(x&1<<31-i)return i}return 32});Math.clz32=Math["clz32"];if(!Math["trunc"])Math["trunc"]=(function(x){return x<0?Math.ceil(x):Math.floor(x)});Math.trunc=Math["trunc"];var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_min=Math.min;var runDependencies=0;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;STATIC_BASE=Runtime.GLOBAL_BASE;STATICTOP=STATIC_BASE+17504;__ATINIT__.push();memoryInitializer="data:application/octet-stream;base64,AQAA8JP14UORcLl5SOgzKF1YgYG2RVC4KaAx4XJOZDCnbSGuRea4G+NZXOOxOv5ThYC7Uz2DSYylRE5/sdAWAon6ilNb/Czz+wFF1BEZ57X2f0EK/x6rRx81uMpxn9gG3zAV2q9tzbG2PSin5hDyYvsK2goMC3/vRCVZLZBu/SBH/XzYFowgPI3KcWiRaoGXXViBgbZFULgpoDHhck5kMAAAAAAAAP8DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8DAAAAAAAAAAAAAAAAAAAAAP8DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wMAAAAAAACgBgAADQAAAHYqAADAAQAACAcAAA0AAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAEAAgACAwAAAAAEAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAADAgAAAAAGAAIAAAcAAAIIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAkKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAEAAAAAAAAAAgQAAAwAAgAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAABAgMDAwQDAwMDAwMFBgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAADA/wAAAAD/AwAAAAAAAAAA/wMAAP8DAAAAAAAAAAAAAADAAQDA/wAAAAAAAP8D/wMAAAAAAAAAAAAA/wMAAAAA/////+cBAAAAAAAAgAAAAP4DAAcAAP8DAAD/AwAAAAAAAAAA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dC9zcmMvbGliY29yZS9vcHRpb24ucnNtaWxsZXIgbG9vcCBjYW5ub3QgcHJvZHVjZSB6ZXJvL2NoZWNrb3V0L3NyYy9saWJhbGxvYy92ZWMucnNjYXBhY2l0eSBvdmVyZmxvdy9jaGVja291dC9zcmMvbGliYWxsb2MvcmF3X3ZlYy5yc25vdCB5ZXQgaW1wbGVtZW50ZWQvaG9tZS9odWdvLy5jYXJnby9naXQvY2hlY2tvdXRzL2JuLTgwMTNiNDgxODM5NWRjZmIvNjI0YzYwYi9zcmMvZmllbGRzL2ZxNi5yc2NhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvY2hlY2tvdXQvc3JjL2xpYmNvcmUvb3B0aW9uLnJzaW52YWxpZCBsYXlvdXQgZm9yIGFsbG9jX2FycmF5SW52YWxpZCBjaGFyYWN0ZXIgJycgYXQgcG9zaXRpb24gSW52YWxpZCBpbnB1dCBsZW5ndGhjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL2NoZWNrb3V0L3NyYy9saWJjb3JlL29wdGlvbi5yc2NhcGFjaXR5IG92ZXJmbG93L2NoZWNrb3V0L3NyYy9saWJhbGxvYy9yYXdfdmVjLnJzaW52YWxpZCBsYXlvdXQgZm9yIGFsbG9jX2FycmF5Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZS9jaGVja291dC9zcmMvbGliY29yZS9vcHRpb24ucnNmYXRhbCBydW50aW1lIGVycm9yOiBtYWludW5leHBlY3RlZCByZXR1cm4gdmFsdWUgd2hpbGUgdW53aW5kaW5nOiBfX3J1c3RfYmVnaW5fc2hvcnRfYmFja3RyYWNlL2NoZWNrb3V0L3NyYy9saWJjb3JlL3N0ci9wYXR0ZXJuLnJzL2NoZWNrb3V0L3NyYy9saWJjb3JlL3NsaWNlL21vZC5yc1Vud2luZEVycm9yY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZWZhaWxlZCB0byBpbml0aWF0ZSBwYW5pYywgZXJyb3IgL2NoZWNrb3V0L3NyYy9saWJzdGQvc3lzL3VuaXgvb3MucnNzdHJlcnJvcl9yIGZhaWx1cmVyd2xvY2sgbWF4aW11bSByZWFkZXIgY291bnQgZXhjZWVkZWRyd2xvY2sgcmVhZCBsb2NrIHdvdWxkIHJlc3VsdCBpbiBkZWFkbG9ja3RocmVhZCBwYW5pY2tlZCB3aGlsZSBwYW5pY2tpbmcuIGFib3J0aW5nLgpCb3g8QW55Pjx1bm5hbWVkPgFub3RlOiBSdW4gd2l0aCBgUlVTVF9CQUNLVFJBQ0U9MWAgZm9yIGEgYmFja3RyYWNlLgp0aHJlYWQgJycgcGFuaWNrZWQgYXQgJycsIDoKdGhyZWFkIHBhbmlja2VkIHdoaWxlIHByb2Nlc3NpbmcgcGFuaWMuIGFib3J0aW5nLgovY2hlY2tvdXQvc3JjL2xpYnN0ZC9zeXMvdW5peC9yd2xvY2sucnM6IC9jaGVja291dC9zcmMvbGliY29yZS9yZXN1bHQucnMvY2hlY2tvdXQvc3JjL2xpYnN0ZC9zeW5jL2NvbmR2YXIucnNhdHRlbXB0ZWQgdG8gdXNlIGEgY29uZGl0aW9uIHZhcmlhYmxlIHdpdGggdHdvIG11dGV4ZXNpbnZhbGlkIGxheW91dCBmb3IgYWxsb2NfYXJyYXlkYXRhIHByb3ZpZGVkIGNvbnRhaW5zIGEgbnVsIGJ5dGVhc3NlcnRpb24gZmFpbGVkOiBgKGxlZnQgPT0gcmlnaHQpYAogIGxlZnQ6IGBgLAogcmlnaHQ6IGBgL2NoZWNrb3V0L3NyYy9saWJzdGQvc3lzL3VuaXgvY29uZHZhci5yc0Vycm9ycmVwck9zY29kZW1lc3NhZ2VLaW5kQ3VzdG9ta2luZGVycm9yTm90Rm91bmRQZXJtaXNzaW9uRGVuaWVkQ29ubmVjdGlvblJlZnVzZWRDb25uZWN0aW9uUmVzZXRDb25uZWN0aW9uQWJvcnRlZE5vdENvbm5lY3RlZEFkZHJJblVzZUFkZHJOb3RBdmFpbGFibGVCcm9rZW5QaXBlQWxyZWFkeUV4aXN0c1dvdWxkQmxvY2tJbnZhbGlkSW5wdXRJbnZhbGlkRGF0YVRpbWVkT3V0V3JpdGVaZXJvSW50ZXJydXB0ZWRPdGhlclVuZXhwZWN0ZWRFb2ZfX05vbmV4aGF1c3RpdmVpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlZW50aXR5IG5vdCBmb3VuZGNvbm5lY3Rpb24gcmVmdXNlZGNvbm5lY3Rpb24gcmVzZXRjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVicm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja2ludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb29wZXJhdGlvbiBpbnRlcnJ1cHRlZG90aGVyIG9zIGVycm9ydW5leHBlY3RlZCBlbmQgb2YgZmlsZXBlcm1pc3Npb24gZGVuaWVkL2NoZWNrb3V0L3NyYy9saWJzdGQvaW8vZXJyb3IucnMgKG9zIGVycm9yIFx4TnVsRXJyb3JjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL2NoZWNrb3V0L3NyYy9saWJjb3JlL29wdGlvbi5yc2Fzc2VydGlvbiBmYWlsZWQ6IGAobGVmdCA9PSByaWdodClgCiAgbGVmdDogYGAsCiByaWdodDogYGAvY2hlY2tvdXQvc3JjL2xpYnN0ZC9lbnYucnNmYWlsZWQgdG8gZ2V0IGVudmlyb25tZW50IHZhcmlhYmxlIGBgOiBPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWRhc3NlcnRpb24gZmFpbGVkOiBzdGF0ZSAmIFNUQVRFX01BU0sgPT0gUlVOTklORy9jaGVja291dC9zcmMvbGlic3RkL3N5bmMvb25jZS5yc1N0cmluZ0Vycm9yY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZXVzZSBvZiBzdGQ6OnRocmVhZDo6Y3VycmVudCgpIGlzIG5vdCBwb3NzaWJsZSBhZnRlciB0aGUgdGhyZWFkJ3MgbG9jYWwgZGF0YSBoYXMgYmVlbiBkZXN0cm95ZWQvY2hlY2tvdXQvc3JjL2xpYnN0ZC90aHJlYWQvbW9kLnJzaW5jb25zaXN0ZW50IHN0YXRlIGluIHVucGFyay9jaGVja291dC9zcmMvbGlic3RkL3N5c19jb21tb24vYmFja3RyYWNlLnJzaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZVJVU1RfQkFDS1RSQUNFMGZ1bGxjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL2NoZWNrb3V0L3NyYy9saWJjb3JlL29wdGlvbi5yc2luY29uc2lzdGVudCBwYXJrIHN0YXRldGhyZWFkIG5hbWUgbWF5IG5vdCBjb250YWluIGludGVyaW9yIG51bGwgYnl0ZXNmYWlsZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIHRocmVhZCBJRDogYml0c3BhY2UgZXhoYXVzdGVkc3RhY2sgYmFja3RyYWNlOgpub3RlOiBTb21lIGRldGFpbHMgYXJlIG9taXR0ZWQsIHJ1biB3aXRoIGBSVVNUX0JBQ0tUUkFDRT1mdWxsYCBmb3IgYSB2ZXJib3NlIGJhY2t0cmFjZS4KLmxsdm0uRV9aTlpOMTdoXyQkJFNQJCRCUCQkUkYkJExUJCRHVCQkTFAkJFJQJCRDJCR1N2UkJHUyMCQkdTI3JCR1NWIkJHU1ZCQkdTdiJCR1N2QkJHUzYiQkdTJiJCR1MjIkL2NoZWNrb3V0L3NyYy9saWJjb3JlL3N0ci9wYXR0ZXJuLnJzL2NoZWNrb3V0L3NyYy9saWJjb3JlL3NsaWNlL21vZC5ycyAgOiAgLSBjYXBhY2l0eSBvdmVyZmxvdy9jaGVja291dC9zcmMvbGliYWxsb2MvcmF3X3ZlYy5yc1RyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0eWNhbm5vdCBjaGFuZ2UgYWxpZ25tZW50IG9uIGByZWFsbG9jYC9jaGVja291dC9zcmMvbGlic3RkL3N5c19jb21tb24vYXRfZXhpdF9pbXAucnNhc3NlcnRpb24gZmFpbGVkOiBxdWV1ZSBhcyB1c2l6ZSAhPSAxYXNzZXJ0aW9uIGZhaWxlZDoga2V5ICE9IDAvY2hlY2tvdXQvc3JjL2xpYnN0ZC9zeXNfY29tbW9uL3RocmVhZF9sb2NhbC5ycy9jaGVja291dC9zcmMvbGlic3RkL3N5cy91bml4L3RocmVhZF9sb2NhbC5yc2Fzc2VydGlvbiBmYWlsZWQ6IGAobGVmdCA9PSByaWdodClgCiAgbGVmdDogYGAsCiByaWdodDogYGBhbHJlYWR5IGJvcnJvd2VkYWxyZWFkeSBtdXRhYmx5IGJvcnJvd2VkY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZS9jaGVja291dC9zcmMvbGliY29yZS9vcHRpb24ucnNjYW5ub3QgYWNjZXNzIGEgVExTIHZhbHVlIGR1cmluZyBvciBhZnRlciBpdCBpcyBkZXN0cm95ZWRmb3JtYXR0ZXIgZXJyb3IvY2hlY2tvdXQvc3JjL2xpYnN0ZC9zeXNfY29tbW9uL3RocmVhZF9pbmZvLnJzYXNzZXJ0aW9uIGZhaWxlZDogYy5ib3Jyb3coKS5pc19ub25lKClBY2Nlc3NFcnJvcmZhaWxlZCB0byB3cml0ZSB3aG9sZSBidWZmZXIvY2hlY2tvdXQvc3JjL2xpYnN0ZC9zeXMvdW5peC9hcmdzLnJzYXNzZXJ0aW9uIGZhaWxlZDogKCpwdHIpLmlzX25vbmUoKS9jaGVja291dC9zcmMvbGliY29yZS9zdHIvcGF0dGVybi5ycy9jaGVja291dC9zcmMvbGliY29yZS9zbGljZS9tb2QucnNQb2lzb25FcnJvciB7IGlubmVyOiAuLiB9ZmF0YWwgcnVudGltZSBlcnJvcjogCmFzc2VydGlvbiBmYWlsZWQ6ICFwdHIuaXNfbnVsbCgpL2NoZWNrb3V0L3NyYy9saWJwYW5pY191bndpbmQvZW1jYy5yc2ludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVfVVJDX05PX1JFQVNPTl9VUkNfRk9SRUlHTl9FWENFUFRJT05fQ0FVR0hUX1VSQ19GQVRBTF9QSEFTRTJfRVJST1JfVVJDX0ZBVEFMX1BIQVNFMV9FUlJPUl9VUkNfTk9STUFMX1NUT1BfVVJDX0VORF9PRl9TVEFDS19VUkNfSEFORExFUl9GT1VORF9VUkNfSU5TVEFMTF9DT05URVhUX1VSQ19DT05USU5VRV9VTldJTkRfVVJDX0ZBSUxVUkVhbGxvY2F0b3IgbWVtb3J5IGV4aGF1c3RlZHVuc3VwcG9ydGVkIGFsbG9j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gLpXCRKAjoFHA4VCDxWFUCuH1YDXKUsFCgQChKA8BgEEVQUbNAKBDiwEZAxWCg0DXAQ9OR0NLAQJBwIOBoCag9ULDQMJB3QMVSsMBDgICgYoCB5SDAQ9AxwUGCgBDxeGGUJvcnJvd0Vycm9yQm9ycm93TXV0RXJyb3JjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL2NoZWNrb3V0L3NyYy9saWJjb3JlL29wdGlvbi5yc1QhIhkNAQIDEUscDBAECx0SHidobm9wcWIgBQYPExQVGggWBygkFxgJCg4bHyUjg4J9JiorPD0+P0NHSk1YWVpbXF1eX2BhY2RlZmdpamtscnN0eXp7fABJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbg==";var tempDoublePtr=STATICTOP;STATICTOP+=16;function __ZSt18uncaught_exceptionv(){return !!__ZSt18uncaught_exceptionv.uncaught_exception}var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:(function(adjusted){if(!adjusted||EXCEPTIONS.infos[adjusted])return adjusted;for(var ptr in EXCEPTIONS.infos){var info=EXCEPTIONS.infos[ptr];if(info.adjusted===adjusted){return ptr}}return adjusted}),addRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount++;}),decRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];assert(info.refcount>0);info.refcount--;if(info.refcount===0&&!info.rethrown){if(info.destructor){Module["dynCall_vi"](info.destructor,ptr);}delete EXCEPTIONS.infos[ptr];___cxa_free_exception(ptr);}}),clearRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount=0;})};function ___resumeException(ptr){if(!EXCEPTIONS.last){EXCEPTIONS.last=ptr;}throw ptr}function ___cxa_find_matching_catch(){var thrown=EXCEPTIONS.last;if(!thrown){return (Runtime.setTempRet0(0),0)|0}var info=EXCEPTIONS.infos[thrown];var throwntype=info.type;if(!throwntype){return (Runtime.setTempRet0(0),thrown)|0}var typeArray=Array.prototype.slice.call(arguments);Module["___cxa_is_pointer_type"](throwntype);if(!___cxa_find_matching_catch.buffer)___cxa_find_matching_catch.buffer=_malloc(4);HEAP32[___cxa_find_matching_catch.buffer>>2]=thrown;thrown=___cxa_find_matching_catch.buffer;for(var i=0;i<typeArray.length;i++){if(typeArray[i]&&Module["___cxa_can_catch"](typeArray[i],throwntype,thrown)){thrown=HEAP32[thrown>>2];info.adjusted=thrown;return (Runtime.setTempRet0(typeArray[i]),thrown)|0}}thrown=HEAP32[thrown>>2];return (Runtime.setTempRet0(throwntype),thrown)|0}function ___cxa_throw(ptr,type,destructor){EXCEPTIONS.infos[ptr]={ptr:ptr,adjusted:ptr,type:type,destructor:destructor,refcount:0,caught:false,rethrown:false};EXCEPTIONS.last=ptr;if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exception=1;}else {__ZSt18uncaught_exceptionv.uncaught_exception++;}throw ptr}function __Unwind_FindEnclosingFunction(){return 0}function _emscripten_set_main_loop_timing(mode,value){Browser.mainLoop.timingMode=mode;Browser.mainLoop.timingValue=value;if(!Browser.mainLoop.func){return 1}if(mode==0){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setTimeout(){var timeUntilNextTick=Math.max(0,Browser.mainLoop.tickStartTime+value-_emscripten_get_now())|0;setTimeout(Browser.mainLoop.runner,timeUntilNextTick);};Browser.mainLoop.method="timeout";}else if(mode==1){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_rAF(){Browser.requestAnimationFrame(Browser.mainLoop.runner);};Browser.mainLoop.method="rAF";}else if(mode==2){if(!window["setImmediate"]){var setImmediates=[];var emscriptenMainLoopMessageId="setimmediate";function Browser_setImmediate_messageHandler(event){if(event.source===window&&event.data===emscriptenMainLoopMessageId){event.stopPropagation();setImmediates.shift()();}}window.addEventListener("message",Browser_setImmediate_messageHandler,true);window["setImmediate"]=function Browser_emulated_setImmediate(func){setImmediates.push(func);if(ENVIRONMENT_IS_WORKER){if(Module["setImmediates"]===undefined)Module["setImmediates"]=[];Module["setImmediates"].push(func);window.postMessage({target:emscriptenMainLoopMessageId});}else window.postMessage(emscriptenMainLoopMessageId,"*");};}Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setImmediate(){window["setImmediate"](Browser.mainLoop.runner);};Browser.mainLoop.method="immediate";}return 0}function _emscripten_get_now(){abort();}function _emscripten_set_main_loop(func,fps,simulateInfiniteLoop,arg,noSetTiming){Module["noExitRuntime"]=true;assert(!Browser.mainLoop.func,"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.");Browser.mainLoop.func=func;Browser.mainLoop.arg=arg;var browserIterationFunc;if(typeof arg!=="undefined"){browserIterationFunc=(function(){Module["dynCall_vi"](func,arg);});}else {browserIterationFunc=(function(){Module["dynCall_v"](func);});}var thisMainLoopId=Browser.mainLoop.currentlyRunningMainloop;Browser.mainLoop.runner=function Browser_mainLoop_runner(){if(ABORT)return;if(Browser.mainLoop.queue.length>0){var start=Date.now();var blocker=Browser.mainLoop.queue.shift();blocker.func(blocker.arg);if(Browser.mainLoop.remainingBlockers){var remaining=Browser.mainLoop.remainingBlockers;var next=remaining%1==0?remaining-1:Math.floor(remaining);if(blocker.counted){Browser.mainLoop.remainingBlockers=next;}else {next=next+.5;Browser.mainLoop.remainingBlockers=(8*remaining+next)/9;}}console.log('main loop blocker "'+blocker.name+'" took '+(Date.now()-start)+" ms");Browser.mainLoop.updateStatus();if(thisMainLoopId<Browser.mainLoop.currentlyRunningMainloop)return;setTimeout(Browser.mainLoop.runner,0);return}if(thisMainLoopId<Browser.mainLoop.currentlyRunningMainloop)return;Browser.mainLoop.currentFrameNumber=Browser.mainLoop.currentFrameNumber+1|0;if(Browser.mainLoop.timingMode==1&&Browser.mainLoop.timingValue>1&&Browser.mainLoop.currentFrameNumber%Browser.mainLoop.timingValue!=0){Browser.mainLoop.scheduler();return}else if(Browser.mainLoop.timingMode==0){Browser.mainLoop.tickStartTime=_emscripten_get_now();}if(Browser.mainLoop.method==="timeout"&&Module.ctx){Module.printErr("Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!");Browser.mainLoop.method="";}Browser.mainLoop.runIter(browserIterationFunc);if(thisMainLoopId<Browser.mainLoop.currentlyRunningMainloop)return;if(typeof SDL==="object"&&SDL.audio&&SDL.audio.queueNewAudioData)SDL.audio.queueNewAudioData();Browser.mainLoop.scheduler();};if(!noSetTiming){if(fps&&fps>0)_emscripten_set_main_loop_timing(0,1e3/fps);else _emscripten_set_main_loop_timing(1,1);Browser.mainLoop.scheduler();}if(simulateInfiniteLoop){throw "SimulateInfiniteLoop"}}var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:(function(){Browser.mainLoop.scheduler=null;Browser.mainLoop.currentlyRunningMainloop++;}),resume:(function(){Browser.mainLoop.currentlyRunningMainloop++;var timingMode=Browser.mainLoop.timingMode;var timingValue=Browser.mainLoop.timingValue;var func=Browser.mainLoop.func;Browser.mainLoop.func=null;_emscripten_set_main_loop(func,0,false,Browser.mainLoop.arg,true);_emscripten_set_main_loop_timing(timingMode,timingValue);Browser.mainLoop.scheduler();}),updateStatus:(function(){if(Module["setStatus"]){var message=Module["statusMessage"]||"Please wait...";var remaining=Browser.mainLoop.remainingBlockers;var expected=Browser.mainLoop.expectedBlockers;if(remaining){if(remaining<expected){Module["setStatus"](message+" ("+(expected-remaining)+"/"+expected+")");}else {Module["setStatus"](message);}}else {Module["setStatus"]("");}}}),runIter:(function(func){if(ABORT)return;if(Module["preMainLoop"]){var preRet=Module["preMainLoop"]();if(preRet===false){return}}try{func();}catch(e){if(e instanceof ExitStatus){return}else {if(e&&typeof e==="object"&&e.stack)Module.printErr("exception thrown: "+[e,e.stack]);throw e}}if(Module["postMainLoop"])Module["postMainLoop"]();})},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:(function(){if(!Module["preloadPlugins"])Module["preloadPlugins"]=[];if(Browser.initted)return;Browser.initted=true;try{new Blob;Browser.hasBlobConstructor=true;}catch(e){Browser.hasBlobConstructor=false;console.log("warning: no blob constructor, cannot create blobs with mimetypes");}Browser.BlobBuilder=typeof MozBlobBuilder!="undefined"?MozBlobBuilder:typeof WebKitBlobBuilder!="undefined"?WebKitBlobBuilder:!Browser.hasBlobConstructor?console.log("warning: no BlobBuilder"):null;Browser.URLObject=typeof window!="undefined"?window.URL?window.URL:window.webkitURL:undefined;if(!Module.noImageDecoding&&typeof Browser.URLObject==="undefined"){console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");Module.noImageDecoding=true;}var imagePlugin={};imagePlugin["canHandle"]=function imagePlugin_canHandle(name){return !Module.noImageDecoding&&/\.(jpg|jpeg|png|bmp)$/i.test(name)};imagePlugin["handle"]=function imagePlugin_handle(byteArray,name,onload,onerror){var b=null;if(Browser.hasBlobConstructor){try{b=new Blob([byteArray],{type:Browser.getMimetype(name)});if(b.size!==byteArray.length){b=new Blob([(new Uint8Array(byteArray)).buffer],{type:Browser.getMimetype(name)});}}catch(e){Runtime.warnOnce("Blob constructor present but fails: "+e+"; falling back to blob builder");}}if(!b){var bb=new Browser.BlobBuilder;bb.append((new Uint8Array(byteArray)).buffer);b=bb.getBlob();}var url=Browser.URLObject.createObjectURL(b);var img=new Image;img.onload=function img_onload(){assert(img.complete,"Image "+name+" could not be decoded");var canvas=document.createElement("canvas");canvas.width=img.width;canvas.height=img.height;var ctx=canvas.getContext("2d");ctx.drawImage(img,0,0);Module["preloadedImages"][name]=canvas;Browser.URLObject.revokeObjectURL(url);if(onload)onload(byteArray);};img.onerror=function img_onerror(event){console.log("Image "+url+" could not be decoded");if(onerror)onerror();};img.src=url;};Module["preloadPlugins"].push(imagePlugin);var audioPlugin={};audioPlugin["canHandle"]=function audioPlugin_canHandle(name){return !Module.noAudioDecoding&&name.substr(-4)in{".ogg":1,".wav":1,".mp3":1}};audioPlugin["handle"]=function audioPlugin_handle(byteArray,name,onload,onerror){var done=false;function finish(audio){if(done)return;done=true;Module["preloadedAudios"][name]=audio;if(onload)onload(byteArray);}function fail(){if(done)return;done=true;Module["preloadedAudios"][name]=new Audio;if(onerror)onerror();}if(Browser.hasBlobConstructor){try{var b=new Blob([byteArray],{type:Browser.getMimetype(name)});}catch(e){return fail()}var url=Browser.URLObject.createObjectURL(b);var audio=new Audio;audio.addEventListener("canplaythrough",(function(){finish(audio);}),false);audio.onerror=function audio_onerror(event){if(done)return;console.log("warning: browser could not fully decode audio "+name+", trying slower base64 approach");function encode64(data){var BASE="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var PAD="=";var ret="";var leftchar=0;var leftbits=0;for(var i=0;i<data.length;i++){leftchar=leftchar<<8|data[i];leftbits+=8;while(leftbits>=6){var curr=leftchar>>leftbits-6&63;leftbits-=6;ret+=BASE[curr];}}if(leftbits==2){ret+=BASE[(leftchar&3)<<4];ret+=PAD+PAD;}else if(leftbits==4){ret+=BASE[(leftchar&15)<<2];ret+=PAD;}return ret}audio.src="data:audio/x-"+name.substr(-3)+";base64,"+encode64(byteArray);finish(audio);};audio.src=url;Browser.safeSetTimeout((function(){finish(audio);}),1e4);}else {return fail()}};Module["preloadPlugins"].push(audioPlugin);function pointerLockChange(){Browser.pointerLock=document["pointerLockElement"]===Module["canvas"]||document["mozPointerLockElement"]===Module["canvas"]||document["webkitPointerLockElement"]===Module["canvas"]||document["msPointerLockElement"]===Module["canvas"];}var canvas=Module["canvas"];if(canvas){canvas.requestPointerLock=canvas["requestPointerLock"]||canvas["mozRequestPointerLock"]||canvas["webkitRequestPointerLock"]||canvas["msRequestPointerLock"]||(function(){});canvas.exitPointerLock=document["exitPointerLock"]||document["mozExitPointerLock"]||document["webkitExitPointerLock"]||document["msExitPointerLock"]||(function(){});canvas.exitPointerLock=canvas.exitPointerLock.bind(document);document.addEventListener("pointerlockchange",pointerLockChange,false);document.addEventListener("mozpointerlockchange",pointerLockChange,false);document.addEventListener("webkitpointerlockchange",pointerLockChange,false);document.addEventListener("mspointerlockchange",pointerLockChange,false);if(Module["elementPointerLock"]){canvas.addEventListener("click",(function(ev){if(!Browser.pointerLock&&Module["canvas"].requestPointerLock){Module["canvas"].requestPointerLock();ev.preventDefault();}}),false);}}}),createContext:(function(canvas,useWebGL,setInModule,webGLContextAttributes){if(useWebGL&&Module.ctx&&canvas==Module.canvas)return Module.ctx;var ctx;var contextHandle;if(useWebGL){var contextAttributes={antialias:false,alpha:false};if(webGLContextAttributes){for(var attribute in webGLContextAttributes){contextAttributes[attribute]=webGLContextAttributes[attribute];}}contextHandle=GL.createContext(canvas,contextAttributes);if(contextHandle){ctx=GL.getContext(contextHandle).GLctx;}}else {ctx=canvas.getContext("2d");}if(!ctx)return null;if(setInModule){if(!useWebGL)assert(typeof GLctx==="undefined","cannot set in module if GLctx is used, but we are a non-GL context that would replace it");Module.ctx=ctx;if(useWebGL)GL.makeContextCurrent(contextHandle);Module.useWebGL=useWebGL;Browser.moduleContextCreatedCallbacks.forEach((function(callback){callback();}));Browser.init();}return ctx}),destroyContext:(function(canvas,useWebGL,setInModule){}),fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:(function(lockPointer,resizeCanvas,vrDevice){Browser.lockPointer=lockPointer;Browser.resizeCanvas=resizeCanvas;Browser.vrDevice=vrDevice;if(typeof Browser.lockPointer==="undefined")Browser.lockPointer=true;if(typeof Browser.resizeCanvas==="undefined")Browser.resizeCanvas=false;if(typeof Browser.vrDevice==="undefined")Browser.vrDevice=null;var canvas=Module["canvas"];function fullscreenChange(){Browser.isFullscreen=false;var canvasContainer=canvas.parentNode;if((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvasContainer){canvas.exitFullscreen=document["exitFullscreen"]||document["cancelFullScreen"]||document["mozCancelFullScreen"]||document["msExitFullscreen"]||document["webkitCancelFullScreen"]||(function(){});canvas.exitFullscreen=canvas.exitFullscreen.bind(document);if(Browser.lockPointer)canvas.requestPointerLock();Browser.isFullscreen=true;if(Browser.resizeCanvas)Browser.setFullscreenCanvasSize();}else {canvasContainer.parentNode.insertBefore(canvas,canvasContainer);canvasContainer.parentNode.removeChild(canvasContainer);if(Browser.resizeCanvas)Browser.setWindowedCanvasSize();}if(Module["onFullScreen"])Module["onFullScreen"](Browser.isFullscreen);if(Module["onFullscreen"])Module["onFullscreen"](Browser.isFullscreen);Browser.updateCanvasDimensions(canvas);}if(!Browser.fullscreenHandlersInstalled){Browser.fullscreenHandlersInstalled=true;document.addEventListener("fullscreenchange",fullscreenChange,false);document.addEventListener("mozfullscreenchange",fullscreenChange,false);document.addEventListener("webkitfullscreenchange",fullscreenChange,false);document.addEventListener("MSFullscreenChange",fullscreenChange,false);}var canvasContainer=document.createElement("div");canvas.parentNode.insertBefore(canvasContainer,canvas);canvasContainer.appendChild(canvas);canvasContainer.requestFullscreen=canvasContainer["requestFullscreen"]||canvasContainer["mozRequestFullScreen"]||canvasContainer["msRequestFullscreen"]||(canvasContainer["webkitRequestFullscreen"]?(function(){canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]);}):null)||(canvasContainer["webkitRequestFullScreen"]?(function(){canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]);}):null);if(vrDevice){canvasContainer.requestFullscreen({vrDisplay:vrDevice});}else {canvasContainer.requestFullscreen();}}),requestFullScreen:(function(lockPointer,resizeCanvas,vrDevice){Module.printErr("Browser.requestFullScreen() is deprecated. Please call Browser.requestFullscreen instead.");Browser.requestFullScreen=(function(lockPointer,resizeCanvas,vrDevice){return Browser.requestFullscreen(lockPointer,resizeCanvas,vrDevice)});return Browser.requestFullscreen(lockPointer,resizeCanvas,vrDevice)}),nextRAF:0,fakeRequestAnimationFrame:(function(func){var now=Date.now();if(Browser.nextRAF===0){Browser.nextRAF=now+1e3/60;}else {while(now+2>=Browser.nextRAF){Browser.nextRAF+=1e3/60;}}var delay=Math.max(Browser.nextRAF-now,0);setTimeout(func,delay);}),requestAnimationFrame:function requestAnimationFrame(func){if(typeof window==="undefined"){Browser.fakeRequestAnimationFrame(func);}else {if(!window.requestAnimationFrame){window.requestAnimationFrame=window["requestAnimationFrame"]||window["mozRequestAnimationFrame"]||window["webkitRequestAnimationFrame"]||window["msRequestAnimationFrame"]||window["oRequestAnimationFrame"]||Browser.fakeRequestAnimationFrame;}window.requestAnimationFrame(func);}},safeCallback:(function(func){return(function(){if(!ABORT)return func.apply(null,arguments)})}),allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:(function(){Browser.allowAsyncCallbacks=false;}),resumeAsyncCallbacks:(function(){Browser.allowAsyncCallbacks=true;if(Browser.queuedAsyncCallbacks.length>0){var callbacks=Browser.queuedAsyncCallbacks;Browser.queuedAsyncCallbacks=[];callbacks.forEach((function(func){func();}));}}),safeRequestAnimationFrame:(function(func){return Browser.requestAnimationFrame((function(){if(ABORT)return;if(Browser.allowAsyncCallbacks){func();}else {Browser.queuedAsyncCallbacks.push(func);}}))}),safeSetTimeout:(function(func,timeout){Module["noExitRuntime"]=true;return setTimeout((function(){if(ABORT)return;if(Browser.allowAsyncCallbacks){func();}else {Browser.queuedAsyncCallbacks.push(func);}}),timeout)}),safeSetInterval:(function(func,timeout){Module["noExitRuntime"]=true;return setInterval((function(){if(ABORT)return;if(Browser.allowAsyncCallbacks){func();}}),timeout)}),getMimetype:(function(name){return {"jpg":"image/jpeg","jpeg":"image/jpeg","png":"image/png","bmp":"image/bmp","ogg":"audio/ogg","wav":"audio/wav","mp3":"audio/mpeg"}[name.substr(name.lastIndexOf(".")+1)]}),getUserMedia:(function(func){if(!window.getUserMedia){window.getUserMedia=navigator["getUserMedia"]||navigator["mozGetUserMedia"];}window.getUserMedia(func);}),getMovementX:(function(event){return event["movementX"]||event["mozMovementX"]||event["webkitMovementX"]||0}),getMovementY:(function(event){return event["movementY"]||event["mozMovementY"]||event["webkitMovementY"]||0}),getMouseWheelDelta:(function(event){var delta=0;switch(event.type){case"DOMMouseScroll":delta=event.detail;break;case"mousewheel":delta=event.wheelDelta;break;case"wheel":delta=event["deltaY"];break;default:throw "unrecognized mouse wheel event: "+event.type}return delta}),mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:(function(event){if(Browser.pointerLock){if(event.type!="mousemove"&&"mozMovementX"in event){Browser.mouseMovementX=Browser.mouseMovementY=0;}else {Browser.mouseMovementX=Browser.getMovementX(event);Browser.mouseMovementY=Browser.getMovementY(event);}if(typeof SDL!="undefined"){Browser.mouseX=SDL.mouseX+Browser.mouseMovementX;Browser.mouseY=SDL.mouseY+Browser.mouseMovementY;}else {Browser.mouseX+=Browser.mouseMovementX;Browser.mouseY+=Browser.mouseMovementY;}}else {var rect=Module["canvas"].getBoundingClientRect();var cw=Module["canvas"].width;var ch=Module["canvas"].height;var scrollX=typeof window.scrollX!=="undefined"?window.scrollX:window.pageXOffset;var scrollY=typeof window.scrollY!=="undefined"?window.scrollY:window.pageYOffset;if(event.type==="touchstart"||event.type==="touchend"||event.type==="touchmove"){var touch=event.touch;if(touch===undefined){return}var adjustedX=touch.pageX-(scrollX+rect.left);var adjustedY=touch.pageY-(scrollY+rect.top);adjustedX=adjustedX*(cw/rect.width);adjustedY=adjustedY*(ch/rect.height);var coords={x:adjustedX,y:adjustedY};if(event.type==="touchstart"){Browser.lastTouches[touch.identifier]=coords;Browser.touches[touch.identifier]=coords;}else if(event.type==="touchend"||event.type==="touchmove"){var last=Browser.touches[touch.identifier];if(!last)last=coords;Browser.lastTouches[touch.identifier]=last;Browser.touches[touch.identifier]=coords;}return}var x=event.pageX-(scrollX+rect.left);var y=event.pageY-(scrollY+rect.top);x=x*(cw/rect.width);y=y*(ch/rect.height);Browser.mouseMovementX=x-Browser.mouseX;Browser.mouseMovementY=y-Browser.mouseY;Browser.mouseX=x;Browser.mouseY=y;}}),asyncLoad:(function(url,onload,onerror,noRunDep){var dep=!noRunDep?getUniqueRunDependency("al "+url):"";Module["readAsync"](url,(function(arrayBuffer){assert(arrayBuffer,'Loading data file "'+url+'" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency();}),(function(event){if(onerror){onerror();}else {throw 'Loading data file "'+url+'" failed.'}}));if(dep)addRunDependency();}),resizeListeners:[],updateResizeListeners:(function(){var canvas=Module["canvas"];Browser.resizeListeners.forEach((function(listener){listener(canvas.width,canvas.height);}));}),setCanvasSize:(function(width,height,noUpdates){var canvas=Module["canvas"];Browser.updateCanvasDimensions(canvas,width,height);if(!noUpdates)Browser.updateResizeListeners();}),windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:(function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags|8388608;HEAP32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2]=flags;}Browser.updateResizeListeners();}),setWindowedCanvasSize:(function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags&~8388608;HEAP32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2]=flags;}Browser.updateResizeListeners();}),updateCanvasDimensions:(function(canvas,wNative,hNative){if(wNative&&hNative){canvas.widthNative=wNative;canvas.heightNative=hNative;}else {wNative=canvas.widthNative;hNative=canvas.heightNative;}var w=wNative;var h=hNative;if(Module["forcedAspectRatio"]&&Module["forcedAspectRatio"]>0){if(w/h<Module["forcedAspectRatio"]){w=Math.round(h*Module["forcedAspectRatio"]);}else {h=Math.round(w/Module["forcedAspectRatio"]);}}if((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvas.parentNode&&typeof screen!="undefined"){var factor=Math.min(screen.width/w,screen.height/h);w=Math.round(w*factor);h=Math.round(h*factor);}if(Browser.resizeCanvas){if(canvas.width!=w)canvas.width=w;if(canvas.height!=h)canvas.height=h;if(typeof canvas.style!="undefined"){canvas.style.removeProperty("width");canvas.style.removeProperty("height");}}else {if(canvas.width!=wNative)canvas.width=wNative;if(canvas.height!=hNative)canvas.height=hNative;if(typeof canvas.style!="undefined"){if(w!=wNative||h!=hNative){canvas.style.setProperty("width",w+"px","important");canvas.style.setProperty("height",h+"px","important");}else {canvas.style.removeProperty("width");canvas.style.removeProperty("height");}}}}),wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:(function(){var handle=Browser.nextWgetRequestHandle;Browser.nextWgetRequestHandle++;return handle})};function _emscripten_exit_with_live_runtime(){Module["noExitRuntime"]=true;throw "SimulateInfiniteLoop"}function _pthread_mutexattr_settype(){}function _abort(){Module["abort"]();}function _pthread_cond_destroy(){return 0}function _pthread_condattr_destroy(){return 0}function ___cxa_free_exception(ptr){try{return _free(ptr)}catch(e){}}function ___lock(){}function ___unlock(){}function _pthread_cond_wait(){return 0}var PTHREAD_SPECIFIC={};function _pthread_getspecific(key){return PTHREAD_SPECIFIC[key]||0}var PTHREAD_SPECIFIC_NEXT_KEY=1;var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _pthread_key_create(key,destructor){if(key==0){return ERRNO_CODES.EINVAL}HEAP32[key>>2]=PTHREAD_SPECIFIC_NEXT_KEY;PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY]=0;PTHREAD_SPECIFIC_NEXT_KEY++;return 0}function _llvm_bswap_i64(l,h){var retl=_llvm_bswap_i32(h)>>>0;var reth=_llvm_bswap_i32(l)>>>0;return (Runtime.setTempRet0(reth),retl)|0}function _pthread_mutex_init(){}function _pthread_key_delete(key){if(key in PTHREAD_SPECIFIC){delete PTHREAD_SPECIFIC[key];return 0}return ERRNO_CODES.EINVAL}function _pthread_setspecific(key,value){if(!(key in PTHREAD_SPECIFIC)){return ERRNO_CODES.EINVAL}PTHREAD_SPECIFIC[key]=value;return 0}function _pthread_mutexattr_destroy(){}function ___cxa_allocate_exception(size){return _malloc(size)}var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}var PATH={splitPath:(function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)}),normalizeArray:(function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1);}else if(last===".."){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}if(allowAboveRoot){for(;up;up--){parts.unshift("..");}}return parts}),normalize:(function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter((function(p){return !!p})),!isAbsolute).join("/");if(!path&&!isAbsolute){path=".";}if(path&&trailingSlash){path+="/";}return (isAbsolute?"/":"")+path}),dirname:(function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return "."}if(dir){dir=dir.substr(0,dir.length-1);}return root+dir}),basename:(function(path){if(path==="/")return "/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)}),extname:(function(path){return PATH.splitPath(path)[3]}),join:(function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))}),join2:(function(l,r){return PATH.normalize(l+"/"+r)}),resolve:(function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return ""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/";}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter((function(p){return !!p})),!resolvedAbsolute).join("/");return (resolvedAbsolute?"/":"")+resolvedPath||"."}),relative:(function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return [];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..");}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")})};var TTY={ttys:[],init:(function(){}),shutdown:(function(){}),register:(function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops);}),stream_ops:{open:(function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}stream.tty=tty;stream.seekable=false;}),close:(function(stream){stream.tty.ops.flush(stream.tty);}),flush:(function(stream){stream.tty.ops.flush(stream.tty);}),read:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty);}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead}),write:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}for(var i=0;i<length;i++){try{stream.tty.ops.put_char(stream.tty,buffer[offset+i]);}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}}if(length){stream.node.timestamp=Date.now();}return i})},default_tty_ops:{get_char:(function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=new Buffer$8(BUFSIZE);var bytesRead=0;var isPosixPlatform=browser$1$1.platform!="win32";var fd=browser$1$1.stdin.fd;if(isPosixPlatform){var usingDevice=false;try{fd=fs.openSync("/dev/stdin","r");usingDevice=true;}catch(e){}}try{bytesRead=fs.readSync(fd,buf,0,BUFSIZE,null);}catch(e){if(e.toString().indexOf("EOF")!=-1)bytesRead=0;else throw e}if(usingDevice){fs.closeSync(fd);}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8");}else {result=null;}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n";}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n";}}if(!result){return null}tty.input=intArrayFromString(result,true);}return tty.input.shift()}),put_char:(function(tty,val){if(val===null||val===10){Module["print"](UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}}),flush:(function(tty){if(tty.output&&tty.output.length>0){Module["print"](UTF8ArrayToString(tty.output,0));tty.output=[];}})},default_tty1_ops:{put_char:(function(tty,val){if(val===null||val===10){Module["printErr"](UTF8ArrayToString(tty.output,0));tty.output=[];}else {if(val!=0)tty.output.push(val);}}),flush:(function(tty){if(tty.output&&tty.output.length>0){Module["printErr"](UTF8ArrayToString(tty.output,0));tty.output=[];}})}};var MEMFS={ops_table:null,mount:(function(mount){return MEMFS.createNode(null,"/",16384|511,0)}),createNode:(function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={};}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null;}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream;}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream;}node.timestamp=Date.now();if(parent){parent.contents[name]=node;}return node}),getFileDataAsRegularArray:(function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents}),getFileDataAsTypedArray:(function(node){if(!node.contents)return new Uint8Array;if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)}),expandFileStorage:(function(node,newCapacity){if(node.contents&&node.contents.subarray&&newCapacity>node.contents.length){node.contents=MEMFS.getFileDataAsRegularArray(node);node.usedBytes=node.contents.length;}if(!node.contents||node.contents.subarray){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return}if(!node.contents&&newCapacity>0)node.contents=[];while(node.contents.length<newCapacity)node.contents.push(0);}),resizeFileStorage:(function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));}node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize;}),node_ops:{getattr:(function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096;}else if(FS.isFile(node.mode)){attr.size=node.usedBytes;}else if(FS.isLink(node.mode)){attr.size=node.link.length;}else {attr.size=0;}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size);}}),lookup:(function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT]}),mknod:(function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)}),rename:(function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}}}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=new_dir;}),unlink:(function(parent,name){delete parent.contents[name];}),rmdir:(function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}delete parent.contents[name];}),readdir:(function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key);}return entries}),symlink:(function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node}),readlink:(function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return node.link})},stream_ops:{read:(function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset);}else {for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];}return size}),write:(function(stream,buffer,offset,length,position,canOwn){if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else {for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i];}}node.usedBytes=Math.max(node.usedBytes,position+length);return length}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes;}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position}),allocate:(function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length);}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset;}else {if(position>0||position+length<stream.node.usedBytes){if(contents.subarray){contents=contents.subarray(position,position+length);}else {contents=Array.prototype.slice.call(contents,position,position+length);}}allocated=true;ptr=_malloc(length);if(!ptr){throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)}buffer.set(contents,ptr);}return {ptr:ptr,allocated:allocated}}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(mmapFlags&2){return 0}MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0})}};var IDBFS={dbs:{},indexedDB:(function(){if(typeof indexedDB!=="undefined")return indexedDB;var ret=null;if(typeof window==="object")ret=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;assert(ret,"IDBFS used, but indexedDB not supported");return ret}),DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:(function(mount){return MEMFS.mount.apply(null,arguments)}),syncfs:(function(mount,populate,callback){IDBFS.getLocalSet(mount,(function(err,local){if(err)return callback(err);IDBFS.getRemoteSet(mount,(function(err,remote){if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,callback);}));}));}),getDB:(function(name,callback){var db=IDBFS.dbs[name];if(db){return callback(null,db)}var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION);}catch(e){return callback(e)}if(!req){return callback("Unable to connect to IndexedDB")}req.onupgradeneeded=(function(e){var db=e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)){fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME);}else {fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME);}if(!fileStore.indexNames.contains("timestamp")){fileStore.createIndex("timestamp","timestamp",{unique:false});}});req.onsuccess=(function(){db=req.result;IDBFS.dbs[name]=db;callback(null,db);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),getLocalSet:(function(mount,callback){var entries={};function isRealDir(p){return p!=="."&&p!==".."}function toAbsolute(root){return(function(p){return PATH.join2(root,p)})}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path);}catch(e){return callback(e)}if(FS.isDir(stat.mode)){check.push.apply(check,FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));}entries[path]={timestamp:stat.mtime};}return callback(null,{type:"local",entries:entries})}),getRemoteSet:(function(mount,callback){var entries={};IDBFS.getDB(mount.mountpoint,(function(err,db){if(err)return callback(err);try{var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=(function(e){callback(this.error);e.preventDefault();});var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=(function(event){var cursor=event.target.result;if(!cursor){return callback(null,{type:"remote",db:db,entries:entries})}entries[cursor.primaryKey]={timestamp:cursor.key};cursor.continue();});}catch(e){return callback(e)}}));}),loadLocalEntry:(function(path,callback){var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path);}catch(e){return callback(e)}if(FS.isDir(stat.mode)){return callback(null,{timestamp:stat.mtime,mode:stat.mode})}else if(FS.isFile(stat.mode)){node.contents=MEMFS.getFileDataAsTypedArray(node);return callback(null,{timestamp:stat.mtime,mode:stat.mode,contents:node.contents})}else {return callback(new Error("node type not supported"))}}),storeLocalEntry:(function(path,entry,callback){try{if(FS.isDir(entry.mode)){FS.mkdir(path,entry.mode);}else if(FS.isFile(entry.mode)){FS.writeFile(path,entry.contents,{encoding:"binary",canOwn:true});}else {return callback(new Error("node type not supported"))}FS.chmod(path,entry.mode);FS.utime(path,entry.timestamp,entry.timestamp);}catch(e){return callback(e)}callback(null);}),removeLocalEntry:(function(path,callback){try{var lookup=FS.lookupPath(path);var stat=FS.stat(path);if(FS.isDir(stat.mode)){FS.rmdir(path);}else if(FS.isFile(stat.mode)){FS.unlink(path);}}catch(e){return callback(e)}callback(null);}),loadRemoteEntry:(function(store,path,callback){var req=store.get(path);req.onsuccess=(function(event){callback(null,event.target.result);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),storeRemoteEntry:(function(store,path,entry,callback){var req=store.put(entry,path);req.onsuccess=(function(){callback(null);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),removeRemoteEntry:(function(store,path,callback){var req=store.delete(path);req.onsuccess=(function(){callback(null);});req.onerror=(function(e){callback(this.error);e.preventDefault();});}),reconcile:(function(src,dst,callback){var total=0;var create=[];Object.keys(src.entries).forEach((function(key){var e=src.entries[key];var e2=dst.entries[key];if(!e2||e.timestamp>e2.timestamp){create.push(key);total++;}}));var remove=[];Object.keys(dst.entries).forEach((function(key){dst.entries[key];var e2=src.entries[key];if(!e2){remove.push(key);total++;}}));if(!total){return callback(null)}var completed=0;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err){if(!done.errored){done.errored=true;return callback(err)}return}if(++completed>=total){return callback(null)}}transaction.onerror=(function(e){done(this.error);e.preventDefault();});create.sort().forEach((function(path){if(dst.type==="local"){IDBFS.loadRemoteEntry(store,path,(function(err,entry){if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done);}));}else {IDBFS.loadLocalEntry(path,(function(err,entry){if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done);}));}}));remove.sort().reverse().forEach((function(path){if(dst.type==="local"){IDBFS.removeLocalEntry(path,done);}else {IDBFS.removeRemoteEntry(store,path,done);}}));})};var NODEFS={isWindows:false,staticInit:(function(){NODEFS.isWindows=!!browser$1$1.platform.match(/^win/);}),mount:(function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)}),createNode:(function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node}),getMode:(function(path){var stat;try{stat=fs.lstatSync(path);if(NODEFS.isWindows){stat.mode=stat.mode|(stat.mode&146)>>1;}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return stat.mode}),realPath:(function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent;}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)}),flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:(function(flags){flags&=~2097152;flags&=~2048;flags&=~32768;flags&=~524288;if(flags in NODEFS.flagsToPermissionStringMap){return NODEFS.flagsToPermissionStringMap[flags]}else {throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}}),node_ops:{getattr:(function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(NODEFS.isWindows&&!stat.blksize){stat.blksize=4096;}if(NODEFS.isWindows&&!stat.blocks){stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0;}return {dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}}),setattr:(function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode;}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,date,date);}if(attr.size!==undefined){fs.truncateSync(path,attr.size);}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),lookup:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)}),mknod:(function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode)){fs.mkdirSync(path,node.mode);}else {fs.writeFileSync(path,"",{mode:node.mode});}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return node}),rename:(function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),unlink:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),rmdir:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readdir:(function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),symlink:(function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath);}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readlink:(function(node){var path=NODEFS.realPath(node);try{path=fs.readlinkSync(path);path=NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root),path);return path}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}})},stream_ops:{open:(function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode)){stream.nfd=fs.openSync(path,NODEFS.flagsToPermissionString(stream.flags));}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),close:(function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd){fs.closeSync(stream.nfd);}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),read:(function(stream,buffer,offset,length,position){if(length===0)return 0;var nbuffer=new Buffer$8(length);var res;try{res=fs.readSync(stream.nfd,nbuffer,0,length,position);}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(res>0){for(var i=0;i<res;i++){buffer[offset+i]=nbuffer[i];}}return res}),write:(function(stream,buffer,offset,length,position){var nbuffer=new Buffer$8(buffer.subarray(offset,offset+length));var res;try{res=fs.writeSync(stream.nfd,nbuffer,0,length,position);}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}return res}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){try{var stat=fs.fstatSync(stream.nfd);position+=stat.size;}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:(function(mount){assert(ENVIRONMENT_IS_WORKER);if(!WORKERFS.reader)WORKERFS.reader=new FileReaderSync;var root=WORKERFS.createNode(null,"/",WORKERFS.DIR_MODE,0);var createdParents={};function ensureParent(path){var parts=path.split("/");var parent=root;for(var i=0;i<parts.length-1;i++){var curr=parts.slice(0,i+1).join("/");if(!createdParents[curr]){createdParents[curr]=WORKERFS.createNode(parent,parts[i],WORKERFS.DIR_MODE,0);}parent=createdParents[curr];}return parent}function base(path){var parts=path.split("/");return parts[parts.length-1]}Array.prototype.forEach.call(mount.opts["files"]||[],(function(file){WORKERFS.createNode(ensureParent(file.name),base(file.name),WORKERFS.FILE_MODE,0,file,file.lastModifiedDate);}));(mount.opts["blobs"]||[]).forEach((function(obj){WORKERFS.createNode(ensureParent(obj["name"]),base(obj["name"]),WORKERFS.FILE_MODE,0,obj["data"]);}));(mount.opts["packages"]||[]).forEach((function(pack){pack["metadata"].files.forEach((function(file){var name=file.filename.substr(1);WORKERFS.createNode(ensureParent(name),base(name),WORKERFS.FILE_MODE,0,pack["blob"].slice(file.start,file.end));}));}));return root}),createNode:(function(parent,name,mode,dev,contents,mtime){var node=FS.createNode(parent,name,mode);node.mode=mode;node.node_ops=WORKERFS.node_ops;node.stream_ops=WORKERFS.stream_ops;node.timestamp=(mtime||new Date).getTime();assert(WORKERFS.FILE_MODE!==WORKERFS.DIR_MODE);if(mode===WORKERFS.FILE_MODE){node.size=contents.size;node.contents=contents;}else {node.size=4096;node.contents={};}if(parent){parent.contents[name]=node;}return node}),node_ops:{getattr:(function(node){return {dev:1,ino:undefined,mode:node.mode,nlink:1,uid:0,gid:0,rdev:undefined,size:node.size,atime:new Date(node.timestamp),mtime:new Date(node.timestamp),ctime:new Date(node.timestamp),blksize:4096,blocks:Math.ceil(node.size/4096)}}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}}),lookup:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}),mknod:(function(parent,name,mode,dev){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rename:(function(oldNode,newDir,newName){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),unlink:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rmdir:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readdir:(function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key);}return entries}),symlink:(function(parent,newName,oldPath){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readlink:(function(node){throw new FS.ErrnoError(ERRNO_CODES.EPERM)})},stream_ops:{read:(function(stream,buffer,offset,length,position){if(position>=stream.node.size)return 0;var chunk=stream.node.contents.slice(position,position+length);var ab=WORKERFS.reader.readAsArrayBuffer(chunk);buffer.set(new Uint8Array(ab),offset);return chunk.size}),write:(function(stream,buffer,offset,length,position){throw new FS.ErrnoError(ERRNO_CODES.EIO)}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.size;}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};STATICTOP+=16;STATICTOP+=16;STATICTOP+=16;var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:(function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)}),lookupPath:(function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};if(!path)return {path:"",node:null};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults){if(opts[key]===undefined){opts[key]=defaults[key];}}if(opts.recurse_count>8){throw new FS.ErrnoError(ERRNO_CODES.ELOOP)}var parts=PATH.normalizeArray(path.split("/").filter((function(p){return !!p})),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root;}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40){throw new FS.ErrnoError(ERRNO_CODES.ELOOP)}}}}return {path:current_path,node:current}}),getPath:(function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent;}}),hashName:(function(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0;}return (parentid+hash>>>0)%FS.nameTable.length}),hashAddNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node;}),hashRemoveNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next;}else {var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next;}}}),lookupNode:(function(parent,name){var err=FS.mayLookup(parent);if(err){throw new FS.ErrnoError(err,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)}),createNode:(function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=(function(parent,name,mode,rdev){if(!parent){parent=this;}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;});FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:(function(){return (this.mode&readMode)===readMode}),set:(function(val){val?this.mode|=readMode:this.mode&=~readMode;})},write:{get:(function(){return (this.mode&writeMode)===writeMode}),set:(function(val){val?this.mode|=writeMode:this.mode&=~writeMode;})},isFolder:{get:(function(){return FS.isDir(this.mode)})},isDevice:{get:(function(){return FS.isChrdev(this.mode)})}});}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node}),destroyNode:(function(node){FS.hashRemoveNode(node);}),isRoot:(function(node){return node===node.parent}),isMountpoint:(function(node){return !!node.mounted}),isFile:(function(mode){return (mode&61440)===32768}),isDir:(function(mode){return (mode&61440)===16384}),isLink:(function(mode){return (mode&61440)===40960}),isChrdev:(function(mode){return (mode&61440)===8192}),isBlkdev:(function(mode){return (mode&61440)===24576}),isFIFO:(function(mode){return (mode&61440)===4096}),isSocket:(function(mode){return (mode&49152)===49152}),flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:(function(str){var flags=FS.flagModes[str];if(typeof flags==="undefined"){throw new Error("Unknown file open mode: "+str)}return flags}),flagsToPermissionString:(function(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w";}return perms}),nodePermissions:(function(node,perms){if(FS.ignorePermissions){return 0}if(perms.indexOf("r")!==-1&&!(node.mode&292)){return ERRNO_CODES.EACCES}else if(perms.indexOf("w")!==-1&&!(node.mode&146)){return ERRNO_CODES.EACCES}else if(perms.indexOf("x")!==-1&&!(node.mode&73)){return ERRNO_CODES.EACCES}return 0}),mayLookup:(function(dir){var err=FS.nodePermissions(dir,"x");if(err)return err;if(!dir.node_ops.lookup)return ERRNO_CODES.EACCES;return 0}),mayCreate:(function(dir,name){try{var node=FS.lookupNode(dir,name);return ERRNO_CODES.EEXIST}catch(e){}return FS.nodePermissions(dir,"wx")}),mayDelete:(function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name);}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err){return err}if(isdir){if(!FS.isDir(node.mode)){return ERRNO_CODES.ENOTDIR}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return ERRNO_CODES.EBUSY}}else {if(FS.isDir(node.mode)){return ERRNO_CODES.EISDIR}}return 0}),mayOpen:(function(node,flags){if(!node){return ERRNO_CODES.ENOENT}if(FS.isLink(node.mode)){return ERRNO_CODES.ELOOP}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return ERRNO_CODES.EISDIR}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))}),MAX_OPEN_FDS:4096,nextfd:(function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(ERRNO_CODES.EMFILE)}),getStream:(function(fd){return FS.streams[fd]}),createStream:(function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=(function(){});FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:(function(){return this.node}),set:(function(val){this.node=val;})},isRead:{get:(function(){return (this.flags&2097155)!==1})},isWrite:{get:(function(){return (this.flags&2097155)!==0})},isAppend:{get:(function(){return this.flags&1024})}});}var newStream=new FS.FSStream;for(var p in stream){newStream[p]=stream[p];}stream=newStream;var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream}),closeStream:(function(fd){FS.streams[fd]=null;}),chrdev_stream_ops:{open:(function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream);}}),llseek:(function(){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)})},major:(function(dev){return dev>>8}),minor:(function(dev){return dev&255}),makedev:(function(ma,mi){return ma<<8|mi}),registerDevice:(function(dev,ops){FS.devices[dev]={stream_ops:ops};}),getDevice:(function(dev){return FS.devices[dev]}),getMounts:(function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts);}return mounts}),syncfs:(function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false;}FS.syncFSRequests++;if(FS.syncFSRequests>1){console.log("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(err){assert(FS.syncFSRequests>0);FS.syncFSRequests--;return callback(err)}function done(err){if(err){if(!done.errored){done.errored=true;return doCallback(err)}return}if(++completed>=mounts.length){doCallback(null);}}mounts.forEach((function(mount){if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done);}));}),mount:(function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot;}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount);}}return mountRoot}),unmount:(function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach((function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1){FS.destroyNode(current);}current=next;}}));node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1);}),lookup:(function(parent,name){return parent.node_ops.lookup(parent,name)}),mknod:(function(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var err=FS.mayCreate(parent,name);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return parent.node_ops.mknod(parent,name,mode,dev)}),create:(function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)}),mkdir:(function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)}),mkdirTree:(function(path,mode){var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode);}catch(e){if(e.errno!=ERRNO_CODES.EEXIST)throw e}}}),mkdev:(function(path,mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438;}mode|=8192;return FS.mknod(path,mode,dev)}),symlink:(function(oldpath,newpath){if(!PATH.resolve(oldpath)){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return parent.node_ops.symlink(parent,newname,oldpath)}),rename:(function(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(!old_dir||!new_dir)throw new FS.ErrnoError(ERRNO_CODES.ENOENT);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(ERRNO_CODES.EXDEV)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err){throw new FS.ErrnoError(err)}err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err){throw new FS.ErrnoError(err)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err){throw new FS.ErrnoError(err)}}try{if(FS.trackingDelegate["willMovePath"]){FS.trackingDelegate["willMovePath"](old_path,new_path);}}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message);}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);}catch(e){throw e}finally{FS.hashAddNode(old_node);}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path);}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message);}}),rmdir:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path);}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message);}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path);}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message);}}),readdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}return node.node_ops.readdir(node)}),unlink:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path);}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message);}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path);}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message);}}),readlink:(function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!link.node_ops.readlink){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return PATH.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))}),stat:(function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!node.node_ops.getattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return node.node_ops.getattr(node)}),lstat:(function(path){return FS.stat(path,true)}),chmod:(function(path,mode,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()});}),lchmod:(function(path,mode){FS.chmod(path,mode,true);}),fchmod:(function(fd,mode){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}FS.chmod(stream.node,mode);}),chown:(function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}node.node_ops.setattr(node,{timestamp:Date.now()});}),lchown:(function(path,uid,gid){FS.chown(path,uid,gid,true);}),fchown:(function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}FS.chown(stream.node,uid,gid);}),truncate:(function(path,len){if(len<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;}else {node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var err=FS.nodePermissions(node,"w");if(err){throw new FS.ErrnoError(err)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()});}),ftruncate:(function(fd,len){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}FS.truncate(stream.node,len);}),utime:(function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)});}),open:(function(path,flags,mode,fd_start,fd_end){if(path===""){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64){mode=mode&4095|32768;}else {mode=0;}var node;if(typeof path==="object"){node=path;}else {path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node;}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(ERRNO_CODES.EEXIST)}}else {node=FS.mknod(path,mode,0);created=true;}}if(!node){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(FS.isChrdev(node.mode)){flags&=~512;}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}if(!created){var err=FS.mayOpen(node,flags);if(err){throw new FS.ErrnoError(err)}}if(flags&512){FS.truncate(node,0);}flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream);}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;Module["printErr"]("read file: "+path);}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1){trackingFlags|=FS.tracking.openFlags.READ;}if((flags&2097155)!==0){trackingFlags|=FS.tracking.openFlags.WRITE;}FS.trackingDelegate["onOpenFile"](path,trackingFlags);}}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message);}return stream}),close:(function(stream){if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream);}}catch(e){throw e}finally{FS.closeStream(stream.fd);}}),llseek:(function(stream,offset,whence){if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position}),read:(function(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!stream.stream_ops.read){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false;}else if(!stream.seekable){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead}),write:(function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!stream.stream_ops.write){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if(stream.flags&1024){FS.llseek(stream,0,2);}var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false;}else if(!stream.seekable){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path);}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: "+e.message);}return bytesWritten}),allocate:(function(stream,offset,length){if(offset<0||length<=0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)}stream.stream_ops.allocate(stream,offset,length);}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1){throw new FS.ErrnoError(ERRNO_CODES.EACCES)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)}),munmap:(function(stream){return 0}),ioctl:(function(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)}return stream.stream_ops.ioctl(stream,cmd,arg)}),readFile:(function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0);}else if(opts.encoding==="binary"){ret=buf;}FS.close(stream);return ret}),writeFile:(function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";opts.encoding=opts.encoding||"utf8";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var stream=FS.open(path,opts.flags,opts.mode);if(opts.encoding==="utf8"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,0,opts.canOwn);}else if(opts.encoding==="binary"){FS.write(stream,data,0,data.length,0,opts.canOwn);}FS.close(stream);}),cwd:(function(){return FS.currentPath}),chdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}var err=FS.nodePermissions(lookup.node,"x");if(err){throw new FS.ErrnoError(err)}FS.currentPath=lookup.path;}),createDefaultDirectories:(function(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user");}),createDefaultDevices:(function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:(function(){return 0}),write:(function(stream,buffer,offset,length,pos){return length})});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device;if(typeof crypto!=="undefined"){var randomBuffer=new Uint8Array(1);random_device=(function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]});}else if(ENVIRONMENT_IS_NODE){random_device=(function(){return require$$2$2.randomBytes(1)[0]});}else {random_device=(function(){return Math.random()*256|0});}FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp");}),createSpecialDirectories:(function(){FS.mkdir("/proc");FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:(function(){var node=FS.createNode("/proc/self","fd",16384|511,73);node.node_ops={lookup:(function(parent,name){var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:(function(){return stream.path})}};ret.parent=ret;return ret})};return node})},{},"/proc/self/fd");}),createStandardStreams:(function(){if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"]);}else {FS.symlink("/dev/tty","/dev/stdin");}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"]);}else {FS.symlink("/dev/tty","/dev/stdout");}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"]);}else {FS.symlink("/dev/tty1","/dev/stderr");}var stdin=FS.open("/dev/stdin","r");assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");var stdout=FS.open("/dev/stdout","w");assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");var stderr=FS.open("/dev/stderr","w");assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")");}),ensureErrnoError:(function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=(function(errno){this.errno=errno;for(var key in ERRNO_CODES){if(ERRNO_CODES[key]===errno){this.code=key;break}}});this.setErrno(errno);this.message=ERRNO_MESSAGES[errno];};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[ERRNO_CODES.ENOENT].forEach((function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>";}));}),staticInit:(function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"IDBFS":IDBFS,"NODEFS":NODEFS,"WORKERFS":WORKERFS};}),init:(function(input,output,error){assert(!FS.init.initialized,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams();}),quit:(function(){FS.init.initialized=false;var fflush=Module["_fflush"];if(fflush)fflush(0);for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream);}}),getMode:(function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode}),joinPath:(function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path}),absolutePath:(function(relative,base){return PATH.resolve(base,relative)}),standardizePath:(function(path){return PATH.normalize(path)}),findObject:(function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else {___setErrNo(ret.error);return null}}),analyzePath:(function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path;}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/";}catch(e){ret.error=e.errno;}return ret}),createFolder:(function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)}),createPath:(function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current);}catch(e){}parent=current;}return current}),createFile:(function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)}),createDataFile:(function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr;}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode);}return node}),createDevice:(function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:(function(stream){stream.seekable=false;}),close:(function(stream){if(output&&output.buffer&&output.buffer.length){output(10);}}),read:(function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input();}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead}),write:(function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i]);}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}}if(length){stream.node.timestamp=Date.now();}return i})});return FS.mkdev(path,mode,dev)}),createLink:(function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)}),forceLoadFile:(function(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(Module["read"]){try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length;}catch(e){success=false;}}else {throw new Error("Cannot load without read() or XMLHttpRequest.")}if(!success)___setErrNo(ERRNO_CODES.EIO);return success}),createLazyFile:(function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[];}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter;};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined");}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else {return intArrayFromString(xhr.responseText||"",true)}});var lazyArray=this;lazyArray.setDataGetter((function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end);}if(typeof lazyArray.chunks[chunkNum]==="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]}));if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;console.log("LazyFiles on gzip forces download of the whole file when length is accessed");}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true;};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:(function(){if(!this.lengthKnown){this.cacheLength();}return this._length})},chunkSize:{get:(function(){if(!this.lengthKnown){this.cacheLength();}return this._chunkSize})}});var properties={isDevice:false,contents:lazyArray};}else {var properties={isDevice:false,url:url};}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents;}else if(properties.url){node.contents=null;node.url=properties.url;}Object.defineProperties(node,{usedBytes:{get:(function(){return this.contents.length})}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach((function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(ERRNO_CODES.EIO)}return fn.apply(null,arguments)};}));stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(ERRNO_CODES.EIO)}var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i];}}else {for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i);}}return size};node.stream_ops=stream_ops;return node}),createPreloadedFile:(function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);}if(onload)onload();removeRunDependency();}var handled=false;Module["preloadPlugins"].forEach((function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,(function(){if(onerror)onerror();removeRunDependency();}));handled=true;}}));if(!handled)finish(byteArray);}addRunDependency();if(typeof url=="string"){Browser.asyncLoad(url,(function(byteArray){processData(byteArray);}),onerror);}else {processData(url);}}),indexedDB:(function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB}),DB_NAME:(function(){return "EM_FS_"+window.location.pathname}),DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME);};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach((function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish();};putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish();};}));transaction.onerror=onerror;};openRequest.onerror=onerror;}),loadFilesFromDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION);}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly");}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror();}paths.forEach((function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists){FS.unlink(path);}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish();};getRequest.onerror=function getRequest_onerror(){fail++;if(ok+fail==total)finish();};}));transaction.onerror=onerror;};openRequest.onerror=onerror;})};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:(function(dirfd,path){if(path[0]!=="/"){var dir;if(dirfd===-100){dir=FS.cwd();}else {var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);dir=dirstream.path;}path=PATH.join2(dir,path);}return path}),doStat:(function(func,path,buf){try{var stat=func(path);}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return -ERRNO_CODES.ENOTDIR}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;HEAP32[buf+36>>2]=stat.size;HEAP32[buf+40>>2]=4096;HEAP32[buf+44>>2]=stat.blocks;HEAP32[buf+48>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+52>>2]=0;HEAP32[buf+56>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ino;return 0}),doMsync:(function(addr,stream,len,flags){var buffer=new Uint8Array(HEAPU8.subarray(addr,addr+len));FS.msync(stream,buffer,0,len,flags);}),doMkdir:(function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0}),doMknod:(function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return -ERRNO_CODES.EINVAL}FS.mknod(path,mode,dev);return 0}),doReadlink:(function(path,buf,bufsize){if(bufsize<=0)return -ERRNO_CODES.EINVAL;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}),doAccess:(function(path,amode){if(amode&~7){return -ERRNO_CODES.EINVAL}var node;var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return -ERRNO_CODES.EACCES}return 0}),doDup:(function(path,flags,suggestFD){var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(path,flags,0,suggestFD,suggestFD).fd}),doReadv:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;if(curr<len)break}return ret}),doWritev:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return -1;ret+=curr;}return ret}),varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),getStreamFromFD:(function(){var stream=FS.getStream(SYSCALLS.get());if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return stream}),getSocketFromFD:(function(){var socket=SOCKFS.getSocket(SYSCALLS.get());if(!socket)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return socket}),getSocketAddress:(function(allowNull){var addrp=SYSCALLS.get(),addrlen=SYSCALLS.get();if(allowNull&&addrp===0)return null;var info=__read_sockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0);})};function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),op=SYSCALLS.get();switch(op){case 21505:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return 0};case 21506:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return 0};case 21519:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0};case 21520:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return -ERRNO_CODES.EINVAL};case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)};case 21523:{if(!stream.tty)return -ERRNO_CODES.ENOTTY;return 0};default:abort("bad ioctl syscall "+op);}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function __Unwind_GetIPInfo(){abort("Unwind_GetIPInfo");}function _pthread_cond_init(){return 0}function __emscripten_traverse_stack(args){if(!args||!args.callee||!args.callee.name){return [null,"",""]}args.callee.toString();var funcname=args.callee.name;var str="(";var first=true;for(i in args){var a=args[i];if(!first){str+=", ";}first=false;if(typeof a==="number"||typeof a==="string"){str+=a;}else {str+="("+typeof a+")";}}str+=")";var caller=args.callee.caller;args=caller?caller.arguments:[];if(first)str="";return [args,funcname,str]}function _emscripten_get_callstack_js(flags){var callstack=jsStackTrace();var iThisFunc=callstack.lastIndexOf("_emscripten_log");var iThisFunc2=callstack.lastIndexOf("_emscripten_get_callstack");var iNextLine=callstack.indexOf("\n",Math.max(iThisFunc,iThisFunc2))+1;callstack=callstack.slice(iNextLine);if(flags&8&&typeof emscripten_source_map==="undefined"){Runtime.warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');flags^=8;flags|=16;}var stack_args=null;if(flags&128){var stack_args=__emscripten_traverse_stack(arguments);while(stack_args[1].indexOf("_emscripten_")>=0)stack_args=__emscripten_traverse_stack(stack_args[0]);}lines=callstack.split("\n");callstack="";var newFirefoxRe=new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");var firefoxRe=new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");var chromeRe=new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");for(l in lines){var line=lines[l];var jsSymbolName="";var file="";var lineno=0;var column=0;var parts=chromeRe.exec(line);if(parts&&parts.length==5){jsSymbolName=parts[1];file=parts[2];lineno=parts[3];column=parts[4];}else {parts=newFirefoxRe.exec(line);if(!parts)parts=firefoxRe.exec(line);if(parts&&parts.length>=4){jsSymbolName=parts[1];file=parts[2];lineno=parts[3];column=parts[4]|0;}else {callstack+=line+"\n";continue}}var cSymbolName=flags&32?demangle(jsSymbolName):jsSymbolName;if(!cSymbolName){cSymbolName=jsSymbolName;}var haveSourceMap=false;if(flags&8){var orig=emscripten_source_map.originalPositionFor({line:lineno,column:column});haveSourceMap=orig&&orig.source;if(haveSourceMap){if(flags&64){orig.source=orig.source.substring(orig.source.replace(/\\/g,"/").lastIndexOf("/")+1);}callstack+="    at "+cSymbolName+" ("+orig.source+":"+orig.line+":"+orig.column+")\n";}}if(flags&16||!haveSourceMap){if(flags&64){file=file.substring(file.replace(/\\/g,"/").lastIndexOf("/")+1);}callstack+=(haveSourceMap?"     = "+jsSymbolName:"    at "+cSymbolName)+" ("+file+":"+lineno+":"+column+")\n";}if(flags&128&&stack_args[0]){if(stack_args[1]==jsSymbolName&&stack_args[2].length>0){callstack=callstack.replace(/\s+$/,"");callstack+=" with values: "+stack_args[1]+stack_args[2]+"\n";}stack_args=__emscripten_traverse_stack(stack_args[0]);}}callstack=callstack.replace(/\s+$/,"");return callstack}function __Unwind_Backtrace(func,arg){var trace=_emscripten_get_callstack_js();var parts=trace.split("\n");for(var i=0;i<parts.length;i++){var ret=Module["dynCall_iii"](func,0,arg);if(ret!==0)return}}function _pthread_condattr_setclock(){return 0}var _environ=STATICTOP;STATICTOP+=16;function ___buildEnvironment(env){var MAX_ENV_VALUES=64;var TOTAL_ENV_SIZE=1024;var poolPtr;var envPtr;if(!___buildEnvironment.called){___buildEnvironment.called=true;ENV["USER"]=ENV["LOGNAME"]="web_user";ENV["PATH"]="/";ENV["PWD"]="/";ENV["HOME"]="/home/web_user";ENV["LANG"]="C";ENV["_"]=Module["thisProgram"];poolPtr=allocate(TOTAL_ENV_SIZE,"i8",ALLOC_STATIC);envPtr=allocate(MAX_ENV_VALUES*4,"i8*",ALLOC_STATIC);HEAP32[envPtr>>2]=poolPtr;HEAP32[_environ>>2]=envPtr;}else {envPtr=HEAP32[_environ>>2];poolPtr=HEAP32[envPtr>>2];}var strings=[];var totalSize=0;for(var key in env){if(typeof env[key]==="string"){var line=key+"="+env[key];strings.push(line);totalSize+=line.length;}}if(totalSize>TOTAL_ENV_SIZE){throw new Error("Environment size exceeded TOTAL_ENV_SIZE!")}var ptrSize=4;for(var i=0;i<strings.length;i++){var line=strings[i];writeAsciiToMemory(line,poolPtr);HEAP32[envPtr+i*ptrSize>>2]=poolPtr;poolPtr+=line.length+1;}HEAP32[envPtr+strings.length*ptrSize>>2]=0;}var ENV={};function _getenv(name){if(name===0)return 0;name=Pointer_stringify(name);if(!ENV.hasOwnProperty(name))return 0;if(_getenv.ret)_free(_getenv.ret);_getenv.ret=allocate(intArrayFromString(ENV[name]),"i8",ALLOC_NORMAL);return _getenv.ret}function _pthread_rwlock_rdlock(){return 0}function ___cxa_find_matching_catch_3(){return ___cxa_find_matching_catch.apply(null,arguments)}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function _pthread_cond_signal(){return 0}function _dladdr(addr,info){var fname=allocate(intArrayFromString(Module["thisProgram"]||"./this.program"),"i8",ALLOC_NORMAL);HEAP32[addr>>2]=fname;HEAP32[addr+4>>2]=0;HEAP32[addr+8>>2]=0;HEAP32[addr+12>>2]=0;return 1}function ___gxx_personality_v0(){}function _pthread_mutex_destroy(){}function _pthread_mutexattr_init(){}function ___syscall4(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),buf=SYSCALLS.get(),count=SYSCALLS.get();return FS.write(stream,HEAP8,buf,count)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function _pthread_condattr_init(){return 0}function _llvm_trap(){abort("trap!");}function ___cxa_find_matching_catch_2(){return ___cxa_find_matching_catch.apply(null,arguments)}function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doWritev(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function _pthread_rwlock_unlock(){return 0}Module["requestFullScreen"]=function Module_requestFullScreen(lockPointer,resizeCanvas,vrDevice){Module.printErr("Module.requestFullScreen is deprecated. Please call Module.requestFullscreen instead.");Module["requestFullScreen"]=Module["requestFullscreen"];Browser.requestFullScreen(lockPointer,resizeCanvas,vrDevice);};Module["requestFullscreen"]=function Module_requestFullscreen(lockPointer,resizeCanvas,vrDevice){Browser.requestFullscreen(lockPointer,resizeCanvas,vrDevice);};Module["requestAnimationFrame"]=function Module_requestAnimationFrame(func){Browser.requestAnimationFrame(func);};Module["setCanvasSize"]=function Module_setCanvasSize(width,height,noUpdates){Browser.setCanvasSize(width,height,noUpdates);};Module["pauseMainLoop"]=function Module_pauseMainLoop(){Browser.mainLoop.pause();};Module["resumeMainLoop"]=function Module_resumeMainLoop(){Browser.mainLoop.resume();};Module["getUserMedia"]=function Module_getUserMedia(){Browser.getUserMedia();};Module["createContext"]=function Module_createContext(canvas,useWebGL,setInModule,webGLContextAttributes){return Browser.createContext(canvas,useWebGL,setInModule,webGLContextAttributes)};if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function _emscripten_get_now_actual(){var t=browser$1$1["hrtime"]();return t[0]*1e3+t[1]/1e6};}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow;}else if(typeof self==="object"&&self["performance"]&&typeof self["performance"]["now"]==="function"){_emscripten_get_now=(function(){return self["performance"]["now"]()});}else if(typeof performance==="object"&&typeof performance["now"]==="function"){_emscripten_get_now=(function(){return performance["now"]()});}else {_emscripten_get_now=Date.now;}FS.staticInit();__ATINIT__.unshift((function(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();}));__ATMAIN__.push((function(){FS.ignorePermissions=false;}));__ATEXIT__.push((function(){FS.quit();}));Module["FS_createFolder"]=FS.createFolder;Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createLink"]=FS.createLink;Module["FS_createDevice"]=FS.createDevice;Module["FS_unlink"]=FS.unlink;__ATINIT__.unshift((function(){}));__ATEXIT__.push((function(){}));if(ENVIRONMENT_IS_NODE){var fs=require$$0$2;var NODEJS_PATH=require$$1;NODEFS.staticInit();}___buildEnvironment(ENV);DYNAMICTOP_PTR=allocate(1,"i32",ALLOC_STATIC);STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=Runtime.alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;staticSealed=true;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var ASSERTIONS;var intArrayToString=ASSERTIONS?(function(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.");chr&=255;}ret.push(String.fromCharCode(chr));}return ret.join("")}):(function(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255;}ret.push(String.fromCharCode(chr));}return ret.join("")});Module["intArrayFromString"]=intArrayFromString;Module["intArrayToString"]=intArrayToString;var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var decodeBase64=typeof atob==="function"?atob:(function(input){var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output});function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer$8.from(s,"base64");}catch(_){buf=new Buffer$8(s,"base64");}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){var dataURIPrefix="data:application/octet-stream;base64,";if(!(String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viiiii(index,a1,a2,a3,a4,a5){try{Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5);}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_i(index){try{return Module["dynCall_i"](index)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_vi(index,a1){try{Module["dynCall_vi"](index,a1);}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_vii(index,a1,a2){try{Module["dynCall_vii"](index,a1,a2);}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viii(index,a1,a2,a3){try{Module["dynCall_viii"](index,a1,a2,a3);}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_v(index){try{Module["dynCall_v"](index);}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iii(index,a1,a2){try{return Module["dynCall_iii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){try{return Module["dynCall_iiiiii"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}function invoke_viiii(index,a1,a2,a3,a4){try{Module["dynCall_viiii"](index,a1,a2,a3,a4);}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;Module["setThrew"](1,0);}}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array,"NaN":NaN,"Infinity":Infinity};Module.asmLibraryArg={"abort":abort,"assert":assert,"enlargeMemory":enlargeMemory,"getTotalMemory":getTotalMemory,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"invoke_iiii":invoke_iiii,"invoke_viiiii":invoke_viiiii,"invoke_i":invoke_i,"invoke_vi":invoke_vi,"invoke_vii":invoke_vii,"invoke_ii":invoke_ii,"invoke_viii":invoke_viii,"invoke_v":invoke_v,"invoke_iii":invoke_iii,"invoke_iiiiii":invoke_iiiiii,"invoke_viiii":invoke_viiii,"_pthread_cond_wait":_pthread_cond_wait,"_llvm_bswap_i64":_llvm_bswap_i64,"__Unwind_FindEnclosingFunction":__Unwind_FindEnclosingFunction,"_emscripten_get_callstack_js":_emscripten_get_callstack_js,"_pthread_key_create":_pthread_key_create,"___setErrNo":___setErrNo,"___gxx_personality_v0":___gxx_personality_v0,"_pthread_rwlock_unlock":_pthread_rwlock_unlock,"___cxa_find_matching_catch_2":___cxa_find_matching_catch_2,"__ZSt18uncaught_exceptionv":__ZSt18uncaught_exceptionv,"___buildEnvironment":___buildEnvironment,"_pthread_cond_init":_pthread_cond_init,"__Unwind_GetIPInfo":__Unwind_GetIPInfo,"_pthread_mutexattr_destroy":_pthread_mutexattr_destroy,"__emscripten_traverse_stack":__emscripten_traverse_stack,"_emscripten_set_main_loop_timing":_emscripten_set_main_loop_timing,"___cxa_free_exception":___cxa_free_exception,"_pthread_key_delete":_pthread_key_delete,"___cxa_allocate_exception":___cxa_allocate_exception,"_pthread_rwlock_rdlock":_pthread_rwlock_rdlock,"___resumeException":___resumeException,"___cxa_find_matching_catch":___cxa_find_matching_catch,"_pthread_condattr_setclock":_pthread_condattr_setclock,"_pthread_getspecific":_pthread_getspecific,"___cxa_find_matching_catch_3":___cxa_find_matching_catch_3,"_emscripten_memcpy_big":_emscripten_memcpy_big,"_pthread_cond_signal":_pthread_cond_signal,"_pthread_mutex_destroy":_pthread_mutex_destroy,"_abort":_abort,"_pthread_condattr_init":_pthread_condattr_init,"_pthread_mutexattr_settype":_pthread_mutexattr_settype,"_getenv":_getenv,"_pthread_condattr_destroy":_pthread_condattr_destroy,"___syscall54":___syscall54,"___unlock":___unlock,"___syscall140":___syscall140,"_emscripten_set_main_loop":_emscripten_set_main_loop,"_emscripten_get_now":_emscripten_get_now,"_pthread_mutexattr_init":_pthread_mutexattr_init,"_pthread_setspecific":_pthread_setspecific,"_dladdr":_dladdr,"___cxa_throw":___cxa_throw,"___lock":___lock,"___syscall6":___syscall6,"___syscall4":___syscall4,"_pthread_cond_destroy":_pthread_cond_destroy,"_llvm_trap":_llvm_trap,"_pthread_mutex_init":_pthread_mutex_init,"__Unwind_Backtrace":__Unwind_Backtrace,"___syscall146":___syscall146,"_emscripten_exit_with_live_runtime":_emscripten_exit_with_live_runtime,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX};// EMSCRIPTEN_START_ASM
  var asm=(function(global,env,buffer) {
  "use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.DYNAMICTOP_PTR|0;var j=env.tempDoublePtr|0;var k=env.ABORT|0;var l=env.STACKTOP|0;var m=env.STACK_MAX|0;var n=0;var o=0;var p=0;var q=0;var r=global.NaN,s=global.Infinity;var t=0,u=0,v=0,w=0,x=0.0;var y=0;var z=global.Math.floor;var A=global.Math.abs;var B=global.Math.sqrt;var C=global.Math.pow;var D=global.Math.cos;var E=global.Math.sin;var F=global.Math.tan;var G=global.Math.acos;var H=global.Math.asin;var I=global.Math.atan;var J=global.Math.atan2;var K=global.Math.exp;var L=global.Math.log;var M=global.Math.ceil;var N=global.Math.imul;var O=global.Math.min;var P=global.Math.max;var Q=global.Math.clz32;var R=env.abort;var S=env.assert;var T=env.enlargeMemory;var U=env.getTotalMemory;var V=env.abortOnCannotGrowMemory;var W=env.invoke_iiii;var X=env.invoke_viiiii;var Y=env.invoke_i;var Z=env.invoke_vi;var _=env.invoke_vii;var $=env.invoke_ii;var aa=env.invoke_viii;var ba=env.invoke_v;var ca=env.invoke_iii;var da=env.invoke_iiiiii;var ea=env.invoke_viiii;var fa=env._pthread_cond_wait;var ga=env._llvm_bswap_i64;var ha=env.__Unwind_FindEnclosingFunction;var ia=env._emscripten_get_callstack_js;var ja=env._pthread_key_create;var ka=env.___setErrNo;var la=env.___gxx_personality_v0;var ma=env._pthread_rwlock_unlock;var na=env.___cxa_find_matching_catch_2;var oa=env.__ZSt18uncaught_exceptionv;var pa=env.___buildEnvironment;var qa=env._pthread_cond_init;var ra=env.__Unwind_GetIPInfo;var sa=env._pthread_mutexattr_destroy;var ta=env.__emscripten_traverse_stack;var ua=env._emscripten_set_main_loop_timing;var va=env.___cxa_free_exception;var wa=env._pthread_key_delete;var xa=env.___cxa_allocate_exception;var ya=env._pthread_rwlock_rdlock;var za=env.___resumeException;var Aa=env.___cxa_find_matching_catch;var Ba=env._pthread_condattr_setclock;var Ca=env._pthread_getspecific;var Da=env.___cxa_find_matching_catch_3;var Ea=env._emscripten_memcpy_big;var Fa=env._pthread_cond_signal;var Ga=env._pthread_mutex_destroy;var Ha=env._abort;var Ia=env._pthread_condattr_init;var Ja=env._pthread_mutexattr_settype;var Ka=env._getenv;var La=env._pthread_condattr_destroy;var Ma=env.___syscall54;var Na=env.___unlock;var Oa=env.___syscall140;var Pa=env._emscripten_set_main_loop;var Qa=env._emscripten_get_now;var Ra=env._pthread_mutexattr_init;var Sa=env._pthread_setspecific;var Ta=env._dladdr;var Ua=env.___cxa_throw;var Va=env.___lock;var Wa=env.___syscall6;var Xa=env.___syscall4;var Ya=env._pthread_cond_destroy;var Za=env._llvm_trap;var _a=env._pthread_mutex_init;var $a=env.__Unwind_Backtrace;var ab=env.___syscall146;var bb=env._emscripten_exit_with_live_runtime;var cb=0.0;
  // EMSCRIPTEN_START_FUNCS
  function ob(a){a=a|0;var b=0;b=l;l=l+a|0;l=l+15&-16;return b|0}function pb(){return l|0}function qb(a){a=a|0;l=a;}function rb(a,b){a=a|0;b=b|0;l=a;m=b;}function sb(a,b){a=a|0;b=b|0;if(!n){n=a;o=b;}}function tb(a){a=a|0;y=a;}function ub(){return y|0}function vb(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;i=l;l=l+16|0;g=i;h=a+4|0;f=c[h>>2]|0;e=f*288|0;if(f|0){b=f*576|0;if((b|0)<0)$i(1928);b=_b(c[a>>2]|0,e,8,b,8,g)|0;if(!b){d=g+4|0;j=c[d>>2]|0;d=c[d+4>>2]|0;c[g>>2]=c[g>>2];e=g+4|0;c[e>>2]=j;c[e+4>>2]=d;Yb(g);}e=b;g=a;j=f<<1;c[g>>2]=e;c[h>>2]=j;l=i;return}Wb(g,288,8,4);if((c[g>>2]|0)==1){b=c[g+4>>2]|0;if(b|0?(d=Xb(b,c[g+8>>2]|0,g)|0,d|0):0){f=d;g=a;j=4;c[g>>2]=f;c[h>>2]=j;l=i;return}}c[g>>2]=1;c[g+4>>2]=5846;c[g+8>>2]=30;Yb(g);}function wb(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+16|0;h=j;i=a+4|0;e=c[i>>2]|0;if((e-b|0)>>>0>=d>>>0){l=j;return}d=b+d|0;if(d>>>0<b>>>0)cj(5796,17);g=e<<1;g=d>>>0>=g>>>0?d:g;Wb(h,1,1,g);if((c[h>>2]|0)!=1)$i(1904);d=c[h+4>>2]|0;b=c[h+8>>2]|0;if((d|0)<0)$i(1928);e=c[i>>2]|0;if(!e){b=Xb(d,b,h)|0;d=(b|0)==0&1;e=0;f=0;}else {b=_b(c[a>>2]|0,e,1,d,b,h)|0;e=(b|0)==0;f=h+4|0;d=e&1;b=e?c[h>>2]|0:b;e=c[f>>2]|0;f=c[f+4>>2]|0;}if((d|0)==1){c[h>>2]=b;d=h+4|0;c[d>>2]=e;c[d+4>>2]=f;Yb(h);}c[a>>2]=b;c[i>>2]=g;l=j;return}function xb(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0;s=l;l=l+16|0;k=s;if(!f){a[b>>0]=3;l=s;return}m=d+9|0;o=d+4|0;p=k+4|0;q=d+8|0;while(1){do if(!(a[m>>0]|0)){i=c[o>>2]|0;g=f>>>0<=i>>>0?f:i;h=c[d>>2]|0;i=i-g|0;j=h+g|0;if((g|0)!=1){ok(e|0,h|0,g|0)|0;c[d>>2]=j;c[o>>2]=i;if(!g){a[m>>0]=1;r=9;break}}else {a[e>>0]=a[h>>0]|0;c[d>>2]=j;c[o>>2]=i;}c[k>>2]=0;c[p>>2]=g;}else r=9;while(0);if((r|0)==9){r=0;g=e+f|0;h=e;do{a[h>>0]=a[q>>0]|0;h=h+1|0;}while((h|0)!=(g|0));c[k>>2]=0;c[p>>2]=f;if(!f){r=3;break}else g=f;}if(f>>>0<g>>>0){r=12;break}f=f-g|0;if(!f){r=16;break}else e=e+g|0;}if((r|0)==3){a[b>>0]=3;l=s;return}else if((r|0)==12){n=0;_(8,g|0,f|0);n=0;s=na()|0;yb(k);za(s|0);}else if((r|0)==16){a[b>>0]=3;l=s;return}}function yb(a){a=a|0;var b=0,e=0,f=0;if(!(c[a>>2]|0))return;if((d[a+4>>0]|0)<2)return;e=a+8|0;f=c[e>>2]|0;a=f+4|0;n=0;Z(c[c[a>>2]>>2]|0,c[f>>2]|0);b=n;n=0;if(b&1){b=na()|0;zb(c[f>>2]|0,c[a>>2]|0);Ab(c[e>>2]|0);za(b|0);}a=c[a>>2]|0;b=c[a+4>>2]|0;if(b|0)Zb(c[f>>2]|0,b,c[a+8>>2]|0);Zb(c[e>>2]|0,12,4);return}function zb(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Ab(a){a=a|0;Zb(a,12,4);return}function Bb(a){a=a|0;return}function Cb(a){a=a|0;kb[c[a>>2]&3]();return Rd()|0}function Db(a){a=a|0;kb[a&3]();return Rd()|0}function Eb(a){a=a|0;var b=0,e=0,f=0;if((d[a>>0]|0)<2)return;e=a+4|0;f=c[e>>2]|0;a=f+4|0;n=0;Z(c[c[a>>2]>>2]|0,c[f>>2]|0);b=n;n=0;if(b&1){b=na()|0;Fb(c[f>>2]|0,c[a>>2]|0);Gb(c[e>>2]|0);za(b|0);}a=c[a>>2]|0;b=c[a+4>>2]|0;if(b|0)Zb(c[f>>2]|0,b,c[a+8>>2]|0);Zb(c[e>>2]|0,12,4);return}function Fb(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Gb(a){a=a|0;Zb(a,12,4);return}function Hb(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=l;l=l+48|0;f=g+32|0;e=g+8|0;c[g>>2]=a;c[g+4>>2]=b;c[f>>2]=g;c[f+4>>2]=33;c[f+8>>2]=d;c[f+12>>2]=34;c[e>>2]=1976;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;n=0;_(9,e|0,1992);n=0;b=na()|0;Eb(d);za(b|0);}function Ib(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=l;l=l+64|0;g=i+32|0;f=i+8|0;h=i+48|0;c[i>>2]=b;c[i+4>>2]=d;a[h>>0]=e&1;c[g>>2]=i;c[g+4>>2]=33;c[g+8>>2]=h;c[g+12>>2]=35;c[f>>2]=1976;c[f+4>>2]=2;c[f+8>>2]=5264;c[f+12>>2]=2;c[f+16>>2]=g;c[f+20>>2]=2;aj(f,1992);}function Jb(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=l;l=l+48|0;f=g+32|0;e=g+8|0;c[g>>2]=a;c[g+4>>2]=b;c[f>>2]=g;c[f+4>>2]=33;c[f+8>>2]=d;c[f+12>>2]=36;c[e>>2]=1976;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;aj(e,1992);}function Kb(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=l;l=l+48|0;f=g+32|0;e=g+8|0;c[g>>2]=a;c[g+4>>2]=b;c[f>>2]=g;c[f+4>>2]=33;c[f+8>>2]=d;c[f+12>>2]=37;c[e>>2]=1976;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;aj(e,1992);}function Lb(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;B=l;l=l+848|0;A=B;j=B+680|0;u=B+640|0;k=B+632|0;m=B+816|0;y=B+740|0;w=B+600|0;v=B+568|0;x=B+504|0;o=B+472|0;p=B+376|0;q=B+280|0;r=B+208|0;d=B+752|0;s=B+712|0;h=B+104|0;t=B+8|0;i=B+700|0;z=B+688|0;Ff(A,b);Gf(u,c[A>>2]|0,c[A+4>>2]|0);if((c[u>>2]|0)==1){f=u+4|0;g=c[f+4>>2]|0;A=j;c[A>>2]=c[f>>2];c[A+4>>2]=g;Kb(5909,43,j);}od(u,c[u+4>>2]|0,c[u+8>>2]|0);if((c[u>>2]|0)==1){f=u+4|0;g=c[f+4>>2]|0;A=j;c[A>>2]=c[f>>2];c[A+4>>2]=g;Jb(5909,43,j);}b=u+4|0;c[z>>2]=c[b>>2];c[z+4>>2]=c[b+4>>2];c[z+8>>2]=c[b+8>>2];b=c[z>>2]|0;e=c[z+8>>2]|0;A=b;n=0;f=$(9,0)|0;g=n;n=0;a:do if(!(g&1)?(c[i>>2]=b,c[i+4>>2]=e,a[i+8>>0]=f,a[i+9>>0]=0,n=0,_(10,h|0,i|0),g=n,n=0,!(g&1)):0){do if((c[h>>2]|0)!=1){g=t;e=h+8|0;f=g+96|0;do{c[g>>2]=c[e>>2];g=g+4|0;e=e+4|0;}while((g|0)<(f|0));g=m;f=g+32|0;do{a[g>>0]=0;g=g+1|0;}while((g|0)<(f|0));n=0;ea(3,k|0,i|0,m|0,32);i=n;n=0;if(i&1)break a;if((a[k>>0]|0)!=3){y=k;A=c[y+4>>2]|0;B=j;c[B>>2]=c[y>>2];c[B+4>>2]=A;n=0;aa(2,5952,50,j|0);n=0;break a}n=0;aa(3,u|0,m|0,32);m=n;n=0;if(m&1)break a;if((a[u>>0]|0)==1)break;b=c[u+8>>2]|0;g=u+12|0;c[s>>2]=c[g>>2];c[s+4>>2]=c[g+4>>2];c[s+8>>2]=c[g+8>>2];c[s+12>>2]=c[g+12>>2];c[s+16>>2]=c[g+16>>2];c[s+20>>2]=c[g+20>>2];c[s+24>>2]=c[g+24>>2];g=d;f=g+64|0;do{a[g>>0]=0;g=g+1|0;}while((g|0)<(f|0));g=p;e=t;f=g+96|0;do{c[g>>2]=c[e>>2];g=g+4|0;e=e+4|0;}while((g|0)<(f|0));c[o>>2]=b;u=o+4|0;c[u>>2]=c[s>>2];c[u+4>>2]=c[s+4>>2];c[u+8>>2]=c[s+8>>2];c[u+12>>2]=c[s+12>>2];c[u+16>>2]=c[s+16>>2];c[u+20>>2]=c[s+20>>2];c[u+24>>2]=c[s+24>>2];n=0;aa(4,q|0,p|0,o|0);u=n;n=0;if(u&1)break a;n=0;_(11,r|0,q|0);u=n;n=0;if(u&1)break a;u=r;do if((c[u>>2]|0)==1&(c[u+4>>2]|0)==0){g=x;e=r+8|0;f=g+64|0;do{c[g>>2]=c[e>>2];g=g+4|0;e=e+4|0;}while((g|0)<(f|0));n=0;_(12,v|0,x|0);u=n;n=0;if(u&1)break a;n=0;b=W(9,v|0,d|0,32)|0;v=n;n=0;if(v&1)break a;if(b<<24>>24!=2){n=0;aa(6,6002,41,(b&1)!=0|0);n=0;break a}n=0;_(13,w|0,x|0);x=n;n=0;if(x&1)break a;n=0;b=W(9,w|0,d+32|0,32)|0;x=n;n=0;if(x&1)break a;if(b<<24>>24==2)break;else {n=0;aa(6,6043,42,(b&1)!=0|0);n=0;break a}}while(0);n=0;aa(5,y|0,d|0,64);x=n;n=0;if(x&1)break a;d=y+8|0;n=0;aa(7,y|0,c[d>>2]|0,1);x=n;n=0;if(x&1){B=na()|0;Ob(y);Mb(z);za(B|0);}b=c[d>>2]|0;c[d>>2]=b+1;a[(c[y>>2]|0)+b>>0]=0;b=c[y>>2]|0;d=c[y+4>>2]|0;if(d|0)Zb(b,d,1);d=c[z+4>>2]|0;if(d|0)Zb(A,d,1);A=b;l=B;return A|0}while(0);d=c[z+4>>2]|0;if(d|0)Zb(A,d,1);A=16464;l=B;return A|0}while(0);B=na()|0;Mb(z);za(B|0);return 0}function Mb(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function Nb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;q=l;l=l+480|0;k=q+264|0;f=q+232|0;j=q+160|0;m=q+388|0;n=q+328|0;o=q+64|0;g=q+32|0;h=q;e=q+448|0;p=e;r=p+32|0;do{a[p>>0]=0;p=p+1|0;}while((p|0)<(r|0));xb(f,d,e,32);if((a[f>>0]|0)!=3){s=f;p=c[s+4>>2]|0;r=k;c[r>>2]=c[s>>2];c[r+4>>2]=p;Hb(5952,50,k);}cc(k,e,32);if((a[k>>0]|0)==1){c[b>>2]=1;c[b+4>>2]=6085;c[b+8>>2]=26;}else {s=c[k+8>>2]|0;r=k+12|0;c[f>>2]=c[r>>2];c[f+4>>2]=c[r+4>>2];c[f+8>>2]=c[r+8>>2];c[f+12>>2]=c[r+12>>2];c[f+16>>2]=c[r+16>>2];c[f+20>>2]=c[r+20>>2];c[f+24>>2]=c[r+24>>2];c[j>>2]=c[f>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];c[h>>2]=s;s=h+4|0;c[s>>2]=c[j>>2];c[s+4>>2]=c[j+4>>2];c[s+8>>2]=c[j+8>>2];c[s+12>>2]=c[j+12>>2];c[s+16>>2]=c[j+16>>2];c[s+20>>2]=c[j+20>>2];c[s+24>>2]=c[j+24>>2];xb(f,d,e,32);if((a[f>>0]|0)!=3){p=f;r=c[p+4>>2]|0;s=k;c[s>>2]=c[p>>2];c[s+4>>2]=r;Hb(5952,50,k);}cc(k,e,32);a:do if((a[k>>0]|0)==1){c[b>>2]=1;c[b+4>>2]=6111;c[b+8>>2]=26;}else {s=c[k+8>>2]|0;r=k+12|0;c[f>>2]=c[r>>2];c[f+4>>2]=c[r+4>>2];c[f+8>>2]=c[r+8>>2];c[f+12>>2]=c[r+12>>2];c[f+16>>2]=c[r+16>>2];c[f+20>>2]=c[r+20>>2];c[f+24>>2]=c[r+24>>2];c[j>>2]=c[f>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];c[g>>2]=s;s=g+4|0;c[s>>2]=c[j>>2];c[s+4>>2]=c[j+4>>2];c[s+8>>2]=c[j+8>>2];c[s+12>>2]=c[j+12>>2];c[s+16>>2]=c[j+16>>2];c[s+20>>2]=c[j+20>>2];c[s+24>>2]=c[j+24>>2];ac(f);if((Xj(h,f,32)|0)==0?(ac(k),(Xj(g,k,32)|0)==0):0)fc(o);else i=13;do if((i|0)==13){c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[f+28>>2]=c[h+28>>2];c[k>>2]=c[g>>2];c[k+4>>2]=c[g+4>>2];c[k+8>>2]=c[g+8>>2];c[k+12>>2]=c[g+12>>2];c[k+16>>2]=c[g+16>>2];c[k+20>>2]=c[g+20>>2];c[k+24>>2]=c[g+24>>2];c[k+28>>2]=c[g+28>>2];ic(j,f,k);if((a[j>>0]|0)==1){c[b>>2]=1;c[b+4>>2]=6137;c[b+8>>2]=19;break a}else {e=c[j+8>>2]|0;p=m;d=j+12|0;r=p+60|0;do{c[p>>2]=c[d>>2];p=p+4|0;d=d+4|0;}while((p|0)<(r|0));p=n;d=m;r=p+60|0;do{c[p>>2]=c[d>>2];p=p+4|0;d=d+4|0;}while((p|0)<(r|0));c[k>>2]=e;p=k+4|0;d=n;r=p+60|0;do{c[p>>2]=c[d>>2];p=p+4|0;d=d+4|0;}while((p|0)<(r|0));mc(o,k);break}}while(0);c[b>>2]=0;p=b+8|0;d=o;r=p+96|0;do{c[p>>2]=c[d>>2];p=p+4|0;d=d+4|0;}while((p|0)<(r|0));l=q;return}while(0)}l=q;return}function Ob(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function Pb(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0;D=l;l=l+1072|0;C=D;j=D+808|0;A=D+864|0;y=D+776|0;u=D+744|0;z=D+680|0;v=D+584|0;w=D+488|0;x=D+392|0;s=D+320|0;d=D+1008|0;q=D+216|0;k=D+112|0;t=D+16|0;r=D+852|0;m=D+840|0;h=D+8|0;o=D+880|0;i=D+828|0;B=D+816|0;Ff(C,b);Gf(A,c[C>>2]|0,c[C+4>>2]|0);if((c[A>>2]|0)==1){f=A+4|0;g=c[f+4>>2]|0;C=j;c[C>>2]=c[f>>2];c[C+4>>2]=g;Kb(5909,43,j);}od(A,c[A+4>>2]|0,c[A+8>>2]|0);if((c[A>>2]|0)==1){f=A+4|0;g=c[f+4>>2]|0;C=j;c[C>>2]=c[f>>2];c[C+4>>2]=g;Jb(5909,43,j);}b=A+4|0;c[B>>2]=c[b>>2];c[B+4>>2]=c[b+4>>2];c[B+8>>2]=c[b+8>>2];b=c[B>>2]|0;e=c[B+8>>2]|0;C=b;n=0;f=$(9,0)|0;g=n;n=0;a:do if(!(g&1)){c[i>>2]=b;c[i+4>>2]=e;a[i+8>>0]=f;a[i+9>>0]=0;f=o;g=f+128|0;do{a[f>>0]=0;f=f+1|0;}while((f|0)<(g|0));n=0;ea(3,h|0,i|0,o|0,128);i=n;n=0;if(!(i&1)){if((a[h>>0]|0)!=3){A=h;C=c[A+4>>2]|0;D=j;c[D>>2]=c[A>>2];c[D+4>>2]=C;n=0;aa(2,5952,50,j|0);n=0;break}b=o+64|0;n=0;e=$(9,0)|0;j=n;n=0;if((!(j&1)?(c[m>>2]=o,c[m+4>>2]=64,a[m+8>>0]=e,a[m+9>>0]=0,n=0,p=$(9,0)|0,o=n,n=0,!(o&1)):0)?(c[r>>2]=b,c[r+4>>2]=64,a[r+8>>0]=p,a[r+9>>0]=0,n=0,_(10,k|0,m|0),p=n,n=0,!(p&1)):0){if((c[k>>2]|0)==1){d=c[B+4>>2]|0;if(d|0)Zb(C,d,1);C=16464;l=D;return C|0}f=t;e=k+8|0;g=f+96|0;do{c[f>>2]=c[e>>2];f=f+4|0;e=e+4|0;}while((f|0)<(g|0));n=0;_(10,q|0,r|0);r=n;n=0;if(!(r&1)){if((c[q>>2]|0)==1)b=16464;else {b=q+8|0;f=d;g=f+64|0;do{a[f>>0]=0;f=f+1|0;}while((f|0)<(g|0));f=w;e=t;g=f+96|0;do{c[f>>2]=c[e>>2];f=f+4|0;e=e+4|0;}while((f|0)<(g|0));f=v;e=b;g=f+96|0;do{c[f>>2]=c[e>>2];f=f+4|0;e=e+4|0;}while((f|0)<(g|0));n=0;aa(8,x|0,w|0,v|0);w=n;n=0;if(w&1)break;n=0;_(11,s|0,x|0);x=n;n=0;if(x&1)break;x=s;do if((c[x>>2]|0)==1&(c[x+4>>2]|0)==0){f=z;e=s+8|0;g=f+64|0;do{c[f>>2]=c[e>>2];f=f+4|0;e=e+4|0;}while((f|0)<(g|0));n=0;_(12,u|0,z|0);x=n;n=0;if(x&1)break a;n=0;b=W(9,u|0,d|0,32)|0;x=n;n=0;if(x&1)break a;if(b<<24>>24!=2){n=0;aa(6,6002,41,(b&1)!=0|0);n=0;break a}n=0;_(13,y|0,z|0);z=n;n=0;if(z&1)break a;n=0;b=W(9,y|0,d+32|0,32)|0;z=n;n=0;if(z&1)break a;if(b<<24>>24==2)break;else {n=0;aa(6,6043,42,(b&1)!=0|0);n=0;break a}}while(0);n=0;aa(5,A|0,d|0,64);z=n;n=0;if(z&1)break;d=A+8|0;n=0;aa(7,A|0,c[d>>2]|0,1);z=n;n=0;if(z&1){D=na()|0;Ob(A);Mb(B);za(D|0);}b=c[d>>2]|0;c[d>>2]=b+1;a[(c[A>>2]|0)+b>>0]=0;b=c[A>>2]|0;d=c[A+4>>2]|0;if(d|0)Zb(b,d,1);}d=c[B+4>>2]|0;if(d|0)Zb(C,d,1);C=b;l=D;return C|0}}}}while(0);D=na()|0;Mb(B);za(D|0);return 0}function Qb(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,ba=0,ca=0,da=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0;Ga=l;l=l+6960|0;z=Ga;ta=Ga+6664|0;ua=Ga+6568|0;va=Ga+6184|0;wa=Ga+5800|0;ya=Ga+5128|0;Aa=Ga+4456|0;Ba=Ga+4072|0;Ca=Ga+3688|0;Fa=Ga+6896|0;pa=Ga+6908|0;qa=Ga+6920|0;ra=Ga+3304|0;oa=Ga+2920|0;Ea=Ga+6880|0;sa=Ga+2536|0;A=Ga+2248|0;B=Ga+2120|0;C=Ga+1928|0;D=Ga+1864|0;E=Ga+1800|0;F=Ga+1664|0;G=Ga+1472|0;H=Ga+1280|0;I=Ga+1248|0;J=Ga+1216|0;K=Ga+1152|0;L=Ga+1120|0;M=Ga+1088|0;N=Ga+1024|0;O=Ga+960|0;P=Ga+864|0;Q=Ga+832|0;R=Ga+800|0;S=Ga+728|0;T=Ga+632|0;U=Ga+600|0;V=Ga+568|0;W=Ga+472|0;X=Ga+432|0;Y=Ga+400|0;ba=Ga+360|0;ca=Ga+328|0;da=Ga+288|0;fa=Ga+256|0;ga=Ga+216|0;ha=Ga+184|0;ia=Ga+144|0;ja=Ga+112|0;ka=Ga+72|0;la=Ga+40|0;ma=Ga+6868|0;xa=Ga+8|0;Ha=Ga+6856|0;Ff(z,b);Gf(ua,c[z>>2]|0,c[z+4>>2]|0);if((c[ua>>2]|0)==1){x=ua+4|0;y=c[x+4>>2]|0;z=ta;c[z>>2]=c[x>>2];c[z+4>>2]=y;Kb(5909,43,ta);}od(ua,c[ua+4>>2]|0,c[ua+8>>2]|0);if((c[ua>>2]|0)==1){x=ua+4|0;y=c[x+4>>2]|0;z=ta;c[z>>2]=c[x>>2];c[z+4>>2]=y;Jb(5909,43,ta);}y=ua+4|0;c[Ha>>2]=c[y>>2];c[Ha+4>>2]=c[y+4>>2];c[Ha+8>>2]=c[y+8>>2];y=c[Ha+8>>2]|0;z=(y>>>0)/192|0;a:do if(!((y>>>0)%192|0)){if(y){c[ma>>2]=8;g=ma+4|0;c[g>>2]=0;h=ma+8|0;c[h>>2]=0;b:do if(y>>>0>191){i=ka+8|0;j=ia+8|0;p=ga+8|0;q=da+8|0;r=ba+8|0;s=X+8|0;t=A+96|0;u=F+8|0;v=S+8|0;w=c[Ha>>2]|0;x=0;c:while(1){f=x*192|0;x=x+1|0;b=f|32;if(y>>>0<b>>>0){Da=16;break}n=0;aa(9,ka|0,w+f|0,b-f|0);o=n;n=0;if(o&1){Da=125;break}if((a[ka>>0]|0)==1){Da=23;break};c[la>>2]=c[i>>2];c[la+4>>2]=c[i+4>>2];c[la+8>>2]=c[i+8>>2];c[la+12>>2]=c[i+12>>2];c[la+16>>2]=c[i+16>>2];c[la+20>>2]=c[i+20>>2];c[la+24>>2]=c[i+24>>2];c[la+28>>2]=c[i+28>>2];d=f+64|0;if(d>>>0<b>>>0){Da=20;break}if(y>>>0<d>>>0){Da=22;break}n=0;aa(9,ia|0,w+b|0,d-b|0);o=n;n=0;if(o&1){Da=125;break}if((a[ia>>0]|0)==1){Da=31;break};c[ja>>2]=c[j>>2];c[ja+4>>2]=c[j+4>>2];c[ja+8>>2]=c[j+8>>2];c[ja+12>>2]=c[j+12>>2];c[ja+16>>2]=c[j+16>>2];c[ja+20>>2]=c[j+20>>2];c[ja+24>>2]=c[j+24>>2];c[ja+28>>2]=c[j+28>>2];b=f+96|0;if(y>>>0<b>>>0){Da=30;break}n=0;aa(9,ga|0,w+d|0,32);o=n;n=0;if(o&1){Da=125;break}if((a[ga>>0]|0)==1){Da=37;break};c[ha>>2]=c[p>>2];c[ha+4>>2]=c[p+4>>2];c[ha+8>>2]=c[p+8>>2];c[ha+12>>2]=c[p+12>>2];c[ha+16>>2]=c[p+16>>2];c[ha+20>>2]=c[p+20>>2];c[ha+24>>2]=c[p+24>>2];c[ha+28>>2]=c[p+28>>2];d=f+128|0;if(y>>>0<d>>>0){Da=36;break}n=0;aa(9,da|0,w+b|0,32);o=n;n=0;if(o&1){Da=125;break}if((a[da>>0]|0)==1){Da=43;break};c[fa>>2]=c[q>>2];c[fa+4>>2]=c[q+4>>2];c[fa+8>>2]=c[q+8>>2];c[fa+12>>2]=c[q+12>>2];c[fa+16>>2]=c[q+16>>2];c[fa+20>>2]=c[q+20>>2];c[fa+24>>2]=c[q+24>>2];c[fa+28>>2]=c[q+28>>2];e=f+160|0;if(y>>>0<e>>>0){Da=42;break}n=0;aa(9,ba|0,w+d|0,32);o=n;n=0;if(o&1){Da=125;break}if((a[ba>>0]|0)==1){Da=49;break};c[ca>>2]=c[r>>2];c[ca+4>>2]=c[r+4>>2];c[ca+8>>2]=c[r+8>>2];c[ca+12>>2]=c[r+12>>2];c[ca+16>>2]=c[r+16>>2];c[ca+20>>2]=c[r+20>>2];c[ca+24>>2]=c[r+24>>2];c[ca+28>>2]=c[r+28>>2];b=f+192|0;if(y>>>0<b>>>0){Da=48;break}n=0;aa(9,X|0,w+e|0,32);o=n;n=0;if(o&1){Da=125;break}if((a[X>>0]|0)==1){Da=54;break};c[Y>>2]=c[s>>2];c[Y+4>>2]=c[s+4>>2];c[Y+8>>2]=c[s+8>>2];c[Y+12>>2]=c[s+12>>2];c[Y+16>>2]=c[s+16>>2];c[Y+20>>2]=c[s+20>>2];c[Y+24>>2]=c[s+24>>2];c[Y+28>>2]=c[s+28>>2];n=0;Z(36,V|0);o=n;n=0;if(o&1){Da=125;break}do if(!(Xj(la,V,32)|0)){n=0;Z(36,U|0);o=n;n=0;if(o&1){Da=125;break c}if(Xj(ja,U,32)|0){Da=56;break}n=0;Z(37,T|0);o=n;n=0;if(o&1){Da=125;break c}k=W;m=T;o=k+96|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0))}else Da=56;while(0);if((Da|0)==56){Da=0;c[R>>2]=c[la>>2];c[R+4>>2]=c[la+4>>2];c[R+8>>2]=c[la+8>>2];c[R+12>>2]=c[la+12>>2];c[R+16>>2]=c[la+16>>2];c[R+20>>2]=c[la+20>>2];c[R+24>>2]=c[la+24>>2];c[R+28>>2]=c[la+28>>2];c[Q>>2]=c[ja>>2];c[Q+4>>2]=c[ja+4>>2];c[Q+8>>2]=c[ja+8>>2];c[Q+12>>2]=c[ja+12>>2];c[Q+16>>2]=c[ja+16>>2];c[Q+20>>2]=c[ja+20>>2];c[Q+24>>2]=c[ja+24>>2];c[Q+28>>2]=c[ja+28>>2];n=0;aa(10,S|0,R|0,Q|0);o=n;n=0;if(o&1){Da=125;break}if((a[S>>0]|0)==1){Da=65;break}k=O;m=v;o=k+64|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0));n=0;_(15,P|0,O|0);o=n;n=0;if(o&1){Da=125;break}k=W;m=P;o=k+96|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0))};c[M>>2]=c[fa>>2];c[M+4>>2]=c[fa+4>>2];c[M+8>>2]=c[fa+8>>2];c[M+12>>2]=c[fa+12>>2];c[M+16>>2]=c[fa+16>>2];c[M+20>>2]=c[fa+20>>2];c[M+24>>2]=c[fa+24>>2];c[M+28>>2]=c[fa+28>>2];c[L>>2]=c[ha>>2];c[L+4>>2]=c[ha+4>>2];c[L+8>>2]=c[ha+8>>2];c[L+12>>2]=c[ha+12>>2];c[L+16>>2]=c[ha+16>>2];c[L+20>>2]=c[ha+20>>2];c[L+24>>2]=c[ha+24>>2];c[L+28>>2]=c[ha+28>>2];n=0;aa(11,N|0,M|0,L|0);o=n;n=0;if(o&1){Da=125;break};c[J>>2]=c[Y>>2];c[J+4>>2]=c[Y+4>>2];c[J+8>>2]=c[Y+8>>2];c[J+12>>2]=c[Y+12>>2];c[J+16>>2]=c[Y+16>>2];c[J+20>>2]=c[Y+20>>2];c[J+24>>2]=c[Y+24>>2];c[J+28>>2]=c[Y+28>>2];c[I>>2]=c[ca>>2];c[I+4>>2]=c[ca+4>>2];c[I+8>>2]=c[ca+8>>2];c[I+12>>2]=c[ca+12>>2];c[I+16>>2]=c[ca+16>>2];c[I+20>>2]=c[ca+20>>2];c[I+24>>2]=c[ca+24>>2];c[I+28>>2]=c[ca+28>>2];n=0;aa(11,K|0,J|0,I|0);o=n;n=0;if(o&1){Da=125;break}n=0;b=$(10,fa|0)|0;o=n;n=0;if(o&1){Da=125;break}do if(b){n=0;b=$(10,ha|0)|0;o=n;n=0;if(o&1){Da=125;break c}if(!b){Da=70;break}n=0;b=$(10,Y|0)|0;o=n;n=0;if(o&1){Da=125;break c}if(!b){Da=70;break}n=0;b=$(10,ca|0)|0;o=n;n=0;if(o&1){Da=125;break c}if(!b){Da=70;break}n=0;Z(38,G|0);o=n;n=0;if(o&1){Da=125;break c}ok(H|0,G|0,192)|0;}else Da=70;while(0);if((Da|0)==70){Da=0;k=E;m=N;o=k+64|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0));k=D;m=K;o=k+64|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0));n=0;aa(12,F|0,E|0,D|0);o=n;n=0;if(o&1){Da=125;break}if((a[F>>0]|0)==1){Da=83;break}k=B;m=u;o=k+128|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0));n=0;_(16,C|0,B|0);o=n;n=0;if(o&1){Da=125;break}ok(H|0,C|0,192)|0;}k=A;m=W;o=k+96|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0));ok(t|0,H|0,192)|0;b=c[h>>2]|0;if((b|0)==(c[g>>2]|0)){n=0;Z(39,ma|0);o=n;n=0;if(o&1){Da=125;break}b=c[h>>2]|0;}ok((c[ma>>2]|0)+(b*288|0)|0,A|0,288)|0;c[h>>2]=b+1;if(x>>>0>=z>>>0)break b}switch(Da|0){case 16:{n=0;_(14,b|0,y|0);n=0;Da=125;break}case 20:{n=0;_(8,b|0,d|0);n=0;Da=125;break}case 22:{n=0;_(14,d|0,y|0);n=0;Da=125;break}case 23:break;case 30:{n=0;_(14,b|0,y|0);n=0;Da=125;break}case 31:{Da=32;break}case 36:{n=0;_(14,d|0,y|0);n=0;Da=125;break}case 37:{Da=38;break}case 42:{n=0;_(14,e|0,y|0);n=0;Da=125;break}case 43:{Da=44;break}case 48:{n=0;_(14,b|0,y|0);n=0;Da=125;break}case 49:{Da=50;break}case 54:{Da=55;break}case 65:{Da=66;break}case 83:{Da=66;break}}if((Da|0)==66)Da=55;else if((Da|0)==125){Ga=na()|0;Sb(ma);Mb(Ha);za(Ga|0);}if((Da|0)==55)Da=50;if((Da|0)==50)Da=44;if((Da|0)==44)Da=38;if((Da|0)==38)Da=32;b=c[g>>2]|0;if(b|0)Zb(c[ma>>2]|0,b*288|0,8);break a}while(0);c[ta>>2]=c[ma>>2];c[ta+4>>2]=c[ma+4>>2];c[ta+8>>2]=c[ma+8>>2];g=c[ta>>2]|0;b=c[ta+8>>2]|0;h=g+(b*288|0)|0;i=c[ta+4>>2]|0;c[Ea>>2]=g;c[Ea+4>>2]=i;j=Ea+8|0;c[j>>2]=g;c[Ea+12>>2]=h;n=0;Z(40,oa|0);ma=n;n=0;if(ma&1){Ga=na()|0;Rb(Ea);Mb(Ha);za(Ga|0);}ok(Ca|0,oa|0,384)|0;do if(b){b=Aa+384|0;d=ya+384|0;e=ya+480|0;f=g;while(1){k=f;f=f+288|0;ok(Aa|0,Ca|0,384)|0;ok(b|0,k|0,288)|0;ok(ya|0,Ca|0,384)|0;ok(d|0,k|0,288)|0;ok(wa|0,Aa|0,384)|0;k=ua;m=b;o=k+96|0;do{c[k>>2]=c[m>>2];k=k+4|0;m=m+4|0;}while((k|0)<(o|0));ok(ta|0,e|0,192)|0;n=0;aa(13,va|0,ua|0,ta|0);oa=n;n=0;if(oa&1)break;n=0;aa(14,Ba|0,wa|0,va|0);oa=n;n=0;if(oa&1)break;ok(Ca|0,Ba|0,384)|0;if((f|0)==(h|0)){Da=94;break}}if((Da|0)==94){c[j>>2]=h;ok(sa|0,Ca|0,384)|0;break}b=na()|0;c[j>>2]=f;n=0;Z(41,Ea|0);Ga=n;n=0;if(Ga&1){Ga=na()|0;Mb(Ha);za(Ga|0);}else {Ga=b;Mb(Ha);za(Ga|0);}}else ok(sa|0,Ca|0,384)|0;while(0);if(i|0)Zb(g,i*288|0,8);n=0;Z(40,ra|0);Ea=n;n=0;if(Ea&1){Ga=na()|0;Mb(Ha);za(Ga|0);}do if((((((((Xj(sa,ra,32)|0)==0?(Xj(sa+32|0,ra+32|0,32)|0)==0:0)?(Xj(sa+64|0,ra+64|0,32)|0)==0:0)?(Xj(sa+96|0,ra+96|0,32)|0)==0:0)?(Xj(sa+128|0,ra+128|0,32)|0)==0:0)?(Xj(sa+160|0,ra+160|0,32)|0)==0:0)?(Xj(sa+192|0,ra+192|0,32)|0)==0:0)?(Xj(sa+224|0,ra+224|0,32)|0)==0:0){if(Xj(sa+256|0,ra+256|0,32)|0){Da=113;break}if(Xj(sa+288|0,ra+288|0,32)|0){Da=113;break}if(Xj(sa+320|0,ra+320|0,32)|0){Da=113;break}if(Xj(sa+352|0,ra+352|0,32)|0){Da=115;break}Ea=xa;c[Ea>>2]=1;c[Ea+4>>2]=0;Ea=xa+8|0;c[Ea>>2]=0;c[Ea+4>>2]=0;c[Ea+8>>2]=0;c[Ea+12>>2]=0;c[Ea+16>>2]=0;c[Ea+20>>2]=0;}else Da=113;while(0);if((Da|0)==113)Da=115;if((Da|0)==115){c[xa>>2]=0;c[xa+4>>2]=0;c[xa+8>>2]=0;c[xa+12>>2]=0;c[xa+16>>2]=0;c[xa+20>>2]=0;c[xa+24>>2]=0;c[xa+28>>2]=0;}}else {Ea=xa;c[Ea>>2]=1;c[Ea+4>>2]=0;Ea=xa+8|0;c[Ea>>2]=0;c[Ea+4>>2]=0;c[Ea+8>>2]=0;c[Ea+12>>2]=0;c[Ea+16>>2]=0;c[Ea+20>>2]=0;}k=qa;o=k+32|0;do{a[k>>0]=0;k=k+1|0;}while((k|0)<(o|0));n=0;ea(4,pa|0,xa|0,qa|0,32);Ea=n;n=0;if(!(Ea&1)?(n=0,aa(5,Fa|0,qa|0,32),Ea=n,n=0,!(Ea&1)):0){b=Fa+8|0;n=0;aa(7,Fa|0,c[b>>2]|0,1);Ea=n;n=0;if(Ea&1){Ga=na()|0;Ob(Fa);Mb(Ha);za(Ga|0);}d=c[b>>2]|0;c[b>>2]=d+1;a[(c[Fa>>2]|0)+d>>0]=0;d=c[Fa>>2]|0;b=c[Fa+4>>2]|0;if(b|0)Zb(d,b,1);b=c[Ha+4>>2]|0;if(b|0)Zb(c[Ha>>2]|0,b,1);Ha=d;l=Ga;return Ha|0}Ga=na()|0;Mb(Ha);za(Ga|0);}while(0);b=c[Ha+4>>2]|0;if(b|0)Zb(c[Ha>>2]|0,b,1);Ha=16464;l=Ga;return Ha|0}function Rb(a){a=a|0;var b=0,d=0,e=0;b=a+8|0;d=c[b>>2]|0;e=c[a+12>>2]|0;if((d|0)!=(e|0))c[b>>2]=d+(((((e+-288-d|0)>>>0)/288|0)+1|0)*288|0);b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b*288|0,8);return}function Sb(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b*288|0,8);return}function Tb(a,b){a=a|0;b=b|0;var d=0,e=0;d=l;l=l+16|0;e=d;c[e>>2]=1;b=Od(e,1952,a,b)|0;l=d;return b|0}function Ub(){bb();return}function Vb(a,b){a=a|0;b=b|0;return zi(c[a>>2]|0,c[a+4>>2]|0,b)|0}function Wb(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;g=0-d|0;f=b+((b+-1+d&g)-b)|0;if(f>>>0<b>>>0){c[a>>2]=0;return}b=N(f,e)|0;h=(e|0)==0;if(h?0:((b>>>0)/((h?1:e)>>>0)|0|0)!=(f|0)){c[a>>2]=0;return}if((d+-1&(d|-2147483648)|0)!=0|b>>>0>g>>>0)$i(2008);c[a>>2]=1;c[a+4>>2]=b;c[a+8>>2]=d;c[a+12>>2]=f;return}function Xb(a,b,c){a=a|0;b=b|0;c=c|0;return Mg(a,b,c)|0}function Yb(a){a=a|0;Ng(a);}function Zb(a,b,c){a=a|0;b=b|0;c=c|0;Og(a,b,c);return}function _b(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return Pg(a,b,c,d,e,f)|0}function $b(e,f,g){e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0;k=l;l=l+112|0;h=k+32|0;j=k;if((g|0)==32){m=f;g=m;m=m+4|0;m=ga(d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24|0,d[m>>0]|d[m+1>>0]<<8|d[m+2>>0]<<16|d[m+3>>0]<<24|0)|0;g=y;o=f+8|0;n=o;o=o+4|0;o=ga(d[n>>0]|d[n+1>>0]<<8|d[n+2>>0]<<16|d[n+3>>0]<<24|0,d[o>>0]|d[o+1>>0]<<8|d[o+2>>0]<<16|d[o+3>>0]<<24|0)|0;n=y;q=f+16|0;p=q;q=q+4|0;q=ga(d[p>>0]|d[p+1>>0]<<8|d[p+2>>0]<<16|d[p+3>>0]<<24|0,d[q>>0]|d[q+1>>0]<<8|d[q+2>>0]<<16|d[q+3>>0]<<24|0)|0;p=y;i=f+24|0;f=i;i=i+4|0;i=ga(d[f>>0]|d[f+1>>0]<<8|d[f+2>>0]<<16|d[f+3>>0]<<24|0,d[i>>0]|d[i+1>>0]<<8|d[i+2>>0]<<16|d[i+3>>0]<<24|0)|0;c[h>>2]=i;c[h+4>>2]=y;i=h+8|0;c[i>>2]=q;c[i+4>>2]=p;i=h+16|0;c[i>>2]=o;c[i+4>>2]=n;i=h+24|0;c[i>>2]=m;c[i+4>>2]=g;Mc(h,40,8,-268435457,-1025378925);c[j>>2]=c[h>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[j+28>>2]=c[h+28>>2];h=k+64+6|0;i=h;f=j;g=i+32|0;do{b[i>>1]=b[f>>1]|0;i=i+2|0;f=f+2|0;}while((i|0)<(g|0));i=e+8|0;f=h;g=i+32|0;do{b[i>>1]=b[f>>1]|0;i=i+2|0;f=f+2|0;}while((i|0)<(g|0));q=0;a[e>>0]=q;l=k;return}else {a[e+1>>0]=0;q=1;a[e>>0]=q;l=k;return}}function ac(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;c[a+16>>2]=0;c[a+20>>2]=0;c[a+24>>2]=0;c[a+28>>2]=0;return}function bc(a){a=a|0;var b=0;b=a;if((((c[b>>2]|0)==0&(c[b+4>>2]|0)==0?(b=a+8|0,(c[b>>2]|0)==0&(c[b+4>>2]|0)==0):0)?(b=a+16|0,(c[b>>2]|0)==0&(c[b+4>>2]|0)==0):0)?(b=a+24|0,(c[b>>2]|0)==0&(c[b+4>>2]|0)==0):0){b=1;return b|0}b=0;return b|0}function cc(e,f,g){e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0;k=l;l=l+112|0;i=k+32|0;h=k;j=k+64|0;do if((g|0)==32){n=f;m=n;n=n+4|0;n=ga(d[m>>0]|d[m+1>>0]<<8|d[m+2>>0]<<16|d[m+3>>0]<<24|0,d[n>>0]|d[n+1>>0]<<8|d[n+2>>0]<<16|d[n+3>>0]<<24|0)|0;m=y;p=f+8|0;o=p;p=p+4|0;p=ga(d[o>>0]|d[o+1>>0]<<8|d[o+2>>0]<<16|d[o+3>>0]<<24|0,d[p>>0]|d[p+1>>0]<<8|d[p+2>>0]<<16|d[p+3>>0]<<24|0)|0;o=y;r=f+16|0;q=r;r=r+4|0;r=ga(d[q>>0]|d[q+1>>0]<<8|d[q+2>>0]<<16|d[q+3>>0]<<24|0,d[r>>0]|d[r+1>>0]<<8|d[r+2>>0]<<16|d[r+3>>0]<<24|0)|0;q=y;g=f+24|0;f=g;g=g+4|0;g=ga(d[f>>0]|d[f+1>>0]<<8|d[f+2>>0]<<16|d[f+3>>0]<<24|0,d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24|0)|0;c[i>>2]=g;c[i+4>>2]=y;g=i+8|0;c[g>>2]=r;c[g+4>>2]=q;g=i+16|0;c[g>>2]=p;c[g+4>>2]=o;g=i+24|0;c[g>>2]=n;c[g+4>>2]=m;if(!(Qc(i,136)|0)){h=1;break}Mc(i,72,136,-460954743,-2016278654);c[h>>2]=c[i>>2];c[h+4>>2]=c[i+4>>2];c[h+8>>2]=c[i+8>>2];c[h+12>>2]=c[i+12>>2];c[h+16>>2]=c[i+16>>2];c[h+20>>2]=c[i+20>>2];c[h+24>>2]=c[i+24>>2];c[h+28>>2]=c[i+28>>2];g=j+6|0;i=g;f=i+32|0;do{b[i>>1]=b[h>>1]|0;i=i+2|0;h=h+2|0;}while((i|0)<(f|0));i=e+8|0;h=g;f=i+32|0;do{b[i>>1]=b[h>>1]|0;i=i+2|0;h=h+2|0;}while((i|0)<(f|0));r=0;a[e>>0]=r;l=k;return}else h=0;while(0);a[e+1>>0]=h;r=1;a[e>>0]=r;l=k;return}function dc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;g=l;l=l+96|0;h=g+64|0;i=g+32|0;f=g;c[i>>2]=c[b>>2];c[i+4>>2]=c[b+4>>2];c[i+8>>2]=c[b+8>>2];c[i+12>>2]=c[b+12>>2];c[i+16>>2]=c[b+16>>2];c[i+20>>2]=c[b+20>>2];c[i+24>>2]=c[b+24>>2];c[i+28>>2]=c[b+28>>2];b=h;c[b>>2]=1;c[b+4>>2]=0;b=h+8|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;Mc(i,h,136,-460954743,-2016278654);c[f>>2]=c[i>>2];c[f+4>>2]=c[i+4>>2];c[f+8>>2]=c[i+8>>2];c[f+12>>2]=c[i+12>>2];c[f+16>>2]=c[i+16>>2];c[f+20>>2]=c[i+20>>2];c[f+24>>2]=c[i+24>>2];c[f+28>>2]=c[i+28>>2];b=i;c[b>>2]=-980480611;c[b+4>>2]=-748862579;b=i+8|0;c[b>>2]=-171504835;c[b+4>>2]=175696680;b=i+16|0;c[b>>2]=2021213740;c[b+4>>2]=1718526831;b=i+24|0;c[b>>2]=-1710760145;c[b+4>>2]=235567041;b=h;c[b>>2]=-662897337;c[b+4>>2]=1008765974;b=h+8|0;c[b>>2]=1752287885;c[b+4>>2]=-1753126255;b=h+16|0;c[b>>2]=-2122229667;c[b+4>>2]=-1202698826;b=h+24|0;c[b>>2]=-516841431;c[b+4>>2]=811880050;Mc(f,i,h,-460954743,-2016278654);if((e|0)!=32){i=0;l=g;return i|0}e=f+24|0;e=ga(c[e>>2]|0,c[e+4>>2]|0)|0;h=y;i=d;b=i;a[b>>0]=e;a[b+1>>0]=e>>8;a[b+2>>0]=e>>16;a[b+3>>0]=e>>24;i=i+4|0;a[i>>0]=h;a[i+1>>0]=h>>8;a[i+2>>0]=h>>16;a[i+3>>0]=h>>24;i=f+16|0;i=ga(c[i>>2]|0,c[i+4>>2]|0)|0;h=y;b=d+8|0;e=b;a[e>>0]=i;a[e+1>>0]=i>>8;a[e+2>>0]=i>>16;a[e+3>>0]=i>>24;b=b+4|0;a[b>>0]=h;a[b+1>>0]=h>>8;a[b+2>>0]=h>>16;a[b+3>>0]=h>>24;b=f+8|0;b=ga(c[b>>2]|0,c[b+4>>2]|0)|0;h=y;e=d+16|0;i=e;a[i>>0]=b;a[i+1>>0]=b>>8;a[i+2>>0]=b>>16;a[i+3>>0]=b>>24;e=e+4|0;a[e>>0]=h;a[e+1>>0]=h>>8;a[e+2>>0]=h>>16;a[e+3>>0]=h>>24;e=f;e=ga(c[e>>2]|0,c[e+4>>2]|0)|0;h=y;i=d+24|0;f=i;a[f>>0]=e;a[f+1>>0]=e>>8;a[f+2>>0]=e>>16;a[f+3>>0]=e>>24;i=i+4|0;a[i>>0]=h;a[i+1>>0]=h>>8;a[i+2>>0]=h>>16;a[i+3>>0]=h>>24;i=2;l=g;return i|0}function ec(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=l;l=l+64|0;f=e;c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];c[f+8>>2]=c[b+8>>2];c[f+12>>2]=c[b+12>>2];c[f+16>>2]=c[b+16>>2];c[f+20>>2]=c[b+20>>2];c[f+24>>2]=c[b+24>>2];c[f+28>>2]=c[b+28>>2];b=f+32|0;c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[b+28>>2]=c[d+28>>2];b=f;d=a+64|0;do{c[a>>2]=c[b>>2];a=a+4|0;b=b+4|0;}while((a|0)<(d|0));l=e;return}function fc(a){a=a|0;var b=0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;c[a+16>>2]=0;c[a+20>>2]=0;c[a+24>>2]=0;c[a+28>>2]=0;b=a+32|0;c[b>>2]=-980480611;c[b+4>>2]=-748862579;b=a+40|0;c[b>>2]=-171504835;c[b+4>>2]=175696680;b=a+48|0;c[b>>2]=2021213740;c[b+4>>2]=1718526831;b=a+56|0;c[b>>2]=-1710760145;c[b+4>>2]=235567041;a=a+64|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;c[a+16>>2]=0;c[a+20>>2]=0;c[a+24>>2]=0;c[a+28>>2]=0;return}function gc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+288|0;f=j+192|0;g=j+96|0;h=j;i=g;e=i+96|0;do{c[i>>2]=c[b>>2];i=i+4|0;b=b+4|0;}while((i|0)<(e|0));i=f;b=d;e=i+96|0;do{c[i>>2]=c[b>>2];i=i+4|0;b=b+4|0;}while((i|0)<(e|0));Dc(h,g,f);i=a;b=h;e=i+96|0;do{c[i>>2]=c[b>>2];i=i+4|0;b=b+4|0;}while((i|0)<(e|0));l=j;return}function hc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+224|0;f=j+192|0;g=j+96|0;h=j;i=g;e=i+96|0;do{c[i>>2]=c[b>>2];i=i+4|0;b=b+4|0;}while((i|0)<(e|0));c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[f+16>>2]=c[d+16>>2];c[f+20>>2]=c[d+20>>2];c[f+24>>2]=c[d+24>>2];c[f+28>>2]=c[d+28>>2];Cc(h,g,f);i=a;b=h;e=i+96|0;do{c[i>>2]=c[b>>2];i=i+4|0;b=b+4|0;}while((i|0)<(e|0));l=j;return}function ic(d,e,f){d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0;k=l;l=l+208|0;g=k+104|0;i=k+72|0;h=k;j=k+136|0;c[i>>2]=c[e>>2];c[i+4>>2]=c[e+4>>2];c[i+8>>2]=c[e+8>>2];c[i+12>>2]=c[e+12>>2];c[i+16>>2]=c[e+16>>2];c[i+20>>2]=c[e+20>>2];c[i+24>>2]=c[e+24>>2];c[i+28>>2]=c[e+28>>2];c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];c[g+28>>2]=c[f+28>>2];uc(h,i,g);e=a[h>>0]|0;f=a[h+1>>0]|0;g=j;h=h+2|0;i=g+70|0;do{b[g>>1]=b[h>>1]|0;g=g+2|0;h=h+2|0;}while((g|0)<(i|0));if(e<<24>>24==1){a[d+1>>0]=f<<24>>24!=0&1;j=1;a[d>>0]=j;l=k;return}else {g=d+8|0;h=j+6|0;i=g+64|0;do{b[g>>1]=b[h>>1]|0;g=g+2|0;h=h+2|0;}while((g|0)<(i|0));j=0;a[d>>0]=j;l=k;return}}function jc(a,b){a=a|0;b=b|0;c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[a+28>>2]=c[b+28>>2];return}function kc(a,b){a=a|0;b=b|0;b=b+32|0;c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[a+28>>2]=c[b+28>>2];return}function lc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=l;l=l+80|0;d=f;Ac(d,b);e=d;if((c[e>>2]|0)==1&(c[e+4>>2]|0)==0){e=a+8|0;b=d+8|0;d=e+64|0;do{c[e>>2]=c[b>>2];e=e+4|0;b=b+4|0;}while((e|0)<(d|0));b=1;d=0;}else {b=0;d=0;}c[a>>2]=b;c[a+4>>2]=d;l=f;return}function mc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=l;l=l+64|0;d=f;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];c[d+16>>2]=c[b+16>>2];c[d+20>>2]=c[b+20>>2];c[d+24>>2]=c[b+24>>2];c[d+28>>2]=c[b+28>>2];e=b+32|0;b=d+32|0;c[b>>2]=c[e>>2];c[b+4>>2]=c[e+4>>2];c[b+8>>2]=c[e+8>>2];c[b+12>>2]=c[e+12>>2];c[b+16>>2]=c[e+16>>2];c[b+20>>2]=c[e+20>>2];c[b+24>>2]=c[e+24>>2];c[b+28>>2]=c[e+28>>2];b=a;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));e=a+64|0;c[e>>2]=-980480611;c[e+4>>2]=-748862579;e=a+72|0;c[e>>2]=-171504835;c[e+4>>2]=175696680;e=a+80|0;c[e>>2]=2021213740;c[e+4>>2]=1718526831;a=a+88|0;c[a>>2]=-1710760145;c[a+4>>2]=235567041;l=f;return}function nc(a){a=a|0;var b=0,d=0;b=a;d=b+64|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));b=a+64|0;c[b>>2]=-980480611;c[b+4>>2]=-748862579;b=a+72|0;c[b>>2]=-171504835;c[b+4>>2]=175696680;b=a+80|0;c[b>>2]=2021213740;c[b+4>>2]=1718526831;b=a+88|0;c[b>>2]=-1710760145;c[b+4>>2]=235567041;b=a+96|0;d=b+96|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));return}function oc(a){a=a|0;var b=0;b=a;c[b>>2]=-980480611;c[b+4>>2]=-748862579;b=a+8|0;c[b>>2]=-171504835;c[b+4>>2]=175696680;b=a+16|0;c[b>>2]=2021213740;c[b+4>>2]=1718526831;b=a+24|0;c[b>>2]=-1710760145;c[b+4>>2]=235567041;hk(a+32|0,0,352)|0;return}function pc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;d=l;l=l+1152|0;f=d+768|0;g=d+384|0;e=d;ok(g|0,b|0,384)|0;ok(f|0,c|0,384)|0;Tc(e,g,f);ok(a|0,e|0,384)|0;l=d;return}function qc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=l;l=l+384|0;e=d;Ec(e,b,c);ok(a|0,e|0,384)|0;l=d;return}function rc(d,e,f){d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,n=0;n=l;l=l+400|0;h=n+200|0;i=n+136|0;k=n;m=n+264|0;j=i;g=j+64|0;do{c[j>>2]=c[e>>2];j=j+4|0;e=e+4|0;}while((j|0)<(g|0));j=h;e=f;g=j+64|0;do{c[j>>2]=c[e>>2];j=j+4|0;e=e+4|0;}while((j|0)<(g|0));vc(k,i,h);j=a[k>>0]|0;e=a[k+1>>0]|0;ok(m|0,k+2|0,134)|0;if(j<<24>>24==1){a[d+1>>0]=e<<24>>24!=0&1;m=1;a[d>>0]=m;l=n;return}else {j=d+8|0;e=m+6|0;g=j+128|0;do{b[j>>1]=b[e>>1]|0;j=j+2|0;e=e+2|0;}while((j|0)<(g|0));m=0;a[d>>0]=m;l=n;return}}function sc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;f=l;l=l+128|0;d=f;e=d;g=b;h=e+64|0;do{c[e>>2]=c[g>>2];e=e+4|0;g=g+4|0;}while((e|0)<(h|0));e=d+64|0;g=b+64|0;h=e+64|0;do{c[e>>2]=c[g>>2];e=e+4|0;g=g+4|0;}while((e|0)<(h|0));e=a;g=d;h=e+128|0;do{c[e>>2]=c[g>>2];e=e+4|0;g=g+4|0;}while((e|0)<(h|0));h=a+128|0;c[h>>2]=-980480611;c[h+4>>2]=-748862579;h=a+136|0;c[h>>2]=-171504835;c[h+4>>2]=175696680;h=a+144|0;c[h>>2]=2021213740;c[h+4>>2]=1718526831;h=a+152|0;c[h>>2]=-1710760145;c[h+4>>2]=235567041;h=a+160|0;c[h>>2]=0;c[h+4>>2]=0;c[h+8>>2]=0;c[h+12>>2]=0;c[h+16>>2]=0;c[h+20>>2]=0;c[h+24>>2]=0;c[h+28>>2]=0;l=f;return}function tc(b,c){b=b|0;c=c|0;var d=0,e=0;e=l;l=l+16|0;d=e;if((a[b>>0]|0)==1){vi(d,c,6248,9);d=Ti(d)|0;l=e;return d|0}else {vi(d,c,6230,18);d=Ti(d)|0;l=e;return d|0}return 0}function uc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0;h=l;l=l+224|0;f=h+160|0;m=h+128|0;k=h+96|0;j=h+64|0;g=h+32|0;i=h;c[m>>2]=c[e>>2];c[m+4>>2]=c[e+4>>2];c[m+8>>2]=c[e+8>>2];c[m+12>>2]=c[e+12>>2];c[m+16>>2]=c[e+16>>2];c[m+20>>2]=c[e+20>>2];c[m+24>>2]=c[e+24>>2];c[m+28>>2]=c[e+28>>2];c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];Mc(m,f,136,-460954743,-2016278654);c[i>>2]=c[m>>2];c[i+4>>2]=c[m+4>>2];c[i+8>>2]=c[m+8>>2];c[i+12>>2]=c[m+12>>2];c[i+16>>2]=c[m+16>>2];c[i+20>>2]=c[m+20>>2];c[i+24>>2]=c[m+24>>2];c[i+28>>2]=c[m+28>>2];c[m>>2]=c[d>>2];c[m+4>>2]=c[d+4>>2];c[m+8>>2]=c[d+8>>2];c[m+12>>2]=c[d+12>>2];c[m+16>>2]=c[d+16>>2];c[m+20>>2]=c[d+20>>2];c[m+24>>2]=c[d+24>>2];c[m+28>>2]=c[d+28>>2];c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[f+16>>2]=c[d+16>>2];c[f+20>>2]=c[d+20>>2];c[f+24>>2]=c[d+24>>2];c[f+28>>2]=c[d+28>>2];Mc(m,f,136,-460954743,-2016278654);c[k>>2]=c[m>>2];c[k+4>>2]=c[m+4>>2];c[k+8>>2]=c[m+8>>2];c[k+12>>2]=c[m+12>>2];c[k+16>>2]=c[m+16>>2];c[k+20>>2]=c[m+20>>2];c[k+24>>2]=c[m+24>>2];c[k+28>>2]=c[m+28>>2];c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[f+16>>2]=c[d+16>>2];c[f+20>>2]=c[d+20>>2];c[f+24>>2]=c[d+24>>2];c[f+28>>2]=c[d+28>>2];Mc(k,f,136,-460954743,-2016278654);c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];c[j+16>>2]=c[k+16>>2];c[j+20>>2]=c[k+20>>2];c[j+24>>2]=c[k+24>>2];c[j+28>>2]=c[k+28>>2];k=f;c[k>>2]=1353525463;c[k+4>>2]=2048379561;k=f+8|0;c[k>>2]=-514514503;c[k+4>>2]=527090042;k=f+16|0;c[k>>2]=1768673924;c[k+4>>2]=860613198;k=f+24|0;c[k>>2]=-837313138;c[k+4>>2]=706701124;Kc(j,f,136);c[g>>2]=c[j>>2];c[g+4>>2]=c[j+4>>2];c[g+8>>2]=c[j+8>>2];c[g+12>>2]=c[j+12>>2];c[g+16>>2]=c[j+16>>2];c[g+20>>2]=c[j+20>>2];c[g+24>>2]=c[j+24>>2];c[g+28>>2]=c[j+28>>2];if(!(Xj(i,g,32)|0)){c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[f+16>>2]=c[d+16>>2];c[f+20>>2]=c[d+20>>2];c[f+24>>2]=c[d+24>>2];c[f+28>>2]=c[d+28>>2];g=f+32|0;c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[g+16>>2]=c[e+16>>2];c[g+20>>2]=c[e+20>>2];c[g+24>>2]=c[e+24>>2];c[g+28>>2]=c[e+28>>2];g=b+8|0;d=f;e=g+64|0;do{c[g>>2]=c[d>>2];g=g+4|0;d=d+4|0;}while((g|0)<(e|0));m=0;a[b>>0]=m;l=h;return}else {a[b+1>>0]=0;m=1;a[b>>0]=m;l=h;return}}function vc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0;n=l;l=l+960|0;f=n+768|0;g=n+704|0;h=n+512|0;i=n+320|0;j=n+128|0;k=n;dd(k,e);dd(g,d);m=f;o=d;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));cd(i,g,f);c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];c[g+8>>2]=c[i+8>>2];c[g+12>>2]=c[i+12>>2];c[g+16>>2]=c[i+16>>2];c[g+20>>2]=c[i+20>>2];c[g+24>>2]=c[i+24>>2];c[g+28>>2]=c[i+28>>2];p=f;c[p>>2]=2008548008;c[p+4>>2]=1006188771;p=f+8|0;c[p>>2]=909333341;c[p+4>>2]=34282279;p=f+16|0;c[p>>2]=1232425568;c[p+4>>2]=649588208;p=f+24|0;c[p>>2]=1132767341;c[p+4>>2]=622118450;Kc(g,f,136);c[j>>2]=c[g>>2];c[j+4>>2]=c[g+4>>2];c[j+8>>2]=c[g+8>>2];c[j+12>>2]=c[g+12>>2];c[j+16>>2]=c[g+16>>2];c[j+20>>2]=c[g+20>>2];c[j+24>>2]=c[g+24>>2];c[j+28>>2]=c[g+28>>2];p=i+32|0;c[g>>2]=c[p>>2];c[g+4>>2]=c[p+4>>2];c[g+8>>2]=c[p+8>>2];c[g+12>>2]=c[p+12>>2];c[g+16>>2]=c[p+16>>2];c[g+20>>2]=c[p+20>>2];c[g+24>>2]=c[p+24>>2];c[g+28>>2]=c[p+28>>2];p=f;c[p>>2]=-774045849;c[p+4>>2]=954723532;p=f+8|0;c[p>>2]=-1815212738;c[p+4>>2]=1710273405;p=f+16|0;c[p>>2]=581697706;c[p+4>>2]=-683028259;p=f+24|0;c[p>>2]=1248365901;c[p+4>>2]=21084622;Kc(g,f,136);c[h>>2]=c[g>>2];c[h+4>>2]=c[g+4>>2];c[h+8>>2]=c[g+8>>2];c[h+12>>2]=c[g+12>>2];c[h+16>>2]=c[g+16>>2];c[h+20>>2]=c[g+20>>2];c[h+24>>2]=c[g+24>>2];c[h+28>>2]=c[g+28>>2];p=j+32|0;c[p>>2]=c[h>>2];c[p+4>>2]=c[h+4>>2];c[p+8>>2]=c[h+8>>2];c[p+12>>2]=c[h+12>>2];c[p+16>>2]=c[h+16>>2];c[p+20>>2]=c[h+20>>2];c[p+24>>2]=c[h+24>>2];c[p+28>>2]=c[h+28>>2];if((Xj(k,j,32)|0)==0?(Xj(k+32|0,j+32|0,32)|0)==0:0){m=k;o=d;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=k+64|0;o=e;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=h;o=k;p=m+128|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=h+128|0;c[m>>2]=-980480611;c[m+4>>2]=-748862579;m=h+136|0;c[m>>2]=-171504835;c[m+4>>2]=175696680;m=h+144|0;c[m>>2]=2021213740;c[m+4>>2]=1718526831;m=h+152|0;c[m>>2]=-1710760145;c[m+4>>2]=235567041;m=h+160|0;c[m>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;c[m+16>>2]=0;c[m+20>>2]=0;c[m+24>>2]=0;c[m+28>>2]=0;m=f;c[m>>2]=1342177275;c[m+4>>2]=-1399442404;m=f+8|0;c[m>>2]=-1621045975;c[m+4>>2]=922515093;m=f+16|0;c[m>>2]=2021213742;c[m+4>>2]=1718526831;m=f+24|0;c[m>>2]=-1710760145;c[m+4>>2]=235567041;Nc(f,8);c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];c[g+28>>2]=c[f+28>>2];wc(i,h,g);m=f;o=k;p=m+128|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));p=f+128|0;c[p>>2]=-980480611;c[p+4>>2]=-748862579;p=f+136|0;c[p>>2]=-171504835;c[p+4>>2]=175696680;p=f+144|0;c[p>>2]=2021213740;c[p+4>>2]=1718526831;p=f+152|0;c[p>>2]=-1710760145;c[p+4>>2]=235567041;p=f+160|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p+16>>2]=0;c[p+20>>2]=0;c[p+24>>2]=0;c[p+28>>2]=0;xc(j,i,f);p=j+128|0;do if((c[p>>2]|0)==0&(c[p+4>>2]|0)==0){p=j+136|0;if(!((c[p>>2]|0)==0&(c[p+4>>2]|0)==0))break;p=j+144|0;if(!((c[p>>2]|0)==0&(c[p+4>>2]|0)==0))break;p=j+152|0;if(!((c[p>>2]|0)==0&(c[p+4>>2]|0)==0))break;p=j+160|0;if(!((c[p>>2]|0)==0&(c[p+4>>2]|0)==0))break;p=j+168|0;if(!((c[p>>2]|0)==0&(c[p+4>>2]|0)==0))break;p=j+176|0;if(!((c[p>>2]|0)==0&(c[p+4>>2]|0)==0))break;p=j+184|0;if((c[p>>2]|0)==0&(c[p+4>>2]|0)==0){m=f;o=d;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=f+64|0;o=e;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));a[b>>0]=0;m=b+8|0;o=f;p=m+128|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));l=n;return}}while(0);a[b>>0]=1;a[b+1>>0]=1;l=n;return}a[b>>0]=1;a[b+1>>0]=0;l=n;return}function wc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0;n=l;l=l+800|0;h=n+608|0;i=n+416|0;j=n+224|0;k=n+192|0;m=n;f=m;g=f+64|0;do{c[f>>2]=0;f=f+4|0;}while((f|0)<(g|0));f=m+64|0;c[f>>2]=-980480611;c[f+4>>2]=-748862579;f=m+72|0;c[f>>2]=-171504835;c[f+4>>2]=175696680;f=m+80|0;c[f>>2]=2021213740;c[f+4>>2]=1718526831;f=m+88|0;c[f>>2]=-1710760145;c[f+4>>2]=235567041;f=m+96|0;g=f+96|0;do{c[f>>2]=0;f=f+4|0;}while((f|0)<(g|0));c[i>>2]=c[d>>2];c[i+4>>2]=c[d+4>>2];c[i+8>>2]=c[d+8>>2];c[i+12>>2]=c[d+12>>2];c[i+16>>2]=c[d+16>>2];c[i+20>>2]=c[d+20>>2];c[i+24>>2]=c[d+24>>2];c[i+28>>2]=c[d+28>>2];d=h;c[d>>2]=1;c[d+4>>2]=0;d=h+8|0;c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;Mc(i,h,8,-268435457,-1025378925);c[k>>2]=c[i>>2];c[k+4>>2]=c[i+4>>2];c[k+8>>2]=c[i+8>>2];c[k+12>>2]=c[i+12>>2];c[k+16>>2]=c[i+16>>2];c[k+20>>2]=c[i+20>>2];c[k+24>>2]=c[i+24>>2];c[k+28>>2]=c[i+28>>2];d=256;while(1){if(!d){d=7;break}d=d+-1|0;if(d>>>0>255){d=7;break}g=k+(d>>>6<<3)|0;o=c[g>>2]|0;g=c[g+4>>2]|0;f=nk(1,0,d&63|0)|0;if(!((o&f|0)==0&(g&y|0)==0)){e=d;d=9;break}}if((d|0)==7){ok(a|0,m|0,192)|0;l=n;return}else if((d|0)==9){a:while(1){ok(i|0,m|0,192)|0;ok(h|0,b|0,192)|0;xc(j,i,h);ok(m|0,j|0,192)|0;while(1){if(!e){d=7;break a}e=e+-1|0;if(e>>>0>255){d=7;break a}o=k+(e>>>6<<3)|0;f=c[o>>2]|0;o=c[o+4>>2]|0;g=nk(1,0,e&63|0)|0;o=(f&g|0)==0&(o&y|0)==0;yc(h,m);ok(m|0,h|0,192)|0;if(!o)continue a}}if((d|0)==7){ok(a|0,m|0,192)|0;l=n;return}}}function xc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;J=l;l=l+1696|0;E=J+1632|0;F=J+1568|0;G=J+1536|0;H=J+1472|0;v=J+1408|0;w=J+1344|0;x=J+1280|0;y=J+1216|0;z=J+1152|0;A=J+1088|0;B=J+1024|0;p=J+960|0;q=J+896|0;r=J+832|0;s=J+768|0;e=J+704|0;f=J+640|0;g=J+576|0;C=J+512|0;h=J+448|0;i=J+384|0;j=J+320|0;k=J+256|0;m=J+192|0;n=J+128|0;D=J+64|0;t=J;u=b+128|0;L=u;if((((((((c[L>>2]|0)==0&(c[L+4>>2]|0)==0?(L=b+136|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=b+144|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=b+152|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=b+160|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=b+168|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=b+176|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=b+184|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0){ok(a|0,d|0,192)|0;l=J;return}o=d+128|0;L=o;if((((((((c[L>>2]|0)==0&(c[L+4>>2]|0)==0?(L=d+136|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=d+144|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=d+152|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=d+160|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=d+168|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=d+176|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0)?(L=d+184|0,(c[L>>2]|0)==0&(c[L+4>>2]|0)==0):0){ok(a|0,b|0,192)|0;l=J;return}dd(t,u);dd(D,o);I=F;K=b;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=D;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(n,F,E);I=F;K=d;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=t;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(m,F,E);I=F;K=u;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=t;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(k,F,E);I=F;K=o;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=D;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(j,F,E);I=F;K=b+64|0;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=j;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(i,F,E);I=F;K=d+64|0;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=k;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(h,F,E);if((((Xj(n,m,32)|0)==0?(Xj(n+32|0,m+32|0,32)|0)==0:0)?(Xj(i,h,32)|0)==0:0)?(Xj(i+32|0,h+32|0,32)|0)==0:0)yc(a,b);else {I=v;K=m;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=n;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[m>>2];c[F+4>>2]=c[m+4>>2];c[F+8>>2]=c[m+8>>2];c[F+12>>2]=c[m+12>>2];c[F+16>>2]=c[m+16>>2];c[F+20>>2]=c[m+20>>2];c[F+24>>2]=c[m+24>>2];c[F+28>>2]=c[m+28>>2];c[E>>2]=c[n>>2];c[E+4>>2]=c[n+4>>2];c[E+8>>2]=c[n+8>>2];c[E+12>>2]=c[n+12>>2];c[E+16>>2]=c[n+16>>2];c[E+20>>2]=c[n+20>>2];c[E+24>>2]=c[n+24>>2];c[E+28>>2]=c[n+28>>2];Lc(F,E,136);c[C>>2]=c[F>>2];c[C+4>>2]=c[F+4>>2];c[C+8>>2]=c[F+8>>2];c[C+12>>2]=c[F+12>>2];c[C+16>>2]=c[F+16>>2];c[C+20>>2]=c[F+20>>2];c[C+24>>2]=c[F+24>>2];c[C+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=C+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];I=v;K=h;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=i;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[h>>2];c[F+4>>2]=c[h+4>>2];c[F+8>>2]=c[h+8>>2];c[F+12>>2]=c[h+12>>2];c[F+16>>2]=c[h+16>>2];c[F+20>>2]=c[h+20>>2];c[F+24>>2]=c[h+24>>2];c[F+28>>2]=c[h+28>>2];c[E>>2]=c[i>>2];c[E+4>>2]=c[i+4>>2];c[E+8>>2]=c[i+8>>2];c[E+12>>2]=c[i+12>>2];c[E+16>>2]=c[i+16>>2];c[E+20>>2]=c[i+20>>2];c[E+24>>2]=c[i+24>>2];c[E+28>>2]=c[i+28>>2];Lc(F,E,136);c[g>>2]=c[F>>2];c[g+4>>2]=c[F+4>>2];c[g+8>>2]=c[F+8>>2];c[g+12>>2]=c[F+12>>2];c[g+16>>2]=c[F+16>>2];c[g+20>>2]=c[F+20>>2];c[g+24>>2]=c[F+24>>2];c[g+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=g+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];I=v;K=C;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=C;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[v>>2];c[F+4>>2]=c[v+4>>2];c[F+8>>2]=c[v+8>>2];c[F+12>>2]=c[v+12>>2];c[F+16>>2]=c[v+16>>2];c[F+20>>2]=c[v+20>>2];c[F+24>>2]=c[v+24>>2];c[F+28>>2]=c[v+28>>2];c[E>>2]=c[C>>2];c[E+4>>2]=c[C+4>>2];c[E+8>>2]=c[C+8>>2];c[E+12>>2]=c[C+12>>2];c[E+16>>2]=c[C+16>>2];c[E+20>>2]=c[C+20>>2];c[E+24>>2]=c[C+24>>2];c[E+28>>2]=c[C+28>>2];Kc(F,E,136);c[w>>2]=c[F>>2];c[w+4>>2]=c[F+4>>2];c[w+8>>2]=c[F+8>>2];c[w+12>>2]=c[F+12>>2];c[w+16>>2]=c[F+16>>2];c[w+20>>2]=c[F+20>>2];c[w+24>>2]=c[F+24>>2];c[w+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Kc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=w+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];dd(f,w);I=F;K=C;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=f;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(e,F,E);I=v;K=g;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=g;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[v>>2];c[F+4>>2]=c[v+4>>2];c[F+8>>2]=c[v+8>>2];c[F+12>>2]=c[v+12>>2];c[F+16>>2]=c[v+16>>2];c[F+20>>2]=c[v+20>>2];c[F+24>>2]=c[v+24>>2];c[F+28>>2]=c[v+28>>2];c[E>>2]=c[g>>2];c[E+4>>2]=c[g+4>>2];c[E+8>>2]=c[g+8>>2];c[E+12>>2]=c[g+12>>2];c[E+16>>2]=c[g+16>>2];c[E+20>>2]=c[g+20>>2];c[E+24>>2]=c[g+24>>2];c[E+28>>2]=c[g+28>>2];Kc(F,E,136);c[s>>2]=c[F>>2];c[s+4>>2]=c[F+4>>2];c[s+8>>2]=c[F+8>>2];c[s+12>>2]=c[F+12>>2];c[s+16>>2]=c[F+16>>2];c[s+20>>2]=c[F+20>>2];c[s+24>>2]=c[F+24>>2];c[s+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Kc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=s+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];I=F;K=n;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=f;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(r,F,E);I=F;K=i;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=E;K=e;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(q,F,E);dd(v,s);I=H;K=e;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[v>>2];c[F+4>>2]=c[v+4>>2];c[F+8>>2]=c[v+8>>2];c[F+12>>2]=c[v+12>>2];c[F+16>>2]=c[v+16>>2];c[F+20>>2]=c[v+20>>2];c[F+24>>2]=c[v+24>>2];c[F+28>>2]=c[v+28>>2];c[E>>2]=c[e>>2];c[E+4>>2]=c[e+4>>2];c[E+8>>2]=c[e+8>>2];c[E+12>>2]=c[e+12>>2];c[E+16>>2]=c[e+16>>2];c[E+20>>2]=c[e+20>>2];c[E+24>>2]=c[e+24>>2];c[E+28>>2]=c[e+28>>2];Lc(F,E,136);c[x>>2]=c[F>>2];c[x+4>>2]=c[F+4>>2];c[x+8>>2]=c[F+8>>2];c[x+12>>2]=c[F+12>>2];c[x+16>>2]=c[F+16>>2];c[x+20>>2]=c[F+20>>2];c[x+24>>2]=c[F+24>>2];c[x+28>>2]=c[F+28>>2];b=v+32|0;c[F>>2]=c[b>>2];c[F+4>>2]=c[b+4>>2];c[F+8>>2]=c[b+8>>2];c[F+12>>2]=c[b+12>>2];c[F+16>>2]=c[b+16>>2];c[F+20>>2]=c[b+20>>2];c[F+24>>2]=c[b+24>>2];c[F+28>>2]=c[b+28>>2];b=H+32|0;c[E>>2]=c[b>>2];c[E+4>>2]=c[b+4>>2];c[E+8>>2]=c[b+8>>2];c[E+12>>2]=c[b+12>>2];c[E+16>>2]=c[b+16>>2];c[E+20>>2]=c[b+20>>2];c[E+24>>2]=c[b+24>>2];c[E+28>>2]=c[b+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];b=x+32|0;c[b>>2]=c[G>>2];c[b+4>>2]=c[G+4>>2];c[b+8>>2]=c[G+8>>2];c[b+12>>2]=c[G+12>>2];c[b+16>>2]=c[G+16>>2];c[b+20>>2]=c[G+20>>2];c[b+24>>2]=c[G+24>>2];c[b+28>>2]=c[G+28>>2];I=v;K=r;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=r;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[v>>2];c[F+4>>2]=c[v+4>>2];c[F+8>>2]=c[v+8>>2];c[F+12>>2]=c[v+12>>2];c[F+16>>2]=c[v+16>>2];c[F+20>>2]=c[v+20>>2];c[F+24>>2]=c[v+24>>2];c[F+28>>2]=c[v+28>>2];c[E>>2]=c[r>>2];c[E+4>>2]=c[r+4>>2];c[E+8>>2]=c[r+8>>2];c[E+12>>2]=c[r+12>>2];c[E+16>>2]=c[r+16>>2];c[E+20>>2]=c[r+20>>2];c[E+24>>2]=c[r+24>>2];c[E+28>>2]=c[r+28>>2];Kc(F,E,136);c[w>>2]=c[F>>2];c[w+4>>2]=c[F+4>>2];c[w+8>>2]=c[F+8>>2];c[w+12>>2]=c[F+12>>2];c[w+16>>2]=c[F+16>>2];c[w+20>>2]=c[F+20>>2];c[w+24>>2]=c[F+24>>2];c[w+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Kc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=w+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];c[F>>2]=c[x>>2];c[F+4>>2]=c[x+4>>2];c[F+8>>2]=c[x+8>>2];c[F+12>>2]=c[x+12>>2];c[F+16>>2]=c[x+16>>2];c[F+20>>2]=c[x+20>>2];c[F+24>>2]=c[x+24>>2];c[F+28>>2]=c[x+28>>2];c[E>>2]=c[w>>2];c[E+4>>2]=c[w+4>>2];c[E+8>>2]=c[w+8>>2];c[E+12>>2]=c[w+12>>2];c[E+16>>2]=c[w+16>>2];c[E+20>>2]=c[w+20>>2];c[E+24>>2]=c[w+24>>2];c[E+28>>2]=c[w+28>>2];Lc(F,E,136);c[p>>2]=c[F>>2];c[p+4>>2]=c[F+4>>2];c[p+8>>2]=c[F+8>>2];c[p+12>>2]=c[F+12>>2];c[p+16>>2]=c[F+16>>2];c[p+20>>2]=c[F+20>>2];c[p+24>>2]=c[F+24>>2];c[p+28>>2]=c[F+28>>2];c[F>>2]=c[b>>2];c[F+4>>2]=c[b+4>>2];c[F+8>>2]=c[b+8>>2];c[F+12>>2]=c[b+12>>2];c[F+16>>2]=c[b+16>>2];c[F+20>>2]=c[b+20>>2];c[F+24>>2]=c[b+24>>2];c[F+28>>2]=c[b+28>>2];c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=p+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];I=a;K=p;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=x;K=s;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=v;K=r;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=p;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[r>>2];c[F+4>>2]=c[r+4>>2];c[F+8>>2]=c[r+8>>2];c[F+12>>2]=c[r+12>>2];c[F+16>>2]=c[r+16>>2];c[F+20>>2]=c[r+20>>2];c[F+24>>2]=c[r+24>>2];c[F+28>>2]=c[r+28>>2];c[E>>2]=c[p>>2];c[E+4>>2]=c[p+4>>2];c[E+8>>2]=c[p+8>>2];c[E+12>>2]=c[p+12>>2];c[E+16>>2]=c[p+16>>2];c[E+20>>2]=c[p+20>>2];c[E+24>>2]=c[p+24>>2];c[E+28>>2]=c[p+28>>2];Lc(F,E,136);c[w>>2]=c[F>>2];c[w+4>>2]=c[F+4>>2];c[w+8>>2]=c[F+8>>2];c[w+12>>2]=c[F+12>>2];c[w+16>>2]=c[F+16>>2];c[w+20>>2]=c[F+20>>2];c[w+24>>2]=c[F+24>>2];c[w+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=w+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];cd(y,x,w);I=v;K=q;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=q;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[v>>2];c[F+4>>2]=c[v+4>>2];c[F+8>>2]=c[v+8>>2];c[F+12>>2]=c[v+12>>2];c[F+16>>2]=c[v+16>>2];c[F+20>>2]=c[v+20>>2];c[F+24>>2]=c[v+24>>2];c[F+28>>2]=c[v+28>>2];c[E>>2]=c[q>>2];c[E+4>>2]=c[q+4>>2];c[E+8>>2]=c[q+8>>2];c[E+12>>2]=c[q+12>>2];c[E+16>>2]=c[q+16>>2];c[E+20>>2]=c[q+20>>2];c[E+24>>2]=c[q+24>>2];c[E+28>>2]=c[q+28>>2];Kc(F,E,136);c[w>>2]=c[F>>2];c[w+4>>2]=c[F+4>>2];c[w+8>>2]=c[F+8>>2];c[w+12>>2]=c[F+12>>2];c[w+16>>2]=c[F+16>>2];c[w+20>>2]=c[F+20>>2];c[w+24>>2]=c[F+24>>2];c[w+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Kc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=w+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];c[F>>2]=c[y>>2];c[F+4>>2]=c[y+4>>2];c[F+8>>2]=c[y+8>>2];c[F+12>>2]=c[y+12>>2];c[F+16>>2]=c[y+16>>2];c[F+20>>2]=c[y+20>>2];c[F+24>>2]=c[y+24>>2];c[F+28>>2]=c[y+28>>2];c[E>>2]=c[w>>2];c[E+4>>2]=c[w+4>>2];c[E+8>>2]=c[w+8>>2];c[E+12>>2]=c[w+12>>2];c[E+16>>2]=c[w+16>>2];c[E+20>>2]=c[w+20>>2];c[E+24>>2]=c[w+24>>2];c[E+28>>2]=c[w+28>>2];Lc(F,E,136);c[B>>2]=c[F>>2];c[B+4>>2]=c[F+4>>2];c[B+8>>2]=c[F+8>>2];c[B+12>>2]=c[F+12>>2];c[B+16>>2]=c[F+16>>2];c[B+20>>2]=c[F+20>>2];c[B+24>>2]=c[F+24>>2];c[B+28>>2]=c[F+28>>2];K=y+32|0;c[F>>2]=c[K>>2];c[F+4>>2]=c[K+4>>2];c[F+8>>2]=c[K+8>>2];c[F+12>>2]=c[K+12>>2];c[F+16>>2]=c[K+16>>2];c[F+20>>2]=c[K+20>>2];c[F+24>>2]=c[K+24>>2];c[F+28>>2]=c[K+28>>2];c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=B+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];I=v;K=u;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=H;K=o;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[u>>2];c[F+4>>2]=c[u+4>>2];c[F+8>>2]=c[u+8>>2];c[F+12>>2]=c[u+12>>2];c[F+16>>2]=c[u+16>>2];c[F+20>>2]=c[u+20>>2];c[F+24>>2]=c[u+24>>2];c[F+28>>2]=c[u+28>>2];c[E>>2]=c[o>>2];c[E+4>>2]=c[o+4>>2];c[E+8>>2]=c[o+8>>2];c[E+12>>2]=c[o+12>>2];c[E+16>>2]=c[o+16>>2];c[E+20>>2]=c[o+20>>2];c[E+24>>2]=c[o+24>>2];c[E+28>>2]=c[o+28>>2];Kc(F,E,136);c[w>>2]=c[F>>2];c[w+4>>2]=c[F+4>>2];c[w+8>>2]=c[F+8>>2];c[w+12>>2]=c[F+12>>2];c[w+16>>2]=c[F+16>>2];c[w+20>>2]=c[F+20>>2];c[w+24>>2]=c[F+24>>2];c[w+28>>2]=c[F+28>>2];I=v+32|0;c[F>>2]=c[I>>2];c[F+4>>2]=c[I+4>>2];c[F+8>>2]=c[I+8>>2];c[F+12>>2]=c[I+12>>2];c[F+16>>2]=c[I+16>>2];c[F+20>>2]=c[I+20>>2];c[F+24>>2]=c[I+24>>2];c[F+28>>2]=c[I+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Kc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=w+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];dd(x,w);I=H;K=t;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[x>>2];c[F+4>>2]=c[x+4>>2];c[F+8>>2]=c[x+8>>2];c[F+12>>2]=c[x+12>>2];c[F+16>>2]=c[x+16>>2];c[F+20>>2]=c[x+20>>2];c[F+24>>2]=c[x+24>>2];c[F+28>>2]=c[x+28>>2];c[E>>2]=c[t>>2];c[E+4>>2]=c[t+4>>2];c[E+8>>2]=c[t+8>>2];c[E+12>>2]=c[t+12>>2];c[E+16>>2]=c[t+16>>2];c[E+20>>2]=c[t+20>>2];c[E+24>>2]=c[t+24>>2];c[E+28>>2]=c[t+28>>2];Lc(F,E,136);c[y>>2]=c[F>>2];c[y+4>>2]=c[F+4>>2];c[y+8>>2]=c[F+8>>2];c[y+12>>2]=c[F+12>>2];c[y+16>>2]=c[F+16>>2];c[y+20>>2]=c[F+20>>2];c[y+24>>2]=c[F+24>>2];c[y+28>>2]=c[F+28>>2];b=x+32|0;c[F>>2]=c[b>>2];c[F+4>>2]=c[b+4>>2];c[F+8>>2]=c[b+8>>2];c[F+12>>2]=c[b+12>>2];c[F+16>>2]=c[b+16>>2];c[F+20>>2]=c[b+20>>2];c[F+24>>2]=c[b+24>>2];c[F+28>>2]=c[b+28>>2];b=H+32|0;c[E>>2]=c[b>>2];c[E+4>>2]=c[b+4>>2];c[E+8>>2]=c[b+8>>2];c[E+12>>2]=c[b+12>>2];c[E+16>>2]=c[b+16>>2];c[E+20>>2]=c[b+20>>2];c[E+24>>2]=c[b+24>>2];c[E+28>>2]=c[b+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];b=y+32|0;c[b>>2]=c[G>>2];c[b+4>>2]=c[G+4>>2];c[b+8>>2]=c[G+8>>2];c[b+12>>2]=c[G+12>>2];c[b+16>>2]=c[G+16>>2];c[b+20>>2]=c[G+20>>2];c[b+24>>2]=c[G+24>>2];c[b+28>>2]=c[G+28>>2];I=H;K=D;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));c[F>>2]=c[y>>2];c[F+4>>2]=c[y+4>>2];c[F+8>>2]=c[y+8>>2];c[F+12>>2]=c[y+12>>2];c[F+16>>2]=c[y+16>>2];c[F+20>>2]=c[y+20>>2];c[F+24>>2]=c[y+24>>2];c[F+28>>2]=c[y+28>>2];c[E>>2]=c[D>>2];c[E+4>>2]=c[D+4>>2];c[E+8>>2]=c[D+8>>2];c[E+12>>2]=c[D+12>>2];c[E+16>>2]=c[D+16>>2];c[E+20>>2]=c[D+20>>2];c[E+24>>2]=c[D+24>>2];c[E+28>>2]=c[D+28>>2];Lc(F,E,136);c[z>>2]=c[F>>2];c[z+4>>2]=c[F+4>>2];c[z+8>>2]=c[F+8>>2];c[z+12>>2]=c[F+12>>2];c[z+16>>2]=c[F+16>>2];c[z+20>>2]=c[F+20>>2];c[z+24>>2]=c[F+24>>2];c[z+28>>2]=c[F+28>>2];c[F>>2]=c[b>>2];c[F+4>>2]=c[b+4>>2];c[F+8>>2]=c[b+8>>2];c[F+12>>2]=c[b+12>>2];c[F+16>>2]=c[b+16>>2];c[F+20>>2]=c[b+20>>2];c[F+24>>2]=c[b+24>>2];c[F+28>>2]=c[b+28>>2];I=H+32|0;c[E>>2]=c[I>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];c[E+16>>2]=c[I+16>>2];c[E+20>>2]=c[I+20>>2];c[E+24>>2]=c[I+24>>2];c[E+28>>2]=c[I+28>>2];Lc(F,E,136);c[G>>2]=c[F>>2];c[G+4>>2]=c[F+4>>2];c[G+8>>2]=c[F+8>>2];c[G+12>>2]=c[F+12>>2];c[G+16>>2]=c[F+16>>2];c[G+20>>2]=c[F+20>>2];c[G+24>>2]=c[F+24>>2];c[G+28>>2]=c[F+28>>2];I=z+32|0;c[I>>2]=c[G>>2];c[I+4>>2]=c[G+4>>2];c[I+8>>2]=c[G+8>>2];c[I+12>>2]=c[G+12>>2];c[I+16>>2]=c[G+16>>2];c[I+20>>2]=c[G+20>>2];c[I+24>>2]=c[G+24>>2];c[I+28>>2]=c[G+28>>2];I=E;K=C;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));cd(A,z,E);I=a+64|0;K=B;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0));I=a+128|0;K=A;L=I+64|0;do{c[I>>2]=c[K>>2];I=I+4|0;K=K+4|0;}while((I|0)<(L|0))}l=J;return}function yc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;y=l;l=l+1120|0;o=y+1056|0;q=y+992|0;r=y+960|0;s=y+896|0;t=y+832|0;u=y+768|0;v=y+704|0;w=y+640|0;h=y+576|0;i=y+512|0;j=y+448|0;k=y+384|0;e=y+320|0;m=y+256|0;n=y+192|0;f=y+128|0;d=y+64|0;g=y;dd(g,b);p=b+64|0;dd(d,p);dd(f,d);x=t;z=b;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=d;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[b>>2];c[q+4>>2]=c[b+4>>2];c[q+8>>2]=c[b+8>>2];c[q+12>>2]=c[b+12>>2];c[q+16>>2]=c[b+16>>2];c[q+20>>2]=c[b+20>>2];c[q+24>>2]=c[b+24>>2];c[q+28>>2]=c[b+28>>2];c[o>>2]=c[d>>2];c[o+4>>2]=c[d+4>>2];c[o+8>>2]=c[d+8>>2];c[o+12>>2]=c[d+12>>2];c[o+16>>2]=c[d+16>>2];c[o+20>>2]=c[d+20>>2];c[o+24>>2]=c[d+24>>2];c[o+28>>2]=c[d+28>>2];Kc(q,o,136);c[u>>2]=c[q>>2];c[u+4>>2]=c[q+4>>2];c[u+8>>2]=c[q+8>>2];c[u+12>>2]=c[q+12>>2];c[u+16>>2]=c[q+16>>2];c[u+20>>2]=c[q+20>>2];c[u+24>>2]=c[q+24>>2];c[u+28>>2]=c[q+28>>2];x=t+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];x=u+32|0;c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];dd(v,u);x=s;z=g;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[v>>2];c[q+4>>2]=c[v+4>>2];c[q+8>>2]=c[v+8>>2];c[q+12>>2]=c[v+12>>2];c[q+16>>2]=c[v+16>>2];c[q+20>>2]=c[v+20>>2];c[q+24>>2]=c[v+24>>2];c[q+28>>2]=c[v+28>>2];c[o>>2]=c[g>>2];c[o+4>>2]=c[g+4>>2];c[o+8>>2]=c[g+8>>2];c[o+12>>2]=c[g+12>>2];c[o+16>>2]=c[g+16>>2];c[o+20>>2]=c[g+20>>2];c[o+24>>2]=c[g+24>>2];c[o+28>>2]=c[g+28>>2];Lc(q,o,136);c[w>>2]=c[q>>2];c[w+4>>2]=c[q+4>>2];c[w+8>>2]=c[q+8>>2];c[w+12>>2]=c[q+12>>2];c[w+16>>2]=c[q+16>>2];c[w+20>>2]=c[q+20>>2];c[w+24>>2]=c[q+24>>2];c[w+28>>2]=c[q+28>>2];d=v+32|0;c[q>>2]=c[d>>2];c[q+4>>2]=c[d+4>>2];c[q+8>>2]=c[d+8>>2];c[q+12>>2]=c[d+12>>2];c[q+16>>2]=c[d+16>>2];c[q+20>>2]=c[d+20>>2];c[q+24>>2]=c[d+24>>2];c[q+28>>2]=c[d+28>>2];d=s+32|0;c[o>>2]=c[d>>2];c[o+4>>2]=c[d+4>>2];c[o+8>>2]=c[d+8>>2];c[o+12>>2]=c[d+12>>2];c[o+16>>2]=c[d+16>>2];c[o+20>>2]=c[d+20>>2];c[o+24>>2]=c[d+24>>2];c[o+28>>2]=c[d+28>>2];Lc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];d=w+32|0;c[d>>2]=c[r>>2];c[d+4>>2]=c[r+4>>2];c[d+8>>2]=c[r+8>>2];c[d+12>>2]=c[r+12>>2];c[d+16>>2]=c[r+16>>2];c[d+20>>2]=c[r+20>>2];c[d+24>>2]=c[r+24>>2];c[d+28>>2]=c[r+28>>2];x=s;z=f;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[w>>2];c[q+4>>2]=c[w+4>>2];c[q+8>>2]=c[w+8>>2];c[q+12>>2]=c[w+12>>2];c[q+16>>2]=c[w+16>>2];c[q+20>>2]=c[w+20>>2];c[q+24>>2]=c[w+24>>2];c[q+28>>2]=c[w+28>>2];c[o>>2]=c[f>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];c[o+28>>2]=c[f+28>>2];Lc(q,o,136);c[n>>2]=c[q>>2];c[n+4>>2]=c[q+4>>2];c[n+8>>2]=c[q+8>>2];c[n+12>>2]=c[q+12>>2];c[n+16>>2]=c[q+16>>2];c[n+20>>2]=c[q+20>>2];c[n+24>>2]=c[q+24>>2];c[n+28>>2]=c[q+28>>2];c[q>>2]=c[d>>2];c[q+4>>2]=c[d+4>>2];c[q+8>>2]=c[d+8>>2];c[q+12>>2]=c[d+12>>2];c[q+16>>2]=c[d+16>>2];c[q+20>>2]=c[d+20>>2];c[q+24>>2]=c[d+24>>2];c[q+28>>2]=c[d+28>>2];d=s+32|0;c[o>>2]=c[d>>2];c[o+4>>2]=c[d+4>>2];c[o+8>>2]=c[d+8>>2];c[o+12>>2]=c[d+12>>2];c[o+16>>2]=c[d+16>>2];c[o+20>>2]=c[d+20>>2];c[o+24>>2]=c[d+24>>2];c[o+28>>2]=c[d+28>>2];Lc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];d=n+32|0;c[d>>2]=c[r>>2];c[d+4>>2]=c[r+4>>2];c[d+8>>2]=c[r+8>>2];c[d+12>>2]=c[r+12>>2];c[d+16>>2]=c[r+16>>2];c[d+20>>2]=c[r+20>>2];c[d+24>>2]=c[r+24>>2];c[d+28>>2]=c[r+28>>2];x=t;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];c[q+12>>2]=c[t+12>>2];c[q+16>>2]=c[t+16>>2];c[q+20>>2]=c[t+20>>2];c[q+24>>2]=c[t+24>>2];c[q+28>>2]=c[t+28>>2];c[o>>2]=c[n>>2];c[o+4>>2]=c[n+4>>2];c[o+8>>2]=c[n+8>>2];c[o+12>>2]=c[n+12>>2];c[o+16>>2]=c[n+16>>2];c[o+20>>2]=c[n+20>>2];c[o+24>>2]=c[n+24>>2];c[o+28>>2]=c[n+28>>2];Kc(q,o,136);c[n>>2]=c[q>>2];c[n+4>>2]=c[q+4>>2];c[n+8>>2]=c[q+8>>2];c[n+12>>2]=c[q+12>>2];c[n+16>>2]=c[q+16>>2];c[n+20>>2]=c[q+20>>2];c[n+24>>2]=c[q+24>>2];c[n+28>>2]=c[q+28>>2];x=t+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];c[d>>2]=c[r>>2];c[d+4>>2]=c[r+4>>2];c[d+8>>2]=c[r+8>>2];c[d+12>>2]=c[r+12>>2];c[d+16>>2]=c[r+16>>2];c[d+20>>2]=c[r+20>>2];c[d+24>>2]=c[r+24>>2];c[d+28>>2]=c[r+28>>2];x=t;z=g;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=g;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];c[q+12>>2]=c[t+12>>2];c[q+16>>2]=c[t+16>>2];c[q+20>>2]=c[t+20>>2];c[q+24>>2]=c[t+24>>2];c[q+28>>2]=c[t+28>>2];c[o>>2]=c[g>>2];c[o+4>>2]=c[g+4>>2];c[o+8>>2]=c[g+8>>2];c[o+12>>2]=c[g+12>>2];c[o+16>>2]=c[g+16>>2];c[o+20>>2]=c[g+20>>2];c[o+24>>2]=c[g+24>>2];c[o+28>>2]=c[g+28>>2];Kc(q,o,136);c[u>>2]=c[q>>2];c[u+4>>2]=c[q+4>>2];c[u+8>>2]=c[q+8>>2];c[u+12>>2]=c[q+12>>2];c[u+16>>2]=c[q+16>>2];c[u+20>>2]=c[q+20>>2];c[u+24>>2]=c[q+24>>2];c[u+28>>2]=c[q+28>>2];d=t+32|0;c[q>>2]=c[d>>2];c[q+4>>2]=c[d+4>>2];c[q+8>>2]=c[d+8>>2];c[q+12>>2]=c[d+12>>2];c[q+16>>2]=c[d+16>>2];c[q+20>>2]=c[d+20>>2];c[q+24>>2]=c[d+24>>2];c[q+28>>2]=c[d+28>>2];d=s+32|0;c[o>>2]=c[d>>2];c[o+4>>2]=c[d+4>>2];c[o+8>>2]=c[d+8>>2];c[o+12>>2]=c[d+12>>2];c[o+16>>2]=c[d+16>>2];c[o+20>>2]=c[d+20>>2];c[o+24>>2]=c[d+24>>2];c[o+28>>2]=c[d+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];d=u+32|0;c[d>>2]=c[r>>2];c[d+4>>2]=c[r+4>>2];c[d+8>>2]=c[r+8>>2];c[d+12>>2]=c[r+12>>2];c[d+16>>2]=c[r+16>>2];c[d+20>>2]=c[r+20>>2];c[d+24>>2]=c[r+24>>2];c[d+28>>2]=c[r+28>>2];x=s;z=g;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[u>>2];c[q+4>>2]=c[u+4>>2];c[q+8>>2]=c[u+8>>2];c[q+12>>2]=c[u+12>>2];c[q+16>>2]=c[u+16>>2];c[q+20>>2]=c[u+20>>2];c[q+24>>2]=c[u+24>>2];c[q+28>>2]=c[u+28>>2];c[o>>2]=c[g>>2];c[o+4>>2]=c[g+4>>2];c[o+8>>2]=c[g+8>>2];c[o+12>>2]=c[g+12>>2];c[o+16>>2]=c[g+16>>2];c[o+20>>2]=c[g+20>>2];c[o+24>>2]=c[g+24>>2];c[o+28>>2]=c[g+28>>2];Kc(q,o,136);c[m>>2]=c[q>>2];c[m+4>>2]=c[q+4>>2];c[m+8>>2]=c[q+8>>2];c[m+12>>2]=c[q+12>>2];c[m+16>>2]=c[q+16>>2];c[m+20>>2]=c[q+20>>2];c[m+24>>2]=c[q+24>>2];c[m+28>>2]=c[q+28>>2];c[q>>2]=c[d>>2];c[q+4>>2]=c[d+4>>2];c[q+8>>2]=c[d+8>>2];c[q+12>>2]=c[d+12>>2];c[q+16>>2]=c[d+16>>2];c[q+20>>2]=c[d+20>>2];c[q+24>>2]=c[d+24>>2];c[q+28>>2]=c[d+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];x=m+32|0;c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];dd(e,m);x=v;z=e;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=t;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];c[q+12>>2]=c[t+12>>2];c[q+16>>2]=c[t+16>>2];c[q+20>>2]=c[t+20>>2];c[q+24>>2]=c[t+24>>2];c[q+28>>2]=c[t+28>>2];c[o>>2]=c[n>>2];c[o+4>>2]=c[n+4>>2];c[o+8>>2]=c[n+8>>2];c[o+12>>2]=c[n+12>>2];c[o+16>>2]=c[n+16>>2];c[o+20>>2]=c[n+20>>2];c[o+24>>2]=c[n+24>>2];c[o+28>>2]=c[n+28>>2];Kc(q,o,136);c[u>>2]=c[q>>2];c[u+4>>2]=c[q+4>>2];c[u+8>>2]=c[q+8>>2];c[u+12>>2]=c[q+12>>2];c[u+16>>2]=c[q+16>>2];c[u+20>>2]=c[q+20>>2];c[u+24>>2]=c[q+24>>2];c[u+28>>2]=c[q+28>>2];x=t+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];x=u+32|0;c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];c[q>>2]=c[e>>2];c[q+4>>2]=c[e+4>>2];c[q+8>>2]=c[e+8>>2];c[q+12>>2]=c[e+12>>2];c[q+16>>2]=c[e+16>>2];c[q+20>>2]=c[e+20>>2];c[q+24>>2]=c[e+24>>2];c[q+28>>2]=c[e+28>>2];c[o>>2]=c[u>>2];c[o+4>>2]=c[u+4>>2];c[o+8>>2]=c[u+8>>2];c[o+12>>2]=c[u+12>>2];c[o+16>>2]=c[u+16>>2];c[o+20>>2]=c[u+20>>2];c[o+24>>2]=c[u+24>>2];c[o+28>>2]=c[u+28>>2];Lc(q,o,136);c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];c[k+16>>2]=c[q+16>>2];c[k+20>>2]=c[q+20>>2];c[k+24>>2]=c[q+24>>2];c[k+28>>2]=c[q+28>>2];z=v+32|0;c[q>>2]=c[z>>2];c[q+4>>2]=c[z+4>>2];c[q+8>>2]=c[z+8>>2];c[q+12>>2]=c[z+12>>2];c[q+16>>2]=c[z+16>>2];c[q+20>>2]=c[z+20>>2];c[q+24>>2]=c[z+24>>2];c[q+28>>2]=c[z+28>>2];c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Lc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];x=k+32|0;c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];x=t;z=f;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=f;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];c[q+12>>2]=c[t+12>>2];c[q+16>>2]=c[t+16>>2];c[q+20>>2]=c[t+20>>2];c[q+24>>2]=c[t+24>>2];c[q+28>>2]=c[t+28>>2];c[o>>2]=c[f>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];c[o+28>>2]=c[f+28>>2];Kc(q,o,136);c[j>>2]=c[q>>2];c[j+4>>2]=c[q+4>>2];c[j+8>>2]=c[q+8>>2];c[j+12>>2]=c[q+12>>2];c[j+16>>2]=c[q+16>>2];c[j+20>>2]=c[q+20>>2];c[j+24>>2]=c[q+24>>2];c[j+28>>2]=c[q+28>>2];d=t+32|0;c[q>>2]=c[d>>2];c[q+4>>2]=c[d+4>>2];c[q+8>>2]=c[d+8>>2];c[q+12>>2]=c[d+12>>2];c[q+16>>2]=c[d+16>>2];c[q+20>>2]=c[d+20>>2];c[q+24>>2]=c[d+24>>2];c[q+28>>2]=c[d+28>>2];d=s+32|0;c[o>>2]=c[d>>2];c[o+4>>2]=c[d+4>>2];c[o+8>>2]=c[d+8>>2];c[o+12>>2]=c[d+12>>2];c[o+16>>2]=c[d+16>>2];c[o+20>>2]=c[d+20>>2];c[o+24>>2]=c[d+24>>2];c[o+28>>2]=c[d+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];d=j+32|0;c[d>>2]=c[r>>2];c[d+4>>2]=c[r+4>>2];c[d+8>>2]=c[r+8>>2];c[d+12>>2]=c[r+12>>2];c[d+16>>2]=c[r+16>>2];c[d+20>>2]=c[r+20>>2];c[d+24>>2]=c[r+24>>2];c[d+28>>2]=c[r+28>>2];x=t;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];c[q+12>>2]=c[t+12>>2];c[q+16>>2]=c[t+16>>2];c[q+20>>2]=c[t+20>>2];c[q+24>>2]=c[t+24>>2];c[q+28>>2]=c[t+28>>2];c[o>>2]=c[j>>2];c[o+4>>2]=c[j+4>>2];c[o+8>>2]=c[j+8>>2];c[o+12>>2]=c[j+12>>2];c[o+16>>2]=c[j+16>>2];c[o+20>>2]=c[j+20>>2];c[o+24>>2]=c[j+24>>2];c[o+28>>2]=c[j+28>>2];Kc(q,o,136);c[j>>2]=c[q>>2];c[j+4>>2]=c[q+4>>2];c[j+8>>2]=c[q+8>>2];c[j+12>>2]=c[q+12>>2];c[j+16>>2]=c[q+16>>2];c[j+20>>2]=c[q+20>>2];c[j+24>>2]=c[q+24>>2];c[j+28>>2]=c[q+28>>2];x=t+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];c[d>>2]=c[r>>2];c[d+4>>2]=c[r+4>>2];c[d+8>>2]=c[r+8>>2];c[d+12>>2]=c[r+12>>2];c[d+16>>2]=c[r+16>>2];c[d+20>>2]=c[r+20>>2];c[d+24>>2]=c[r+24>>2];c[d+28>>2]=c[r+28>>2];x=t;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];c[q+12>>2]=c[t+12>>2];c[q+16>>2]=c[t+16>>2];c[q+20>>2]=c[t+20>>2];c[q+24>>2]=c[t+24>>2];c[q+28>>2]=c[t+28>>2];c[o>>2]=c[j>>2];c[o+4>>2]=c[j+4>>2];c[o+8>>2]=c[j+8>>2];c[o+12>>2]=c[j+12>>2];c[o+16>>2]=c[j+16>>2];c[o+20>>2]=c[j+20>>2];c[o+24>>2]=c[j+24>>2];c[o+28>>2]=c[j+28>>2];Kc(q,o,136);c[j>>2]=c[q>>2];c[j+4>>2]=c[q+4>>2];c[j+8>>2]=c[q+8>>2];c[j+12>>2]=c[q+12>>2];c[j+16>>2]=c[q+16>>2];c[j+20>>2]=c[q+20>>2];c[j+24>>2]=c[q+24>>2];c[j+28>>2]=c[q+28>>2];x=t+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];c[d>>2]=c[r>>2];c[d+4>>2]=c[r+4>>2];c[d+8>>2]=c[r+8>>2];c[d+12>>2]=c[r+12>>2];c[d+16>>2]=c[r+16>>2];c[d+20>>2]=c[r+20>>2];c[d+24>>2]=c[r+24>>2];c[d+28>>2]=c[r+28>>2];x=q;z=p;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=o;z=b+128|0;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));cd(i,q,o);x=a;z=k;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=v;z=m;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=t;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=k;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[n>>2];c[q+4>>2]=c[n+4>>2];c[q+8>>2]=c[n+8>>2];c[q+12>>2]=c[n+12>>2];c[q+16>>2]=c[n+16>>2];c[q+20>>2]=c[n+20>>2];c[q+24>>2]=c[n+24>>2];c[q+28>>2]=c[n+28>>2];c[o>>2]=c[k>>2];c[o+4>>2]=c[k+4>>2];c[o+8>>2]=c[k+8>>2];c[o+12>>2]=c[k+12>>2];c[o+16>>2]=c[k+16>>2];c[o+20>>2]=c[k+20>>2];c[o+24>>2]=c[k+24>>2];c[o+28>>2]=c[k+28>>2];Lc(q,o,136);c[u>>2]=c[q>>2];c[u+4>>2]=c[q+4>>2];c[u+8>>2]=c[q+8>>2];c[u+12>>2]=c[q+12>>2];c[u+16>>2]=c[q+16>>2];c[u+20>>2]=c[q+20>>2];c[u+24>>2]=c[q+24>>2];c[u+28>>2]=c[q+28>>2];x=t+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Lc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];x=u+32|0;c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];cd(w,v,u);x=s;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[w>>2];c[q+4>>2]=c[w+4>>2];c[q+8>>2]=c[w+8>>2];c[q+12>>2]=c[w+12>>2];c[q+16>>2]=c[w+16>>2];c[q+20>>2]=c[w+20>>2];c[q+24>>2]=c[w+24>>2];c[q+28>>2]=c[w+28>>2];c[o>>2]=c[j>>2];c[o+4>>2]=c[j+4>>2];c[o+8>>2]=c[j+8>>2];c[o+12>>2]=c[j+12>>2];c[o+16>>2]=c[j+16>>2];c[o+20>>2]=c[j+20>>2];c[o+24>>2]=c[j+24>>2];c[o+28>>2]=c[j+28>>2];Lc(q,o,136);c[h>>2]=c[q>>2];c[h+4>>2]=c[q+4>>2];c[h+8>>2]=c[q+8>>2];c[h+12>>2]=c[q+12>>2];c[h+16>>2]=c[q+16>>2];c[h+20>>2]=c[q+20>>2];c[h+24>>2]=c[q+24>>2];c[h+28>>2]=c[q+28>>2];x=w+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Lc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];x=h+32|0;c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];x=t;z=i;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=s;z=i;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];c[q+12>>2]=c[t+12>>2];c[q+16>>2]=c[t+16>>2];c[q+20>>2]=c[t+20>>2];c[q+24>>2]=c[t+24>>2];c[q+28>>2]=c[t+28>>2];c[o>>2]=c[i>>2];c[o+4>>2]=c[i+4>>2];c[o+8>>2]=c[i+8>>2];c[o+12>>2]=c[i+12>>2];c[o+16>>2]=c[i+16>>2];c[o+20>>2]=c[i+20>>2];c[o+24>>2]=c[i+24>>2];c[o+28>>2]=c[i+28>>2];Kc(q,o,136);c[u>>2]=c[q>>2];c[u+4>>2]=c[q+4>>2];c[u+8>>2]=c[q+8>>2];c[u+12>>2]=c[q+12>>2];c[u+16>>2]=c[q+16>>2];c[u+20>>2]=c[q+20>>2];c[u+24>>2]=c[q+24>>2];c[u+28>>2]=c[q+28>>2];x=t+32|0;c[q>>2]=c[x>>2];c[q+4>>2]=c[x+4>>2];c[q+8>>2]=c[x+8>>2];c[q+12>>2]=c[x+12>>2];c[q+16>>2]=c[x+16>>2];c[q+20>>2]=c[x+20>>2];c[q+24>>2]=c[x+24>>2];c[q+28>>2]=c[x+28>>2];x=s+32|0;c[o>>2]=c[x>>2];c[o+4>>2]=c[x+4>>2];c[o+8>>2]=c[x+8>>2];c[o+12>>2]=c[x+12>>2];c[o+16>>2]=c[x+16>>2];c[o+20>>2]=c[x+20>>2];c[o+24>>2]=c[x+24>>2];c[o+28>>2]=c[x+28>>2];Kc(q,o,136);c[r>>2]=c[q>>2];c[r+4>>2]=c[q+4>>2];c[r+8>>2]=c[q+8>>2];c[r+12>>2]=c[q+12>>2];c[r+16>>2]=c[q+16>>2];c[r+20>>2]=c[q+20>>2];c[r+24>>2]=c[q+24>>2];c[r+28>>2]=c[q+28>>2];x=u+32|0;c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];x=a+64|0;z=h;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=a+128|0;z=u;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));l=y;return}function zc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0;p=l;l=l+656|0;g=p+520|0;h=p+448|0;i=p+384|0;j=p+320|0;k=p+256|0;m=p+128|0;n=p+64|0;o=p;f=b+128|0;d=f;if((((((((c[d>>2]|0)==0&(c[d+4>>2]|0)==0?(d=b+136|0,(c[d>>2]|0)==0&(c[d+4>>2]|0)==0):0)?(d=b+144|0,(c[d>>2]|0)==0&(c[d+4>>2]|0)==0):0)?(d=b+152|0,(c[d>>2]|0)==0&(c[d+4>>2]|0)==0):0)?(d=b+160|0,(c[d>>2]|0)==0&(c[d+4>>2]|0)==0):0)?(d=b+168|0,(c[d>>2]|0)==0&(c[d+4>>2]|0)==0):0)?(d=b+176|0,(c[d>>2]|0)==0&(c[d+4>>2]|0)==0):0)?(d=b+184|0,(c[d>>2]|0)==0&(c[d+4>>2]|0)==0):0){o=a;c[o>>2]=0;c[o+4>>2]=0;l=p;return}d=g;c[d>>2]=-980480611;c[d+4>>2]=-748862579;d=g+8|0;c[d>>2]=-171504835;c[d+4>>2]=175696680;d=g+16|0;c[d>>2]=2021213740;c[d+4>>2]=1718526831;d=g+24|0;c[d>>2]=-1710760145;c[d+4>>2]=235567041;d=g+32|0;c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;if((f|0)!=(g|0)?(Xj(f,g,32)|0)!=0:0)d=f;else e=12;do if((e|0)==12){d=b+160|0;e=g+32|0;if((d|0)!=(e|0)?Xj(d,e,32)|0:0){d=f;break}f=g;d=b;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));f=g+64|0;d=b+64|0;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));f=a;c[f>>2]=1;c[f+4>>2]=0;f=a+8|0;d=g;e=f+128|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));l=p;return}while(0);f=g;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));ed(h,g);f=h;if(!((c[f>>2]|0)==1&(c[f+4>>2]|0)==0))$i(2032);f=o;d=h+8|0;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));dd(n,o);f=h;d=b;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));f=g;d=n;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));cd(m,h,g);f=j;d=b+64|0;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));f=h;d=n;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));f=g;d=o;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));cd(i,h,g);cd(k,j,i);f=m+64|0;d=k;e=f+64|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));f=a;c[f>>2]=1;c[f+4>>2]=0;f=a+8|0;d=m;e=f+128|0;do{c[f>>2]=c[d>>2];f=f+4|0;d=d+4|0;}while((f|0)<(e|0));l=p;return}function Ac(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0;n=l;l=l+320|0;d=n+256|0;f=n+224|0;g=n+192|0;h=n+160|0;i=n+128|0;m=n+64|0;j=n+32|0;k=n;e=b+64|0;o=e;if((((c[o>>2]|0)==0&(c[o+4>>2]|0)==0?(o=b+72|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0)?(o=b+80|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0)?(o=b+88|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0){o=a;c[o>>2]=0;c[o+4>>2]=0;l=n;return}o=d;c[o>>2]=-980480611;c[o+4>>2]=-748862579;o=d+8|0;c[o>>2]=-171504835;c[o+4>>2]=175696680;o=d+16|0;c[o>>2]=2021213740;c[o+4>>2]=1718526831;o=d+24|0;c[o>>2]=-1710760145;c[o+4>>2]=235567041;if((e|0)!=(d|0))if(Xj(e,d,32)|0){c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];c[d+8>>2]=c[e+8>>2];c[d+12>>2]=c[e+12>>2];c[d+16>>2]=c[e+16>>2];c[d+20>>2]=c[e+20>>2];c[d+24>>2]=c[e+24>>2];c[d+28>>2]=c[e+28>>2];o=d;if((((c[o>>2]|0)==0&(c[o+4>>2]|0)==0?(o=d+8|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0)?(o=d+16|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0)?(o=d+24|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0)$i(2032);Oc(d,136);Mc(d,104,136,-460954743,-2016278654);c[k>>2]=c[d>>2];c[k+4>>2]=c[d+4>>2];c[k+8>>2]=c[d+8>>2];c[k+12>>2]=c[d+12>>2];c[k+16>>2]=c[d+16>>2];c[k+20>>2]=c[d+20>>2];c[k+24>>2]=c[d+24>>2];c[k+28>>2]=c[d+28>>2];c[f>>2]=c[k>>2];c[f+4>>2]=c[k+4>>2];c[f+8>>2]=c[k+8>>2];c[f+12>>2]=c[k+12>>2];c[f+16>>2]=c[k+16>>2];c[f+20>>2]=c[k+20>>2];c[f+24>>2]=c[k+24>>2];c[f+28>>2]=c[k+28>>2];c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];c[d+8>>2]=c[k+8>>2];c[d+12>>2]=c[k+12>>2];c[d+16>>2]=c[k+16>>2];c[d+20>>2]=c[k+20>>2];c[d+24>>2]=c[k+24>>2];c[d+28>>2]=c[k+28>>2];Mc(f,d,136,-460954743,-2016278654);c[j>>2]=c[f>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];c[j+28>>2]=c[f+28>>2];c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];c[f+8>>2]=c[b+8>>2];c[f+12>>2]=c[b+12>>2];c[f+16>>2]=c[b+16>>2];c[f+20>>2]=c[b+20>>2];c[f+24>>2]=c[b+24>>2];c[f+28>>2]=c[b+28>>2];c[d>>2]=c[j>>2];c[d+4>>2]=c[j+4>>2];c[d+8>>2]=c[j+8>>2];c[d+12>>2]=c[j+12>>2];c[d+16>>2]=c[j+16>>2];c[d+20>>2]=c[j+20>>2];c[d+24>>2]=c[j+24>>2];c[d+28>>2]=c[j+28>>2];Mc(f,d,136,-460954743,-2016278654);c[m>>2]=c[f>>2];c[m+4>>2]=c[f+4>>2];c[m+8>>2]=c[f+8>>2];c[m+12>>2]=c[f+12>>2];c[m+16>>2]=c[f+16>>2];c[m+20>>2]=c[f+20>>2];c[m+24>>2]=c[f+24>>2];c[m+28>>2]=c[f+28>>2];b=b+32|0;c[h>>2]=c[b>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[h+28>>2]=c[b+28>>2];c[f>>2]=c[j>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[f+28>>2]=c[j+28>>2];c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];c[d+8>>2]=c[k+8>>2];c[d+12>>2]=c[k+12>>2];c[d+16>>2]=c[k+16>>2];c[d+20>>2]=c[k+20>>2];c[d+24>>2]=c[k+24>>2];c[d+28>>2]=c[k+28>>2];Mc(f,d,136,-460954743,-2016278654);c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];c[g+28>>2]=c[f+28>>2];Mc(h,g,136,-460954743,-2016278654);c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];c[i+8>>2]=c[h+8>>2];c[i+12>>2]=c[h+12>>2];c[i+16>>2]=c[h+16>>2];c[i+20>>2]=c[h+20>>2];c[i+24>>2]=c[h+24>>2];c[i+28>>2]=c[h+28>>2];b=m+32|0;c[b>>2]=c[i>>2];c[b+4>>2]=c[i+4>>2];c[b+8>>2]=c[i+8>>2];c[b+12>>2]=c[i+12>>2];c[b+16>>2]=c[i+16>>2];c[b+20>>2]=c[i+20>>2];c[b+24>>2]=c[i+24>>2];c[b+28>>2]=c[i+28>>2];b=a;c[b>>2]=1;c[b+4>>2]=0;b=a+8|0;d=m;a=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(a|0));l=n;return};c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];c[d+16>>2]=c[b+16>>2];c[d+20>>2]=c[b+20>>2];c[d+24>>2]=c[b+24>>2];c[d+28>>2]=c[b+28>>2];o=b+32|0;b=d+32|0;c[b>>2]=c[o>>2];c[b+4>>2]=c[o+4>>2];c[b+8>>2]=c[o+8>>2];c[b+12>>2]=c[o+12>>2];c[b+16>>2]=c[o+16>>2];c[b+20>>2]=c[o+20>>2];c[b+24>>2]=c[o+24>>2];c[b+28>>2]=c[o+28>>2];b=a;c[b>>2]=1;c[b+4>>2]=0;b=a+8|0;a=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(a|0));l=n;return}function Bc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;d=l;l=l+480|0;h=d+448|0;g=d+416|0;e=d+384|0;m=d+352|0;j=d+320|0;f=d+288|0;i=d+256|0;k=d+224|0;n=d+192|0;s=d+160|0;p=d+128|0;o=d+96|0;r=d+64|0;u=d+32|0;t=d;c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];c[h>>2]=c[b>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[h+28>>2]=c[b+28>>2];Mc(g,h,136,-460954743,-2016278654);c[t>>2]=c[g>>2];c[t+4>>2]=c[g+4>>2];c[t+8>>2]=c[g+8>>2];c[t+12>>2]=c[g+12>>2];c[t+16>>2]=c[g+16>>2];c[t+20>>2]=c[g+20>>2];c[t+24>>2]=c[g+24>>2];c[t+28>>2]=c[g+28>>2];q=b+32|0;c[g>>2]=c[q>>2];c[g+4>>2]=c[q+4>>2];c[g+8>>2]=c[q+8>>2];c[g+12>>2]=c[q+12>>2];c[g+16>>2]=c[q+16>>2];c[g+20>>2]=c[q+20>>2];c[g+24>>2]=c[q+24>>2];c[g+28>>2]=c[q+28>>2];c[h>>2]=c[q>>2];c[h+4>>2]=c[q+4>>2];c[h+8>>2]=c[q+8>>2];c[h+12>>2]=c[q+12>>2];c[h+16>>2]=c[q+16>>2];c[h+20>>2]=c[q+20>>2];c[h+24>>2]=c[q+24>>2];c[h+28>>2]=c[q+28>>2];Mc(g,h,136,-460954743,-2016278654);c[u>>2]=c[g>>2];c[u+4>>2]=c[g+4>>2];c[u+8>>2]=c[g+8>>2];c[u+12>>2]=c[g+12>>2];c[u+16>>2]=c[g+16>>2];c[u+20>>2]=c[g+20>>2];c[u+24>>2]=c[g+24>>2];c[u+28>>2]=c[g+28>>2];c[g>>2]=c[u>>2];c[g+4>>2]=c[u+4>>2];c[g+8>>2]=c[u+8>>2];c[g+12>>2]=c[u+12>>2];c[g+16>>2]=c[u+16>>2];c[g+20>>2]=c[u+20>>2];c[g+24>>2]=c[u+24>>2];c[g+28>>2]=c[u+28>>2];c[h>>2]=c[u>>2];c[h+4>>2]=c[u+4>>2];c[h+8>>2]=c[u+8>>2];c[h+12>>2]=c[u+12>>2];c[h+16>>2]=c[u+16>>2];c[h+20>>2]=c[u+20>>2];c[h+24>>2]=c[u+24>>2];c[h+28>>2]=c[u+28>>2];Mc(g,h,136,-460954743,-2016278654);c[r>>2]=c[g>>2];c[r+4>>2]=c[g+4>>2];c[r+8>>2]=c[g+8>>2];c[r+12>>2]=c[g+12>>2];c[r+16>>2]=c[g+16>>2];c[r+20>>2]=c[g+20>>2];c[r+24>>2]=c[g+24>>2];c[r+28>>2]=c[g+28>>2];c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];c[h>>2]=c[u>>2];c[h+4>>2]=c[u+4>>2];c[h+8>>2]=c[u+8>>2];c[h+12>>2]=c[u+12>>2];c[h+16>>2]=c[u+16>>2];c[h+20>>2]=c[u+20>>2];c[h+24>>2]=c[u+24>>2];c[h+28>>2]=c[u+28>>2];Kc(g,h,136);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];c[e+16>>2]=c[g+16>>2];c[e+20>>2]=c[g+20>>2];c[e+24>>2]=c[g+24>>2];c[e+28>>2]=c[g+28>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[g+16>>2]=c[e+16>>2];c[g+20>>2]=c[e+20>>2];c[g+24>>2]=c[e+24>>2];c[g+28>>2]=c[e+28>>2];c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];c[h+8>>2]=c[e+8>>2];c[h+12>>2]=c[e+12>>2];c[h+16>>2]=c[e+16>>2];c[h+20>>2]=c[e+20>>2];c[h+24>>2]=c[e+24>>2];c[h+28>>2]=c[e+28>>2];Mc(g,h,136,-460954743,-2016278654);c[m>>2]=c[g>>2];c[m+4>>2]=c[g+4>>2];c[m+8>>2]=c[g+8>>2];c[m+12>>2]=c[g+12>>2];c[m+16>>2]=c[g+16>>2];c[m+20>>2]=c[g+20>>2];c[m+24>>2]=c[g+24>>2];c[m+28>>2]=c[g+28>>2];c[h>>2]=c[t>>2];c[h+4>>2]=c[t+4>>2];c[h+8>>2]=c[t+8>>2];c[h+12>>2]=c[t+12>>2];c[h+16>>2]=c[t+16>>2];c[h+20>>2]=c[t+20>>2];c[h+24>>2]=c[t+24>>2];c[h+28>>2]=c[t+28>>2];Lc(m,h,136);c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];c[j+8>>2]=c[m+8>>2];c[j+12>>2]=c[m+12>>2];c[j+16>>2]=c[m+16>>2];c[j+20>>2]=c[m+20>>2];c[j+24>>2]=c[m+24>>2];c[j+28>>2]=c[m+28>>2];c[h>>2]=c[r>>2];c[h+4>>2]=c[r+4>>2];c[h+8>>2]=c[r+8>>2];c[h+12>>2]=c[r+12>>2];c[h+16>>2]=c[r+16>>2];c[h+20>>2]=c[r+20>>2];c[h+24>>2]=c[r+24>>2];c[h+28>>2]=c[r+28>>2];Lc(j,h,136);c[o>>2]=c[j>>2];c[o+4>>2]=c[j+4>>2];c[o+8>>2]=c[j+8>>2];c[o+12>>2]=c[j+12>>2];c[o+16>>2]=c[j+16>>2];c[o+20>>2]=c[j+20>>2];c[o+24>>2]=c[j+24>>2];c[o+28>>2]=c[j+28>>2];c[g>>2]=c[o>>2];c[g+4>>2]=c[o+4>>2];c[g+8>>2]=c[o+8>>2];c[g+12>>2]=c[o+12>>2];c[g+16>>2]=c[o+16>>2];c[g+20>>2]=c[o+20>>2];c[g+24>>2]=c[o+24>>2];c[g+28>>2]=c[o+28>>2];c[h>>2]=c[o>>2];c[h+4>>2]=c[o+4>>2];c[h+8>>2]=c[o+8>>2];c[h+12>>2]=c[o+12>>2];c[h+16>>2]=c[o+16>>2];c[h+20>>2]=c[o+20>>2];c[h+24>>2]=c[o+24>>2];c[h+28>>2]=c[o+28>>2];Kc(g,h,136);c[o>>2]=c[g>>2];c[o+4>>2]=c[g+4>>2];c[o+8>>2]=c[g+8>>2];c[o+12>>2]=c[g+12>>2];c[o+16>>2]=c[g+16>>2];c[o+20>>2]=c[g+20>>2];c[o+24>>2]=c[g+24>>2];c[o+28>>2]=c[g+28>>2];c[g>>2]=c[t>>2];c[g+4>>2]=c[t+4>>2];c[g+8>>2]=c[t+8>>2];c[g+12>>2]=c[t+12>>2];c[g+16>>2]=c[t+16>>2];c[g+20>>2]=c[t+20>>2];c[g+24>>2]=c[t+24>>2];c[g+28>>2]=c[t+28>>2];c[h>>2]=c[t>>2];c[h+4>>2]=c[t+4>>2];c[h+8>>2]=c[t+8>>2];c[h+12>>2]=c[t+12>>2];c[h+16>>2]=c[t+16>>2];c[h+20>>2]=c[t+20>>2];c[h+24>>2]=c[t+24>>2];c[h+28>>2]=c[t+28>>2];Kc(g,h,136);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];c[e+16>>2]=c[g+16>>2];c[e+20>>2]=c[g+20>>2];c[e+24>>2]=c[g+24>>2];c[e+28>>2]=c[g+28>>2];c[h>>2]=c[t>>2];c[h+4>>2]=c[t+4>>2];c[h+8>>2]=c[t+8>>2];c[h+12>>2]=c[t+12>>2];c[h+16>>2]=c[t+16>>2];c[h+20>>2]=c[t+20>>2];c[h+24>>2]=c[t+24>>2];c[h+28>>2]=c[t+28>>2];Kc(e,h,136);c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[p+16>>2]=c[e+16>>2];c[p+20>>2]=c[e+20>>2];c[p+24>>2]=c[e+24>>2];c[p+28>>2]=c[e+28>>2];c[g>>2]=c[p>>2];c[g+4>>2]=c[p+4>>2];c[g+8>>2]=c[p+8>>2];c[g+12>>2]=c[p+12>>2];c[g+16>>2]=c[p+16>>2];c[g+20>>2]=c[p+20>>2];c[g+24>>2]=c[p+24>>2];c[g+28>>2]=c[p+28>>2];c[h>>2]=c[p>>2];c[h+4>>2]=c[p+4>>2];c[h+8>>2]=c[p+8>>2];c[h+12>>2]=c[p+12>>2];c[h+16>>2]=c[p+16>>2];c[h+20>>2]=c[p+20>>2];c[h+24>>2]=c[p+24>>2];c[h+28>>2]=c[p+28>>2];Mc(g,h,136,-460954743,-2016278654);c[s>>2]=c[g>>2];c[s+4>>2]=c[g+4>>2];c[s+8>>2]=c[g+8>>2];c[s+12>>2]=c[g+12>>2];c[s+16>>2]=c[g+16>>2];c[s+20>>2]=c[g+20>>2];c[s+24>>2]=c[g+24>>2];c[s+28>>2]=c[g+28>>2];c[m>>2]=c[s>>2];c[m+4>>2]=c[s+4>>2];c[m+8>>2]=c[s+8>>2];c[m+12>>2]=c[s+12>>2];c[m+16>>2]=c[s+16>>2];c[m+20>>2]=c[s+20>>2];c[m+24>>2]=c[s+24>>2];c[m+28>>2]=c[s+28>>2];c[g>>2]=c[o>>2];c[g+4>>2]=c[o+4>>2];c[g+8>>2]=c[o+8>>2];c[g+12>>2]=c[o+12>>2];c[g+16>>2]=c[o+16>>2];c[g+20>>2]=c[o+20>>2];c[g+24>>2]=c[o+24>>2];c[g+28>>2]=c[o+28>>2];c[h>>2]=c[o>>2];c[h+4>>2]=c[o+4>>2];c[h+8>>2]=c[o+8>>2];c[h+12>>2]=c[o+12>>2];c[h+16>>2]=c[o+16>>2];c[h+20>>2]=c[o+20>>2];c[h+24>>2]=c[o+24>>2];c[h+28>>2]=c[o+28>>2];Kc(g,h,136);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];c[e+16>>2]=c[g+16>>2];c[e+20>>2]=c[g+20>>2];c[e+24>>2]=c[g+24>>2];c[e+28>>2]=c[g+28>>2];Lc(m,e,136);c[n>>2]=c[m>>2];c[n+4>>2]=c[m+4>>2];c[n+8>>2]=c[m+8>>2];c[n+12>>2]=c[m+12>>2];c[n+16>>2]=c[m+16>>2];c[n+20>>2]=c[m+20>>2];c[n+24>>2]=c[m+24>>2];c[n+28>>2]=c[m+28>>2];c[g>>2]=c[r>>2];c[g+4>>2]=c[r+4>>2];c[g+8>>2]=c[r+8>>2];c[g+12>>2]=c[r+12>>2];c[g+16>>2]=c[r+16>>2];c[g+20>>2]=c[r+20>>2];c[g+24>>2]=c[r+24>>2];c[g+28>>2]=c[r+28>>2];c[h>>2]=c[r>>2];c[h+4>>2]=c[r+4>>2];c[h+8>>2]=c[r+8>>2];c[h+12>>2]=c[r+12>>2];c[h+16>>2]=c[r+16>>2];c[h+20>>2]=c[r+20>>2];c[h+24>>2]=c[r+24>>2];c[h+28>>2]=c[r+28>>2];Kc(g,h,136);c[k>>2]=c[g>>2];c[k+4>>2]=c[g+4>>2];c[k+8>>2]=c[g+8>>2];c[k+12>>2]=c[g+12>>2];c[k+16>>2]=c[g+16>>2];c[k+20>>2]=c[g+20>>2];c[k+24>>2]=c[g+24>>2];c[k+28>>2]=c[g+28>>2];c[g>>2]=c[k>>2];c[g+4>>2]=c[k+4>>2];c[g+8>>2]=c[k+8>>2];c[g+12>>2]=c[k+12>>2];c[g+16>>2]=c[k+16>>2];c[g+20>>2]=c[k+20>>2];c[g+24>>2]=c[k+24>>2];c[g+28>>2]=c[k+28>>2];c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[h+16>>2]=c[k+16>>2];c[h+20>>2]=c[k+20>>2];c[h+24>>2]=c[k+24>>2];c[h+28>>2]=c[k+28>>2];Kc(g,h,136);c[k>>2]=c[g>>2];c[k+4>>2]=c[g+4>>2];c[k+8>>2]=c[g+8>>2];c[k+12>>2]=c[g+12>>2];c[k+16>>2]=c[g+16>>2];c[k+20>>2]=c[g+20>>2];c[k+24>>2]=c[g+24>>2];c[k+28>>2]=c[g+28>>2];c[g>>2]=c[k>>2];c[g+4>>2]=c[k+4>>2];c[g+8>>2]=c[k+8>>2];c[g+12>>2]=c[k+12>>2];c[g+16>>2]=c[k+16>>2];c[g+20>>2]=c[k+20>>2];c[g+24>>2]=c[k+24>>2];c[g+28>>2]=c[k+28>>2];c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[h+16>>2]=c[k+16>>2];c[h+20>>2]=c[k+20>>2];c[h+24>>2]=c[k+24>>2];c[h+28>>2]=c[k+28>>2];Kc(g,h,136);c[k>>2]=c[g>>2];c[k+4>>2]=c[g+4>>2];c[k+8>>2]=c[g+8>>2];c[k+12>>2]=c[g+12>>2];c[k+16>>2]=c[g+16>>2];c[k+20>>2]=c[g+20>>2];c[k+24>>2]=c[g+24>>2];c[k+28>>2]=c[g+28>>2];c[g>>2]=c[q>>2];c[g+4>>2]=c[q+4>>2];c[g+8>>2]=c[q+8>>2];c[g+12>>2]=c[q+12>>2];c[g+16>>2]=c[q+16>>2];c[g+20>>2]=c[q+20>>2];c[g+24>>2]=c[q+24>>2];c[g+28>>2]=c[q+28>>2];b=b+64|0;c[h>>2]=c[b>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[h+28>>2]=c[b+28>>2];Mc(g,h,136,-460954743,-2016278654);c[i>>2]=c[g>>2];c[i+4>>2]=c[g+4>>2];c[i+8>>2]=c[g+8>>2];c[i+12>>2]=c[g+12>>2];c[i+16>>2]=c[g+16>>2];c[i+20>>2]=c[g+20>>2];c[i+24>>2]=c[g+24>>2];c[i+28>>2]=c[g+28>>2];c[a>>2]=c[n>>2];c[a+4>>2]=c[n+4>>2];c[a+8>>2]=c[n+8>>2];c[a+12>>2]=c[n+12>>2];c[a+16>>2]=c[n+16>>2];c[a+20>>2]=c[n+20>>2];c[a+24>>2]=c[n+24>>2];c[a+28>>2]=c[n+28>>2];c[m>>2]=c[p>>2];c[m+4>>2]=c[p+4>>2];c[m+8>>2]=c[p+8>>2];c[m+12>>2]=c[p+12>>2];c[m+16>>2]=c[p+16>>2];c[m+20>>2]=c[p+20>>2];c[m+24>>2]=c[p+24>>2];c[m+28>>2]=c[p+28>>2];c[g>>2]=c[o>>2];c[g+4>>2]=c[o+4>>2];c[g+8>>2]=c[o+8>>2];c[g+12>>2]=c[o+12>>2];c[g+16>>2]=c[o+16>>2];c[g+20>>2]=c[o+20>>2];c[g+24>>2]=c[o+24>>2];c[g+28>>2]=c[o+28>>2];c[h>>2]=c[n>>2];c[h+4>>2]=c[n+4>>2];c[h+8>>2]=c[n+8>>2];c[h+12>>2]=c[n+12>>2];c[h+16>>2]=c[n+16>>2];c[h+20>>2]=c[n+20>>2];c[h+24>>2]=c[n+24>>2];c[h+28>>2]=c[n+28>>2];Lc(g,h,136);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];c[e+16>>2]=c[g+16>>2];c[e+20>>2]=c[g+20>>2];c[e+24>>2]=c[g+24>>2];c[e+28>>2]=c[g+28>>2];Mc(m,e,136,-460954743,-2016278654);c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];c[j+8>>2]=c[m+8>>2];c[j+12>>2]=c[m+12>>2];c[j+16>>2]=c[m+16>>2];c[j+20>>2]=c[m+20>>2];c[j+24>>2]=c[m+24>>2];c[j+28>>2]=c[m+28>>2];c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[h+16>>2]=c[k+16>>2];c[h+20>>2]=c[k+20>>2];c[h+24>>2]=c[k+24>>2];c[h+28>>2]=c[k+28>>2];Lc(j,h,136);c[f>>2]=c[j>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[f+28>>2]=c[j+28>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];c[g+8>>2]=c[i+8>>2];c[g+12>>2]=c[i+12>>2];c[g+16>>2]=c[i+16>>2];c[g+20>>2]=c[i+20>>2];c[g+24>>2]=c[i+24>>2];c[g+28>>2]=c[i+28>>2];c[h>>2]=c[i>>2];c[h+4>>2]=c[i+4>>2];c[h+8>>2]=c[i+8>>2];c[h+12>>2]=c[i+12>>2];c[h+16>>2]=c[i+16>>2];c[h+20>>2]=c[i+20>>2];c[h+24>>2]=c[i+24>>2];c[h+28>>2]=c[i+28>>2];Kc(g,h,136);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];c[e+16>>2]=c[g+16>>2];c[e+20>>2]=c[g+20>>2];c[e+24>>2]=c[g+24>>2];c[e+28>>2]=c[g+28>>2];b=a+32|0;c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];c[b+8>>2]=c[f+8>>2];c[b+12>>2]=c[f+12>>2];c[b+16>>2]=c[f+16>>2];c[b+20>>2]=c[f+20>>2];c[b+24>>2]=c[f+24>>2];c[b+28>>2]=c[f+28>>2];b=a+64|0;c[b>>2]=c[e>>2];c[b+4>>2]=c[e+4>>2];c[b+8>>2]=c[e+8>>2];c[b+12>>2]=c[e+12>>2];c[b+16>>2]=c[e+16>>2];c[b+20>>2]=c[e+20>>2];c[b+24>>2]=c[e+24>>2];c[b+28>>2]=c[e+28>>2];l=d;return}function Cc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0;n=l;l=l+320|0;i=n+224|0;j=n+128|0;k=n+96|0;m=n;c[m>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;c[m+16>>2]=0;c[m+20>>2]=0;c[m+24>>2]=0;c[m+28>>2]=0;h=m+32|0;c[h>>2]=-980480611;c[h+4>>2]=-748862579;h=m+40|0;c[h>>2]=-171504835;c[h+4>>2]=175696680;h=m+48|0;c[h>>2]=2021213740;c[h+4>>2]=1718526831;h=m+56|0;c[h>>2]=-1710760145;c[h+4>>2]=235567041;h=m+64|0;c[h>>2]=0;c[h+4>>2]=0;c[h+8>>2]=0;c[h+12>>2]=0;c[h+16>>2]=0;c[h+20>>2]=0;c[h+24>>2]=0;c[h+28>>2]=0;c[j>>2]=c[d>>2];c[j+4>>2]=c[d+4>>2];c[j+8>>2]=c[d+8>>2];c[j+12>>2]=c[d+12>>2];c[j+16>>2]=c[d+16>>2];c[j+20>>2]=c[d+20>>2];c[j+24>>2]=c[d+24>>2];c[j+28>>2]=c[d+28>>2];d=i;c[d>>2]=1;c[d+4>>2]=0;d=i+8|0;c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;Mc(j,i,8,-268435457,-1025378925);c[k>>2]=c[j>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[k+16>>2]=c[j+16>>2];c[k+20>>2]=c[j+20>>2];c[k+24>>2]=c[j+24>>2];c[k+28>>2]=c[j+28>>2];d=256;while(1){if(!d){d=7;break}d=d+-1|0;if(d>>>0>255){d=7;break}h=k+(d>>>6<<3)|0;f=c[h>>2]|0;h=c[h+4>>2]|0;g=nk(1,0,d&63|0)|0;if(!((f&g|0)==0&(h&y|0)==0)){e=d;d=9;break}}if((d|0)==7){f=a;g=m;h=f+96|0;do{c[f>>2]=c[g>>2];f=f+4|0;g=g+4|0;}while((f|0)<(h|0));l=n;return}else if((d|0)==9){a:while(1){f=j;g=m;h=f+96|0;do{c[f>>2]=c[g>>2];f=f+4|0;g=g+4|0;}while((f|0)<(h|0));f=i;g=b;h=f+96|0;do{c[f>>2]=c[g>>2];f=f+4|0;g=g+4|0;}while((f|0)<(h|0));Dc(m,j,i);while(1){if(!e){d=7;break a}e=e+-1|0;if(e>>>0>255){d=7;break a}d=k+(e>>>6<<3)|0;g=c[d>>2]|0;d=c[d+4>>2]|0;f=nk(1,0,e&63|0)|0;d=(g&f|0)==0&(d&y|0)==0;Bc(i,m);f=m;g=i;h=f+96|0;do{c[f>>2]=c[g>>2];f=f+4|0;g=g+4|0;}while((f|0)<(h|0));if(!d)continue a}}if((d|0)==7){f=a;g=m;h=f+96|0;do{c[f>>2]=c[g>>2];f=f+4|0;g=g+4|0;}while((f|0)<(h|0));l=n;return}}}function Dc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;F=l;l=l+768|0;x=F+736|0;y=F+704|0;z=F+672|0;A=F+640|0;C=F+608|0;D=F+576|0;E=F+544|0;e=F+512|0;f=F+480|0;g=F+448|0;h=F+416|0;i=F+384|0;j=F+352|0;k=F+320|0;m=F+288|0;n=F+256|0;o=F+224|0;p=F+192|0;q=F+160|0;r=F+128|0;s=F+96|0;t=F+64|0;u=F+32|0;v=F;w=b+64|0;B=w;if((((c[B>>2]|0)==0&(c[B+4>>2]|0)==0?(B=b+72|0,(c[B>>2]|0)==0&(c[B+4>>2]|0)==0):0)?(B=b+80|0,(c[B>>2]|0)==0&(c[B+4>>2]|0)==0):0)?(B=b+88|0,(c[B>>2]|0)==0&(c[B+4>>2]|0)==0):0){b=d;e=a+96|0;do{c[a>>2]=c[b>>2];a=a+4|0;b=b+4|0;}while((a|0)<(e|0));l=F;return}B=d+64|0;G=B;if((((c[G>>2]|0)==0&(c[G+4>>2]|0)==0?(G=d+72|0,(c[G>>2]|0)==0&(c[G+4>>2]|0)==0):0)?(G=d+80|0,(c[G>>2]|0)==0&(c[G+4>>2]|0)==0):0)?(G=d+88|0,(c[G>>2]|0)==0&(c[G+4>>2]|0)==0):0){e=a+96|0;do{c[a>>2]=c[b>>2];a=a+4|0;b=b+4|0;}while((a|0)<(e|0));l=F;return};c[y>>2]=c[w>>2];c[y+4>>2]=c[w+4>>2];c[y+8>>2]=c[w+8>>2];c[y+12>>2]=c[w+12>>2];c[y+16>>2]=c[w+16>>2];c[y+20>>2]=c[w+20>>2];c[y+24>>2]=c[w+24>>2];c[y+28>>2]=c[w+28>>2];c[x>>2]=c[w>>2];c[x+4>>2]=c[w+4>>2];c[x+8>>2]=c[w+8>>2];c[x+12>>2]=c[w+12>>2];c[x+16>>2]=c[w+16>>2];c[x+20>>2]=c[w+20>>2];c[x+24>>2]=c[w+24>>2];c[x+28>>2]=c[w+28>>2];Mc(y,x,136,-460954743,-2016278654);c[v>>2]=c[y>>2];c[v+4>>2]=c[y+4>>2];c[v+8>>2]=c[y+8>>2];c[v+12>>2]=c[y+12>>2];c[v+16>>2]=c[y+16>>2];c[v+20>>2]=c[y+20>>2];c[v+24>>2]=c[y+24>>2];c[v+28>>2]=c[y+28>>2];c[y>>2]=c[B>>2];c[y+4>>2]=c[B+4>>2];c[y+8>>2]=c[B+8>>2];c[y+12>>2]=c[B+12>>2];c[y+16>>2]=c[B+16>>2];c[y+20>>2]=c[B+20>>2];c[y+24>>2]=c[B+24>>2];c[y+28>>2]=c[B+28>>2];c[x>>2]=c[B>>2];c[x+4>>2]=c[B+4>>2];c[x+8>>2]=c[B+8>>2];c[x+12>>2]=c[B+12>>2];c[x+16>>2]=c[B+16>>2];c[x+20>>2]=c[B+20>>2];c[x+24>>2]=c[B+24>>2];c[x+28>>2]=c[B+28>>2];Mc(y,x,136,-460954743,-2016278654);c[u>>2]=c[y>>2];c[u+4>>2]=c[y+4>>2];c[u+8>>2]=c[y+8>>2];c[u+12>>2]=c[y+12>>2];c[u+16>>2]=c[y+16>>2];c[u+20>>2]=c[y+20>>2];c[u+24>>2]=c[y+24>>2];c[u+28>>2]=c[y+28>>2];c[y>>2]=c[b>>2];c[y+4>>2]=c[b+4>>2];c[y+8>>2]=c[b+8>>2];c[y+12>>2]=c[b+12>>2];c[y+16>>2]=c[b+16>>2];c[y+20>>2]=c[b+20>>2];c[y+24>>2]=c[b+24>>2];c[y+28>>2]=c[b+28>>2];c[x>>2]=c[u>>2];c[x+4>>2]=c[u+4>>2];c[x+8>>2]=c[u+8>>2];c[x+12>>2]=c[u+12>>2];c[x+16>>2]=c[u+16>>2];c[x+20>>2]=c[u+20>>2];c[x+24>>2]=c[u+24>>2];c[x+28>>2]=c[u+28>>2];Mc(y,x,136,-460954743,-2016278654);c[t>>2]=c[y>>2];c[t+4>>2]=c[y+4>>2];c[t+8>>2]=c[y+8>>2];c[t+12>>2]=c[y+12>>2];c[t+16>>2]=c[y+16>>2];c[t+20>>2]=c[y+20>>2];c[t+24>>2]=c[y+24>>2];c[t+28>>2]=c[y+28>>2];c[y>>2]=c[d>>2];c[y+4>>2]=c[d+4>>2];c[y+8>>2]=c[d+8>>2];c[y+12>>2]=c[d+12>>2];c[y+16>>2]=c[d+16>>2];c[y+20>>2]=c[d+20>>2];c[y+24>>2]=c[d+24>>2];c[y+28>>2]=c[d+28>>2];c[x>>2]=c[v>>2];c[x+4>>2]=c[v+4>>2];c[x+8>>2]=c[v+8>>2];c[x+12>>2]=c[v+12>>2];c[x+16>>2]=c[v+16>>2];c[x+20>>2]=c[v+20>>2];c[x+24>>2]=c[v+24>>2];c[x+28>>2]=c[v+28>>2];Mc(y,x,136,-460954743,-2016278654);c[s>>2]=c[y>>2];c[s+4>>2]=c[y+4>>2];c[s+8>>2]=c[y+8>>2];c[s+12>>2]=c[y+12>>2];c[s+16>>2]=c[y+16>>2];c[s+20>>2]=c[y+20>>2];c[s+24>>2]=c[y+24>>2];c[s+28>>2]=c[y+28>>2];c[y>>2]=c[w>>2];c[y+4>>2]=c[w+4>>2];c[y+8>>2]=c[w+8>>2];c[y+12>>2]=c[w+12>>2];c[y+16>>2]=c[w+16>>2];c[y+20>>2]=c[w+20>>2];c[y+24>>2]=c[w+24>>2];c[y+28>>2]=c[w+28>>2];c[x>>2]=c[v>>2];c[x+4>>2]=c[v+4>>2];c[x+8>>2]=c[v+8>>2];c[x+12>>2]=c[v+12>>2];c[x+16>>2]=c[v+16>>2];c[x+20>>2]=c[v+20>>2];c[x+24>>2]=c[v+24>>2];c[x+28>>2]=c[v+28>>2];Mc(y,x,136,-460954743,-2016278654);c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];c[y>>2]=c[B>>2];c[y+4>>2]=c[B+4>>2];c[y+8>>2]=c[B+8>>2];c[y+12>>2]=c[B+12>>2];c[y+16>>2]=c[B+16>>2];c[y+20>>2]=c[B+20>>2];c[y+24>>2]=c[B+24>>2];c[y+28>>2]=c[B+28>>2];c[x>>2]=c[u>>2];c[x+4>>2]=c[u+4>>2];c[x+8>>2]=c[u+8>>2];c[x+12>>2]=c[u+12>>2];c[x+16>>2]=c[u+16>>2];c[x+20>>2]=c[u+20>>2];c[x+24>>2]=c[u+24>>2];c[x+28>>2]=c[u+28>>2];Mc(y,x,136,-460954743,-2016278654);c[q>>2]=c[y>>2];c[q+4>>2]=c[y+4>>2];c[q+8>>2]=c[y+8>>2];c[q+12>>2]=c[y+12>>2];c[q+16>>2]=c[y+16>>2];c[q+20>>2]=c[y+20>>2];c[q+24>>2]=c[y+24>>2];c[q+28>>2]=c[y+28>>2];G=b+32|0;c[y>>2]=c[G>>2];c[y+4>>2]=c[G+4>>2];c[y+8>>2]=c[G+8>>2];c[y+12>>2]=c[G+12>>2];c[y+16>>2]=c[G+16>>2];c[y+20>>2]=c[G+20>>2];c[y+24>>2]=c[G+24>>2];c[y+28>>2]=c[G+28>>2];c[x>>2]=c[q>>2];c[x+4>>2]=c[q+4>>2];c[x+8>>2]=c[q+8>>2];c[x+12>>2]=c[q+12>>2];c[x+16>>2]=c[q+16>>2];c[x+20>>2]=c[q+20>>2];c[x+24>>2]=c[q+24>>2];c[x+28>>2]=c[q+28>>2];Mc(y,x,136,-460954743,-2016278654);c[p>>2]=c[y>>2];c[p+4>>2]=c[y+4>>2];c[p+8>>2]=c[y+8>>2];c[p+12>>2]=c[y+12>>2];c[p+16>>2]=c[y+16>>2];c[p+20>>2]=c[y+20>>2];c[p+24>>2]=c[y+24>>2];c[p+28>>2]=c[y+28>>2];G=d+32|0;c[y>>2]=c[G>>2];c[y+4>>2]=c[G+4>>2];c[y+8>>2]=c[G+8>>2];c[y+12>>2]=c[G+12>>2];c[y+16>>2]=c[G+16>>2];c[y+20>>2]=c[G+20>>2];c[y+24>>2]=c[G+24>>2];c[y+28>>2]=c[G+28>>2];c[x>>2]=c[r>>2];c[x+4>>2]=c[r+4>>2];c[x+8>>2]=c[r+8>>2];c[x+12>>2]=c[r+12>>2];c[x+16>>2]=c[r+16>>2];c[x+20>>2]=c[r+20>>2];c[x+24>>2]=c[r+24>>2];c[x+28>>2]=c[r+28>>2];Mc(y,x,136,-460954743,-2016278654);c[o>>2]=c[y>>2];c[o+4>>2]=c[y+4>>2];c[o+8>>2]=c[y+8>>2];c[o+12>>2]=c[y+12>>2];c[o+16>>2]=c[y+16>>2];c[o+20>>2]=c[y+20>>2];c[o+24>>2]=c[y+24>>2];c[o+28>>2]=c[y+28>>2];if((Xj(t,s,32)|0)==0?(Xj(p,o,32)|0)==0:0)Bc(a,b);else {c[y>>2]=c[s>>2];c[y+4>>2]=c[s+4>>2];c[y+8>>2]=c[s+8>>2];c[y+12>>2]=c[s+12>>2];c[y+16>>2]=c[s+16>>2];c[y+20>>2]=c[s+20>>2];c[y+24>>2]=c[s+24>>2];c[y+28>>2]=c[s+28>>2];c[x>>2]=c[t>>2];c[x+4>>2]=c[t+4>>2];c[x+8>>2]=c[t+8>>2];c[x+12>>2]=c[t+12>>2];c[x+16>>2]=c[t+16>>2];c[x+20>>2]=c[t+20>>2];c[x+24>>2]=c[t+24>>2];c[x+28>>2]=c[t+28>>2];Lc(y,x,136);c[n>>2]=c[y>>2];c[n+4>>2]=c[y+4>>2];c[n+8>>2]=c[y+8>>2];c[n+12>>2]=c[y+12>>2];c[n+16>>2]=c[y+16>>2];c[n+20>>2]=c[y+20>>2];c[n+24>>2]=c[y+24>>2];c[n+28>>2]=c[y+28>>2];c[y>>2]=c[o>>2];c[y+4>>2]=c[o+4>>2];c[y+8>>2]=c[o+8>>2];c[y+12>>2]=c[o+12>>2];c[y+16>>2]=c[o+16>>2];c[y+20>>2]=c[o+20>>2];c[y+24>>2]=c[o+24>>2];c[y+28>>2]=c[o+28>>2];c[x>>2]=c[p>>2];c[x+4>>2]=c[p+4>>2];c[x+8>>2]=c[p+8>>2];c[x+12>>2]=c[p+12>>2];c[x+16>>2]=c[p+16>>2];c[x+20>>2]=c[p+20>>2];c[x+24>>2]=c[p+24>>2];c[x+28>>2]=c[p+28>>2];Lc(y,x,136);c[m>>2]=c[y>>2];c[m+4>>2]=c[y+4>>2];c[m+8>>2]=c[y+8>>2];c[m+12>>2]=c[y+12>>2];c[m+16>>2]=c[y+16>>2];c[m+20>>2]=c[y+20>>2];c[m+24>>2]=c[y+24>>2];c[m+28>>2]=c[y+28>>2];c[y>>2]=c[n>>2];c[y+4>>2]=c[n+4>>2];c[y+8>>2]=c[n+8>>2];c[y+12>>2]=c[n+12>>2];c[y+16>>2]=c[n+16>>2];c[y+20>>2]=c[n+20>>2];c[y+24>>2]=c[n+24>>2];c[y+28>>2]=c[n+28>>2];c[x>>2]=c[n>>2];c[x+4>>2]=c[n+4>>2];c[x+8>>2]=c[n+8>>2];c[x+12>>2]=c[n+12>>2];c[x+16>>2]=c[n+16>>2];c[x+20>>2]=c[n+20>>2];c[x+24>>2]=c[n+24>>2];c[x+28>>2]=c[n+28>>2];Kc(y,x,136);c[z>>2]=c[y>>2];c[z+4>>2]=c[y+4>>2];c[z+8>>2]=c[y+8>>2];c[z+12>>2]=c[y+12>>2];c[z+16>>2]=c[y+16>>2];c[z+20>>2]=c[y+20>>2];c[z+24>>2]=c[y+24>>2];c[z+28>>2]=c[y+28>>2];c[y>>2]=c[z>>2];c[y+4>>2]=c[z+4>>2];c[y+8>>2]=c[z+8>>2];c[y+12>>2]=c[z+12>>2];c[y+16>>2]=c[z+16>>2];c[y+20>>2]=c[z+20>>2];c[y+24>>2]=c[z+24>>2];c[y+28>>2]=c[z+28>>2];c[x>>2]=c[z>>2];c[x+4>>2]=c[z+4>>2];c[x+8>>2]=c[z+8>>2];c[x+12>>2]=c[z+12>>2];c[x+16>>2]=c[z+16>>2];c[x+20>>2]=c[z+20>>2];c[x+24>>2]=c[z+24>>2];c[x+28>>2]=c[z+28>>2];Mc(y,x,136,-460954743,-2016278654);c[k>>2]=c[y>>2];c[k+4>>2]=c[y+4>>2];c[k+8>>2]=c[y+8>>2];c[k+12>>2]=c[y+12>>2];c[k+16>>2]=c[y+16>>2];c[k+20>>2]=c[y+20>>2];c[k+24>>2]=c[y+24>>2];c[k+28>>2]=c[y+28>>2];c[y>>2]=c[n>>2];c[y+4>>2]=c[n+4>>2];c[y+8>>2]=c[n+8>>2];c[y+12>>2]=c[n+12>>2];c[y+16>>2]=c[n+16>>2];c[y+20>>2]=c[n+20>>2];c[y+24>>2]=c[n+24>>2];c[y+28>>2]=c[n+28>>2];c[x>>2]=c[k>>2];c[x+4>>2]=c[k+4>>2];c[x+8>>2]=c[k+8>>2];c[x+12>>2]=c[k+12>>2];c[x+16>>2]=c[k+16>>2];c[x+20>>2]=c[k+20>>2];c[x+24>>2]=c[k+24>>2];c[x+28>>2]=c[k+28>>2];Mc(y,x,136,-460954743,-2016278654);c[j>>2]=c[y>>2];c[j+4>>2]=c[y+4>>2];c[j+8>>2]=c[y+8>>2];c[j+12>>2]=c[y+12>>2];c[j+16>>2]=c[y+16>>2];c[j+20>>2]=c[y+20>>2];c[j+24>>2]=c[y+24>>2];c[j+28>>2]=c[y+28>>2];c[y>>2]=c[m>>2];c[y+4>>2]=c[m+4>>2];c[y+8>>2]=c[m+8>>2];c[y+12>>2]=c[m+12>>2];c[y+16>>2]=c[m+16>>2];c[y+20>>2]=c[m+20>>2];c[y+24>>2]=c[m+24>>2];c[y+28>>2]=c[m+28>>2];c[x>>2]=c[m>>2];c[x+4>>2]=c[m+4>>2];c[x+8>>2]=c[m+8>>2];c[x+12>>2]=c[m+12>>2];c[x+16>>2]=c[m+16>>2];c[x+20>>2]=c[m+20>>2];c[x+24>>2]=c[m+24>>2];c[x+28>>2]=c[m+28>>2];Kc(y,x,136);c[i>>2]=c[y>>2];c[i+4>>2]=c[y+4>>2];c[i+8>>2]=c[y+8>>2];c[i+12>>2]=c[y+12>>2];c[i+16>>2]=c[y+16>>2];c[i+20>>2]=c[y+20>>2];c[i+24>>2]=c[y+24>>2];c[i+28>>2]=c[y+28>>2];c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];c[x>>2]=c[k>>2];c[x+4>>2]=c[k+4>>2];c[x+8>>2]=c[k+8>>2];c[x+12>>2]=c[k+12>>2];c[x+16>>2]=c[k+16>>2];c[x+20>>2]=c[k+20>>2];c[x+24>>2]=c[k+24>>2];c[x+28>>2]=c[k+28>>2];Mc(y,x,136,-460954743,-2016278654);c[h>>2]=c[y>>2];c[h+4>>2]=c[y+4>>2];c[h+8>>2]=c[y+8>>2];c[h+12>>2]=c[y+12>>2];c[h+16>>2]=c[y+16>>2];c[h+20>>2]=c[y+20>>2];c[h+24>>2]=c[y+24>>2];c[h+28>>2]=c[y+28>>2];c[y>>2]=c[p>>2];c[y+4>>2]=c[p+4>>2];c[y+8>>2]=c[p+8>>2];c[y+12>>2]=c[p+12>>2];c[y+16>>2]=c[p+16>>2];c[y+20>>2]=c[p+20>>2];c[y+24>>2]=c[p+24>>2];c[y+28>>2]=c[p+28>>2];c[x>>2]=c[j>>2];c[x+4>>2]=c[j+4>>2];c[x+8>>2]=c[j+8>>2];c[x+12>>2]=c[j+12>>2];c[x+16>>2]=c[j+16>>2];c[x+20>>2]=c[j+20>>2];c[x+24>>2]=c[j+24>>2];c[x+28>>2]=c[j+28>>2];Mc(y,x,136,-460954743,-2016278654);c[g>>2]=c[y>>2];c[g+4>>2]=c[y+4>>2];c[g+8>>2]=c[y+8>>2];c[g+12>>2]=c[y+12>>2];c[g+16>>2]=c[y+16>>2];c[g+20>>2]=c[y+20>>2];c[g+24>>2]=c[y+24>>2];c[g+28>>2]=c[y+28>>2];c[y>>2]=c[i>>2];c[y+4>>2]=c[i+4>>2];c[y+8>>2]=c[i+8>>2];c[y+12>>2]=c[i+12>>2];c[y+16>>2]=c[i+16>>2];c[y+20>>2]=c[i+20>>2];c[y+24>>2]=c[i+24>>2];c[y+28>>2]=c[i+28>>2];c[x>>2]=c[i>>2];c[x+4>>2]=c[i+4>>2];c[x+8>>2]=c[i+8>>2];c[x+12>>2]=c[i+12>>2];c[x+16>>2]=c[i+16>>2];c[x+20>>2]=c[i+20>>2];c[x+24>>2]=c[i+24>>2];c[x+28>>2]=c[i+28>>2];Mc(y,x,136,-460954743,-2016278654);c[z>>2]=c[y>>2];c[z+4>>2]=c[y+4>>2];c[z+8>>2]=c[y+8>>2];c[z+12>>2]=c[y+12>>2];c[z+16>>2]=c[y+16>>2];c[z+20>>2]=c[y+20>>2];c[z+24>>2]=c[y+24>>2];c[z+28>>2]=c[y+28>>2];c[x>>2]=c[j>>2];c[x+4>>2]=c[j+4>>2];c[x+8>>2]=c[j+8>>2];c[x+12>>2]=c[j+12>>2];c[x+16>>2]=c[j+16>>2];c[x+20>>2]=c[j+20>>2];c[x+24>>2]=c[j+24>>2];c[x+28>>2]=c[j+28>>2];Lc(z,x,136);c[A>>2]=c[z>>2];c[A+4>>2]=c[z+4>>2];c[A+8>>2]=c[z+8>>2];c[A+12>>2]=c[z+12>>2];c[A+16>>2]=c[z+16>>2];c[A+20>>2]=c[z+20>>2];c[A+24>>2]=c[z+24>>2];c[A+28>>2]=c[z+28>>2];c[y>>2]=c[h>>2];c[y+4>>2]=c[h+4>>2];c[y+8>>2]=c[h+8>>2];c[y+12>>2]=c[h+12>>2];c[y+16>>2]=c[h+16>>2];c[y+20>>2]=c[h+20>>2];c[y+24>>2]=c[h+24>>2];c[y+28>>2]=c[h+28>>2];c[x>>2]=c[h>>2];c[x+4>>2]=c[h+4>>2];c[x+8>>2]=c[h+8>>2];c[x+12>>2]=c[h+12>>2];c[x+16>>2]=c[h+16>>2];c[x+20>>2]=c[h+20>>2];c[x+24>>2]=c[h+24>>2];c[x+28>>2]=c[h+28>>2];Kc(y,x,136);c[z>>2]=c[y>>2];c[z+4>>2]=c[y+4>>2];c[z+8>>2]=c[y+8>>2];c[z+12>>2]=c[y+12>>2];c[z+16>>2]=c[y+16>>2];c[z+20>>2]=c[y+20>>2];c[z+24>>2]=c[y+24>>2];c[z+28>>2]=c[y+28>>2];Lc(A,z,136);c[f>>2]=c[A>>2];c[f+4>>2]=c[A+4>>2];c[f+8>>2]=c[A+8>>2];c[f+12>>2]=c[A+12>>2];c[f+16>>2]=c[A+16>>2];c[f+20>>2]=c[A+20>>2];c[f+24>>2]=c[A+24>>2];c[f+28>>2]=c[A+28>>2];c[a>>2]=c[f>>2];c[a+4>>2]=c[f+4>>2];c[a+8>>2]=c[f+8>>2];c[a+12>>2]=c[f+12>>2];c[a+16>>2]=c[f+16>>2];c[a+20>>2]=c[f+20>>2];c[a+24>>2]=c[f+24>>2];c[a+28>>2]=c[f+28>>2];c[A>>2]=c[i>>2];c[A+4>>2]=c[i+4>>2];c[A+8>>2]=c[i+8>>2];c[A+12>>2]=c[i+12>>2];c[A+16>>2]=c[i+16>>2];c[A+20>>2]=c[i+20>>2];c[A+24>>2]=c[i+24>>2];c[A+28>>2]=c[i+28>>2];c[y>>2]=c[h>>2];c[y+4>>2]=c[h+4>>2];c[y+8>>2]=c[h+8>>2];c[y+12>>2]=c[h+12>>2];c[y+16>>2]=c[h+16>>2];c[y+20>>2]=c[h+20>>2];c[y+24>>2]=c[h+24>>2];c[y+28>>2]=c[h+28>>2];c[x>>2]=c[f>>2];c[x+4>>2]=c[f+4>>2];c[x+8>>2]=c[f+8>>2];c[x+12>>2]=c[f+12>>2];c[x+16>>2]=c[f+16>>2];c[x+20>>2]=c[f+20>>2];c[x+24>>2]=c[f+24>>2];c[x+28>>2]=c[f+28>>2];Lc(y,x,136);c[z>>2]=c[y>>2];c[z+4>>2]=c[y+4>>2];c[z+8>>2]=c[y+8>>2];c[z+12>>2]=c[y+12>>2];c[z+16>>2]=c[y+16>>2];c[z+20>>2]=c[y+20>>2];c[z+24>>2]=c[y+24>>2];c[z+28>>2]=c[y+28>>2];Mc(A,z,136,-460954743,-2016278654);c[C>>2]=c[A>>2];c[C+4>>2]=c[A+4>>2];c[C+8>>2]=c[A+8>>2];c[C+12>>2]=c[A+12>>2];c[C+16>>2]=c[A+16>>2];c[C+20>>2]=c[A+20>>2];c[C+24>>2]=c[A+24>>2];c[C+28>>2]=c[A+28>>2];c[y>>2]=c[g>>2];c[y+4>>2]=c[g+4>>2];c[y+8>>2]=c[g+8>>2];c[y+12>>2]=c[g+12>>2];c[y+16>>2]=c[g+16>>2];c[y+20>>2]=c[g+20>>2];c[y+24>>2]=c[g+24>>2];c[y+28>>2]=c[g+28>>2];c[x>>2]=c[g>>2];c[x+4>>2]=c[g+4>>2];c[x+8>>2]=c[g+8>>2];c[x+12>>2]=c[g+12>>2];c[x+16>>2]=c[g+16>>2];c[x+20>>2]=c[g+20>>2];c[x+24>>2]=c[g+24>>2];c[x+28>>2]=c[g+28>>2];Kc(y,x,136);c[z>>2]=c[y>>2];c[z+4>>2]=c[y+4>>2];c[z+8>>2]=c[y+8>>2];c[z+12>>2]=c[y+12>>2];c[z+16>>2]=c[y+16>>2];c[z+20>>2]=c[y+20>>2];c[z+24>>2]=c[y+24>>2];c[z+28>>2]=c[y+28>>2];Lc(C,z,136);c[e>>2]=c[C>>2];c[e+4>>2]=c[C+4>>2];c[e+8>>2]=c[C+8>>2];c[e+12>>2]=c[C+12>>2];c[e+16>>2]=c[C+16>>2];c[e+20>>2]=c[C+20>>2];c[e+24>>2]=c[C+24>>2];c[e+28>>2]=c[C+28>>2];c[y>>2]=c[w>>2];c[y+4>>2]=c[w+4>>2];c[y+8>>2]=c[w+8>>2];c[y+12>>2]=c[w+12>>2];c[y+16>>2]=c[w+16>>2];c[y+20>>2]=c[w+20>>2];c[y+24>>2]=c[w+24>>2];c[y+28>>2]=c[w+28>>2];c[x>>2]=c[B>>2];c[x+4>>2]=c[B+4>>2];c[x+8>>2]=c[B+8>>2];c[x+12>>2]=c[B+12>>2];c[x+16>>2]=c[B+16>>2];c[x+20>>2]=c[B+20>>2];c[x+24>>2]=c[B+24>>2];c[x+28>>2]=c[B+28>>2];Kc(y,x,136);c[z>>2]=c[y>>2];c[z+4>>2]=c[y+4>>2];c[z+8>>2]=c[y+8>>2];c[z+12>>2]=c[y+12>>2];c[z+16>>2]=c[y+16>>2];c[z+20>>2]=c[y+20>>2];c[z+24>>2]=c[y+24>>2];c[z+28>>2]=c[y+28>>2];c[y>>2]=c[z>>2];c[y+4>>2]=c[z+4>>2];c[y+8>>2]=c[z+8>>2];c[y+12>>2]=c[z+12>>2];c[y+16>>2]=c[z+16>>2];c[y+20>>2]=c[z+20>>2];c[y+24>>2]=c[z+24>>2];c[y+28>>2]=c[z+28>>2];c[x>>2]=c[z>>2];c[x+4>>2]=c[z+4>>2];c[x+8>>2]=c[z+8>>2];c[x+12>>2]=c[z+12>>2];c[x+16>>2]=c[z+16>>2];c[x+20>>2]=c[z+20>>2];c[x+24>>2]=c[z+24>>2];c[x+28>>2]=c[z+28>>2];Mc(y,x,136,-460954743,-2016278654);c[A>>2]=c[y>>2];c[A+4>>2]=c[y+4>>2];c[A+8>>2]=c[y+8>>2];c[A+12>>2]=c[y+12>>2];c[A+16>>2]=c[y+16>>2];c[A+20>>2]=c[y+20>>2];c[A+24>>2]=c[y+24>>2];c[A+28>>2]=c[y+28>>2];c[x>>2]=c[v>>2];c[x+4>>2]=c[v+4>>2];c[x+8>>2]=c[v+8>>2];c[x+12>>2]=c[v+12>>2];c[x+16>>2]=c[v+16>>2];c[x+20>>2]=c[v+20>>2];c[x+24>>2]=c[v+24>>2];c[x+28>>2]=c[v+28>>2];Lc(A,x,136);c[C>>2]=c[A>>2];c[C+4>>2]=c[A+4>>2];c[C+8>>2]=c[A+8>>2];c[C+12>>2]=c[A+12>>2];c[C+16>>2]=c[A+16>>2];c[C+20>>2]=c[A+20>>2];c[C+24>>2]=c[A+24>>2];c[C+28>>2]=c[A+28>>2];c[x>>2]=c[u>>2];c[x+4>>2]=c[u+4>>2];c[x+8>>2]=c[u+8>>2];c[x+12>>2]=c[u+12>>2];c[x+16>>2]=c[u+16>>2];c[x+20>>2]=c[u+20>>2];c[x+24>>2]=c[u+24>>2];c[x+28>>2]=c[u+28>>2];Lc(C,x,136);c[D>>2]=c[C>>2];c[D+4>>2]=c[C+4>>2];c[D+8>>2]=c[C+8>>2];c[D+12>>2]=c[C+12>>2];c[D+16>>2]=c[C+16>>2];c[D+20>>2]=c[C+20>>2];c[D+24>>2]=c[C+24>>2];c[D+28>>2]=c[C+28>>2];c[x>>2]=c[n>>2];c[x+4>>2]=c[n+4>>2];c[x+8>>2]=c[n+8>>2];c[x+12>>2]=c[n+12>>2];c[x+16>>2]=c[n+16>>2];c[x+20>>2]=c[n+20>>2];c[x+24>>2]=c[n+24>>2];c[x+28>>2]=c[n+28>>2];Mc(D,x,136,-460954743,-2016278654);c[E>>2]=c[D>>2];c[E+4>>2]=c[D+4>>2];c[E+8>>2]=c[D+8>>2];c[E+12>>2]=c[D+12>>2];c[E+16>>2]=c[D+16>>2];c[E+20>>2]=c[D+20>>2];c[E+24>>2]=c[D+24>>2];c[E+28>>2]=c[D+28>>2];G=a+32|0;c[G>>2]=c[e>>2];c[G+4>>2]=c[e+4>>2];c[G+8>>2]=c[e+8>>2];c[G+12>>2]=c[e+12>>2];c[G+16>>2]=c[e+16>>2];c[G+20>>2]=c[e+20>>2];c[G+24>>2]=c[e+24>>2];c[G+28>>2]=c[e+28>>2];G=a+64|0;c[G>>2]=c[E>>2];c[G+4>>2]=c[E+4>>2];c[G+8>>2]=c[E+8>>2];c[G+12>>2]=c[E+12>>2];c[G+16>>2]=c[E+16>>2];c[G+20>>2]=c[E+20>>2];c[G+24>>2]=c[E+24>>2];c[G+28>>2]=c[E+28>>2];}l=F;return}function Ec(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,Y=0,$=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,_b=0,$b=0,ac=0,bc=0,cc=0,dc=0,ec=0,fc=0,gc=0,hc=0,ic=0,jc=0,kc=0,lc=0,mc=0,nc=0,oc=0,pc=0,qc=0,rc=0,sc=0,tc=0,uc=0,vc=0,wc=0,xc=0,yc=0,Bc=0,Cc=0,Dc=0,Ec=0,Fc=0,Ic=0,Jc=0,Kc=0,Lc=0,Mc=0,Nc=0,Oc=0,Pc=0,Qc=0,Rc=0,Sc=0,Tc=0,Uc=0,Vc=0,Wc=0,Xc=0,Yc=0,Zc=0,_c=0,$c=0,ad=0,bd=0,cd=0,dd=0,ed=0,fd=0,gd=0,hd=0,id=0,jd=0,kd=0,ld=0,md=0,nd=0,od=0,pd=0,qd=0,rd=0,sd=0,td=0,ud=0,vd=0,wd=0,xd=0,yd=0,zd=0,Ad=0,Bd=0,Cd=0,Dd=0,Ed=0,Fd=0,Gd=0,Hd=0,Id=0,Jd=0,Kd=0,Ld=0,Md=0,Nd=0,Od=0,Pd=0,Qd=0,Rd=0,Sd=0,Td=0,Ud=0,Vd=0,Wd=0,Xd=0,Yd=0,Zd=0,_d=0,$d=0,ae=0,be=0,ce=0;ce=l;l=l+12736|0;Xc=ce+12576|0;bd=ce+12504|0;fd=ce+12472|0;qd=ce+12440|0;sd=ce+12408|0;td=ce+12376|0;ud=ce+12344|0;Tc=ce+12312|0;vd=ce+12280|0;wd=ce+12248|0;xd=ce+12216|0;yd=ce+12184|0;zd=ce+12152|0;Ad=ce+12120|0;Cd=ce+12088|0;Hd=ce+12056|0;Id=ce+12024|0;Jd=ce+11992|0;Kd=ce+11960|0;Ld=ce+11928|0;Md=ce+11896|0;Nd=ce+11864|0;Od=ce+11832|0;Pd=ce+11800|0;Uc=ce+11768|0;Vc=ce+11736|0;Wc=ce+11704|0;Yc=ce+11672|0;Zc=ce+11640|0;_c=ce+11608|0;$c=ce+11576|0;ad=ce+11544|0;Qd=ce+11512|0;Rd=ce+11448|0;Sd=ce+11416|0;Td=ce+11352|0;Ud=ce+11288|0;Vd=ce+10904|0;Wd=ce+10872|0;Xd=ce+10808|0;Yd=ce+10776|0;Zd=ce+10712|0;_d=ce+10648|0;$d=ce+10264|0;cd=ce+10232|0;dd=ce+10168|0;ed=ce+10136|0;gd=ce+10072|0;hd=ce+10008|0;id=ce+9624|0;jd=ce+9592|0;kd=ce+9528|0;ld=ce+9496|0;md=ce+9432|0;nd=ce+9368|0;od=ce+8984|0;pd=ce+8600|0;rd=ce+8568|0;ae=ce+8184|0;Nb=ce+8152|0;Ob=ce+8120|0;Pb=ce+8088|0;Qb=ce+8056|0;Rb=ce+8024|0;Sb=ce+7992|0;Tb=ce+7960|0;Ub=ce+7928|0;Vb=ce+7896|0;Wb=ce+7864|0;_b=ce+7832|0;$b=ce+7800|0;ac=ce+7768|0;bc=ce+7736|0;cc=ce+7704|0;dc=ce+7672|0;ec=ce+7640|0;sc=ce+7608|0;tc=ce+7576|0;uc=ce+7544|0;vc=ce+7512|0;be=ce+7480|0;Ic=ce+7416|0;Jc=ce+7352|0;xc=ce+7288|0;yc=ce+7224|0;Kc=ce+7160|0;Bc=ce+7096|0;Cc=ce+7032|0;Dc=ce+6968|0;fc=ce+6904|0;gc=ce+6840|0;hc=ce+6776|0;ic=ce+6712|0;jc=ce+6648|0;kc=ce+6584|0;lc=ce+6520|0;mc=ce+6456|0;Ka=ce+6392|0;La=ce+6328|0;Ma=ce+6264|0;Na=ce+6200|0;Oa=ce+6136|0;Pa=ce+6072|0;Qa=ce+6008|0;Ra=ce+5944|0;Sa=ce+5880|0;Ta=ce+5816|0;Ua=ce+5752|0;Va=ce+5688|0;Wa=ce+5624|0;Xa=ce+5560|0;Ya=ce+5496|0;Za=ce+5432|0;_a=ce+5368|0;$a=ce+5304|0;ab=ce+5240|0;bb=ce+5176|0;cb=ce+5112|0;db=ce+5048|0;eb=ce+4984|0;fb=ce+4920|0;gb=ce+4856|0;hb=ce+4792|0;ib=ce+4728|0;jb=ce+4664|0;kb=ce+4600|0;lb=ce+4536|0;mb=ce+4472|0;nb=ce+4408|0;ob=ce+4344|0;pb=ce+4280|0;qb=ce+4216|0;rb=ce+4152|0;sb=ce+4088|0;tb=ce+4024|0;ub=ce+3960|0;vb=ce+3896|0;wb=ce+3832|0;xb=ce+3768|0;yb=ce+3704|0;zb=ce+3640|0;Ab=ce+3576|0;Bb=ce+3512|0;Cb=ce+3448|0;Db=ce+3384|0;Eb=ce+3320|0;Fb=ce+3256|0;Gb=ce+3192|0;Hb=ce+3128|0;Ib=ce+3064|0;nc=ce+3e3|0;oc=ce+2936|0;wc=ce+2872|0;pc=ce+2808|0;qc=ce+2744|0;rc=ce+2680|0;Rc=ce+2488|0;Lc=ce+2296|0;Ec=ce+2168|0;Mc=ce+2040|0;Fc=ce+1912|0;Jb=ce+1720|0;Kb=ce+1528|0;Lb=ce+1496|0;Sc=ce+12712|0;Nc=ce+1304|0;Bd=ce+1160|0;Dd=ce+776|0;Ed=ce+384|0;Fd=ce+256|0;Gd=ce+192|0;e=ce+128|0;f=ce;Ac(bd,b);zc(Xc,d);b=c[bd>>2]|0;Oc=e;Pc=bd+8|0;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));d=c[Xc>>2]|0;Oc=f;Pc=Xc+8|0;Qc=Oc+128|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));if((b|0)==0|(d|0)==0){be=a;c[be>>2]=-980480611;c[be+4>>2]=-748862579;be=a+8|0;c[be>>2]=-171504835;c[be+4>>2]=175696680;be=a+16|0;c[be>>2]=2021213740;c[be+4>>2]=1718526831;be=a+24|0;c[be>>2]=-1710760145;c[be+4>>2]=235567041;hk(a+32|0,0,352)|0;l=ce;return}Oc=Fd;Pc=f;Qc=Oc+128|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Gd;Pc=e;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Nc;Pc=f;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Ia=Fd+64|0;Ga=Nc+64|0;Oc=Ga;Pc=Ia;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Ha=Nc+128|0;b=Nc+128|0;c[b>>2]=-980480611;c[b+4>>2]=-748862579;b=Nc+136|0;c[b>>2]=-171504835;c[b+4>>2]=175696680;b=Nc+144|0;c[b>>2]=2021213740;c[b+4>>2]=1718526831;b=Nc+152|0;c[b>>2]=-1710760145;c[b+4>>2]=235567041;b=Nc+160|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;c[b+24>>2]=0;c[b+28>>2]=0;b=Xb(19584,8,Xc)|0;if(!b){c[Xc>>2]=0;Yb(Xc);}c[Sc>>2]=b;Ja=Sc+4|0;c[Ja>>2]=102;Mb=Sc+8|0;c[Mb>>2]=0;e=Lb;c[e>>2]=-1099547736;c[e+4>>2]=-1652985799;e=Lb+8|0;c[e>>2]=1;c[e+4>>2]=0;e=Lb+16|0;c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;e=Kb+64|0;f=Kb+128|0;g=dc+8|0;h=dc+16|0;i=dc+24|0;j=Hb+32|0;k=bc+8|0;m=bc+16|0;o=bc+24|0;p=Ib+32|0;q=Ab+32|0;r=zb+32|0;s=Bb+32|0;t=yb+32|0;u=Cb+32|0;v=wb+8|0;w=wb+16|0;x=wb+24|0;z=wb+32|0;A=wb+40|0;B=wb+48|0;C=wb+56|0;D=sb+32|0;E=rb+32|0;F=tb+32|0;G=qb+32|0;H=ub+32|0;I=nb+32|0;J=mb+32|0;K=ob+32|0;L=jd+8|0;M=jd+16|0;N=jd+24|0;O=hd+8|0;P=hd+16|0;Q=hd+24|0;R=pb+32|0;S=ib+32|0;T=hb+32|0;U=jb+32|0;V=fb+32|0;W=eb+32|0;Y=gb+32|0;$=kb+32|0;ba=lb+32|0;ca=cb+32|0;da=bb+32|0;ea=db+32|0;fa=Xa+32|0;ga=Wa+32|0;ha=Ya+32|0;ia=Ra+32|0;ja=Qa+32|0;ka=Sa+32|0;la=Pa+32|0;ma=Ta+32|0;oa=Ua+32|0;pa=Va+32|0;qa=Ka+8|0;ra=Ka+16|0;sa=Ka+24|0;ta=Ka+32|0;ua=Ka+40|0;va=Ka+48|0;wa=Ka+56|0;xa=kc+32|0;ya=lc+32|0;Aa=hc+32|0;Ba=gc+32|0;Ca=ic+32|0;Da=fc+32|0;Ea=jc+32|0;b=0;Fa=256;a:while(1){Fa=Fa+-1|0;d=Lb+(Fa>>>6<<3)|0;Pc=c[d>>2]|0;d=c[d+4>>2]|0;Qc=nk(1,0,Fa&63|0)|0;d=(Pc&Qc|0)!=0|(d&y|0)!=0;do if(b){Oc=Gb;Pc=Nc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Fb;Pc=Ga;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));n=0;aa(15,Hb|0,Gb|0,Fb|0);Qc=n;n=0;if(Qc&1){b=82;break a};c[ec>>2]=c[Hb>>2];c[ec+4>>2]=c[Hb+4>>2];c[ec+8>>2]=c[Hb+8>>2];c[ec+12>>2]=c[Hb+12>>2];c[ec+16>>2]=c[Hb+16>>2];c[ec+20>>2]=c[Hb+20>>2];c[ec+24>>2]=c[Hb+24>>2];c[ec+28>>2]=c[Hb+28>>2];Qc=dc;c[Qc>>2]=1325794674;c[Qc+4>>2]=-2017531950;Qc=g;c[Qc>>2]=790391525;c[Qc+4>>2]=-788714787;Qc=h;c[Qc>>2]=-50507964;c[Qc+4>>2]=-1889569646;Qc=i;c[Qc>>2]=1033682860;c[Qc+4>>2]=523723546;n=0;X(1,ec|0,dc|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){b=82;break a};c[Ib>>2]=c[ec>>2];c[Ib+4>>2]=c[ec+4>>2];c[Ib+8>>2]=c[ec+8>>2];c[Ib+12>>2]=c[ec+12>>2];c[Ib+16>>2]=c[ec+16>>2];c[Ib+20>>2]=c[ec+20>>2];c[Ib+24>>2]=c[ec+24>>2];c[Ib+28>>2]=c[ec+28>>2];c[cc>>2]=c[j>>2];c[cc+4>>2]=c[j+4>>2];c[cc+8>>2]=c[j+8>>2];c[cc+12>>2]=c[j+12>>2];c[cc+16>>2]=c[j+16>>2];c[cc+20>>2]=c[j+20>>2];c[cc+24>>2]=c[j+24>>2];c[cc+28>>2]=c[j+28>>2];Qc=bc;c[Qc>>2]=1325794674;c[Qc+4>>2]=-2017531950;Qc=k;c[Qc>>2]=790391525;c[Qc+4>>2]=-788714787;Qc=m;c[Qc>>2]=-50507964;c[Qc+4>>2]=-1889569646;Qc=o;c[Qc>>2]=1033682860;c[Qc+4>>2]=523723546;n=0;X(1,cc|0,bc|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[cc>>2];c[be+4>>2]=c[cc+4>>2];c[be+8>>2]=c[cc+8>>2];c[be+12>>2]=c[cc+12>>2];c[be+16>>2]=c[cc+16>>2];c[be+20>>2]=c[cc+20>>2];c[be+24>>2]=c[cc+24>>2];c[be+28>>2]=c[cc+28>>2];c[p>>2]=c[be>>2];c[p+4>>2]=c[be+4>>2];c[p+8>>2]=c[be+8>>2];c[p+12>>2]=c[be+12>>2];c[p+16>>2]=c[be+16>>2];c[p+20>>2]=c[be+20>>2];c[p+24>>2]=c[be+24>>2];c[p+28>>2]=c[be+28>>2];n=0;_(17,Eb|0,Ga|0);Qc=n;n=0;if(Qc&1){b=82;break a}n=0;_(17,Db|0,Ha|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=Ab;Pc=Db;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=zb;Pc=Db;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[ac>>2]=c[Ab>>2];c[ac+4>>2]=c[Ab+4>>2];c[ac+8>>2]=c[Ab+8>>2];c[ac+12>>2]=c[Ab+12>>2];c[ac+16>>2]=c[Ab+16>>2];c[ac+20>>2]=c[Ab+20>>2];c[ac+24>>2]=c[Ab+24>>2];c[ac+28>>2]=c[Ab+28>>2];c[$b>>2]=c[Db>>2];c[$b+4>>2]=c[Db+4>>2];c[$b+8>>2]=c[Db+8>>2];c[$b+12>>2]=c[Db+12>>2];c[$b+16>>2]=c[Db+16>>2];c[$b+20>>2]=c[Db+20>>2];c[$b+24>>2]=c[Db+24>>2];c[$b+28>>2]=c[Db+28>>2];n=0;aa(16,ac|0,$b|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[Bb>>2]=c[ac>>2];c[Bb+4>>2]=c[ac+4>>2];c[Bb+8>>2]=c[ac+8>>2];c[Bb+12>>2]=c[ac+12>>2];c[Bb+16>>2]=c[ac+16>>2];c[Bb+20>>2]=c[ac+20>>2];c[Bb+24>>2]=c[ac+24>>2];c[Bb+28>>2]=c[ac+28>>2];c[_b>>2]=c[q>>2];c[_b+4>>2]=c[q+4>>2];c[_b+8>>2]=c[q+8>>2];c[_b+12>>2]=c[q+12>>2];c[_b+16>>2]=c[q+16>>2];c[_b+20>>2]=c[q+20>>2];c[_b+24>>2]=c[q+24>>2];c[_b+28>>2]=c[q+28>>2];c[Wb>>2]=c[r>>2];c[Wb+4>>2]=c[r+4>>2];c[Wb+8>>2]=c[r+8>>2];c[Wb+12>>2]=c[r+12>>2];c[Wb+16>>2]=c[r+16>>2];c[Wb+20>>2]=c[r+20>>2];c[Wb+24>>2]=c[r+24>>2];c[Wb+28>>2]=c[r+28>>2];n=0;aa(16,_b|0,Wb|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[_b>>2];c[be+4>>2]=c[_b+4>>2];c[be+8>>2]=c[_b+8>>2];c[be+12>>2]=c[_b+12>>2];c[be+16>>2]=c[_b+16>>2];c[be+20>>2]=c[_b+20>>2];c[be+24>>2]=c[_b+24>>2];c[be+28>>2]=c[_b+28>>2];c[s>>2]=c[be>>2];c[s+4>>2]=c[be+4>>2];c[s+8>>2]=c[be+8>>2];c[s+12>>2]=c[be+12>>2];c[s+16>>2]=c[be+16>>2];c[s+20>>2]=c[be+20>>2];c[s+24>>2]=c[be+24>>2];c[s+28>>2]=c[be+28>>2];Oc=yb;Pc=Db;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Vb>>2]=c[Bb>>2];c[Vb+4>>2]=c[Bb+4>>2];c[Vb+8>>2]=c[Bb+8>>2];c[Vb+12>>2]=c[Bb+12>>2];c[Vb+16>>2]=c[Bb+16>>2];c[Vb+20>>2]=c[Bb+20>>2];c[Vb+24>>2]=c[Bb+24>>2];c[Vb+28>>2]=c[Bb+28>>2];c[Ub>>2]=c[Db>>2];c[Ub+4>>2]=c[Db+4>>2];c[Ub+8>>2]=c[Db+8>>2];c[Ub+12>>2]=c[Db+12>>2];c[Ub+16>>2]=c[Db+16>>2];c[Ub+20>>2]=c[Db+20>>2];c[Ub+24>>2]=c[Db+24>>2];c[Ub+28>>2]=c[Db+28>>2];n=0;aa(16,Vb|0,Ub|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[Cb>>2]=c[Vb>>2];c[Cb+4>>2]=c[Vb+4>>2];c[Cb+8>>2]=c[Vb+8>>2];c[Cb+12>>2]=c[Vb+12>>2];c[Cb+16>>2]=c[Vb+16>>2];c[Cb+20>>2]=c[Vb+20>>2];c[Cb+24>>2]=c[Vb+24>>2];c[Cb+28>>2]=c[Vb+28>>2];c[Tb>>2]=c[s>>2];c[Tb+4>>2]=c[s+4>>2];c[Tb+8>>2]=c[s+8>>2];c[Tb+12>>2]=c[s+12>>2];c[Tb+16>>2]=c[s+16>>2];c[Tb+20>>2]=c[s+20>>2];c[Tb+24>>2]=c[s+24>>2];c[Tb+28>>2]=c[s+28>>2];c[Sb>>2]=c[t>>2];c[Sb+4>>2]=c[t+4>>2];c[Sb+8>>2]=c[t+8>>2];c[Sb+12>>2]=c[t+12>>2];c[Sb+16>>2]=c[t+16>>2];c[Sb+20>>2]=c[t+20>>2];c[Sb+24>>2]=c[t+24>>2];c[Sb+28>>2]=c[t+28>>2];n=0;aa(16,Tb|0,Sb|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Tb>>2];c[be+4>>2]=c[Tb+4>>2];c[be+8>>2]=c[Tb+8>>2];c[be+12>>2]=c[Tb+12>>2];c[be+16>>2]=c[Tb+16>>2];c[be+20>>2]=c[Tb+20>>2];c[be+24>>2]=c[Tb+24>>2];c[be+28>>2]=c[Tb+28>>2];c[u>>2]=c[be>>2];c[u+4>>2]=c[be+4>>2];c[u+8>>2]=c[be+8>>2];c[u+12>>2]=c[be+12>>2];c[u+16>>2]=c[be+16>>2];c[u+20>>2]=c[be+20>>2];c[u+24>>2]=c[be+24>>2];c[u+28>>2]=c[be+28>>2];Oc=wb;c[Oc>>2]=2008548008;c[Oc+4>>2]=1006188771;Oc=v;c[Oc>>2]=909333341;c[Oc+4>>2]=34282279;Oc=w;c[Oc>>2]=1232425568;c[Oc+4>>2]=649588208;Oc=x;c[Oc>>2]=1132767341;c[Oc+4>>2]=622118450;Oc=z;c[Oc>>2]=-774045849;c[Oc+4>>2]=954723532;Oc=A;c[Oc>>2]=-1815212738;c[Oc+4>>2]=1710273405;Oc=B;c[Oc>>2]=581697706;c[Oc+4>>2]=-683028259;Oc=C;c[Oc>>2]=1248365901;c[Oc+4>>2]=21084622;Oc=vb;Pc=Cb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));n=0;aa(15,xb|0,wb|0,vb|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=sb;Pc=xb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=rb;Pc=xb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Rb>>2]=c[sb>>2];c[Rb+4>>2]=c[sb+4>>2];c[Rb+8>>2]=c[sb+8>>2];c[Rb+12>>2]=c[sb+12>>2];c[Rb+16>>2]=c[sb+16>>2];c[Rb+20>>2]=c[sb+20>>2];c[Rb+24>>2]=c[sb+24>>2];c[Rb+28>>2]=c[sb+28>>2];c[Qb>>2]=c[xb>>2];c[Qb+4>>2]=c[xb+4>>2];c[Qb+8>>2]=c[xb+8>>2];c[Qb+12>>2]=c[xb+12>>2];c[Qb+16>>2]=c[xb+16>>2];c[Qb+20>>2]=c[xb+20>>2];c[Qb+24>>2]=c[xb+24>>2];c[Qb+28>>2]=c[xb+28>>2];n=0;aa(16,Rb|0,Qb|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[tb>>2]=c[Rb>>2];c[tb+4>>2]=c[Rb+4>>2];c[tb+8>>2]=c[Rb+8>>2];c[tb+12>>2]=c[Rb+12>>2];c[tb+16>>2]=c[Rb+16>>2];c[tb+20>>2]=c[Rb+20>>2];c[tb+24>>2]=c[Rb+24>>2];c[tb+28>>2]=c[Rb+28>>2];c[Pb>>2]=c[D>>2];c[Pb+4>>2]=c[D+4>>2];c[Pb+8>>2]=c[D+8>>2];c[Pb+12>>2]=c[D+12>>2];c[Pb+16>>2]=c[D+16>>2];c[Pb+20>>2]=c[D+20>>2];c[Pb+24>>2]=c[D+24>>2];c[Pb+28>>2]=c[D+28>>2];c[Ob>>2]=c[E>>2];c[Ob+4>>2]=c[E+4>>2];c[Ob+8>>2]=c[E+8>>2];c[Ob+12>>2]=c[E+12>>2];c[Ob+16>>2]=c[E+16>>2];c[Ob+20>>2]=c[E+20>>2];c[Ob+24>>2]=c[E+24>>2];c[Ob+28>>2]=c[E+28>>2];n=0;aa(16,Pb|0,Ob|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Pb>>2];c[be+4>>2]=c[Pb+4>>2];c[be+8>>2]=c[Pb+8>>2];c[be+12>>2]=c[Pb+12>>2];c[be+16>>2]=c[Pb+16>>2];c[be+20>>2]=c[Pb+20>>2];c[be+24>>2]=c[Pb+24>>2];c[be+28>>2]=c[Pb+28>>2];c[F>>2]=c[be>>2];c[F+4>>2]=c[be+4>>2];c[F+8>>2]=c[be+8>>2];c[F+12>>2]=c[be+12>>2];c[F+16>>2]=c[be+16>>2];c[F+20>>2]=c[be+20>>2];c[F+24>>2]=c[be+24>>2];c[F+28>>2]=c[be+28>>2];Oc=qb;Pc=xb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Nb>>2]=c[tb>>2];c[Nb+4>>2]=c[tb+4>>2];c[Nb+8>>2]=c[tb+8>>2];c[Nb+12>>2]=c[tb+12>>2];c[Nb+16>>2]=c[tb+16>>2];c[Nb+20>>2]=c[tb+20>>2];c[Nb+24>>2]=c[tb+24>>2];c[Nb+28>>2]=c[tb+28>>2];c[ae>>2]=c[xb>>2];c[ae+4>>2]=c[xb+4>>2];c[ae+8>>2]=c[xb+8>>2];c[ae+12>>2]=c[xb+12>>2];c[ae+16>>2]=c[xb+16>>2];c[ae+20>>2]=c[xb+20>>2];c[ae+24>>2]=c[xb+24>>2];c[ae+28>>2]=c[xb+28>>2];n=0;aa(16,Nb|0,ae|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[ub>>2]=c[Nb>>2];c[ub+4>>2]=c[Nb+4>>2];c[ub+8>>2]=c[Nb+8>>2];c[ub+12>>2]=c[Nb+12>>2];c[ub+16>>2]=c[Nb+16>>2];c[ub+20>>2]=c[Nb+20>>2];c[ub+24>>2]=c[Nb+24>>2];c[ub+28>>2]=c[Nb+28>>2];c[rd>>2]=c[F>>2];c[rd+4>>2]=c[F+4>>2];c[rd+8>>2]=c[F+8>>2];c[rd+12>>2]=c[F+12>>2];c[rd+16>>2]=c[F+16>>2];c[rd+20>>2]=c[F+20>>2];c[rd+24>>2]=c[F+24>>2];c[rd+28>>2]=c[F+28>>2];c[pd>>2]=c[G>>2];c[pd+4>>2]=c[G+4>>2];c[pd+8>>2]=c[G+8>>2];c[pd+12>>2]=c[G+12>>2];c[pd+16>>2]=c[G+16>>2];c[pd+20>>2]=c[G+20>>2];c[pd+24>>2]=c[G+24>>2];c[pd+28>>2]=c[G+28>>2];n=0;aa(16,rd|0,pd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[rd>>2];c[be+4>>2]=c[rd+4>>2];c[be+8>>2]=c[rd+8>>2];c[be+12>>2]=c[rd+12>>2];c[be+16>>2]=c[rd+16>>2];c[be+20>>2]=c[rd+20>>2];c[be+24>>2]=c[rd+24>>2];c[be+28>>2]=c[rd+28>>2];c[H>>2]=c[be>>2];c[H+4>>2]=c[be+4>>2];c[H+8>>2]=c[be+8>>2];c[H+12>>2]=c[be+12>>2];c[H+16>>2]=c[be+16>>2];c[H+20>>2]=c[be+20>>2];c[H+24>>2]=c[be+24>>2];c[H+28>>2]=c[be+28>>2];Oc=nb;Pc=Eb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=mb;Pc=ub;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[od>>2]=c[Eb>>2];c[od+4>>2]=c[Eb+4>>2];c[od+8>>2]=c[Eb+8>>2];c[od+12>>2]=c[Eb+12>>2];c[od+16>>2]=c[Eb+16>>2];c[od+20>>2]=c[Eb+20>>2];c[od+24>>2]=c[Eb+24>>2];c[od+28>>2]=c[Eb+28>>2];c[nd>>2]=c[ub>>2];c[nd+4>>2]=c[ub+4>>2];c[nd+8>>2]=c[ub+8>>2];c[nd+12>>2]=c[ub+12>>2];c[nd+16>>2]=c[ub+16>>2];c[nd+20>>2]=c[ub+20>>2];c[nd+24>>2]=c[ub+24>>2];c[nd+28>>2]=c[ub+28>>2];n=0;aa(16,od|0,nd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[ob>>2]=c[od>>2];c[ob+4>>2]=c[od+4>>2];c[ob+8>>2]=c[od+8>>2];c[ob+12>>2]=c[od+12>>2];c[ob+16>>2]=c[od+16>>2];c[ob+20>>2]=c[od+20>>2];c[ob+24>>2]=c[od+24>>2];c[ob+28>>2]=c[od+28>>2];c[md>>2]=c[I>>2];c[md+4>>2]=c[I+4>>2];c[md+8>>2]=c[I+8>>2];c[md+12>>2]=c[I+12>>2];c[md+16>>2]=c[I+16>>2];c[md+20>>2]=c[I+20>>2];c[md+24>>2]=c[I+24>>2];c[md+28>>2]=c[I+28>>2];c[ld>>2]=c[J>>2];c[ld+4>>2]=c[J+4>>2];c[ld+8>>2]=c[J+8>>2];c[ld+12>>2]=c[J+12>>2];c[ld+16>>2]=c[J+16>>2];c[ld+20>>2]=c[J+20>>2];c[ld+24>>2]=c[J+24>>2];c[ld+28>>2]=c[J+28>>2];n=0;aa(16,md|0,ld|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[md>>2];c[be+4>>2]=c[md+4>>2];c[be+8>>2]=c[md+8>>2];c[be+12>>2]=c[md+12>>2];c[be+16>>2]=c[md+16>>2];c[be+20>>2]=c[md+20>>2];c[be+24>>2]=c[md+24>>2];c[be+28>>2]=c[md+28>>2];c[K>>2]=c[be>>2];c[K+4>>2]=c[be+4>>2];c[K+8>>2]=c[be+8>>2];c[K+12>>2]=c[be+12>>2];c[K+16>>2]=c[be+16>>2];c[K+20>>2]=c[be+20>>2];c[K+24>>2]=c[be+24>>2];c[K+28>>2]=c[be+28>>2];c[kd>>2]=c[ob>>2];c[kd+4>>2]=c[ob+4>>2];c[kd+8>>2]=c[ob+8>>2];c[kd+12>>2]=c[ob+12>>2];c[kd+16>>2]=c[ob+16>>2];c[kd+20>>2]=c[ob+20>>2];c[kd+24>>2]=c[ob+24>>2];c[kd+28>>2]=c[ob+28>>2];Qc=jd;c[Qc>>2]=1325794674;c[Qc+4>>2]=-2017531950;Qc=L;c[Qc>>2]=790391525;c[Qc+4>>2]=-788714787;Qc=M;c[Qc>>2]=-50507964;c[Qc+4>>2]=-1889569646;Qc=N;c[Qc>>2]=1033682860;c[Qc+4>>2]=523723546;n=0;X(1,kd|0,jd|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){b=82;break a};c[pb>>2]=c[kd>>2];c[pb+4>>2]=c[kd+4>>2];c[pb+8>>2]=c[kd+8>>2];c[pb+12>>2]=c[kd+12>>2];c[pb+16>>2]=c[kd+16>>2];c[pb+20>>2]=c[kd+20>>2];c[pb+24>>2]=c[kd+24>>2];c[pb+28>>2]=c[kd+28>>2];c[id>>2]=c[K>>2];c[id+4>>2]=c[K+4>>2];c[id+8>>2]=c[K+8>>2];c[id+12>>2]=c[K+12>>2];c[id+16>>2]=c[K+16>>2];c[id+20>>2]=c[K+20>>2];c[id+24>>2]=c[K+24>>2];c[id+28>>2]=c[K+28>>2];Qc=hd;c[Qc>>2]=1325794674;c[Qc+4>>2]=-2017531950;Qc=O;c[Qc>>2]=790391525;c[Qc+4>>2]=-788714787;Qc=P;c[Qc>>2]=-50507964;c[Qc+4>>2]=-1889569646;Qc=Q;c[Qc>>2]=1033682860;c[Qc+4>>2]=523723546;n=0;X(1,id|0,hd|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[id>>2];c[be+4>>2]=c[id+4>>2];c[be+8>>2]=c[id+8>>2];c[be+12>>2]=c[id+12>>2];c[be+16>>2]=c[id+16>>2];c[be+20>>2]=c[id+20>>2];c[be+24>>2]=c[id+24>>2];c[be+28>>2]=c[id+28>>2];c[R>>2]=c[be>>2];c[R+4>>2]=c[be+4>>2];c[R+8>>2]=c[be+8>>2];c[R+12>>2]=c[be+12>>2];c[R+16>>2]=c[be+16>>2];c[R+20>>2]=c[be+20>>2];c[R+24>>2]=c[be+24>>2];c[R+28>>2]=c[be+28>>2];Oc=ib;Pc=Ga;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=hb;Pc=Ha;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[gd>>2]=c[Ga>>2];c[gd+4>>2]=c[Ga+4>>2];c[gd+8>>2]=c[Ga+8>>2];c[gd+12>>2]=c[Ga+12>>2];c[gd+16>>2]=c[Ga+16>>2];c[gd+20>>2]=c[Ga+20>>2];c[gd+24>>2]=c[Ga+24>>2];c[gd+28>>2]=c[Ga+28>>2];c[ed>>2]=c[Ha>>2];c[ed+4>>2]=c[Ha+4>>2];c[ed+8>>2]=c[Ha+8>>2];c[ed+12>>2]=c[Ha+12>>2];c[ed+16>>2]=c[Ha+16>>2];c[ed+20>>2]=c[Ha+20>>2];c[ed+24>>2]=c[Ha+24>>2];c[ed+28>>2]=c[Ha+28>>2];n=0;aa(16,gd|0,ed|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[jb>>2]=c[gd>>2];c[jb+4>>2]=c[gd+4>>2];c[jb+8>>2]=c[gd+8>>2];c[jb+12>>2]=c[gd+12>>2];c[jb+16>>2]=c[gd+16>>2];c[jb+20>>2]=c[gd+20>>2];c[jb+24>>2]=c[gd+24>>2];c[jb+28>>2]=c[gd+28>>2];c[dd>>2]=c[S>>2];c[dd+4>>2]=c[S+4>>2];c[dd+8>>2]=c[S+8>>2];c[dd+12>>2]=c[S+12>>2];c[dd+16>>2]=c[S+16>>2];c[dd+20>>2]=c[S+20>>2];c[dd+24>>2]=c[S+24>>2];c[dd+28>>2]=c[S+28>>2];c[cd>>2]=c[T>>2];c[cd+4>>2]=c[T+4>>2];c[cd+8>>2]=c[T+8>>2];c[cd+12>>2]=c[T+12>>2];c[cd+16>>2]=c[T+16>>2];c[cd+20>>2]=c[T+20>>2];c[cd+24>>2]=c[T+24>>2];c[cd+28>>2]=c[T+28>>2];n=0;aa(16,dd|0,cd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[dd>>2];c[be+4>>2]=c[dd+4>>2];c[be+8>>2]=c[dd+8>>2];c[be+12>>2]=c[dd+12>>2];c[be+16>>2]=c[dd+16>>2];c[be+20>>2]=c[dd+20>>2];c[be+24>>2]=c[dd+24>>2];c[be+28>>2]=c[dd+28>>2];c[U>>2]=c[be>>2];c[U+4>>2]=c[be+4>>2];c[U+8>>2]=c[be+8>>2];c[U+12>>2]=c[be+12>>2];c[U+16>>2]=c[be+16>>2];c[U+20>>2]=c[be+20>>2];c[U+24>>2]=c[be+24>>2];c[U+28>>2]=c[be+28>>2];n=0;_(17,kb|0,jb|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=fb;Pc=Eb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=eb;Pc=Db;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[$d>>2]=c[Eb>>2];c[$d+4>>2]=c[Eb+4>>2];c[$d+8>>2]=c[Eb+8>>2];c[$d+12>>2]=c[Eb+12>>2];c[$d+16>>2]=c[Eb+16>>2];c[$d+20>>2]=c[Eb+20>>2];c[$d+24>>2]=c[Eb+24>>2];c[$d+28>>2]=c[Eb+28>>2];c[_d>>2]=c[Db>>2];c[_d+4>>2]=c[Db+4>>2];c[_d+8>>2]=c[Db+8>>2];c[_d+12>>2]=c[Db+12>>2];c[_d+16>>2]=c[Db+16>>2];c[_d+20>>2]=c[Db+20>>2];c[_d+24>>2]=c[Db+24>>2];c[_d+28>>2]=c[Db+28>>2];n=0;aa(16,$d|0,_d|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[gb>>2]=c[$d>>2];c[gb+4>>2]=c[$d+4>>2];c[gb+8>>2]=c[$d+8>>2];c[gb+12>>2]=c[$d+12>>2];c[gb+16>>2]=c[$d+16>>2];c[gb+20>>2]=c[$d+20>>2];c[gb+24>>2]=c[$d+24>>2];c[gb+28>>2]=c[$d+28>>2];c[Zd>>2]=c[V>>2];c[Zd+4>>2]=c[V+4>>2];c[Zd+8>>2]=c[V+8>>2];c[Zd+12>>2]=c[V+12>>2];c[Zd+16>>2]=c[V+16>>2];c[Zd+20>>2]=c[V+20>>2];c[Zd+24>>2]=c[V+24>>2];c[Zd+28>>2]=c[V+28>>2];c[Yd>>2]=c[W>>2];c[Yd+4>>2]=c[W+4>>2];c[Yd+8>>2]=c[W+8>>2];c[Yd+12>>2]=c[W+12>>2];c[Yd+16>>2]=c[W+16>>2];c[Yd+20>>2]=c[W+20>>2];c[Yd+24>>2]=c[W+24>>2];c[Yd+28>>2]=c[W+28>>2];n=0;aa(16,Zd|0,Yd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Zd>>2];c[be+4>>2]=c[Zd+4>>2];c[be+8>>2]=c[Zd+8>>2];c[be+12>>2]=c[Zd+12>>2];c[be+16>>2]=c[Zd+16>>2];c[be+20>>2]=c[Zd+20>>2];c[be+24>>2]=c[Zd+24>>2];c[be+28>>2]=c[Zd+28>>2];c[Y>>2]=c[be>>2];c[Y+4>>2]=c[be+4>>2];c[Y+8>>2]=c[be+8>>2];c[Y+12>>2]=c[be+12>>2];c[Y+16>>2]=c[be+16>>2];c[Y+20>>2]=c[be+20>>2];c[Y+24>>2]=c[be+24>>2];c[Y+28>>2]=c[be+28>>2];c[Xd>>2]=c[kb>>2];c[Xd+4>>2]=c[kb+4>>2];c[Xd+8>>2]=c[kb+8>>2];c[Xd+12>>2]=c[kb+12>>2];c[Xd+16>>2]=c[kb+16>>2];c[Xd+20>>2]=c[kb+20>>2];c[Xd+24>>2]=c[kb+24>>2];c[Xd+28>>2]=c[kb+28>>2];c[Wd>>2]=c[gb>>2];c[Wd+4>>2]=c[gb+4>>2];c[Wd+8>>2]=c[gb+8>>2];c[Wd+12>>2]=c[gb+12>>2];c[Wd+16>>2]=c[gb+16>>2];c[Wd+20>>2]=c[gb+20>>2];c[Wd+24>>2]=c[gb+24>>2];c[Wd+28>>2]=c[gb+28>>2];n=0;aa(17,Xd|0,Wd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[lb>>2]=c[Xd>>2];c[lb+4>>2]=c[Xd+4>>2];c[lb+8>>2]=c[Xd+8>>2];c[lb+12>>2]=c[Xd+12>>2];c[lb+16>>2]=c[Xd+16>>2];c[lb+20>>2]=c[Xd+20>>2];c[lb+24>>2]=c[Xd+24>>2];c[lb+28>>2]=c[Xd+28>>2];c[Vd>>2]=c[$>>2];c[Vd+4>>2]=c[$+4>>2];c[Vd+8>>2]=c[$+8>>2];c[Vd+12>>2]=c[$+12>>2];c[Vd+16>>2]=c[$+16>>2];c[Vd+20>>2]=c[$+20>>2];c[Vd+24>>2]=c[$+24>>2];c[Vd+28>>2]=c[$+28>>2];c[Ud>>2]=c[Y>>2];c[Ud+4>>2]=c[Y+4>>2];c[Ud+8>>2]=c[Y+8>>2];c[Ud+12>>2]=c[Y+12>>2];c[Ud+16>>2]=c[Y+16>>2];c[Ud+20>>2]=c[Y+20>>2];c[Ud+24>>2]=c[Y+24>>2];c[Ud+28>>2]=c[Y+28>>2];n=0;aa(17,Vd|0,Ud|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Vd>>2];c[be+4>>2]=c[Vd+4>>2];c[be+8>>2]=c[Vd+8>>2];c[be+12>>2]=c[Vd+12>>2];c[be+16>>2]=c[Vd+16>>2];c[be+20>>2]=c[Vd+20>>2];c[be+24>>2]=c[Vd+24>>2];c[be+28>>2]=c[Vd+28>>2];c[ba>>2]=c[be>>2];c[ba+4>>2]=c[be+4>>2];c[ba+8>>2]=c[be+8>>2];c[ba+12>>2]=c[be+12>>2];c[ba+16>>2]=c[be+16>>2];c[ba+20>>2]=c[be+20>>2];c[ba+24>>2]=c[be+24>>2];c[ba+28>>2]=c[be+28>>2];Oc=cb;Pc=xb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=bb;Pc=Eb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Td>>2]=c[xb>>2];c[Td+4>>2]=c[xb+4>>2];c[Td+8>>2]=c[xb+8>>2];c[Td+12>>2]=c[xb+12>>2];c[Td+16>>2]=c[xb+16>>2];c[Td+20>>2]=c[xb+20>>2];c[Td+24>>2]=c[xb+24>>2];c[Td+28>>2]=c[xb+28>>2];c[Sd>>2]=c[Eb>>2];c[Sd+4>>2]=c[Eb+4>>2];c[Sd+8>>2]=c[Eb+8>>2];c[Sd+12>>2]=c[Eb+12>>2];c[Sd+16>>2]=c[Eb+16>>2];c[Sd+20>>2]=c[Eb+20>>2];c[Sd+24>>2]=c[Eb+24>>2];c[Sd+28>>2]=c[Eb+28>>2];n=0;aa(17,Td|0,Sd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[db>>2]=c[Td>>2];c[db+4>>2]=c[Td+4>>2];c[db+8>>2]=c[Td+8>>2];c[db+12>>2]=c[Td+12>>2];c[db+16>>2]=c[Td+16>>2];c[db+20>>2]=c[Td+20>>2];c[db+24>>2]=c[Td+24>>2];c[db+28>>2]=c[Td+28>>2];c[Rd>>2]=c[ca>>2];c[Rd+4>>2]=c[ca+4>>2];c[Rd+8>>2]=c[ca+8>>2];c[Rd+12>>2]=c[ca+12>>2];c[Rd+16>>2]=c[ca+16>>2];c[Rd+20>>2]=c[ca+20>>2];c[Rd+24>>2]=c[ca+24>>2];c[Rd+28>>2]=c[ca+28>>2];c[Qd>>2]=c[da>>2];c[Qd+4>>2]=c[da+4>>2];c[Qd+8>>2]=c[da+8>>2];c[Qd+12>>2]=c[da+12>>2];c[Qd+16>>2]=c[da+16>>2];c[Qd+20>>2]=c[da+20>>2];c[Qd+24>>2]=c[da+24>>2];c[Qd+28>>2]=c[da+28>>2];n=0;aa(17,Rd|0,Qd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Rd>>2];c[be+4>>2]=c[Rd+4>>2];c[be+8>>2]=c[Rd+8>>2];c[be+12>>2]=c[Rd+12>>2];c[be+16>>2]=c[Rd+16>>2];c[be+20>>2]=c[Rd+20>>2];c[be+24>>2]=c[Rd+24>>2];c[be+28>>2]=c[Rd+28>>2];c[ea>>2]=c[be>>2];c[ea+4>>2]=c[be+4>>2];c[ea+8>>2]=c[be+8>>2];c[ea+12>>2]=c[be+12>>2];c[ea+16>>2]=c[be+16>>2];c[ea+20>>2]=c[be+20>>2];c[ea+24>>2]=c[be+24>>2];c[ea+28>>2]=c[be+28>>2];n=0;_(17,ab|0,Nc|0);Qc=n;n=0;if(Qc&1){b=82;break a}n=0;_(17,$a|0,xb|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=Za;Pc=Ib;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Xa;Pc=Eb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Wa;Pc=ub;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[ad>>2]=c[Eb>>2];c[ad+4>>2]=c[Eb+4>>2];c[ad+8>>2]=c[Eb+8>>2];c[ad+12>>2]=c[Eb+12>>2];c[ad+16>>2]=c[Eb+16>>2];c[ad+20>>2]=c[Eb+20>>2];c[ad+24>>2]=c[Eb+24>>2];c[ad+28>>2]=c[Eb+28>>2];c[$c>>2]=c[ub>>2];c[$c+4>>2]=c[ub+4>>2];c[$c+8>>2]=c[ub+8>>2];c[$c+12>>2]=c[ub+12>>2];c[$c+16>>2]=c[ub+16>>2];c[$c+20>>2]=c[ub+20>>2];c[$c+24>>2]=c[ub+24>>2];c[$c+28>>2]=c[ub+28>>2];n=0;aa(17,ad|0,$c|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[Ya>>2]=c[ad>>2];c[Ya+4>>2]=c[ad+4>>2];c[Ya+8>>2]=c[ad+8>>2];c[Ya+12>>2]=c[ad+12>>2];c[Ya+16>>2]=c[ad+16>>2];c[Ya+20>>2]=c[ad+20>>2];c[Ya+24>>2]=c[ad+24>>2];c[Ya+28>>2]=c[ad+28>>2];c[_c>>2]=c[fa>>2];c[_c+4>>2]=c[fa+4>>2];c[_c+8>>2]=c[fa+8>>2];c[_c+12>>2]=c[fa+12>>2];c[_c+16>>2]=c[fa+16>>2];c[_c+20>>2]=c[fa+20>>2];c[_c+24>>2]=c[fa+24>>2];c[_c+28>>2]=c[fa+28>>2];c[Zc>>2]=c[ga>>2];c[Zc+4>>2]=c[ga+4>>2];c[Zc+8>>2]=c[ga+8>>2];c[Zc+12>>2]=c[ga+12>>2];c[Zc+16>>2]=c[ga+16>>2];c[Zc+20>>2]=c[ga+20>>2];c[Zc+24>>2]=c[ga+24>>2];c[Zc+28>>2]=c[ga+28>>2];n=0;aa(17,_c|0,Zc|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[_c>>2];c[be+4>>2]=c[_c+4>>2];c[be+8>>2]=c[_c+8>>2];c[be+12>>2]=c[_c+12>>2];c[be+16>>2]=c[_c+16>>2];c[be+20>>2]=c[_c+20>>2];c[be+24>>2]=c[_c+24>>2];c[be+28>>2]=c[_c+28>>2];c[ha>>2]=c[be>>2];c[ha+4>>2]=c[be+4>>2];c[ha+8>>2]=c[be+8>>2];c[ha+12>>2]=c[be+12>>2];c[ha+16>>2]=c[be+16>>2];c[ha+20>>2]=c[be+20>>2];c[ha+24>>2]=c[be+24>>2];c[ha+28>>2]=c[be+28>>2];n=0;aa(15,_a|0,Za|0,Ya|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=Nc;Pc=_a;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));n=0;_(17,Ua|0,pb|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=Ra;Pc=$a;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Qa;Pc=$a;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Yc>>2]=c[Ra>>2];c[Yc+4>>2]=c[Ra+4>>2];c[Yc+8>>2]=c[Ra+8>>2];c[Yc+12>>2]=c[Ra+12>>2];c[Yc+16>>2]=c[Ra+16>>2];c[Yc+20>>2]=c[Ra+20>>2];c[Yc+24>>2]=c[Ra+24>>2];c[Yc+28>>2]=c[Ra+28>>2];c[Wc>>2]=c[$a>>2];c[Wc+4>>2]=c[$a+4>>2];c[Wc+8>>2]=c[$a+8>>2];c[Wc+12>>2]=c[$a+12>>2];c[Wc+16>>2]=c[$a+16>>2];c[Wc+20>>2]=c[$a+20>>2];c[Wc+24>>2]=c[$a+24>>2];c[Wc+28>>2]=c[$a+28>>2];n=0;aa(16,Yc|0,Wc|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[Sa>>2]=c[Yc>>2];c[Sa+4>>2]=c[Yc+4>>2];c[Sa+8>>2]=c[Yc+8>>2];c[Sa+12>>2]=c[Yc+12>>2];c[Sa+16>>2]=c[Yc+16>>2];c[Sa+20>>2]=c[Yc+20>>2];c[Sa+24>>2]=c[Yc+24>>2];c[Sa+28>>2]=c[Yc+28>>2];c[Vc>>2]=c[ia>>2];c[Vc+4>>2]=c[ia+4>>2];c[Vc+8>>2]=c[ia+8>>2];c[Vc+12>>2]=c[ia+12>>2];c[Vc+16>>2]=c[ia+16>>2];c[Vc+20>>2]=c[ia+20>>2];c[Vc+24>>2]=c[ia+24>>2];c[Vc+28>>2]=c[ia+28>>2];c[Uc>>2]=c[ja>>2];c[Uc+4>>2]=c[ja+4>>2];c[Uc+8>>2]=c[ja+8>>2];c[Uc+12>>2]=c[ja+12>>2];c[Uc+16>>2]=c[ja+16>>2];c[Uc+20>>2]=c[ja+20>>2];c[Uc+24>>2]=c[ja+24>>2];c[Uc+28>>2]=c[ja+28>>2];n=0;aa(16,Vc|0,Uc|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Vc>>2];c[be+4>>2]=c[Vc+4>>2];c[be+8>>2]=c[Vc+8>>2];c[be+12>>2]=c[Vc+12>>2];c[be+16>>2]=c[Vc+16>>2];c[be+20>>2]=c[Vc+20>>2];c[be+24>>2]=c[Vc+24>>2];c[be+28>>2]=c[Vc+28>>2];c[ka>>2]=c[be>>2];c[ka+4>>2]=c[be+4>>2];c[ka+8>>2]=c[be+8>>2];c[ka+12>>2]=c[be+12>>2];c[ka+16>>2]=c[be+16>>2];c[ka+20>>2]=c[be+20>>2];c[ka+24>>2]=c[be+24>>2];c[ka+28>>2]=c[be+28>>2];Oc=Pa;Pc=$a;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Pd>>2]=c[Sa>>2];c[Pd+4>>2]=c[Sa+4>>2];c[Pd+8>>2]=c[Sa+8>>2];c[Pd+12>>2]=c[Sa+12>>2];c[Pd+16>>2]=c[Sa+16>>2];c[Pd+20>>2]=c[Sa+20>>2];c[Pd+24>>2]=c[Sa+24>>2];c[Pd+28>>2]=c[Sa+28>>2];c[Od>>2]=c[$a>>2];c[Od+4>>2]=c[$a+4>>2];c[Od+8>>2]=c[$a+8>>2];c[Od+12>>2]=c[$a+12>>2];c[Od+16>>2]=c[$a+16>>2];c[Od+20>>2]=c[$a+20>>2];c[Od+24>>2]=c[$a+24>>2];c[Od+28>>2]=c[$a+28>>2];n=0;aa(16,Pd|0,Od|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[Ta>>2]=c[Pd>>2];c[Ta+4>>2]=c[Pd+4>>2];c[Ta+8>>2]=c[Pd+8>>2];c[Ta+12>>2]=c[Pd+12>>2];c[Ta+16>>2]=c[Pd+16>>2];c[Ta+20>>2]=c[Pd+20>>2];c[Ta+24>>2]=c[Pd+24>>2];c[Ta+28>>2]=c[Pd+28>>2];c[Nd>>2]=c[ka>>2];c[Nd+4>>2]=c[ka+4>>2];c[Nd+8>>2]=c[ka+8>>2];c[Nd+12>>2]=c[ka+12>>2];c[Nd+16>>2]=c[ka+16>>2];c[Nd+20>>2]=c[ka+20>>2];c[Nd+24>>2]=c[ka+24>>2];c[Nd+28>>2]=c[ka+28>>2];c[Md>>2]=c[la>>2];c[Md+4>>2]=c[la+4>>2];c[Md+8>>2]=c[la+8>>2];c[Md+12>>2]=c[la+12>>2];c[Md+16>>2]=c[la+16>>2];c[Md+20>>2]=c[la+20>>2];c[Md+24>>2]=c[la+24>>2];c[Md+28>>2]=c[la+28>>2];n=0;aa(16,Nd|0,Md|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Nd>>2];c[be+4>>2]=c[Nd+4>>2];c[be+8>>2]=c[Nd+8>>2];c[be+12>>2]=c[Nd+12>>2];c[be+16>>2]=c[Nd+16>>2];c[be+20>>2]=c[Nd+20>>2];c[be+24>>2]=c[Nd+24>>2];c[be+28>>2]=c[Nd+28>>2];c[ma>>2]=c[be>>2];c[ma+4>>2]=c[be+4>>2];c[ma+8>>2]=c[be+8>>2];c[ma+12>>2]=c[be+12>>2];c[ma+16>>2]=c[be+16>>2];c[ma+20>>2]=c[be+20>>2];c[ma+24>>2]=c[be+24>>2];c[ma+28>>2]=c[be+28>>2];c[Ld>>2]=c[Ua>>2];c[Ld+4>>2]=c[Ua+4>>2];c[Ld+8>>2]=c[Ua+8>>2];c[Ld+12>>2]=c[Ua+12>>2];c[Ld+16>>2]=c[Ua+16>>2];c[Ld+20>>2]=c[Ua+20>>2];c[Ld+24>>2]=c[Ua+24>>2];c[Ld+28>>2]=c[Ua+28>>2];c[Kd>>2]=c[Ta>>2];c[Kd+4>>2]=c[Ta+4>>2];c[Kd+8>>2]=c[Ta+8>>2];c[Kd+12>>2]=c[Ta+12>>2];c[Kd+16>>2]=c[Ta+16>>2];c[Kd+20>>2]=c[Ta+20>>2];c[Kd+24>>2]=c[Ta+24>>2];c[Kd+28>>2]=c[Ta+28>>2];n=0;aa(17,Ld|0,Kd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[Va>>2]=c[Ld>>2];c[Va+4>>2]=c[Ld+4>>2];c[Va+8>>2]=c[Ld+8>>2];c[Va+12>>2]=c[Ld+12>>2];c[Va+16>>2]=c[Ld+16>>2];c[Va+20>>2]=c[Ld+20>>2];c[Va+24>>2]=c[Ld+24>>2];c[Va+28>>2]=c[Ld+28>>2];c[Jd>>2]=c[oa>>2];c[Jd+4>>2]=c[oa+4>>2];c[Jd+8>>2]=c[oa+8>>2];c[Jd+12>>2]=c[oa+12>>2];c[Jd+16>>2]=c[oa+16>>2];c[Jd+20>>2]=c[oa+20>>2];c[Jd+24>>2]=c[oa+24>>2];c[Jd+28>>2]=c[oa+28>>2];c[Id>>2]=c[ma>>2];c[Id+4>>2]=c[ma+4>>2];c[Id+8>>2]=c[ma+8>>2];c[Id+12>>2]=c[ma+12>>2];c[Id+16>>2]=c[ma+16>>2];c[Id+20>>2]=c[ma+20>>2];c[Id+24>>2]=c[ma+24>>2];c[Id+28>>2]=c[ma+28>>2];n=0;aa(17,Jd|0,Id|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Jd>>2];c[be+4>>2]=c[Jd+4>>2];c[be+8>>2]=c[Jd+8>>2];c[be+12>>2]=c[Jd+12>>2];c[be+16>>2]=c[Jd+16>>2];c[be+20>>2]=c[Jd+20>>2];c[be+24>>2]=c[Jd+24>>2];c[be+28>>2]=c[Jd+28>>2];c[pa>>2]=c[be>>2];c[pa+4>>2]=c[be+4>>2];c[pa+8>>2]=c[be+8>>2];c[pa+12>>2]=c[be+12>>2];c[pa+16>>2]=c[be+16>>2];c[pa+20>>2]=c[be+20>>2];c[pa+24>>2]=c[be+24>>2];c[pa+28>>2]=c[be+28>>2];Oc=Ga;Pc=Va;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Na;Pc=Eb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Ma;Pc=lb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));n=0;aa(15,Oa|0,Na|0,Ma|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=Ha;Pc=Oa;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Ka;c[Oc>>2]=1091403767;c[Oc+4>>2]=-167360562;Oc=qa;c[Oc>>2]=-753151983;c[Oc+4>>2]=792555341;Oc=ra;c[Oc>>2]=960546513;c[Oc+4>>2]=692269950;Oc=sa;c[Oc>>2]=-1478256553;c[Oc+4>>2]=496343272;Oc=ta;c[Oc>>2]=-980480611;c[Oc+4>>2]=-748862579;Oc=ua;c[Oc>>2]=-171504835;c[Oc+4>>2]=175696680;Oc=va;c[Oc>>2]=2021213740;c[Oc+4>>2]=1718526831;Oc=wa;c[Oc>>2]=-1710760145;c[Oc+4>>2]=235567041;Oc=mc;Pc=db;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));n=0;aa(15,La|0,Ka|0,mc|0);Qc=n;n=0;if(Qc&1){b=82;break a}Oc=kc;Pc=lb;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Hd>>2]=c[lb>>2];c[Hd+4>>2]=c[lb+4>>2];c[Hd+8>>2]=c[lb+8>>2];c[Hd+12>>2]=c[lb+12>>2];c[Hd+16>>2]=c[lb+16>>2];c[Hd+20>>2]=c[lb+20>>2];c[Hd+24>>2]=c[lb+24>>2];c[Hd+28>>2]=c[lb+28>>2];n=0;_(18,Hd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[lc>>2]=c[Hd>>2];c[lc+4>>2]=c[Hd+4>>2];c[lc+8>>2]=c[Hd+8>>2];c[lc+12>>2]=c[Hd+12>>2];c[lc+16>>2]=c[Hd+16>>2];c[lc+20>>2]=c[Hd+20>>2];c[lc+24>>2]=c[Hd+24>>2];c[lc+28>>2]=c[Hd+28>>2];c[Cd>>2]=c[xa>>2];c[Cd+4>>2]=c[xa+4>>2];c[Cd+8>>2]=c[xa+8>>2];c[Cd+12>>2]=c[xa+12>>2];c[Cd+16>>2]=c[xa+16>>2];c[Cd+20>>2]=c[xa+20>>2];c[Cd+24>>2]=c[xa+24>>2];c[Cd+28>>2]=c[xa+28>>2];n=0;_(18,Cd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Cd>>2];c[be+4>>2]=c[Cd+4>>2];c[be+8>>2]=c[Cd+8>>2];c[be+12>>2]=c[Cd+12>>2];c[be+16>>2]=c[Cd+16>>2];c[be+20>>2]=c[Cd+20>>2];c[be+24>>2]=c[Cd+24>>2];c[be+28>>2]=c[Cd+28>>2];c[ya>>2]=c[be>>2];c[ya+4>>2]=c[be+4>>2];c[ya+8>>2]=c[be+8>>2];c[ya+12>>2]=c[be+12>>2];c[ya+16>>2]=c[be+16>>2];c[ya+20>>2]=c[be+20>>2];c[ya+24>>2]=c[be+24>>2];c[ya+28>>2]=c[be+28>>2];Oc=hc;Pc=ab;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=gc;Pc=ab;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[Ad>>2]=c[hc>>2];c[Ad+4>>2]=c[hc+4>>2];c[Ad+8>>2]=c[hc+8>>2];c[Ad+12>>2]=c[hc+12>>2];c[Ad+16>>2]=c[hc+16>>2];c[Ad+20>>2]=c[hc+20>>2];c[Ad+24>>2]=c[hc+24>>2];c[Ad+28>>2]=c[hc+28>>2];c[zd>>2]=c[ab>>2];c[zd+4>>2]=c[ab+4>>2];c[zd+8>>2]=c[ab+8>>2];c[zd+12>>2]=c[ab+12>>2];c[zd+16>>2]=c[ab+16>>2];c[zd+20>>2]=c[ab+20>>2];c[zd+24>>2]=c[ab+24>>2];c[zd+28>>2]=c[ab+28>>2];n=0;aa(16,Ad|0,zd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[ic>>2]=c[Ad>>2];c[ic+4>>2]=c[Ad+4>>2];c[ic+8>>2]=c[Ad+8>>2];c[ic+12>>2]=c[Ad+12>>2];c[ic+16>>2]=c[Ad+16>>2];c[ic+20>>2]=c[Ad+20>>2];c[ic+24>>2]=c[Ad+24>>2];c[ic+28>>2]=c[Ad+28>>2];c[yd>>2]=c[Aa>>2];c[yd+4>>2]=c[Aa+4>>2];c[yd+8>>2]=c[Aa+8>>2];c[yd+12>>2]=c[Aa+12>>2];c[yd+16>>2]=c[Aa+16>>2];c[yd+20>>2]=c[Aa+20>>2];c[yd+24>>2]=c[Aa+24>>2];c[yd+28>>2]=c[Aa+28>>2];c[xd>>2]=c[Ba>>2];c[xd+4>>2]=c[Ba+4>>2];c[xd+8>>2]=c[Ba+8>>2];c[xd+12>>2]=c[Ba+12>>2];c[xd+16>>2]=c[Ba+16>>2];c[xd+20>>2]=c[Ba+20>>2];c[xd+24>>2]=c[Ba+24>>2];c[xd+28>>2]=c[Ba+28>>2];n=0;aa(16,yd|0,xd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[yd>>2];c[be+4>>2]=c[yd+4>>2];c[be+8>>2]=c[yd+8>>2];c[be+12>>2]=c[yd+12>>2];c[be+16>>2]=c[yd+16>>2];c[be+20>>2]=c[yd+20>>2];c[be+24>>2]=c[yd+24>>2];c[be+28>>2]=c[yd+28>>2];c[Ca>>2]=c[be>>2];c[Ca+4>>2]=c[be+4>>2];c[Ca+8>>2]=c[be+8>>2];c[Ca+12>>2]=c[be+12>>2];c[Ca+16>>2]=c[be+16>>2];c[Ca+20>>2]=c[be+20>>2];c[Ca+24>>2]=c[be+24>>2];c[Ca+28>>2]=c[be+28>>2];Oc=fc;Pc=ab;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[wd>>2]=c[ic>>2];c[wd+4>>2]=c[ic+4>>2];c[wd+8>>2]=c[ic+8>>2];c[wd+12>>2]=c[ic+12>>2];c[wd+16>>2]=c[ic+16>>2];c[wd+20>>2]=c[ic+20>>2];c[wd+24>>2]=c[ic+24>>2];c[wd+28>>2]=c[ic+28>>2];c[vd>>2]=c[ab>>2];c[vd+4>>2]=c[ab+4>>2];c[vd+8>>2]=c[ab+8>>2];c[vd+12>>2]=c[ab+12>>2];c[vd+16>>2]=c[ab+16>>2];c[vd+20>>2]=c[ab+20>>2];c[vd+24>>2]=c[ab+24>>2];c[vd+28>>2]=c[ab+28>>2];n=0;aa(16,wd|0,vd|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[jc>>2]=c[wd>>2];c[jc+4>>2]=c[wd+4>>2];c[jc+8>>2]=c[wd+8>>2];c[jc+12>>2]=c[wd+12>>2];c[jc+16>>2]=c[wd+16>>2];c[jc+20>>2]=c[wd+20>>2];c[jc+24>>2]=c[wd+24>>2];c[jc+28>>2]=c[wd+28>>2];c[Tc>>2]=c[Ca>>2];c[Tc+4>>2]=c[Ca+4>>2];c[Tc+8>>2]=c[Ca+8>>2];c[Tc+12>>2]=c[Ca+12>>2];c[Tc+16>>2]=c[Ca+16>>2];c[Tc+20>>2]=c[Ca+20>>2];c[Tc+24>>2]=c[Ca+24>>2];c[Tc+28>>2]=c[Ca+28>>2];c[ud>>2]=c[Da>>2];c[ud+4>>2]=c[Da+4>>2];c[ud+8>>2]=c[Da+8>>2];c[ud+12>>2]=c[Da+12>>2];c[ud+16>>2]=c[Da+16>>2];c[ud+20>>2]=c[Da+20>>2];c[ud+24>>2]=c[Da+24>>2];c[ud+28>>2]=c[Da+28>>2];n=0;aa(16,Tc|0,ud|0,136);Qc=n;n=0;if(Qc&1){b=82;break a};c[be>>2]=c[Tc>>2];c[be+4>>2]=c[Tc+4>>2];c[be+8>>2]=c[Tc+8>>2];c[be+12>>2]=c[Tc+12>>2];c[be+16>>2]=c[Tc+16>>2];c[be+20>>2]=c[Tc+20>>2];c[be+24>>2]=c[Tc+24>>2];c[be+28>>2]=c[Tc+28>>2];c[Ea>>2]=c[be>>2];c[Ea+4>>2]=c[be+4>>2];c[Ea+8>>2]=c[be+8>>2];c[Ea+12>>2]=c[be+12>>2];c[Ea+16>>2]=c[be+16>>2];c[Ea+20>>2]=c[be+20>>2];c[Ea+24>>2]=c[be+24>>2];c[Ea+28>>2]=c[be+28>>2];Oc=Kb;Pc=La;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=e;Pc=lc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=f;Pc=jc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));b=c[Mb>>2]|0;if((b|0)==(c[Ja>>2]|0)){n=0;Z(42,Sc|0);Qc=n;n=0;if(Qc&1){b=82;break a}b=c[Mb>>2]|0;}ok((c[Sc>>2]|0)+(b*192|0)|0,Kb|0,192)|0;c[Mb>>2]=b+1;if(!d){b=1;break}n=0;aa(18,Jb|0,Nc|0,Fd|0);Qc=n;n=0;if(Qc&1){b=82;break a}b=c[Mb>>2]|0;if((b|0)==(c[Ja>>2]|0)){n=0;Z(42,Sc|0);Qc=n;n=0;if(Qc&1){b=82;break a}b=c[Mb>>2]|0;}ok((c[Sc>>2]|0)+(b*192|0)|0,Jb|0,192)|0;c[Mb>>2]=b+1;b=1;}else b=d;while(0);if(!Fa){b=6;break}}if((b|0)==6){Qc=qc;c[Qc>>2]=1164159792;c[Qc+4>>2]=-1250477296;Qc=qc+8|0;c[Qc>>2]=-1448450988;c[Qc+4>>2]=880775624;Qc=qc+16|0;c[Qc>>2]=606996881;c[Qc+4>>2]=2046849319;Qc=qc+24|0;c[Qc>>2]=293737708;c[Qc+4>>2]=425114840;Qc=qc+32|0;c[Qc>>2]=-1599453353;c[Qc+4>>2]=1854185246;Qc=qc+40|0;c[Qc>>2]=-1980198591;c[Qc+4>>2]=-1440973971;Qc=qc+48|0;c[Qc>>2]=-85931462;c[Qc+4>>2]=-1226370099;Qc=qc+56|0;c[Qc>>2]=1317202883;c[Qc+4>>2]=644435899;c[pc>>2]=c[Fd>>2];c[pc+4>>2]=c[Fd+4>>2];c[pc+8>>2]=c[Fd+8>>2];c[pc+12>>2]=c[Fd+12>>2];c[pc+16>>2]=c[Fd+16>>2];c[pc+20>>2]=c[Fd+20>>2];c[pc+24>>2]=c[Fd+24>>2];c[pc+28>>2]=c[Fd+28>>2];Qc=Fd+32|0;c[vc>>2]=c[Qc>>2];c[vc+4>>2]=c[Qc+4>>2];c[vc+8>>2]=c[Qc+8>>2];c[vc+12>>2]=c[Qc+12>>2];c[vc+16>>2]=c[Qc+16>>2];c[vc+20>>2]=c[Qc+20>>2];c[vc+24>>2]=c[Qc+24>>2];c[vc+28>>2]=c[Qc+28>>2];Qc=uc;c[Qc>>2]=317583274;c[Qc+4>>2]=1757628553;Qc=uc+8|0;c[Qc>>2]=1923792719;c[Qc+4>>2]=-1928822936;Qc=uc+16|0;c[Qc>>2]=151523889;c[Qc+4>>2]=1373741639;Qc=uc+24|0;c[Qc>>2]=1193918714;c[Qc+4>>2]=576313009;n=0;X(1,vc|0,uc|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);};c[be>>2]=c[vc>>2];c[be+4>>2]=c[vc+4>>2];c[be+8>>2]=c[vc+8>>2];c[be+12>>2]=c[vc+12>>2];c[be+16>>2]=c[vc+16>>2];c[be+20>>2]=c[vc+20>>2];c[be+24>>2]=c[vc+24>>2];c[be+28>>2]=c[vc+28>>2];Qc=pc+32|0;c[Qc>>2]=c[be>>2];c[Qc+4>>2]=c[be+4>>2];c[Qc+8>>2]=c[be+8>>2];c[Qc+12>>2]=c[be+12>>2];c[Qc+16>>2]=c[be+16>>2];c[Qc+20>>2]=c[be+20>>2];c[Qc+24>>2]=c[be+24>>2];c[Qc+28>>2]=c[be+28>>2];n=0;aa(15,rc|0,qc|0,pc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}Qc=oc;c[Qc>>2]=691451433;c[Qc+4>>2]=-457450228;Qc=oc+8|0;c[Qc>>2]=-516703541;c[Qc+4>>2]=-1154420382;Qc=oc+16|0;c[Qc>>2]=-110865562;c[Qc+4>>2]=833212854;Qc=oc+24|0;c[Qc>>2]=-1526662947;c[Qc+4>>2]=624259262;Qc=oc+32|0;c[Qc>>2]=1610512327;c[Qc+4>>2]=-1579713308;Qc=oc+40|0;c[Qc>>2]=2015810011;c[Qc+4>>2]=128974097;Qc=oc+48|0;c[Qc>>2]=-1149313941;c[Qc+4>>2]=1830206759;Qc=oc+56|0;c[Qc>>2]=-2048983348;c[Qc+4>>2]=747053058;c[nc>>2]=c[Ia>>2];c[nc+4>>2]=c[Ia+4>>2];c[nc+8>>2]=c[Ia+8>>2];c[nc+12>>2]=c[Ia+12>>2];c[nc+16>>2]=c[Ia+16>>2];c[nc+20>>2]=c[Ia+20>>2];c[nc+24>>2]=c[Ia+24>>2];c[nc+28>>2]=c[Ia+28>>2];Qc=Fd+96|0;c[tc>>2]=c[Qc>>2];c[tc+4>>2]=c[Qc+4>>2];c[tc+8>>2]=c[Qc+8>>2];c[tc+12>>2]=c[Qc+12>>2];c[tc+16>>2]=c[Qc+16>>2];c[tc+20>>2]=c[Qc+20>>2];c[tc+24>>2]=c[Qc+24>>2];c[tc+28>>2]=c[Qc+28>>2];Qc=sc;c[Qc>>2]=317583274;c[Qc+4>>2]=1757628553;Qc=sc+8|0;c[Qc>>2]=1923792719;c[Qc+4>>2]=-1928822936;Qc=sc+16|0;c[Qc>>2]=151523889;c[Qc+4>>2]=1373741639;Qc=sc+24|0;c[Qc>>2]=1193918714;c[Qc+4>>2]=576313009;n=0;X(1,tc|0,sc|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);};c[be>>2]=c[tc>>2];c[be+4>>2]=c[tc+4>>2];c[be+8>>2]=c[tc+8>>2];c[be+12>>2]=c[tc+12>>2];c[be+16>>2]=c[tc+16>>2];c[be+20>>2]=c[tc+20>>2];c[be+24>>2]=c[tc+24>>2];c[be+28>>2]=c[tc+28>>2];Qc=nc+32|0;c[Qc>>2]=c[be>>2];c[Qc+4>>2]=c[be+4>>2];c[Qc+8>>2]=c[be+8>>2];c[Qc+12>>2]=c[be+12>>2];c[Qc+16>>2]=c[be+16>>2];c[Qc+20>>2]=c[be+20>>2];c[Qc+24>>2]=c[be+24>>2];c[Qc+28>>2]=c[be+28>>2];n=0;aa(15,wc|0,oc|0,nc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}Oc=Fc;Pc=rc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));b=Fc+64|0;Oc=b;Pc=wc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Qc=Cc;c[Qc>>2]=1164159792;c[Qc+4>>2]=-1250477296;Qc=Cc+8|0;c[Qc>>2]=-1448450988;c[Qc+4>>2]=880775624;Qc=Cc+16|0;c[Qc>>2]=606996881;c[Qc+4>>2]=2046849319;Qc=Cc+24|0;c[Qc>>2]=293737708;c[Qc+4>>2]=425114840;Qc=Cc+32|0;c[Qc>>2]=-1599453353;c[Qc+4>>2]=1854185246;Qc=Cc+40|0;c[Qc>>2]=-1980198591;c[Qc+4>>2]=-1440973971;Qc=Cc+48|0;c[Qc>>2]=-85931462;c[Qc+4>>2]=-1226370099;Qc=Cc+56|0;c[Qc>>2]=1317202883;c[Qc+4>>2]=644435899;c[Bc>>2]=c[Fc>>2];c[Bc+4>>2]=c[Fc+4>>2];c[Bc+8>>2]=c[Fc+8>>2];c[Bc+12>>2]=c[Fc+12>>2];c[Bc+16>>2]=c[Fc+16>>2];c[Bc+20>>2]=c[Fc+20>>2];c[Bc+24>>2]=c[Fc+24>>2];c[Bc+28>>2]=c[Fc+28>>2];Qc=Fc+32|0;c[td>>2]=c[Qc>>2];c[td+4>>2]=c[Qc+4>>2];c[td+8>>2]=c[Qc+8>>2];c[td+12>>2]=c[Qc+12>>2];c[td+16>>2]=c[Qc+16>>2];c[td+20>>2]=c[Qc+20>>2];c[td+24>>2]=c[Qc+24>>2];c[td+28>>2]=c[Qc+28>>2];Qc=sd;c[Qc>>2]=317583274;c[Qc+4>>2]=1757628553;Qc=sd+8|0;c[Qc>>2]=1923792719;c[Qc+4>>2]=-1928822936;Qc=sd+16|0;c[Qc>>2]=151523889;c[Qc+4>>2]=1373741639;Qc=sd+24|0;c[Qc>>2]=1193918714;c[Qc+4>>2]=576313009;n=0;X(1,td|0,sd|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);};c[be>>2]=c[td>>2];c[be+4>>2]=c[td+4>>2];c[be+8>>2]=c[td+8>>2];c[be+12>>2]=c[td+12>>2];c[be+16>>2]=c[td+16>>2];c[be+20>>2]=c[td+20>>2];c[be+24>>2]=c[td+24>>2];c[be+28>>2]=c[td+28>>2];Qc=Bc+32|0;c[Qc>>2]=c[be>>2];c[Qc+4>>2]=c[be+4>>2];c[Qc+8>>2]=c[be+8>>2];c[Qc+12>>2]=c[be+12>>2];c[Qc+16>>2]=c[be+16>>2];c[Qc+20>>2]=c[be+20>>2];c[Qc+24>>2]=c[be+24>>2];c[Qc+28>>2]=c[be+28>>2];n=0;aa(15,Dc|0,Cc|0,Bc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}Qc=yc;c[Qc>>2]=691451433;c[Qc+4>>2]=-457450228;Qc=yc+8|0;c[Qc>>2]=-516703541;c[Qc+4>>2]=-1154420382;Qc=yc+16|0;c[Qc>>2]=-110865562;c[Qc+4>>2]=833212854;Qc=yc+24|0;c[Qc>>2]=-1526662947;c[Qc+4>>2]=624259262;Qc=yc+32|0;c[Qc>>2]=1610512327;c[Qc+4>>2]=-1579713308;Qc=yc+40|0;c[Qc>>2]=2015810011;c[Qc+4>>2]=128974097;Qc=yc+48|0;c[Qc>>2]=-1149313941;c[Qc+4>>2]=1830206759;Qc=yc+56|0;c[Qc>>2]=-2048983348;c[Qc+4>>2]=747053058;c[xc>>2]=c[b>>2];c[xc+4>>2]=c[b+4>>2];c[xc+8>>2]=c[b+8>>2];c[xc+12>>2]=c[b+12>>2];c[xc+16>>2]=c[b+16>>2];c[xc+20>>2]=c[b+20>>2];c[xc+24>>2]=c[b+24>>2];c[xc+28>>2]=c[b+28>>2];Qc=Fc+96|0;c[qd>>2]=c[Qc>>2];c[qd+4>>2]=c[Qc+4>>2];c[qd+8>>2]=c[Qc+8>>2];c[qd+12>>2]=c[Qc+12>>2];c[qd+16>>2]=c[Qc+16>>2];c[qd+20>>2]=c[Qc+20>>2];c[qd+24>>2]=c[Qc+24>>2];c[qd+28>>2]=c[Qc+28>>2];Qc=fd;c[Qc>>2]=317583274;c[Qc+4>>2]=1757628553;Qc=fd+8|0;c[Qc>>2]=1923792719;c[Qc+4>>2]=-1928822936;Qc=fd+16|0;c[Qc>>2]=151523889;c[Qc+4>>2]=1373741639;Qc=fd+24|0;c[Qc>>2]=1193918714;c[Qc+4>>2]=576313009;n=0;X(1,qd|0,fd|0,136,-460954743,-2016278654);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);};c[be>>2]=c[qd>>2];c[be+4>>2]=c[qd+4>>2];c[be+8>>2]=c[qd+8>>2];c[be+12>>2]=c[qd+12>>2];c[be+16>>2]=c[qd+16>>2];c[be+20>>2]=c[qd+20>>2];c[be+24>>2]=c[qd+24>>2];c[be+28>>2]=c[qd+28>>2];Qc=xc+32|0;c[Qc>>2]=c[be>>2];c[Qc+4>>2]=c[be+4>>2];c[Qc+8>>2]=c[be+8>>2];c[Qc+12>>2]=c[be+12>>2];c[Qc+16>>2]=c[be+16>>2];c[Qc+20>>2]=c[be+20>>2];c[Qc+24>>2]=c[be+24>>2];c[Qc+28>>2]=c[be+28>>2];n=0;aa(15,Kc|0,yc|0,xc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}Oc=Ec;Pc=Dc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));b=Ec+64|0;Oc=b;Pc=Kc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Mc;Pc=Ec;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Oc=Ic;Pc=b;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));c[bd>>2]=c[b>>2];c[bd+4>>2]=c[b+4>>2];c[bd+8>>2]=c[b+8>>2];c[bd+12>>2]=c[b+12>>2];c[bd+16>>2]=c[b+16>>2];c[bd+20>>2]=c[b+20>>2];c[bd+24>>2]=c[b+24>>2];c[bd+28>>2]=c[b+28>>2];n=0;_(18,bd|0,136);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);};c[Jc>>2]=c[bd>>2];c[Jc+4>>2]=c[bd+4>>2];c[Jc+8>>2]=c[bd+8>>2];c[Jc+12>>2]=c[bd+12>>2];c[Jc+16>>2]=c[bd+16>>2];c[Jc+20>>2]=c[bd+20>>2];c[Jc+24>>2]=c[bd+24>>2];c[Jc+28>>2]=c[bd+28>>2];Qc=Ic+32|0;c[Xc>>2]=c[Qc>>2];c[Xc+4>>2]=c[Qc+4>>2];c[Xc+8>>2]=c[Qc+8>>2];c[Xc+12>>2]=c[Qc+12>>2];c[Xc+16>>2]=c[Qc+16>>2];c[Xc+20>>2]=c[Qc+20>>2];c[Xc+24>>2]=c[Qc+24>>2];c[Xc+28>>2]=c[Qc+28>>2];n=0;_(18,Xc|0,136);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);};c[be>>2]=c[Xc>>2];c[be+4>>2]=c[Xc+4>>2];c[be+8>>2]=c[Xc+8>>2];c[be+12>>2]=c[Xc+12>>2];c[be+16>>2]=c[Xc+16>>2];c[be+20>>2]=c[Xc+20>>2];c[be+24>>2]=c[Xc+24>>2];c[be+28>>2]=c[Xc+28>>2];Oc=Jc+32|0;c[Oc>>2]=c[be>>2];c[Oc+4>>2]=c[be+4>>2];c[Oc+8>>2]=c[be+8>>2];c[Oc+12>>2]=c[be+12>>2];c[Oc+16>>2]=c[be+16>>2];c[Oc+20>>2]=c[be+20>>2];c[Oc+24>>2]=c[be+24>>2];c[Oc+28>>2]=c[be+28>>2];Oc=Mc+64|0;Pc=Jc;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));n=0;aa(18,Lc|0,Nc|0,Fc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}b=c[Mb>>2]|0;do if((b|0)==(c[Ja>>2]|0)){n=0;Z(42,Sc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}else {b=c[Mb>>2]|0;break}}while(0);ok((c[Sc>>2]|0)+(b*192|0)|0,Lc|0,192)|0;c[Mb>>2]=b+1;n=0;aa(18,Rc|0,Nc|0,Mc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}b=c[Mb>>2]|0;do if((b|0)==(c[Ja>>2]|0)){n=0;Z(42,Sc|0);Qc=n;n=0;if(Qc&1){ce=na()|0;Gc(Sc);za(ce|0);}else {b=c[Mb>>2]|0;break}}while(0);ok((c[Sc>>2]|0)+(b*192|0)|0,Rc|0,192)|0;c[Mb>>2]=b+1;Oc=Bd;Pc=Fd;Qc=Oc+128|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));o=Bd+128|0;c[o>>2]=c[Sc>>2];c[o+4>>2]=c[Sc+4>>2];c[o+8>>2]=c[Sc+8>>2];k=ae;c[k>>2]=-980480611;c[k+4>>2]=-748862579;k=ae+8|0;c[k>>2]=-171504835;c[k+4>>2]=175696680;k=ae+16|0;c[k>>2]=2021213740;c[k+4>>2]=1718526831;k=ae+24|0;c[k>>2]=-1710760145;c[k+4>>2]=235567041;hk(ae+32|0,0,352)|0;k=rd;c[k>>2]=-1099547736;c[k+4>>2]=-1652985799;k=rd+8|0;c[k>>2]=1;c[k+4>>2]=0;k=rd+16|0;c[k>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;o=c[o>>2]|0;k=c[Bd+136>>2]|0;m=Gd+32|0;f=md+32|0;g=kd+32|0;h=gd+32|0;i=dd+32|0;d=256;b=0;e=0;b:while(1){do{if(!d){b=87;break b}d=d+-1|0;if(d>>>0>255){b=87;break b}Rc=rd+(d>>>6<<3)|0;Pc=c[Rc>>2]|0;Rc=c[Rc+4>>2]|0;Qc=nk(1,0,d&63|0)|0;Sc=b;b=(Pc&Qc|0)!=0|(Rc&y|0)!=0;}while(!Sc);if(k>>>0<=e>>>0){b=103;break}j=e+1|0;n=0;_(19,od|0,ae|0);Sc=n;n=0;if(Sc&1){b=126;break}Oc=nd;Pc=o+(e*192|0)|0;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Sc=o+(e*192|0)+64|0;c[ld>>2]=c[m>>2];c[ld+4>>2]=c[m+4>>2];c[ld+8>>2]=c[m+8>>2];c[ld+12>>2]=c[m+12>>2];c[ld+16>>2]=c[m+16>>2];c[ld+20>>2]=c[m+20>>2];c[ld+24>>2]=c[m+24>>2];c[ld+28>>2]=c[m+28>>2];c[Tc>>2]=c[Sc>>2];c[Tc+4>>2]=c[Sc+4>>2];c[Tc+8>>2]=c[Sc+8>>2];c[Tc+12>>2]=c[Sc+12>>2];c[Tc+16>>2]=c[Sc+16>>2];c[Tc+20>>2]=c[Sc+20>>2];c[Tc+24>>2]=c[Sc+24>>2];c[Tc+28>>2]=c[Sc+28>>2];c[ud>>2]=c[m>>2];c[ud+4>>2]=c[m+4>>2];c[ud+8>>2]=c[m+8>>2];c[ud+12>>2]=c[m+12>>2];c[ud+16>>2]=c[m+16>>2];c[ud+20>>2]=c[m+20>>2];c[ud+24>>2]=c[m+24>>2];c[ud+28>>2]=c[m+28>>2];n=0;X(1,Tc|0,ud|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[md>>2]=c[Tc>>2];c[md+4>>2]=c[Tc+4>>2];c[md+8>>2]=c[Tc+8>>2];c[md+12>>2]=c[Tc+12>>2];c[md+16>>2]=c[Tc+16>>2];c[md+20>>2]=c[Tc+20>>2];c[md+24>>2]=c[Tc+24>>2];c[md+28>>2]=c[Tc+28>>2];Sc=o+(e*192|0)+96|0;c[td>>2]=c[Sc>>2];c[td+4>>2]=c[Sc+4>>2];c[td+8>>2]=c[Sc+8>>2];c[td+12>>2]=c[Sc+12>>2];c[td+16>>2]=c[Sc+16>>2];c[td+20>>2]=c[Sc+20>>2];c[td+24>>2]=c[Sc+24>>2];c[td+28>>2]=c[Sc+28>>2];c[sd>>2]=c[ld>>2];c[sd+4>>2]=c[ld+4>>2];c[sd+8>>2]=c[ld+8>>2];c[sd+12>>2]=c[ld+12>>2];c[sd+16>>2]=c[ld+16>>2];c[sd+20>>2]=c[ld+20>>2];c[sd+24>>2]=c[ld+24>>2];c[sd+28>>2]=c[ld+28>>2];n=0;X(1,td|0,sd|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[be>>2]=c[td>>2];c[be+4>>2]=c[td+4>>2];c[be+8>>2]=c[td+8>>2];c[be+12>>2]=c[td+12>>2];c[be+16>>2]=c[td+16>>2];c[be+20>>2]=c[td+20>>2];c[be+24>>2]=c[td+24>>2];c[be+28>>2]=c[td+28>>2];c[f>>2]=c[be>>2];c[f+4>>2]=c[be+4>>2];c[f+8>>2]=c[be+8>>2];c[f+12>>2]=c[be+12>>2];c[f+16>>2]=c[be+16>>2];c[f+20>>2]=c[be+20>>2];c[f+24>>2]=c[be+24>>2];c[f+28>>2]=c[be+28>>2];Sc=o+(e*192|0)+128|0;c[jd>>2]=c[Gd>>2];c[jd+4>>2]=c[Gd+4>>2];c[jd+8>>2]=c[Gd+8>>2];c[jd+12>>2]=c[Gd+12>>2];c[jd+16>>2]=c[Gd+16>>2];c[jd+20>>2]=c[Gd+20>>2];c[jd+24>>2]=c[Gd+24>>2];c[jd+28>>2]=c[Gd+28>>2];c[qd>>2]=c[Sc>>2];c[qd+4>>2]=c[Sc+4>>2];c[qd+8>>2]=c[Sc+8>>2];c[qd+12>>2]=c[Sc+12>>2];c[qd+16>>2]=c[Sc+16>>2];c[qd+20>>2]=c[Sc+20>>2];c[qd+24>>2]=c[Sc+24>>2];c[qd+28>>2]=c[Sc+28>>2];c[fd>>2]=c[Gd>>2];c[fd+4>>2]=c[Gd+4>>2];c[fd+8>>2]=c[Gd+8>>2];c[fd+12>>2]=c[Gd+12>>2];c[fd+16>>2]=c[Gd+16>>2];c[fd+20>>2]=c[Gd+20>>2];c[fd+24>>2]=c[Gd+24>>2];c[fd+28>>2]=c[Gd+28>>2];n=0;X(1,qd|0,fd|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[kd>>2]=c[qd>>2];c[kd+4>>2]=c[qd+4>>2];c[kd+8>>2]=c[qd+8>>2];c[kd+12>>2]=c[qd+12>>2];c[kd+16>>2]=c[qd+16>>2];c[kd+20>>2]=c[qd+20>>2];c[kd+24>>2]=c[qd+24>>2];c[kd+28>>2]=c[qd+28>>2];Sc=o+(e*192|0)+160|0;c[bd>>2]=c[Sc>>2];c[bd+4>>2]=c[Sc+4>>2];c[bd+8>>2]=c[Sc+8>>2];c[bd+12>>2]=c[Sc+12>>2];c[bd+16>>2]=c[Sc+16>>2];c[bd+20>>2]=c[Sc+20>>2];c[bd+24>>2]=c[Sc+24>>2];c[bd+28>>2]=c[Sc+28>>2];c[Xc>>2]=c[jd>>2];c[Xc+4>>2]=c[jd+4>>2];c[Xc+8>>2]=c[jd+8>>2];c[Xc+12>>2]=c[jd+12>>2];c[Xc+16>>2]=c[jd+16>>2];c[Xc+20>>2]=c[jd+20>>2];c[Xc+24>>2]=c[jd+24>>2];c[Xc+28>>2]=c[jd+28>>2];n=0;X(1,bd|0,Xc|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[be>>2]=c[bd>>2];c[be+4>>2]=c[bd+4>>2];c[be+8>>2]=c[bd+8>>2];c[be+12>>2]=c[bd+12>>2];c[be+16>>2]=c[bd+16>>2];c[be+20>>2]=c[bd+20>>2];c[be+24>>2]=c[bd+24>>2];c[be+28>>2]=c[bd+28>>2];c[g>>2]=c[be>>2];c[g+4>>2]=c[be+4>>2];c[g+8>>2]=c[be+8>>2];c[g+12>>2]=c[be+12>>2];c[g+16>>2]=c[be+16>>2];c[g+20>>2]=c[be+20>>2];c[g+24>>2]=c[be+24>>2];c[g+28>>2]=c[be+28>>2];n=0;X(2,pd|0,od|0,nd|0,md|0,kd|0);Sc=n;n=0;if(Sc&1){b=126;break}ok(ae|0,pd|0,384)|0;if(!b){b=1;e=j;continue}if(k>>>0<=j>>>0){b=112;break}e=e+2|0;Oc=hd;Pc=o+(j*192|0)|0;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));Sc=o+(j*192|0)+64|0;c[ed>>2]=c[m>>2];c[ed+4>>2]=c[m+4>>2];c[ed+8>>2]=c[m+8>>2];c[ed+12>>2]=c[m+12>>2];c[ed+16>>2]=c[m+16>>2];c[ed+20>>2]=c[m+20>>2];c[ed+24>>2]=c[m+24>>2];c[ed+28>>2]=c[m+28>>2];c[Yc>>2]=c[Sc>>2];c[Yc+4>>2]=c[Sc+4>>2];c[Yc+8>>2]=c[Sc+8>>2];c[Yc+12>>2]=c[Sc+12>>2];c[Yc+16>>2]=c[Sc+16>>2];c[Yc+20>>2]=c[Sc+20>>2];c[Yc+24>>2]=c[Sc+24>>2];c[Yc+28>>2]=c[Sc+28>>2];c[Wc>>2]=c[m>>2];c[Wc+4>>2]=c[m+4>>2];c[Wc+8>>2]=c[m+8>>2];c[Wc+12>>2]=c[m+12>>2];c[Wc+16>>2]=c[m+16>>2];c[Wc+20>>2]=c[m+20>>2];c[Wc+24>>2]=c[m+24>>2];c[Wc+28>>2]=c[m+28>>2];n=0;X(1,Yc|0,Wc|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[gd>>2]=c[Yc>>2];c[gd+4>>2]=c[Yc+4>>2];c[gd+8>>2]=c[Yc+8>>2];c[gd+12>>2]=c[Yc+12>>2];c[gd+16>>2]=c[Yc+16>>2];c[gd+20>>2]=c[Yc+20>>2];c[gd+24>>2]=c[Yc+24>>2];c[gd+28>>2]=c[Yc+28>>2];Sc=o+(j*192|0)+96|0;c[Vc>>2]=c[Sc>>2];c[Vc+4>>2]=c[Sc+4>>2];c[Vc+8>>2]=c[Sc+8>>2];c[Vc+12>>2]=c[Sc+12>>2];c[Vc+16>>2]=c[Sc+16>>2];c[Vc+20>>2]=c[Sc+20>>2];c[Vc+24>>2]=c[Sc+24>>2];c[Vc+28>>2]=c[Sc+28>>2];c[Uc>>2]=c[ed>>2];c[Uc+4>>2]=c[ed+4>>2];c[Uc+8>>2]=c[ed+8>>2];c[Uc+12>>2]=c[ed+12>>2];c[Uc+16>>2]=c[ed+16>>2];c[Uc+20>>2]=c[ed+20>>2];c[Uc+24>>2]=c[ed+24>>2];c[Uc+28>>2]=c[ed+28>>2];n=0;X(1,Vc|0,Uc|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[be>>2]=c[Vc>>2];c[be+4>>2]=c[Vc+4>>2];c[be+8>>2]=c[Vc+8>>2];c[be+12>>2]=c[Vc+12>>2];c[be+16>>2]=c[Vc+16>>2];c[be+20>>2]=c[Vc+20>>2];c[be+24>>2]=c[Vc+24>>2];c[be+28>>2]=c[Vc+28>>2];c[h>>2]=c[be>>2];c[h+4>>2]=c[be+4>>2];c[h+8>>2]=c[be+8>>2];c[h+12>>2]=c[be+12>>2];c[h+16>>2]=c[be+16>>2];c[h+20>>2]=c[be+20>>2];c[h+24>>2]=c[be+24>>2];c[h+28>>2]=c[be+28>>2];Sc=o+(j*192|0)+128|0;c[cd>>2]=c[Gd>>2];c[cd+4>>2]=c[Gd+4>>2];c[cd+8>>2]=c[Gd+8>>2];c[cd+12>>2]=c[Gd+12>>2];c[cd+16>>2]=c[Gd+16>>2];c[cd+20>>2]=c[Gd+20>>2];c[cd+24>>2]=c[Gd+24>>2];c[cd+28>>2]=c[Gd+28>>2];c[ad>>2]=c[Sc>>2];c[ad+4>>2]=c[Sc+4>>2];c[ad+8>>2]=c[Sc+8>>2];c[ad+12>>2]=c[Sc+12>>2];c[ad+16>>2]=c[Sc+16>>2];c[ad+20>>2]=c[Sc+20>>2];c[ad+24>>2]=c[Sc+24>>2];c[ad+28>>2]=c[Sc+28>>2];c[$c>>2]=c[Gd>>2];c[$c+4>>2]=c[Gd+4>>2];c[$c+8>>2]=c[Gd+8>>2];c[$c+12>>2]=c[Gd+12>>2];c[$c+16>>2]=c[Gd+16>>2];c[$c+20>>2]=c[Gd+20>>2];c[$c+24>>2]=c[Gd+24>>2];c[$c+28>>2]=c[Gd+28>>2];n=0;X(1,ad|0,$c|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[dd>>2]=c[ad>>2];c[dd+4>>2]=c[ad+4>>2];c[dd+8>>2]=c[ad+8>>2];c[dd+12>>2]=c[ad+12>>2];c[dd+16>>2]=c[ad+16>>2];c[dd+20>>2]=c[ad+20>>2];c[dd+24>>2]=c[ad+24>>2];c[dd+28>>2]=c[ad+28>>2];Sc=o+(j*192|0)+160|0;c[_c>>2]=c[Sc>>2];c[_c+4>>2]=c[Sc+4>>2];c[_c+8>>2]=c[Sc+8>>2];c[_c+12>>2]=c[Sc+12>>2];c[_c+16>>2]=c[Sc+16>>2];c[_c+20>>2]=c[Sc+20>>2];c[_c+24>>2]=c[Sc+24>>2];c[_c+28>>2]=c[Sc+28>>2];c[Zc>>2]=c[cd>>2];c[Zc+4>>2]=c[cd+4>>2];c[Zc+8>>2]=c[cd+8>>2];c[Zc+12>>2]=c[cd+12>>2];c[Zc+16>>2]=c[cd+16>>2];c[Zc+20>>2]=c[cd+20>>2];c[Zc+24>>2]=c[cd+24>>2];c[Zc+28>>2]=c[cd+28>>2];n=0;X(1,_c|0,Zc|0,136,-460954743,-2016278654);Sc=n;n=0;if(Sc&1){b=126;break};c[be>>2]=c[_c>>2];c[be+4>>2]=c[_c+4>>2];c[be+8>>2]=c[_c+8>>2];c[be+12>>2]=c[_c+12>>2];c[be+16>>2]=c[_c+16>>2];c[be+20>>2]=c[_c+20>>2];c[be+24>>2]=c[_c+24>>2];c[be+28>>2]=c[_c+28>>2];c[i>>2]=c[be>>2];c[i+4>>2]=c[be+4>>2];c[i+8>>2]=c[be+8>>2];c[i+12>>2]=c[be+12>>2];c[i+16>>2]=c[be+16>>2];c[i+20>>2]=c[be+20>>2];c[i+24>>2]=c[be+24>>2];c[i+28>>2]=c[be+28>>2];n=0;X(2,id|0,ae|0,hd|0,gd|0,dd|0);Sc=n;n=0;if(Sc&1){b=126;break}ok(ae|0,id|0,384)|0;b=1;}if((b|0)==87){if(k>>>0<=e>>>0){n=0;aa(19,2056,e|0,k|0);n=0;ce=na()|0;Hc(Bd);za(ce|0);}b=e+1|0;Oc=_d;Pc=o+(e*192|0)|0;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));ud=o+(e*192|0)+64|0;c[Yd>>2]=c[m>>2];c[Yd+4>>2]=c[m+4>>2];c[Yd+8>>2]=c[m+8>>2];c[Yd+12>>2]=c[m+12>>2];c[Yd+16>>2]=c[m+16>>2];c[Yd+20>>2]=c[m+20>>2];c[Yd+24>>2]=c[m+24>>2];c[Yd+28>>2]=c[m+28>>2];c[Pd>>2]=c[ud>>2];c[Pd+4>>2]=c[ud+4>>2];c[Pd+8>>2]=c[ud+8>>2];c[Pd+12>>2]=c[ud+12>>2];c[Pd+16>>2]=c[ud+16>>2];c[Pd+20>>2]=c[ud+20>>2];c[Pd+24>>2]=c[ud+24>>2];c[Pd+28>>2]=c[ud+28>>2];c[Od>>2]=c[m>>2];c[Od+4>>2]=c[m+4>>2];c[Od+8>>2]=c[m+8>>2];c[Od+12>>2]=c[m+12>>2];c[Od+16>>2]=c[m+16>>2];c[Od+20>>2]=c[m+20>>2];c[Od+24>>2]=c[m+24>>2];c[Od+28>>2]=c[m+28>>2];n=0;X(1,Pd|0,Od|0,136,-460954743,-2016278654);Od=n;n=0;if(Od&1){ce=na()|0;Hc(Bd);za(ce|0);};c[Zd>>2]=c[Pd>>2];c[Zd+4>>2]=c[Pd+4>>2];c[Zd+8>>2]=c[Pd+8>>2];c[Zd+12>>2]=c[Pd+12>>2];c[Zd+16>>2]=c[Pd+16>>2];c[Zd+20>>2]=c[Pd+20>>2];c[Zd+24>>2]=c[Pd+24>>2];c[Zd+28>>2]=c[Pd+28>>2];Pd=o+(e*192|0)+96|0;c[Nd>>2]=c[Pd>>2];c[Nd+4>>2]=c[Pd+4>>2];c[Nd+8>>2]=c[Pd+8>>2];c[Nd+12>>2]=c[Pd+12>>2];c[Nd+16>>2]=c[Pd+16>>2];c[Nd+20>>2]=c[Pd+20>>2];c[Nd+24>>2]=c[Pd+24>>2];c[Nd+28>>2]=c[Pd+28>>2];c[Md>>2]=c[Yd>>2];c[Md+4>>2]=c[Yd+4>>2];c[Md+8>>2]=c[Yd+8>>2];c[Md+12>>2]=c[Yd+12>>2];c[Md+16>>2]=c[Yd+16>>2];c[Md+20>>2]=c[Yd+20>>2];c[Md+24>>2]=c[Yd+24>>2];c[Md+28>>2]=c[Yd+28>>2];n=0;X(1,Nd|0,Md|0,136,-460954743,-2016278654);Yd=n;n=0;if(Yd&1){ce=na()|0;Hc(Bd);za(ce|0);};c[be>>2]=c[Nd>>2];c[be+4>>2]=c[Nd+4>>2];c[be+8>>2]=c[Nd+8>>2];c[be+12>>2]=c[Nd+12>>2];c[be+16>>2]=c[Nd+16>>2];c[be+20>>2]=c[Nd+20>>2];c[be+24>>2]=c[Nd+24>>2];c[be+28>>2]=c[Nd+28>>2];Yd=Zd+32|0;c[Yd>>2]=c[be>>2];c[Yd+4>>2]=c[be+4>>2];c[Yd+8>>2]=c[be+8>>2];c[Yd+12>>2]=c[be+12>>2];c[Yd+16>>2]=c[be+16>>2];c[Yd+20>>2]=c[be+20>>2];c[Yd+24>>2]=c[be+24>>2];c[Yd+28>>2]=c[be+28>>2];Yd=o+(e*192|0)+128|0;c[Wd>>2]=c[Gd>>2];c[Wd+4>>2]=c[Gd+4>>2];c[Wd+8>>2]=c[Gd+8>>2];c[Wd+12>>2]=c[Gd+12>>2];c[Wd+16>>2]=c[Gd+16>>2];c[Wd+20>>2]=c[Gd+20>>2];c[Wd+24>>2]=c[Gd+24>>2];c[Wd+28>>2]=c[Gd+28>>2];c[Ld>>2]=c[Yd>>2];c[Ld+4>>2]=c[Yd+4>>2];c[Ld+8>>2]=c[Yd+8>>2];c[Ld+12>>2]=c[Yd+12>>2];c[Ld+16>>2]=c[Yd+16>>2];c[Ld+20>>2]=c[Yd+20>>2];c[Ld+24>>2]=c[Yd+24>>2];c[Ld+28>>2]=c[Yd+28>>2];c[Kd>>2]=c[Gd>>2];c[Kd+4>>2]=c[Gd+4>>2];c[Kd+8>>2]=c[Gd+8>>2];c[Kd+12>>2]=c[Gd+12>>2];c[Kd+16>>2]=c[Gd+16>>2];c[Kd+20>>2]=c[Gd+20>>2];c[Kd+24>>2]=c[Gd+24>>2];c[Kd+28>>2]=c[Gd+28>>2];n=0;X(1,Ld|0,Kd|0,136,-460954743,-2016278654);Yd=n;n=0;if(Yd&1){ce=na()|0;Hc(Bd);za(ce|0);};c[Xd>>2]=c[Ld>>2];c[Xd+4>>2]=c[Ld+4>>2];c[Xd+8>>2]=c[Ld+8>>2];c[Xd+12>>2]=c[Ld+12>>2];c[Xd+16>>2]=c[Ld+16>>2];c[Xd+20>>2]=c[Ld+20>>2];c[Xd+24>>2]=c[Ld+24>>2];c[Xd+28>>2]=c[Ld+28>>2];Yd=o+(e*192|0)+160|0;c[Jd>>2]=c[Yd>>2];c[Jd+4>>2]=c[Yd+4>>2];c[Jd+8>>2]=c[Yd+8>>2];c[Jd+12>>2]=c[Yd+12>>2];c[Jd+16>>2]=c[Yd+16>>2];c[Jd+20>>2]=c[Yd+20>>2];c[Jd+24>>2]=c[Yd+24>>2];c[Jd+28>>2]=c[Yd+28>>2];c[Id>>2]=c[Wd>>2];c[Id+4>>2]=c[Wd+4>>2];c[Id+8>>2]=c[Wd+8>>2];c[Id+12>>2]=c[Wd+12>>2];c[Id+16>>2]=c[Wd+16>>2];c[Id+20>>2]=c[Wd+20>>2];c[Id+24>>2]=c[Wd+24>>2];c[Id+28>>2]=c[Wd+28>>2];n=0;X(1,Jd|0,Id|0,136,-460954743,-2016278654);Yd=n;n=0;if(Yd&1){ce=na()|0;Hc(Bd);za(ce|0);};c[be>>2]=c[Jd>>2];c[be+4>>2]=c[Jd+4>>2];c[be+8>>2]=c[Jd+8>>2];c[be+12>>2]=c[Jd+12>>2];c[be+16>>2]=c[Jd+16>>2];c[be+20>>2]=c[Jd+20>>2];c[be+24>>2]=c[Jd+24>>2];c[be+28>>2]=c[Jd+28>>2];Yd=Xd+32|0;c[Yd>>2]=c[be>>2];c[Yd+4>>2]=c[be+4>>2];c[Yd+8>>2]=c[be+8>>2];c[Yd+12>>2]=c[be+12>>2];c[Yd+16>>2]=c[be+16>>2];c[Yd+20>>2]=c[be+20>>2];c[Yd+24>>2]=c[be+24>>2];c[Yd+28>>2]=c[be+28>>2];n=0;X(2,$d|0,ae|0,_d|0,Zd|0,Xd|0);_d=n;n=0;if(_d&1){ce=na()|0;Hc(Bd);za(ce|0);}ok(ae|0,$d|0,384)|0;if(k>>>0<=b>>>0){n=0;aa(19,2056,b|0,k|0);n=0;ce=na()|0;Hc(Bd);za(ce|0);}Oc=Ud;Pc=o+(b*192|0)|0;Qc=Oc+64|0;do{c[Oc>>2]=c[Pc>>2];Oc=Oc+4|0;Pc=Pc+4|0;}while((Oc|0)<(Qc|0));$d=o+(b*192|0)+64|0;c[Sd>>2]=c[m>>2];c[Sd+4>>2]=c[m+4>>2];c[Sd+8>>2]=c[m+8>>2];c[Sd+12>>2]=c[m+12>>2];c[Sd+16>>2]=c[m+16>>2];c[Sd+20>>2]=c[m+20>>2];c[Sd+24>>2]=c[m+24>>2];c[Sd+28>>2]=c[m+28>>2];c[Hd>>2]=c[$d>>2];c[Hd+4>>2]=c[$d+4>>2];c[Hd+8>>2]=c[$d+8>>2];c[Hd+12>>2]=c[$d+12>>2];c[Hd+16>>2]=c[$d+16>>2];c[Hd+20>>2]=c[$d+20>>2];c[Hd+24>>2]=c[$d+24>>2];c[Hd+28>>2]=c[$d+28>>2];c[Cd>>2]=c[m>>2];c[Cd+4>>2]=c[m+4>>2];c[Cd+8>>2]=c[m+8>>2];c[Cd+12>>2]=c[m+12>>2];c[Cd+16>>2]=c[m+16>>2];c[Cd+20>>2]=c[m+20>>2];c[Cd+24>>2]=c[m+24>>2];c[Cd+28>>2]=c[m+28>>2];n=0;X(1,Hd|0,Cd|0,136,-460954743,-2016278654);$d=n;n=0;if($d&1){ce=na()|0;Hc(Bd);za(ce|0);};c[Td>>2]=c[Hd>>2];c[Td+4>>2]=c[Hd+4>>2];c[Td+8>>2]=c[Hd+8>>2];c[Td+12>>2]=c[Hd+12>>2];c[Td+16>>2]=c[Hd+16>>2];c[Td+20>>2]=c[Hd+20>>2];c[Td+24>>2]=c[Hd+24>>2];c[Td+28>>2]=c[Hd+28>>2];$d=o+(b*192|0)+96|0;c[Ad>>2]=c[$d>>2];c[Ad+4>>2]=c[$d+4>>2];c[Ad+8>>2]=c[$d+8>>2];c[Ad+12>>2]=c[$d+12>>2];c[Ad+16>>2]=c[$d+16>>2];c[Ad+20>>2]=c[$d+20>>2];c[Ad+24>>2]=c[$d+24>>2];c[Ad+28>>2]=c[$d+28>>2];c[zd>>2]=c[Sd>>2];c[zd+4>>2]=c[Sd+4>>2];c[zd+8>>2]=c[Sd+8>>2];c[zd+12>>2]=c[Sd+12>>2];c[zd+16>>2]=c[Sd+16>>2];c[zd+20>>2]=c[Sd+20>>2];c[zd+24>>2]=c[Sd+24>>2];c[zd+28>>2]=c[Sd+28>>2];n=0;X(1,Ad|0,zd|0,136,-460954743,-2016278654);$d=n;n=0;if($d&1){ce=na()|0;Hc(Bd);za(ce|0);};c[be>>2]=c[Ad>>2];c[be+4>>2]=c[Ad+4>>2];c[be+8>>2]=c[Ad+8>>2];c[be+12>>2]=c[Ad+12>>2];c[be+16>>2]=c[Ad+16>>2];c[be+20>>2]=c[Ad+20>>2];c[be+24>>2]=c[Ad+24>>2];c[be+28>>2]=c[Ad+28>>2];$d=Td+32|0;c[$d>>2]=c[be>>2];c[$d+4>>2]=c[be+4>>2];c[$d+8>>2]=c[be+8>>2];c[$d+12>>2]=c[be+12>>2];c[$d+16>>2]=c[be+16>>2];c[$d+20>>2]=c[be+20>>2];c[$d+24>>2]=c[be+24>>2];c[$d+28>>2]=c[be+28>>2];$d=o+(b*192|0)+128|0;c[Qd>>2]=c[Gd>>2];c[Qd+4>>2]=c[Gd+4>>2];c[Qd+8>>2]=c[Gd+8>>2];c[Qd+12>>2]=c[Gd+12>>2];c[Qd+16>>2]=c[Gd+16>>2];c[Qd+20>>2]=c[Gd+20>>2];c[Qd+24>>2]=c[Gd+24>>2];c[Qd+28>>2]=c[Gd+28>>2];c[yd>>2]=c[$d>>2];c[yd+4>>2]=c[$d+4>>2];c[yd+8>>2]=c[$d+8>>2];c[yd+12>>2]=c[$d+12>>2];c[yd+16>>2]=c[$d+16>>2];c[yd+20>>2]=c[$d+20>>2];c[yd+24>>2]=c[$d+24>>2];c[yd+28>>2]=c[$d+28>>2];c[xd>>2]=c[Gd>>2];c[xd+4>>2]=c[Gd+4>>2];c[xd+8>>2]=c[Gd+8>>2];c[xd+12>>2]=c[Gd+12>>2];c[xd+16>>2]=c[Gd+16>>2];c[xd+20>>2]=c[Gd+20>>2];c[xd+24>>2]=c[Gd+24>>2];c[xd+28>>2]=c[Gd+28>>2];n=0;X(1,yd|0,xd|0,136,-460954743,-2016278654);$d=n;n=0;if($d&1){ce=na()|0;Hc(Bd);za(ce|0);};c[Rd>>2]=c[yd>>2];c[Rd+4>>2]=c[yd+4>>2];c[Rd+8>>2]=c[yd+8>>2];c[Rd+12>>2]=c[yd+12>>2];c[Rd+16>>2]=c[yd+16>>2];c[Rd+20>>2]=c[yd+20>>2];c[Rd+24>>2]=c[yd+24>>2];c[Rd+28>>2]=c[yd+28>>2];$d=o+(b*192|0)+160|0;c[wd>>2]=c[$d>>2];c[wd+4>>2]=c[$d+4>>2];c[wd+8>>2]=c[$d+8>>2];c[wd+12>>2]=c[$d+12>>2];c[wd+16>>2]=c[$d+16>>2];c[wd+20>>2]=c[$d+20>>2];c[wd+24>>2]=c[$d+24>>2];c[wd+28>>2]=c[$d+28>>2];c[vd>>2]=c[Qd>>2];c[vd+4>>2]=c[Qd+4>>2];c[vd+8>>2]=c[Qd+8>>2];c[vd+12>>2]=c[Qd+12>>2];c[vd+16>>2]=c[Qd+16>>2];c[vd+20>>2]=c[Qd+20>>2];c[vd+24>>2]=c[Qd+24>>2];c[vd+28>>2]=c[Qd+28>>2];n=0;X(1,wd|0,vd|0,136,-460954743,-2016278654);$d=n;n=0;if($d&1){ce=na()|0;Hc(Bd);za(ce|0);};c[be>>2]=c[wd>>2];c[be+4>>2]=c[wd+4>>2];c[be+8>>2]=c[wd+8>>2];c[be+12>>2]=c[wd+12>>2];c[be+16>>2]=c[wd+16>>2];c[be+20>>2]=c[wd+20>>2];c[be+24>>2]=c[wd+24>>2];c[be+28>>2]=c[wd+28>>2];$d=Rd+32|0;c[$d>>2]=c[be>>2];c[$d+4>>2]=c[be+4>>2];c[$d+8>>2]=c[be+8>>2];c[$d+12>>2]=c[be+12>>2];c[$d+16>>2]=c[be+16>>2];c[$d+20>>2]=c[be+20>>2];c[$d+24>>2]=c[be+24>>2];c[$d+28>>2]=c[be+28>>2];n=0;X(2,Vd|0,ae|0,Ud|0,Td|0,Rd|0);be=n;n=0;if(be&1){ce=na()|0;Hc(Bd);za(ce|0);}ok(ae|0,Vd|0,384)|0;ok(Dd|0,ae|0,384)|0;n=0;_(20,Ed|0,Dd|0);be=n;n=0;if(be&1){ce=na()|0;Hc(Bd);za(ce|0);}be=Ed;if(!((c[be>>2]|0)==1&(c[be+4>>2]|0)==0)){n=0;_(21,6331,31);n=0;ce=na()|0;Hc(Bd);za(ce|0);}ok(a|0,Ed+8|0,384)|0;b=c[Bd+132>>2]|0;if(b|0)Zb(o,b*192|0,8);l=ce;return}else if((b|0)==103){n=0;aa(19,2056,e|0,k|0);n=0;ce=na()|0;Hc(Bd);za(ce|0);}else if((b|0)==112){n=0;aa(19,2056,j|0,k|0);n=0;ce=na()|0;Hc(Bd);za(ce|0);}else if((b|0)==126){ce=na()|0;Hc(Bd);za(ce|0);}}else if((b|0)==82){ce=na()|0;Gc(Sc);za(ce|0);}}function Fc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;z=l;l=l+1024|0;r=z+960|0;s=z+896|0;t=z+832|0;u=z+768|0;v=z+704|0;w=z+640|0;x=z+576|0;g=z+512|0;h=z+448|0;i=z+384|0;j=z+320|0;k=z+256|0;e=z+192|0;f=z+128|0;m=z+64|0;n=z;y=v;A=b;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));o=b+128|0;y=s;A=o;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=d;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(u,s,r);c[s>>2]=c[v>>2];c[s+4>>2]=c[v+4>>2];c[s+8>>2]=c[v+8>>2];c[s+12>>2]=c[v+12>>2];c[s+16>>2]=c[v+16>>2];c[s+20>>2]=c[v+20>>2];c[s+24>>2]=c[v+24>>2];c[s+28>>2]=c[v+28>>2];c[r>>2]=c[u>>2];c[r+4>>2]=c[u+4>>2];c[r+8>>2]=c[u+8>>2];c[r+12>>2]=c[u+12>>2];c[r+16>>2]=c[u+16>>2];c[r+20>>2]=c[u+20>>2];c[r+24>>2]=c[u+24>>2];c[r+28>>2]=c[u+28>>2];Lc(s,r,136);c[n>>2]=c[s>>2];c[n+4>>2]=c[s+4>>2];c[n+8>>2]=c[s+8>>2];c[n+12>>2]=c[s+12>>2];c[n+16>>2]=c[s+16>>2];c[n+20>>2]=c[s+20>>2];c[n+24>>2]=c[s+24>>2];c[n+28>>2]=c[s+28>>2];p=v+32|0;c[s>>2]=c[p>>2];c[s+4>>2]=c[p+4>>2];c[s+8>>2]=c[p+8>>2];c[s+12>>2]=c[p+12>>2];c[s+16>>2]=c[p+16>>2];c[s+20>>2]=c[p+20>>2];c[s+24>>2]=c[p+24>>2];c[s+28>>2]=c[p+28>>2];p=u+32|0;c[r>>2]=c[p>>2];c[r+4>>2]=c[p+4>>2];c[r+8>>2]=c[p+8>>2];c[r+12>>2]=c[p+12>>2];c[r+16>>2]=c[p+16>>2];c[r+20>>2]=c[p+20>>2];c[r+24>>2]=c[p+24>>2];c[r+28>>2]=c[p+28>>2];Lc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];p=n+32|0;c[p>>2]=c[t>>2];c[p+4>>2]=c[t+4>>2];c[p+8>>2]=c[t+8>>2];c[p+12>>2]=c[t+12>>2];c[p+16>>2]=c[t+16>>2];c[p+20>>2]=c[t+20>>2];c[p+24>>2]=c[t+24>>2];c[p+28>>2]=c[t+28>>2];p=b+64|0;y=v;A=p;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=s;A=o;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));q=d+64|0;y=r;A=q;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(u,s,r);c[s>>2]=c[v>>2];c[s+4>>2]=c[v+4>>2];c[s+8>>2]=c[v+8>>2];c[s+12>>2]=c[v+12>>2];c[s+16>>2]=c[v+16>>2];c[s+20>>2]=c[v+20>>2];c[s+24>>2]=c[v+24>>2];c[s+28>>2]=c[v+28>>2];c[r>>2]=c[u>>2];c[r+4>>2]=c[u+4>>2];c[r+8>>2]=c[u+8>>2];c[r+12>>2]=c[u+12>>2];c[r+16>>2]=c[u+16>>2];c[r+20>>2]=c[u+20>>2];c[r+24>>2]=c[u+24>>2];c[r+28>>2]=c[u+28>>2];Lc(s,r,136);c[m>>2]=c[s>>2];c[m+4>>2]=c[s+4>>2];c[m+8>>2]=c[s+8>>2];c[m+12>>2]=c[s+12>>2];c[m+16>>2]=c[s+16>>2];c[m+20>>2]=c[s+20>>2];c[m+24>>2]=c[s+24>>2];c[m+28>>2]=c[s+28>>2];y=v+32|0;c[s>>2]=c[y>>2];c[s+4>>2]=c[y+4>>2];c[s+8>>2]=c[y+8>>2];c[s+12>>2]=c[y+12>>2];c[s+16>>2]=c[y+16>>2];c[s+20>>2]=c[y+20>>2];c[s+24>>2]=c[y+24>>2];c[s+28>>2]=c[y+28>>2];y=u+32|0;c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];Lc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];y=m+32|0;c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];dd(f,n);dd(e,m);y=s;A=n;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=f;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(k,s,r);y=s;A=b;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=f;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(j,s,r);y=s;A=o;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=e;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(v,s,r);y=u;A=k;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));c[s>>2]=c[v>>2];c[s+4>>2]=c[v+4>>2];c[s+8>>2]=c[v+8>>2];c[s+12>>2]=c[v+12>>2];c[s+16>>2]=c[v+16>>2];c[s+20>>2]=c[v+20>>2];c[s+24>>2]=c[v+24>>2];c[s+28>>2]=c[v+28>>2];c[r>>2]=c[k>>2];c[r+4>>2]=c[k+4>>2];c[r+8>>2]=c[k+8>>2];c[r+12>>2]=c[k+12>>2];c[r+16>>2]=c[k+16>>2];c[r+20>>2]=c[k+20>>2];c[r+24>>2]=c[k+24>>2];c[r+28>>2]=c[k+28>>2];Kc(s,r,136);c[x>>2]=c[s>>2];c[x+4>>2]=c[s+4>>2];c[x+8>>2]=c[s+8>>2];c[x+12>>2]=c[s+12>>2];c[x+16>>2]=c[s+16>>2];c[x+20>>2]=c[s+20>>2];c[x+24>>2]=c[s+24>>2];c[x+28>>2]=c[s+28>>2];e=v+32|0;c[s>>2]=c[e>>2];c[s+4>>2]=c[e+4>>2];c[s+8>>2]=c[e+8>>2];c[s+12>>2]=c[e+12>>2];c[s+16>>2]=c[e+16>>2];c[s+20>>2]=c[e+20>>2];c[s+24>>2]=c[e+24>>2];c[s+28>>2]=c[e+28>>2];e=u+32|0;c[r>>2]=c[e>>2];c[r+4>>2]=c[e+4>>2];c[r+8>>2]=c[e+8>>2];c[r+12>>2]=c[e+12>>2];c[r+16>>2]=c[e+16>>2];c[r+20>>2]=c[e+20>>2];c[r+24>>2]=c[e+24>>2];c[r+28>>2]=c[e+28>>2];Kc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];e=x+32|0;c[e>>2]=c[t>>2];c[e+4>>2]=c[t+4>>2];c[e+8>>2]=c[t+8>>2];c[e+12>>2]=c[t+12>>2];c[e+16>>2]=c[t+16>>2];c[e+20>>2]=c[t+20>>2];c[e+24>>2]=c[t+24>>2];c[e+28>>2]=c[t+28>>2];y=v;A=j;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=u;A=j;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));c[s>>2]=c[v>>2];c[s+4>>2]=c[v+4>>2];c[s+8>>2]=c[v+8>>2];c[s+12>>2]=c[v+12>>2];c[s+16>>2]=c[v+16>>2];c[s+20>>2]=c[v+20>>2];c[s+24>>2]=c[v+24>>2];c[s+28>>2]=c[v+28>>2];c[r>>2]=c[j>>2];c[r+4>>2]=c[j+4>>2];c[r+8>>2]=c[j+8>>2];c[r+12>>2]=c[j+12>>2];c[r+16>>2]=c[j+16>>2];c[r+20>>2]=c[j+20>>2];c[r+24>>2]=c[j+24>>2];c[r+28>>2]=c[j+28>>2];Kc(s,r,136);c[w>>2]=c[s>>2];c[w+4>>2]=c[s+4>>2];c[w+8>>2]=c[s+8>>2];c[w+12>>2]=c[s+12>>2];c[w+16>>2]=c[s+16>>2];c[w+20>>2]=c[s+20>>2];c[w+24>>2]=c[s+24>>2];c[w+28>>2]=c[s+28>>2];y=v+32|0;c[s>>2]=c[y>>2];c[s+4>>2]=c[y+4>>2];c[s+8>>2]=c[y+8>>2];c[s+12>>2]=c[y+12>>2];c[s+16>>2]=c[y+16>>2];c[s+20>>2]=c[y+20>>2];c[s+24>>2]=c[y+24>>2];c[s+28>>2]=c[y+28>>2];y=u+32|0;c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];Kc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];y=w+32|0;c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];c[s>>2]=c[x>>2];c[s+4>>2]=c[x+4>>2];c[s+8>>2]=c[x+8>>2];c[s+12>>2]=c[x+12>>2];c[s+16>>2]=c[x+16>>2];c[s+20>>2]=c[x+20>>2];c[s+24>>2]=c[x+24>>2];c[s+28>>2]=c[x+28>>2];c[r>>2]=c[w>>2];c[r+4>>2]=c[w+4>>2];c[r+8>>2]=c[w+8>>2];c[r+12>>2]=c[w+12>>2];c[r+16>>2]=c[w+16>>2];c[r+20>>2]=c[w+20>>2];c[r+24>>2]=c[w+24>>2];c[r+28>>2]=c[w+28>>2];Lc(s,r,136);c[i>>2]=c[s>>2];c[i+4>>2]=c[s+4>>2];c[i+8>>2]=c[s+8>>2];c[i+12>>2]=c[s+12>>2];c[i+16>>2]=c[s+16>>2];c[i+20>>2]=c[s+20>>2];c[i+24>>2]=c[s+24>>2];c[i+28>>2]=c[s+28>>2];c[s>>2]=c[e>>2];c[s+4>>2]=c[e+4>>2];c[s+8>>2]=c[e+8>>2];c[s+12>>2]=c[e+12>>2];c[s+16>>2]=c[e+16>>2];c[s+20>>2]=c[e+20>>2];c[s+24>>2]=c[e+24>>2];c[s+28>>2]=c[e+28>>2];c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];Lc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];y=i+32|0;c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];y=s;A=n;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=i;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(t,s,r);y=b;A=t;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=x;A=m;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=v;A=j;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=u;A=i;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));c[s>>2]=c[j>>2];c[s+4>>2]=c[j+4>>2];c[s+8>>2]=c[j+8>>2];c[s+12>>2]=c[j+12>>2];c[s+16>>2]=c[j+16>>2];c[s+20>>2]=c[j+20>>2];c[s+24>>2]=c[j+24>>2];c[s+28>>2]=c[j+28>>2];c[r>>2]=c[i>>2];c[r+4>>2]=c[i+4>>2];c[r+8>>2]=c[i+8>>2];c[r+12>>2]=c[i+12>>2];c[r+16>>2]=c[i+16>>2];c[r+20>>2]=c[i+20>>2];c[r+24>>2]=c[i+24>>2];c[r+28>>2]=c[i+28>>2];Lc(s,r,136);c[w>>2]=c[s>>2];c[w+4>>2]=c[s+4>>2];c[w+8>>2]=c[s+8>>2];c[w+12>>2]=c[s+12>>2];c[w+16>>2]=c[s+16>>2];c[w+20>>2]=c[s+20>>2];c[w+24>>2]=c[s+24>>2];c[w+28>>2]=c[s+28>>2];y=v+32|0;c[s>>2]=c[y>>2];c[s+4>>2]=c[y+4>>2];c[s+8>>2]=c[y+8>>2];c[s+12>>2]=c[y+12>>2];c[s+16>>2]=c[y+16>>2];c[s+20>>2]=c[y+20>>2];c[s+24>>2]=c[y+24>>2];c[s+28>>2]=c[y+28>>2];y=u+32|0;c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];Lc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];y=w+32|0;c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];cd(g,x,w);y=s;A=k;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=p;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(u,s,r);c[s>>2]=c[g>>2];c[s+4>>2]=c[g+4>>2];c[s+8>>2]=c[g+8>>2];c[s+12>>2]=c[g+12>>2];c[s+16>>2]=c[g+16>>2];c[s+20>>2]=c[g+20>>2];c[s+24>>2]=c[g+24>>2];c[s+28>>2]=c[g+28>>2];c[r>>2]=c[u>>2];c[r+4>>2]=c[u+4>>2];c[r+8>>2]=c[u+8>>2];c[r+12>>2]=c[u+12>>2];c[r+16>>2]=c[u+16>>2];c[r+20>>2]=c[u+20>>2];c[r+24>>2]=c[u+24>>2];c[r+28>>2]=c[u+28>>2];Lc(s,r,136);c[h>>2]=c[s>>2];c[h+4>>2]=c[s+4>>2];c[h+8>>2]=c[s+8>>2];c[h+12>>2]=c[s+12>>2];c[h+16>>2]=c[s+16>>2];c[h+20>>2]=c[s+20>>2];c[h+24>>2]=c[s+24>>2];c[h+28>>2]=c[s+28>>2];y=g+32|0;c[s>>2]=c[y>>2];c[s+4>>2]=c[y+4>>2];c[s+8>>2]=c[y+8>>2];c[s+12>>2]=c[y+12>>2];c[s+16>>2]=c[y+16>>2];c[s+20>>2]=c[y+20>>2];c[s+24>>2]=c[y+24>>2];c[s+28>>2]=c[y+28>>2];y=u+32|0;c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];Lc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];y=h+32|0;c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];y=p;A=h;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=s;A=o;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=k;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(t,s,r);y=o;A=t;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=x;c[y>>2]=1091403767;c[y+4>>2]=-167360562;y=x+8|0;c[y>>2]=-753151983;c[y+4>>2]=792555341;y=x+16|0;c[y>>2]=960546513;c[y+4>>2]=692269950;y=x+24|0;c[y>>2]=-1478256553;c[y+4>>2]=496343272;y=x+32|0;c[y>>2]=-980480611;c[y+4>>2]=-748862579;y=x+40|0;c[y>>2]=-171504835;c[y+4>>2]=175696680;y=x+48|0;c[y>>2]=2021213740;c[y+4>>2]=1718526831;y=x+56|0;c[y>>2]=-1710760145;c[y+4>>2]=235567041;y=s;A=m;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=d;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(v,s,r);y=s;A=n;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=r;A=q;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));cd(u,s,r);c[s>>2]=c[v>>2];c[s+4>>2]=c[v+4>>2];c[s+8>>2]=c[v+8>>2];c[s+12>>2]=c[v+12>>2];c[s+16>>2]=c[v+16>>2];c[s+20>>2]=c[v+20>>2];c[s+24>>2]=c[v+24>>2];c[s+28>>2]=c[v+28>>2];c[r>>2]=c[u>>2];c[r+4>>2]=c[u+4>>2];c[r+8>>2]=c[u+8>>2];c[r+12>>2]=c[u+12>>2];c[r+16>>2]=c[u+16>>2];c[r+20>>2]=c[u+20>>2];c[r+24>>2]=c[u+24>>2];c[r+28>>2]=c[u+28>>2];Lc(s,r,136);c[w>>2]=c[s>>2];c[w+4>>2]=c[s+4>>2];c[w+8>>2]=c[s+8>>2];c[w+12>>2]=c[s+12>>2];c[w+16>>2]=c[s+16>>2];c[w+20>>2]=c[s+20>>2];c[w+24>>2]=c[s+24>>2];c[w+28>>2]=c[s+28>>2];y=v+32|0;c[s>>2]=c[y>>2];c[s+4>>2]=c[y+4>>2];c[s+8>>2]=c[y+8>>2];c[s+12>>2]=c[y+12>>2];c[s+16>>2]=c[y+16>>2];c[s+20>>2]=c[y+20>>2];c[s+24>>2]=c[y+24>>2];c[s+28>>2]=c[y+28>>2];y=u+32|0;c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];Lc(s,r,136);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];c[t+20>>2]=c[s+20>>2];c[t+24>>2]=c[s+24>>2];c[t+28>>2]=c[s+28>>2];y=w+32|0;c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];cd(g,x,w);y=s;A=m;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));c[r>>2]=c[m>>2];c[r+4>>2]=c[m+4>>2];c[r+8>>2]=c[m+8>>2];c[r+12>>2]=c[m+12>>2];c[r+16>>2]=c[m+16>>2];c[r+20>>2]=c[m+20>>2];c[r+24>>2]=c[m+24>>2];c[r+28>>2]=c[m+28>>2];Nc(r,136);c[u>>2]=c[r>>2];c[u+4>>2]=c[r+4>>2];c[u+8>>2]=c[r+8>>2];c[u+12>>2]=c[r+12>>2];c[u+16>>2]=c[r+16>>2];c[u+20>>2]=c[r+20>>2];c[u+24>>2]=c[r+24>>2];c[u+28>>2]=c[r+28>>2];y=s+32|0;c[r>>2]=c[y>>2];c[r+4>>2]=c[y+4>>2];c[r+8>>2]=c[y+8>>2];c[r+12>>2]=c[y+12>>2];c[r+16>>2]=c[y+16>>2];c[r+20>>2]=c[y+20>>2];c[r+24>>2]=c[y+24>>2];c[r+28>>2]=c[y+28>>2];Nc(r,136);c[t>>2]=c[r>>2];c[t+4>>2]=c[r+4>>2];c[t+8>>2]=c[r+8>>2];c[t+12>>2]=c[r+12>>2];c[t+16>>2]=c[r+16>>2];c[t+20>>2]=c[r+20>>2];c[t+24>>2]=c[r+24>>2];c[t+28>>2]=c[r+28>>2];y=u+32|0;c[y>>2]=c[t>>2];c[y+4>>2]=c[t+4>>2];c[y+8>>2]=c[t+8>>2];c[y+12>>2]=c[t+12>>2];c[y+16>>2]=c[t+16>>2];c[y+20>>2]=c[t+20>>2];c[y+24>>2]=c[t+24>>2];c[y+28>>2]=c[t+28>>2];y=a;A=g;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=a+64|0;A=n;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));y=a+128|0;A=u;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0;}while((y|0)<(B|0));l=z;return}function Gc(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b*192|0,8);return}function Hc(a){a=a|0;var b=0;b=c[a+132>>2]|0;if(!b)return;Zb(c[a+128>>2]|0,b*192|0,8);return}function Ic(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=4;while(1){if(!g){a=0;b=5;break}g=g+-1|0;d=a+(g<<3)|0;h=c[d>>2]|0;d=c[d+4>>2]|0;f=b+(g<<3)|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if(d>>>0<f>>>0|(d|0)==(f|0)&h>>>0<e>>>0){a=-1;b=5;break}if(d>>>0>f>>>0|(d|0)==(f|0)&h>>>0>e>>>0){a=1;b=5;break}}if((b|0)==5)return a|0;return 0}function Jc(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;if((f|0)==32){g=d+24|0;g=ga(c[g>>2]|0,c[g+4>>2]|0)|0;f=y;h=e;i=h;a[i>>0]=g;a[i+1>>0]=g>>8;a[i+2>>0]=g>>16;a[i+3>>0]=g>>24;h=h+4|0;a[h>>0]=f;a[h+1>>0]=f>>8;a[h+2>>0]=f>>16;a[h+3>>0]=f>>24;h=d+16|0;h=ga(c[h>>2]|0,c[h+4>>2]|0)|0;f=y;i=e+8|0;g=i;a[g>>0]=h;a[g+1>>0]=h>>8;a[g+2>>0]=h>>16;a[g+3>>0]=h>>24;i=i+4|0;a[i>>0]=f;a[i+1>>0]=f>>8;a[i+2>>0]=f>>16;a[i+3>>0]=f>>24;i=d+8|0;i=ga(c[i>>2]|0,c[i+4>>2]|0)|0;f=y;g=e+16|0;h=g;a[h>>0]=i;a[h+1>>0]=i>>8;a[h+2>>0]=i>>16;a[h+3>>0]=i>>24;g=g+4|0;a[g>>0]=f;a[g+1>>0]=f>>8;a[g+2>>0]=f>>16;a[g+3>>0]=f>>24;g=d;g=ga(c[g>>2]|0,c[g+4>>2]|0)|0;d=y;f=e+24|0;e=f;a[e>>0]=g;a[e+1>>0]=g>>8;a[e+2>>0]=g>>16;a[e+3>>0]=g>>24;f=f+4|0;a[f>>0]=d;a[f+1>>0]=d>>8;a[f+2>>0]=d>>16;a[f+3>>0]=d>>24;c[b>>2]=0;return}else {c[b>>2]=1;c[b+4>>2]=32;c[b+8>>2]=f;return}}function Kc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;n=a;k=c[n>>2]|0;n=c[n+4>>2]|0;g=b;l=c[g>>2]|0;g=c[g+4>>2]|0;gk(l|0,0,k|0,0)|0;m=y;k=gk(l|0,g|0,k|0,n|0)|0;l=y;n=gk(g|0,0,n|0,0)|0;m=gk(n|0,y|0,m|0,0)|0;n=a;c[n>>2]=k;c[n+4>>2]=m;n=a+8|0;g=n;q=c[g+4>>2]|0;e=b+8|0;o=c[e>>2]|0;e=c[e+4>>2]|0;g=gk(y|0,0,c[g>>2]|0,0)|0;t=y;gk(g|0,t|0,o|0,0)|0;p=y;o=gk(g|0,t|0,o|0,e|0)|0;q=gk(e|0,0,q|0,0)|0;p=gk(q|0,y|0,p|0,0)|0;q=n;c[q>>2]=o;c[q+4>>2]=p;q=a+16|0;e=q;t=c[e+4>>2]|0;g=b+16|0;r=c[g>>2]|0;g=c[g+4>>2]|0;e=gk(y|0,0,c[e>>2]|0,0)|0;f=y;gk(e|0,f|0,r|0,0)|0;s=y;r=gk(e|0,f|0,r|0,g|0)|0;t=gk(g|0,0,t|0,0)|0;s=gk(t|0,y|0,s|0,0)|0;t=q;c[t>>2]=r;c[t+4>>2]=s;t=a+24|0;g=t;f=c[g>>2]|0;g=c[g+4>>2]|0;e=b+24|0;h=c[e>>2]|0;e=c[e+4>>2]|0;b=gk(y|0,0,f|0,0)|0;j=y;i=gk(b|0,j|0,h|0,e|0)|0;gk(0,e|0,f|0,g|0)|0;gk(h|0,y|0,b|0,j|0)|0;j=y;b=t;c[b>>2]=i;c[b+4>>2]=j;b=4;do{if(!b)break;b=b+-1|0;f=a+(b<<3)|0;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d+(b<<3)|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if(f>>>0<h>>>0|(f|0)==(h|0)&e>>>0<g>>>0){u=6;break}}while(!(f>>>0>h>>>0|(f|0)==(h|0)&e>>>0>g>>>0));if((u|0)==6)return;f=d;u=c[f>>2]|0;f=c[f+4>>2]|0;h=fk(k|0,1,u|0,0)|0;g=y;u=fk(k|0,l|0,u|0,f|0)|0;m=fk(m|0,1,f|0,0)|0;l=(g>>>0<1|(g|0)==1&h>>>0<0)<<31>>31;m=gk(l|0,((l|0)<0)<<31>>31|0,m|0,y|0)|0;l=y;k=a;c[k>>2]=u;c[k+4>>2]=m;k=d+8|0;u=c[k+4>>2]|0;o=fk(o|0,1,c[k>>2]|0,0)|0;m=(l>>>0<1|(l|0)==1&m>>>0<0)<<31>>31;o=gk(m|0,((m|0)<0)<<31>>31|0,o|0,y|0)|0;m=y;p=fk(p|0,1,u|0,0)|0;m=(m>>>0<1|(m|0)==1&o>>>0<0)<<31>>31;p=gk(m|0,((m|0)<0)<<31>>31|0,p|0,y|0)|0;m=y;u=n;c[u>>2]=o;c[u+4>>2]=p;u=d+16|0;o=c[u+4>>2]|0;u=fk(r|0,1,c[u>>2]|0,0)|0;p=(m>>>0<1|(m|0)==1&p>>>0<0)<<31>>31;u=gk(p|0,((p|0)<0)<<31>>31|0,u|0,y|0)|0;p=y;s=fk(s|0,1,o|0,0)|0;p=(p>>>0<1|(p|0)==1&u>>>0<0)<<31>>31;s=gk(p|0,((p|0)<0)<<31>>31|0,s|0,y|0)|0;p=y;r=q;c[r>>2]=u;c[r+4>>2]=s;r=d+24|0;u=c[r+4>>2]|0;r=fk(i|0,1,c[r>>2]|0,0)|0;s=(p>>>0<1|(p|0)==1&s>>>0<0)<<31>>31;r=gk(s|0,((s|0)<0)<<31>>31|0,r|0,y|0)|0;s=y;u=fk(j|0,0,u|0,0)|0;s=(s>>>0<1|(s|0)==1&r>>>0<0)<<31>>31;s=gk(u|0,y|0,s|0,((s|0)<0)<<31>>31|0)|0;u=t;c[u>>2]=r;c[u+4>>2]=s;return}function Lc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;i=4;while(1){if(!i){i=6;break}i=i+-1|0;f=a+(i<<3)|0;e=c[f>>2]|0;f=c[f+4>>2]|0;h=b+(i<<3)|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if(f>>>0<h>>>0|(f|0)==(h|0)&e>>>0<g>>>0){i=5;break}if(f>>>0>h>>>0|(f|0)==(h|0)&e>>>0>g>>>0){i=6;break}}if((i|0)==5){g=a;h=c[g>>2]|0;g=c[g+4>>2]|0;m=d;e=c[m>>2]|0;m=c[m+4>>2]|0;gk(e|0,0,h|0,0)|0;j=y;h=gk(e|0,m|0,h|0,g|0)|0;g=gk(m|0,0,g|0,0)|0;j=gk(g|0,y|0,j|0,0)|0;g=a;c[g>>2]=h;c[g+4>>2]=j;g=a+8|0;j=g;h=c[j+4>>2]|0;m=d+8|0;e=c[m>>2]|0;m=c[m+4>>2]|0;j=gk(y|0,0,c[j>>2]|0,0)|0;l=y;gk(j|0,l|0,e|0,0)|0;i=y;e=gk(j|0,l|0,e|0,m|0)|0;h=gk(m|0,0,h|0,0)|0;i=gk(h|0,y|0,i|0,0)|0;h=g;c[h>>2]=e;c[h+4>>2]=i;h=a+16|0;i=h;e=c[i+4>>2]|0;m=d+16|0;l=c[m>>2]|0;m=c[m+4>>2]|0;i=gk(y|0,0,c[i>>2]|0,0)|0;j=y;gk(i|0,j|0,l|0,0)|0;k=y;l=gk(i|0,j|0,l|0,m|0)|0;e=gk(m|0,0,e|0,0)|0;k=gk(e|0,y|0,k|0,0)|0;e=h;c[e>>2]=l;c[e+4>>2]=k;e=a+24|0;k=e;l=c[k>>2]|0;k=c[k+4>>2]|0;m=d+24|0;j=c[m>>2]|0;m=c[m+4>>2]|0;i=gk(y|0,0,l|0,0)|0;f=y;d=gk(i|0,f|0,j|0,m|0)|0;gk(0,m|0,l|0,k|0)|0;gk(j|0,y|0,i|0,f|0)|0;f=e;c[f>>2]=d;c[f+4>>2]=y;f=a;}else if((i|0)==6){f=a;g=a+8|0;h=a+16|0;e=a+24|0;}d=f;a=c[d>>2]|0;d=c[d+4>>2]|0;k=b;m=c[k>>2]|0;k=c[k+4>>2]|0;j=fk(a|0,1,m|0,0)|0;l=y;m=fk(a|0,d|0,m|0,k|0)|0;k=fk(d|0,1,k|0,0)|0;j=(l>>>0<1|(l|0)==1&j>>>0<0)<<31>>31;k=gk(j|0,((j|0)<0)<<31>>31|0,k|0,y|0)|0;j=y;l=f;c[l>>2]=m;c[l+4>>2]=k;l=g;m=c[l+4>>2]|0;d=b+8|0;a=c[d+4>>2]|0;d=fk(c[l>>2]|0,1,c[d>>2]|0,0)|0;k=(j>>>0<1|(j|0)==1&k>>>0<0)<<31>>31;d=gk(k|0,((k|0)<0)<<31>>31|0,d|0,y|0)|0;k=y;a=fk(m|0,1,a|0,0)|0;k=(k>>>0<1|(k|0)==1&d>>>0<0)<<31>>31;a=gk(k|0,((k|0)<0)<<31>>31|0,a|0,y|0)|0;k=y;m=g;c[m>>2]=d;c[m+4>>2]=a;m=h;d=c[m+4>>2]|0;j=b+16|0;l=c[j+4>>2]|0;j=fk(c[m>>2]|0,1,c[j>>2]|0,0)|0;a=(k>>>0<1|(k|0)==1&a>>>0<0)<<31>>31;j=gk(a|0,((a|0)<0)<<31>>31|0,j|0,y|0)|0;a=y;l=fk(d|0,1,l|0,0)|0;a=(a>>>0<1|(a|0)==1&j>>>0<0)<<31>>31;l=gk(a|0,((a|0)<0)<<31>>31|0,l|0,y|0)|0;a=y;d=h;c[d>>2]=j;c[d+4>>2]=l;d=e;j=c[d+4>>2]|0;k=b+24|0;m=c[k+4>>2]|0;k=fk(c[d>>2]|0,1,c[k>>2]|0,0)|0;l=(a>>>0<1|(a|0)==1&l>>>0<0)<<31>>31;k=gk(l|0,((l|0)<0)<<31>>31|0,k|0,y|0)|0;l=y;m=fk(j|0,0,m|0,0)|0;l=(l>>>0<1|(l|0)==1&k>>>0<0)<<31>>31;l=gk(m|0,y|0,l|0,((l|0)<0)<<31>>31|0)|0;m=e;c[m>>2]=k;c[m+4>>2]=l;return}function Mc(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0;x=l;l=l+64|0;v=x;g=v;h=g+64|0;do{c[g>>2]=0;g=g+4|0;}while((g|0)<(h|0));t=a+32|0;u=b+32|0;o=a;p=0;do{r=o;o=o+8|0;g=v+(p<<3)|0;q=c[r>>2]|0;r=c[r+4>>2]|0;a:do if(!((q|0)==0&(r|0)==0)){s=g+(8-p<<3)|0;h=b;m=0;n=0;while(1){k=g;g=g+8|0;if((h|0)==(u|0))if((m|0)==0&(n|0)==0)break a;else {h=u;i=0;j=0;}else {j=h;h=h+8|0;i=c[j>>2]|0;j=c[j+4>>2]|0;}E=k;D=c[E>>2]|0;E=c[E+4>>2]|0;z=qk(i|0,0,q|0,0)|0;D=gk(z|0,y|0,D|0,0)|0;z=y;gk(D|0,z|0,m|0,0)|0;C=y;z=gk(D|0,z|0,m|0,n|0)|0;D=qk(i|0,0,r|0,0)|0;B=y;i=qk(j|0,0,q|0,0)|0;A=y;n=gk(E|0,0,n|0,0)|0;n=gk(n|0,y|0,D|0,0)|0;i=gk(n|0,y|0,i|0,0)|0;i=gk(i|0,y|0,C|0,0)|0;n=y;j=qk(j|0,0,r|0,0)|0;j=gk(B|0,0,j|0,y|0)|0;j=gk(j|0,y|0,A|0,0)|0;m=gk(j|0,y|0,n|0,0)|0;n=k;c[n>>2]=z;c[n+4>>2]=i;if((g|0)==(s|0))break;else n=y;}}while(0);p=p+1|0;}while((o|0)!=(t|0));o=d+32|0;p=0;do{g=v+(p<<3)|0;q=g;q=qk(c[q>>2]|0,c[q+4>>2]|0,e|0,f|0)|0;r=y;b:do if(!((q|0)==0&(r|0)==0)){s=g+(8-p<<3)|0;h=d;j=0;k=0;while(1){i=g;g=g+8|0;if((h|0)==(o|0))if((j|0)==0&(k|0)==0)break b;else {m=0;n=0;h=o;}else {n=h;m=c[n>>2]|0;n=c[n+4>>2]|0;h=h+8|0;}b=i;A=c[b>>2]|0;b=c[b+4>>2]|0;C=qk(m|0,0,q|0,0)|0;A=gk(C|0,y|0,A|0,0)|0;C=y;gk(A|0,C|0,j|0,0)|0;D=y;C=gk(A|0,C|0,j|0,k|0)|0;A=qk(m|0,0,r|0,0)|0;z=y;E=qk(n|0,0,q|0,0)|0;B=y;b=gk(b|0,0,k|0,0)|0;A=gk(b|0,y|0,A|0,0)|0;E=gk(A|0,y|0,E|0,0)|0;D=gk(E|0,y|0,D|0,0)|0;E=y;A=qk(n|0,0,r|0,0)|0;A=gk(z|0,0,A|0,y|0)|0;B=gk(A|0,y|0,B|0,0)|0;j=gk(B|0,y|0,E|0,0)|0;E=i;c[E>>2]=C;c[E+4>>2]=D;if((g|0)==(s|0))break;else k=y;}}while(0);p=p+1|0;}while(p>>>0<4);g=v+32|0;c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[a+16>>2]=c[g+16>>2];c[a+20>>2]=c[g+20>>2];c[a+24>>2]=c[g+24>>2];c[a+28>>2]=c[g+28>>2];g=4;do{if(!g)break;g=g+-1|0;i=a+(g<<3)|0;h=c[i>>2]|0;i=c[i+4>>2]|0;k=d+(g<<3)|0;j=c[k>>2]|0;k=c[k+4>>2]|0;if(i>>>0<k>>>0|(i|0)==(k|0)&h>>>0<j>>>0){w=22;break}}while(!(i>>>0>k>>>0|(i|0)==(k|0)&h>>>0>j>>>0));if((w|0)==22){l=x;return}A=a;B=c[A>>2]|0;A=c[A+4>>2]|0;C=d;D=c[C>>2]|0;C=c[C+4>>2]|0;w=fk(B|0,1,D|0,0)|0;E=y;D=fk(B|0,A|0,D|0,C|0)|0;C=fk(A|0,1,C|0,0)|0;w=(E>>>0<1|(E|0)==1&w>>>0<0)<<31>>31;C=gk(w|0,((w|0)<0)<<31>>31|0,C|0,y|0)|0;w=y;E=a;c[E>>2]=D;c[E+4>>2]=C;E=a+8|0;D=E;A=c[D+4>>2]|0;B=d+8|0;z=c[B+4>>2]|0;B=fk(c[D>>2]|0,1,c[B>>2]|0,0)|0;C=(w>>>0<1|(w|0)==1&C>>>0<0)<<31>>31;B=gk(C|0,((C|0)<0)<<31>>31|0,B|0,y|0)|0;C=y;z=fk(A|0,1,z|0,0)|0;C=(C>>>0<1|(C|0)==1&B>>>0<0)<<31>>31;z=gk(C|0,((C|0)<0)<<31>>31|0,z|0,y|0)|0;C=y;c[E>>2]=B;c[E+4>>2]=z;E=a+16|0;B=E;A=c[B+4>>2]|0;w=d+16|0;D=c[w+4>>2]|0;w=fk(c[B>>2]|0,1,c[w>>2]|0,0)|0;z=(C>>>0<1|(C|0)==1&z>>>0<0)<<31>>31;w=gk(z|0,((z|0)<0)<<31>>31|0,w|0,y|0)|0;z=y;D=fk(A|0,1,D|0,0)|0;z=(z>>>0<1|(z|0)==1&w>>>0<0)<<31>>31;D=gk(z|0,((z|0)<0)<<31>>31|0,D|0,y|0)|0;z=y;c[E>>2]=w;c[E+4>>2]=D;E=a+24|0;w=E;A=c[w+4>>2]|0;C=d+24|0;B=c[C+4>>2]|0;C=fk(c[w>>2]|0,1,c[C>>2]|0,0)|0;D=(z>>>0<1|(z|0)==1&D>>>0<0)<<31>>31;C=gk(D|0,((D|0)<0)<<31>>31|0,C|0,y|0)|0;D=y;B=fk(A|0,0,B|0,0)|0;D=(D>>>0<1|(D|0)==1&C>>>0<0)<<31>>31;D=gk(B|0,y|0,D|0,((D|0)<0)<<31>>31|0)|0;c[E>>2]=C;c[E+4>>2]=D;l=x;return}function Nc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0;j=l;l=l+32|0;h=j;c[h>>2]=0;c[h+4>>2]=0;c[h+8>>2]=0;c[h+12>>2]=0;c[h+16>>2]=0;c[h+20>>2]=0;c[h+24>>2]=0;c[h+28>>2]=0;i=4;while(1){if(!i){d=5;break}i=i+-1|0;e=a+(i<<3)|0;d=c[e>>2]|0;e=c[e+4>>2]|0;g=h+(i<<3)|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if(e>>>0<g>>>0|(e|0)==(g|0)&d>>>0<f>>>0){d=5;break}if(e>>>0>g>>>0|(e|0)==(g|0)&d>>>0>f>>>0){d=6;break}}if((d|0)==5){l=j;return}else if((d|0)==6){k=b;d=c[k>>2]|0;k=c[k+4>>2]|0;e=b+8|0;f=c[e>>2]|0;e=c[e+4>>2]|0;h=b+16|0;p=c[h>>2]|0;h=c[h+4>>2]|0;q=b+24|0;r=c[q>>2]|0;q=c[q+4>>2]|0;n=a;o=c[n>>2]|0;n=c[n+4>>2]|0;i=fk(d|0,1,o|0,0)|0;m=y;o=fk(d|0,k|0,o|0,n|0)|0;n=fk(k|0,1,n|0,0)|0;i=(m>>>0<1|(m|0)==1&i>>>0<0)<<31>>31;n=gk(i|0,((i|0)<0)<<31>>31|0,n|0,y|0)|0;i=y;m=a+8|0;k=m;d=c[k+4>>2]|0;k=fk(f|0,1,c[k>>2]|0,0)|0;i=(i>>>0<1|(i|0)==1&n>>>0<0)<<31>>31;k=gk(i|0,((i|0)<0)<<31>>31|0,k|0,y|0)|0;i=y;d=fk(e|0,1,d|0,0)|0;i=(i>>>0<1|(i|0)==1&k>>>0<0)<<31>>31;d=gk(i|0,((i|0)<0)<<31>>31|0,d|0,y|0)|0;i=y;e=a+16|0;f=e;g=c[f+4>>2]|0;f=fk(p|0,1,c[f>>2]|0,0)|0;i=(i>>>0<1|(i|0)==1&d>>>0<0)<<31>>31;f=gk(i|0,((i|0)<0)<<31>>31|0,f|0,y|0)|0;i=y;g=fk(h|0,1,g|0,0)|0;i=(i>>>0<1|(i|0)==1&f>>>0<0)<<31>>31;g=gk(i|0,((i|0)<0)<<31>>31|0,g|0,y|0)|0;i=y;b=a+24|0;h=b;p=c[h+4>>2]|0;h=fk(r|0,1,c[h>>2]|0,0)|0;i=(i>>>0<1|(i|0)==1&g>>>0<0)<<31>>31;h=gk(i|0,((i|0)<0)<<31>>31|0,h|0,y|0)|0;i=y;p=fk(q|0,0,p|0,0)|0;i=(i>>>0<1|(i|0)==1&h>>>0<0)<<31>>31;i=gk(p|0,y|0,i|0,((i|0)<0)<<31>>31|0)|0;c[a>>2]=o;c[a+4>>2]=n;a=m;c[a>>2]=k;c[a+4>>2]=d;a=e;c[a>>2]=f;c[a+4>>2]=g;c[b>>2]=h;c[b+4>>2]=i;l=j;return}}
  function Oc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0;Z=l;l=l+192|0;E=Z+160|0;N=Z+128|0;R=Z+96|0;W=Z+64|0;X=Z+32|0;Y=Z;c[Y>>2]=c[a>>2];c[Y+4>>2]=c[a+4>>2];c[Y+8>>2]=c[a+8>>2];c[Y+12>>2]=c[a+12>>2];c[Y+16>>2]=c[a+16>>2];c[Y+20>>2]=c[a+20>>2];c[Y+24>>2]=c[a+24>>2];c[Y+28>>2]=c[a+28>>2];c[X>>2]=c[b>>2];c[X+4>>2]=c[b+4>>2];c[X+8>>2]=c[b+8>>2];c[X+12>>2]=c[b+12>>2];c[X+16>>2]=c[b+16>>2];c[X+20>>2]=c[b+20>>2];c[X+24>>2]=c[b+24>>2];c[X+28>>2]=c[b+28>>2];C=W;c[C>>2]=1;c[C+4>>2]=0;C=W+8|0;c[C>>2]=0;c[C+4>>2]=0;c[C+8>>2]=0;c[C+12>>2]=0;c[C+16>>2]=0;c[C+20>>2]=0;c[R>>2]=0;c[R+4>>2]=0;c[R+8>>2]=0;c[R+12>>2]=0;c[R+16>>2]=0;c[R+20>>2]=0;c[R+24>>2]=0;c[R+28>>2]=0;D=N;c[D>>2]=1;c[D+4>>2]=0;D=N+8|0;c[D>>2]=0;c[D+4>>2]=0;c[D+8>>2]=0;c[D+12>>2]=0;c[D+16>>2]=0;c[D+20>>2]=0;a:do if(Xj(Y,N,32)|0){F=E+8|0;G=X+24|0;H=X+16|0;I=X+8|0;J=Y+24|0;K=Y+16|0;L=Y+8|0;O=b;M=c[O>>2]|0;O=c[O+4>>2]|0;Q=b+8|0;P=c[Q>>2]|0;Q=c[Q+4>>2]|0;S=W+16|0;U=b+16|0;T=c[U>>2]|0;U=c[U+4>>2]|0;V=W+24|0;x=b+24|0;w=c[x>>2]|0;x=c[x+4>>2]|0;z=R+8|0;A=R+16|0;B=R+24|0;do{v=E;c[v>>2]=1;c[v+4>>2]=0;c[F>>2]=0;c[F+4>>2]=0;c[F+8>>2]=0;c[F+12>>2]=0;c[F+16>>2]=0;c[F+20>>2]=0;if(!(Xj(X,E,32)|0))break a;d=Y;b=c[d>>2]|0;d=c[d+4>>2]|0;if((b&1|0)==0&0==0){m=W;p=J;r=K;t=L;k=C;j=S;i=V;o=c[p>>2]|0;p=c[p+4>>2]|0;q=c[r>>2]|0;r=c[r+4>>2]|0;s=c[t>>2]|0;t=c[t+4>>2]|0;e=c[m>>2]|0;m=c[m+4>>2]|0;f=c[k>>2]|0;k=c[k+4>>2]|0;g=c[j>>2]|0;j=c[j+4>>2]|0;h=c[i>>2]|0;i=c[i+4>>2]|0;do{v=nk(o|0,p|0,63)|0;u=y;o=kk(o|0,p|0,1)|0;p=y;_=nk(q|0,r|0,63)|0;n=y;$=kk(q|0,r|0,1)|0;q=$|v;r=y|u;u=nk(s|0,t|0,63)|0;v=y;$=kk(s|0,t|0,1)|0;s=$|_;t=y|n;n=kk(b|0,d|0,1)|0;b=u|n;d=v|y;if(!((e&1|0)==0&0==0)){gk(M|0,0,e|0,0)|0;v=y;e=gk(M|0,O|0,e|0,m|0)|0;m=gk(O|0,0,m|0,0)|0;m=gk(m|0,y|0,v|0,0)|0;v=gk(y|0,0,f|0,0)|0;f=y;gk(v|0,f|0,P|0,0)|0;_=y;f=gk(v|0,f|0,P|0,Q|0)|0;k=gk(Q|0,0,k|0,0)|0;k=gk(k|0,y|0,_|0,0)|0;_=gk(y|0,0,g|0,0)|0;g=y;gk(_|0,g|0,T|0,0)|0;v=y;g=gk(_|0,g|0,T|0,U|0)|0;j=gk(U|0,0,j|0,0)|0;j=gk(j|0,y|0,v|0,0)|0;v=gk(y|0,0,h|0,0)|0;_=y;$=gk(v|0,_|0,w|0,x|0)|0;gk(0,x|0,h|0,i|0)|0;gk(w|0,y|0,v|0,_|0)|0;h=$;i=y;}$=nk(h|0,i|0,63)|0;_=y;h=kk(h|0,i|0,1)|0;i=y;u=nk(g|0,j|0,63)|0;v=y;g=kk(g|0,j|0,1)|0;g=g|$;j=y|_;_=nk(f|0,k|0,63)|0;$=y;f=kk(f|0,k|0,1)|0;f=f|u;k=y|v;e=kk(e|0,m|0,1)|0;e=_|e;m=$|y;}while((n&1|0)==0&0==0);v=J;c[v>>2]=o;c[v+4>>2]=p;v=K;c[v>>2]=q;c[v+4>>2]=r;v=L;c[v>>2]=s;c[v+4>>2]=t;v=Y;c[v>>2]=b;c[v+4>>2]=d;v=W;c[v>>2]=e;c[v+4>>2]=m;v=C;c[v>>2]=f;c[v+4>>2]=k;v=S;c[v>>2]=g;c[v+4>>2]=j;v=V;c[v>>2]=h;c[v+4>>2]=i;v=d;}else v=d;i=X;d=c[i>>2]|0;i=c[i+4>>2]|0;if((d&1|0)==0&0==0){h=R;q=G;s=H;u=I;g=z;f=A;e=B;p=c[q>>2]|0;q=c[q+4>>2]|0;r=c[s>>2]|0;s=c[s+4>>2]|0;t=c[u>>2]|0;u=c[u+4>>2]|0;j=c[h>>2]|0;h=c[h+4>>2]|0;k=c[g>>2]|0;g=c[g+4>>2]|0;m=c[f>>2]|0;f=c[f+4>>2]|0;n=c[e>>2]|0;e=c[e+4>>2]|0;do{$=nk(p|0,q|0,63)|0;_=y;p=kk(p|0,q|0,1)|0;q=y;aa=nk(r|0,s|0,63)|0;o=y;ba=kk(r|0,s|0,1)|0;r=ba|$;s=y|_;_=nk(t|0,u|0,63)|0;$=y;ba=kk(t|0,u|0,1)|0;t=ba|aa;u=y|o;o=kk(d|0,i|0,1)|0;d=_|o;i=$|y;if(!((j&1|0)==0&0==0)){gk(M|0,0,j|0,0)|0;$=y;j=gk(M|0,O|0,j|0,h|0)|0;h=gk(O|0,0,h|0,0)|0;h=gk(h|0,y|0,$|0,0)|0;$=gk(y|0,0,k|0,0)|0;k=y;gk($|0,k|0,P|0,0)|0;aa=y;k=gk($|0,k|0,P|0,Q|0)|0;g=gk(Q|0,0,g|0,0)|0;g=gk(g|0,y|0,aa|0,0)|0;aa=gk(y|0,0,m|0,0)|0;m=y;gk(aa|0,m|0,T|0,0)|0;$=y;m=gk(aa|0,m|0,T|0,U|0)|0;f=gk(U|0,0,f|0,0)|0;f=gk(f|0,y|0,$|0,0)|0;$=gk(y|0,0,n|0,0)|0;aa=y;ba=gk($|0,aa|0,w|0,x|0)|0;gk(0,x|0,n|0,e|0)|0;gk(w|0,y|0,$|0,aa|0)|0;n=ba;e=y;}ba=nk(n|0,e|0,63)|0;aa=y;n=kk(n|0,e|0,1)|0;e=y;_=nk(m|0,f|0,63)|0;$=y;m=kk(m|0,f|0,1)|0;m=m|ba;f=y|aa;aa=nk(k|0,g|0,63)|0;ba=y;k=kk(k|0,g|0,1)|0;k=k|_;g=y|$;j=kk(j|0,h|0,1)|0;j=aa|j;h=ba|y;}while((o&1|0)==0&0==0);ba=G;c[ba>>2]=p;c[ba+4>>2]=q;ba=H;c[ba>>2]=r;c[ba+4>>2]=s;ba=I;c[ba>>2]=t;c[ba+4>>2]=u;ba=X;c[ba>>2]=d;c[ba+4>>2]=i;ba=R;c[ba>>2]=j;c[ba+4>>2]=h;j=z;c[j>>2]=k;c[j+4>>2]=g;j=A;c[j>>2]=m;c[j+4>>2]=f;j=B;c[j>>2]=n;c[j+4>>2]=e;j=d;}else j=d;d=4;while(1){if(!d){k=21;break}d=d+-1|0;f=Y+(d<<3)|0;e=c[f>>2]|0;f=c[f+4>>2]|0;h=X+(d<<3)|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if(f>>>0<h>>>0|(f|0)==(h|0)&e>>>0<g>>>0){k=27;break}if(f>>>0>h>>>0|(f|0)==(h|0)&e>>>0>g>>>0){k=21;break}}if((k|0)==21){k=0;$=fk(b|0,1,j|0,0)|0;ba=y;b=fk(b|0,v|0,j|0,i|0)|0;aa=fk(v|0,1,i|0,0)|0;$=(ba>>>0<1|(ba|0)==1&$>>>0<0)<<31>>31;aa=gk($|0,(($|0)<0)<<31>>31|0,aa|0,y|0)|0;$=y;ba=Y;c[ba>>2]=b;c[ba+4>>2]=aa;ba=L;b=c[ba+4>>2]|0;v=I;_=c[v+4>>2]|0;v=fk(c[ba>>2]|0,1,c[v>>2]|0,0)|0;aa=($>>>0<1|($|0)==1&aa>>>0<0)<<31>>31;v=gk(aa|0,((aa|0)<0)<<31>>31|0,v|0,y|0)|0;aa=y;_=fk(b|0,1,_|0,0)|0;aa=(aa>>>0<1|(aa|0)==1&v>>>0<0)<<31>>31;_=gk(aa|0,((aa|0)<0)<<31>>31|0,_|0,y|0)|0;aa=y;b=L;c[b>>2]=v;c[b+4>>2]=_;b=K;v=c[b+4>>2]|0;$=H;ba=c[$+4>>2]|0;$=fk(c[b>>2]|0,1,c[$>>2]|0,0)|0;_=(aa>>>0<1|(aa|0)==1&_>>>0<0)<<31>>31;$=gk(_|0,((_|0)<0)<<31>>31|0,$|0,y|0)|0;_=y;ba=fk(v|0,1,ba|0,0)|0;_=(_>>>0<1|(_|0)==1&$>>>0<0)<<31>>31;ba=gk(_|0,((_|0)<0)<<31>>31|0,ba|0,y|0)|0;_=y;v=K;c[v>>2]=$;c[v+4>>2]=ba;v=J;$=c[v+4>>2]|0;aa=G;b=c[aa+4>>2]|0;aa=fk(c[v>>2]|0,1,c[aa>>2]|0,0)|0;ba=(_>>>0<1|(_|0)==1&ba>>>0<0)<<31>>31;aa=gk(ba|0,((ba|0)<0)<<31>>31|0,aa|0,y|0)|0;ba=y;b=fk($|0,0,b|0,0)|0;ba=(ba>>>0<1|(ba|0)==1&aa>>>0<0)<<31>>31;ba=gk(b|0,y|0,ba|0,((ba|0)<0)<<31>>31|0)|0;b=J;c[b>>2]=aa;c[b+4>>2]=ba;b=4;do{if(!b)break;b=b+-1|0;e=W+(b<<3)|0;d=c[e>>2]|0;e=c[e+4>>2]|0;g=R+(b<<3)|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if(e>>>0<g>>>0|(e|0)==(g|0)&d>>>0<f>>>0){k=25;break}}while(!(e>>>0>g>>>0|(e|0)==(g|0)&d>>>0>f>>>0));if((k|0)==25){v=W;$=c[v>>2]|0;v=c[v+4>>2]|0;gk(M|0,0,$|0,0)|0;ba=y;$=gk(M|0,O|0,$|0,v|0)|0;v=gk(O|0,0,v|0,0)|0;ba=gk(v|0,y|0,ba|0,0)|0;v=W;c[v>>2]=$;c[v+4>>2]=ba;v=C;ba=c[v+4>>2]|0;v=gk(y|0,0,c[v>>2]|0,0)|0;$=y;gk(v|0,$|0,P|0,0)|0;_=y;$=gk(v|0,$|0,P|0,Q|0)|0;ba=gk(Q|0,0,ba|0,0)|0;_=gk(ba|0,y|0,_|0,0)|0;ba=C;c[ba>>2]=$;c[ba+4>>2]=_;ba=S;_=c[ba+4>>2]|0;ba=gk(y|0,0,c[ba>>2]|0,0)|0;$=y;gk(ba|0,$|0,T|0,0)|0;v=y;$=gk(ba|0,$|0,T|0,U|0)|0;_=gk(U|0,0,_|0,0)|0;v=gk(_|0,y|0,v|0,0)|0;_=S;c[_>>2]=$;c[_+4>>2]=v;_=V;v=c[_>>2]|0;_=c[_+4>>2]|0;$=gk(y|0,0,v|0,0)|0;ba=y;aa=gk($|0,ba|0,w|0,x|0)|0;gk(0,x|0,v|0,_|0)|0;gk(w|0,y|0,$|0,ba|0)|0;ba=V;c[ba>>2]=aa;c[ba+4>>2]=y;}g=W;b=c[g>>2]|0;g=c[g+4>>2]|0;h=R;d=c[h>>2]|0;h=c[h+4>>2]|0;j=fk(b|0,1,d|0,0)|0;i=y;d=fk(b|0,g|0,d|0,h|0)|0;b=W;e=W;f=R;}else if((k|0)==27){k=0;$=fk(j|0,1,b|0,0)|0;ba=y;b=fk(j|0,i|0,b|0,v|0)|0;aa=fk(i|0,1,v|0,0)|0;$=(ba>>>0<1|(ba|0)==1&$>>>0<0)<<31>>31;aa=gk($|0,(($|0)<0)<<31>>31|0,aa|0,y|0)|0;$=y;ba=X;c[ba>>2]=b;c[ba+4>>2]=aa;ba=I;b=c[ba+4>>2]|0;v=L;_=c[v+4>>2]|0;v=fk(c[ba>>2]|0,1,c[v>>2]|0,0)|0;aa=($>>>0<1|($|0)==1&aa>>>0<0)<<31>>31;v=gk(aa|0,((aa|0)<0)<<31>>31|0,v|0,y|0)|0;aa=y;_=fk(b|0,1,_|0,0)|0;aa=(aa>>>0<1|(aa|0)==1&v>>>0<0)<<31>>31;_=gk(aa|0,((aa|0)<0)<<31>>31|0,_|0,y|0)|0;aa=y;b=I;c[b>>2]=v;c[b+4>>2]=_;b=H;v=c[b+4>>2]|0;$=K;ba=c[$+4>>2]|0;$=fk(c[b>>2]|0,1,c[$>>2]|0,0)|0;_=(aa>>>0<1|(aa|0)==1&_>>>0<0)<<31>>31;$=gk(_|0,((_|0)<0)<<31>>31|0,$|0,y|0)|0;_=y;ba=fk(v|0,1,ba|0,0)|0;_=(_>>>0<1|(_|0)==1&$>>>0<0)<<31>>31;ba=gk(_|0,((_|0)<0)<<31>>31|0,ba|0,y|0)|0;_=y;v=H;c[v>>2]=$;c[v+4>>2]=ba;v=G;$=c[v+4>>2]|0;aa=J;b=c[aa+4>>2]|0;aa=fk(c[v>>2]|0,1,c[aa>>2]|0,0)|0;ba=(_>>>0<1|(_|0)==1&ba>>>0<0)<<31>>31;aa=gk(ba|0,((ba|0)<0)<<31>>31|0,aa|0,y|0)|0;ba=y;b=fk($|0,0,b|0,0)|0;ba=(ba>>>0<1|(ba|0)==1&aa>>>0<0)<<31>>31;ba=gk(b|0,y|0,ba|0,((ba|0)<0)<<31>>31|0)|0;b=G;c[b>>2]=aa;c[b+4>>2]=ba;b=4;do{if(!b)break;b=b+-1|0;e=R+(b<<3)|0;d=c[e>>2]|0;e=c[e+4>>2]|0;g=W+(b<<3)|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if(e>>>0<g>>>0|(e|0)==(g|0)&d>>>0<f>>>0){k=31;break}}while(!(e>>>0>g>>>0|(e|0)==(g|0)&d>>>0>f>>>0));if((k|0)==31){v=R;$=c[v>>2]|0;v=c[v+4>>2]|0;gk(M|0,0,$|0,0)|0;ba=y;$=gk(M|0,O|0,$|0,v|0)|0;v=gk(O|0,0,v|0,0)|0;ba=gk(v|0,y|0,ba|0,0)|0;v=R;c[v>>2]=$;c[v+4>>2]=ba;v=z;ba=c[v+4>>2]|0;v=gk(y|0,0,c[v>>2]|0,0)|0;$=y;gk(v|0,$|0,P|0,0)|0;_=y;$=gk(v|0,$|0,P|0,Q|0)|0;ba=gk(Q|0,0,ba|0,0)|0;_=gk(ba|0,y|0,_|0,0)|0;ba=z;c[ba>>2]=$;c[ba+4>>2]=_;ba=A;_=c[ba+4>>2]|0;ba=gk(y|0,0,c[ba>>2]|0,0)|0;$=y;gk(ba|0,$|0,T|0,0)|0;v=y;$=gk(ba|0,$|0,T|0,U|0)|0;_=gk(U|0,0,_|0,0)|0;v=gk(_|0,y|0,v|0,0)|0;_=A;c[_>>2]=$;c[_+4>>2]=v;_=B;v=c[_>>2]|0;_=c[_+4>>2]|0;$=gk(y|0,0,v|0,0)|0;ba=y;aa=gk($|0,ba|0,w|0,x|0)|0;gk(0,x|0,v|0,_|0)|0;gk(w|0,y|0,$|0,ba|0)|0;ba=B;c[ba>>2]=aa;c[ba+4>>2]=y;}g=R;b=c[g>>2]|0;g=c[g+4>>2]|0;h=W;d=c[h>>2]|0;h=c[h+4>>2]|0;j=fk(b|0,1,d|0,0)|0;i=y;d=fk(b|0,g|0,d|0,h|0)|0;b=R;e=R;f=W;}_=fk(g|0,1,h|0,0)|0;t=(i>>>0<1|(i|0)==1&j>>>0<0)<<31>>31;_=gk(t|0,((t|0)<0)<<31>>31|0,_|0,y|0)|0;t=y;ba=b;c[ba>>2]=d;c[ba+4>>2]=_;ba=e+8|0;aa=ba;v=c[aa+4>>2]|0;$=f+8|0;u=c[$+4>>2]|0;$=fk(c[aa>>2]|0,1,c[$>>2]|0,0)|0;_=(t>>>0<1|(t|0)==1&_>>>0<0)<<31>>31;_=gk($|0,y|0,_|0,((_|0)<0)<<31>>31|0)|0;$=y;u=fk(v|0,1,u|0,0)|0;$=($>>>0<1|($|0)==1&_>>>0<0)<<31>>31;u=gk($|0,(($|0)<0)<<31>>31|0,u|0,y|0)|0;$=y;c[ba>>2]=_;c[ba+4>>2]=u;ba=e+16|0;_=ba;v=c[_+4>>2]|0;t=f+16|0;aa=c[t+4>>2]|0;t=fk(c[_>>2]|0,1,c[t>>2]|0,0)|0;u=($>>>0<1|($|0)==1&u>>>0<0)<<31>>31;t=gk(u|0,((u|0)<0)<<31>>31|0,t|0,y|0)|0;u=y;aa=fk(v|0,1,aa|0,0)|0;u=(u>>>0<1|(u|0)==1&t>>>0<0)<<31>>31;aa=gk(u|0,((u|0)<0)<<31>>31|0,aa|0,y|0)|0;u=y;c[ba>>2]=t;c[ba+4>>2]=aa;ba=e+24|0;t=ba;v=c[t+4>>2]|0;$=f+24|0;_=c[$+4>>2]|0;$=fk(c[t>>2]|0,1,c[$>>2]|0,0)|0;aa=(u>>>0<1|(u|0)==1&aa>>>0<0)<<31>>31;$=gk(aa|0,((aa|0)<0)<<31>>31|0,$|0,y|0)|0;aa=y;_=fk(v|0,0,_|0,0)|0;aa=(aa>>>0<1|(aa|0)==1&$>>>0<0)<<31>>31;aa=gk(_|0,y|0,aa|0,((aa|0)<0)<<31>>31|0)|0;c[ba>>2]=$;c[ba+4>>2]=aa;ba=N;c[ba>>2]=1;c[ba+4>>2]=0;c[D>>2]=0;c[D+4>>2]=0;c[D+8>>2]=0;c[D+12>>2]=0;c[D+16>>2]=0;c[D+20>>2]=0;}while((Xj(Y,N,32)|0)!=0)}while(0);ba=E;c[ba>>2]=1;c[ba+4>>2]=0;ba=E+8|0;c[ba>>2]=0;c[ba+4>>2]=0;c[ba+8>>2]=0;c[ba+12>>2]=0;c[ba+16>>2]=0;c[ba+20>>2]=0;if(!(Xj(Y,E,32)|0)){c[a>>2]=c[W>>2];c[a+4>>2]=c[W+4>>2];c[a+8>>2]=c[W+8>>2];c[a+12>>2]=c[W+12>>2];c[a+16>>2]=c[W+16>>2];c[a+20>>2]=c[W+20>>2];c[a+24>>2]=c[W+24>>2];c[a+28>>2]=c[W+28>>2];l=Z;return}else {c[a>>2]=c[R>>2];c[a+4>>2]=c[R+4>>2];c[a+8>>2]=c[R+8>>2];c[a+12>>2]=c[R+12>>2];c[a+16>>2]=c[R+16>>2];c[a+20>>2]=c[R+20>>2];c[a+24>>2]=c[R+24>>2];c[a+28>>2]=c[R+28>>2];l=Z;return}}function Pc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;f=a;i=c[f>>2]|0;f=c[f+4>>2]|0;j=b;d=c[j>>2]|0;j=c[j+4>>2]|0;g=fk(i|0,1,d|0,0)|0;e=y;d=fk(i|0,f|0,d|0,j|0)|0;j=fk(f|0,1,j|0,0)|0;g=(e>>>0<1|(e|0)==1&g>>>0<0)<<31>>31;j=gk(g|0,((g|0)<0)<<31>>31|0,j|0,y|0)|0;g=y;e=a;c[e>>2]=d;c[e+4>>2]=j;e=a+8|0;d=e;f=c[d+4>>2]|0;i=b+8|0;h=c[i+4>>2]|0;i=fk(c[d>>2]|0,1,c[i>>2]|0,0)|0;j=fk(i|0,y|0,(g>>>0<1|(g|0)==1&j>>>0<0)&1|0,0)|0;g=y;h=fk(f|0,1,h|0,0)|0;g=(g>>>0<1|(g|0)==1&j>>>0<0)<<31>>31;h=gk(g|0,((g|0)<0)<<31>>31|0,h|0,y|0)|0;g=y;c[e>>2]=j;c[e+4>>2]=h;e=a+16|0;j=e;f=c[j+4>>2]|0;i=b+16|0;d=c[i+4>>2]|0;i=fk(c[j>>2]|0,1,c[i>>2]|0,0)|0;h=fk(i|0,y|0,(g>>>0<1|(g|0)==1&h>>>0<0)&1|0,0)|0;g=y;d=fk(f|0,1,d|0,0)|0;g=(g>>>0<1|(g|0)==1&h>>>0<0)<<31>>31;d=gk(g|0,((g|0)<0)<<31>>31|0,d|0,y|0)|0;g=y;c[e>>2]=h;c[e+4>>2]=d;e=a+24|0;h=e;f=c[h+4>>2]|0;b=b+24|0;a=c[b+4>>2]|0;b=fk(c[h>>2]|0,1,c[b>>2]|0,0)|0;d=fk(b|0,y|0,(g>>>0<1|(g|0)==1&d>>>0<0)&1|0,0)|0;b=y;a=fk(f|0,0,a|0,0)|0;b=(b>>>0<1|(b|0)==1&d>>>0<0)<<31>>31;a=gk(b|0,((b|0)<0)<<31>>31|0,a|0,y|0)|0;b=e;c[b>>2]=d;c[b+4>>2]=a;return}function Qc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=4;while(1){if(!g){a=0;b=5;break}g=g+-1|0;d=a+(g<<3)|0;h=c[d>>2]|0;d=c[d+4>>2]|0;f=b+(g<<3)|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if(d>>>0<f>>>0|(d|0)==(f|0)&h>>>0<e>>>0){a=1;b=5;break}if(d>>>0>f>>>0|(d|0)==(f|0)&h>>>0>e>>>0){a=0;b=5;break}}if((b|0)==5)return a|0;return 0}function Rc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;L=l;l=l+10896|0;q=L+10504|0;B=L+10120|0;F=L+10056|0;G=L+9992|0;H=L+9800|0;I=L+9608|0;J=L+9224|0;K=L+8840|0;f=L+8456|0;g=L+8064|0;h=L+7680|0;i=L+7296|0;j=L+6912|0;k=L+6528|0;m=L+6144|0;n=L+5760|0;o=L+5376|0;p=L+4992|0;r=L+4608|0;s=L+4224|0;t=L+3840|0;u=L+3456|0;v=L+3072|0;w=L+2688|0;x=L+2304|0;y=L+1920|0;z=L+1536|0;A=L+1152|0;C=L+768|0;D=L+384|0;E=L;ok(q|0,b|0,384)|0;Sc(g,q);e=g;if((c[e>>2]|0)==1&(c[e+4>>2]|0)==0){ok(f|0,b|0,192)|0;ok(q|0,b+192|0,192)|0;bd(B,q);ok(f+192|0,B|0,192)|0;ok(B|0,f|0,384)|0;ok(q|0,g+8|0,384)|0;Tc(K,B,q);Zc(J,K,2);Zc(H,K+192|0,2);b=B;d=H;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=16391154;c[b+4>>2]=-896696315;b=q+8|0;c[b>>2]=1756600169;c[b+4>>2]=-255470060;b=q+16|0;c[b>>2]=-1391639528;c[b+4>>2]=236982897;b=q+24|0;c[b>>2]=-1160227098;c[b+4>>2]=69799781;b=q+32|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;c[b+24>>2]=0;c[b+28>>2]=0;cd(I,B,q);b=B;d=H+64|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=16391154;c[b+4>>2]=-896696315;b=q+8|0;c[b>>2]=1756600169;c[b+4>>2]=-255470060;b=q+16|0;c[b>>2]=-1391639528;c[b+4>>2]=236982897;b=q+24|0;c[b>>2]=-1160227098;c[b+4>>2]=69799781;b=q+32|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;c[b+24>>2]=0;c[b+28>>2]=0;cd(G,B,q);b=B;d=H+128|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=16391154;c[b+4>>2]=-896696315;b=q+8|0;c[b>>2]=1756600169;c[b+4>>2]=-255470060;b=q+16|0;c[b>>2]=-1391639528;c[b+4>>2]=236982897;b=q+24|0;c[b>>2]=-1160227098;c[b+4>>2]=69799781;b=q+32|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;c[b+24>>2]=0;c[b+28>>2]=0;cd(F,B,q);b=I+64|0;d=G;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=I+128|0;d=F;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));ok(J+192|0,I|0,192)|0;ok(B|0,J|0,384)|0;ok(q|0,K|0,384)|0;Tc(E,B,q);ok(D|0,E|0,384)|0;ok(A|0,E|0,384)|0;Uc(z,A);Vc(y,z);Vc(x,y);ok(B|0,x|0,384)|0;ok(q|0,y|0,384)|0;Tc(w,B,q);Uc(v,w);Vc(u,v);Uc(t,u);ok(s|0,w|0,192)|0;ok(q|0,w+192|0,192)|0;bd(B,q);ok(s+192|0,B|0,192)|0;ok(r|0,t|0,192)|0;ok(q|0,t+192|0,192)|0;bd(B,q);ok(r+192|0,B|0,192)|0;ok(B|0,r|0,384)|0;ok(q|0,v|0,384)|0;Tc(p,B,q);ok(B|0,p|0,384)|0;ok(q|0,s|0,384)|0;Tc(o,B,q);ok(B|0,o|0,384)|0;ok(q|0,y|0,384)|0;Tc(n,B,q);ok(B|0,o|0,384)|0;ok(q|0,v|0,384)|0;Tc(m,B,q);ok(B|0,A|0,384)|0;ok(q|0,m|0,384)|0;Tc(k,B,q);Zc(j,n,1);Zc(H,n+192|0,1);b=B;d=H;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=856967431;c[b+4>>2]=-1348753770;b=q+8|0;c[b>>2]=-2018527350;c[b+4>>2]=-898949773;b=q+16|0;c[b>>2]=-259383161;c[b+4>>2]=297659742;b=q+24|0;c[b>>2]=438254204;c[b+4>>2]=49499509;b=q+32|0;c[b>>2]=1279864178;c[b+4>>2]=-1574785501;b=q+40|0;c[b>>2]=1448993115;c[b+4>>2]=-804322652;b=q+48|0;c[b>>2]=1407174950;c[b+4>>2]=-600837214;b=q+56|0;c[b>>2]=-1282828975;c[b+4>>2]=279402262;cd(I,B,q);b=B;d=H+64|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=856967431;c[b+4>>2]=-1348753770;b=q+8|0;c[b>>2]=-2018527350;c[b+4>>2]=-898949773;b=q+16|0;c[b>>2]=-259383161;c[b+4>>2]=297659742;b=q+24|0;c[b>>2]=438254204;c[b+4>>2]=49499509;b=q+32|0;c[b>>2]=1279864178;c[b+4>>2]=-1574785501;b=q+40|0;c[b>>2]=1448993115;c[b+4>>2]=-804322652;b=q+48|0;c[b>>2]=1407174950;c[b+4>>2]=-600837214;b=q+56|0;c[b>>2]=-1282828975;c[b+4>>2]=279402262;cd(G,B,q);b=B;d=H+128|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=856967431;c[b+4>>2]=-1348753770;b=q+8|0;c[b>>2]=-2018527350;c[b+4>>2]=-898949773;b=q+16|0;c[b>>2]=-259383161;c[b+4>>2]=297659742;b=q+24|0;c[b>>2]=438254204;c[b+4>>2]=49499509;b=q+32|0;c[b>>2]=1279864178;c[b+4>>2]=-1574785501;b=q+40|0;c[b>>2]=1448993115;c[b+4>>2]=-804322652;b=q+48|0;c[b>>2]=1407174950;c[b+4>>2]=-600837214;b=q+56|0;c[b>>2]=-1282828975;c[b+4>>2]=279402262;cd(F,B,q);b=I+64|0;d=G;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=I+128|0;d=F;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));ok(j+192|0,I|0,192)|0;ok(B|0,j|0,384)|0;ok(q|0,k|0,384)|0;Tc(i,B,q);Zc(h,o,2);Zc(H,o+192|0,2);b=B;d=H;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=16391154;c[b+4>>2]=-896696315;b=q+8|0;c[b>>2]=1756600169;c[b+4>>2]=-255470060;b=q+16|0;c[b>>2]=-1391639528;c[b+4>>2]=236982897;b=q+24|0;c[b>>2]=-1160227098;c[b+4>>2]=69799781;b=q+32|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;c[b+24>>2]=0;c[b+28>>2]=0;cd(I,B,q);b=B;d=H+64|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=16391154;c[b+4>>2]=-896696315;b=q+8|0;c[b>>2]=1756600169;c[b+4>>2]=-255470060;b=q+16|0;c[b>>2]=-1391639528;c[b+4>>2]=236982897;b=q+24|0;c[b>>2]=-1160227098;c[b+4>>2]=69799781;b=q+32|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;c[b+24>>2]=0;c[b+28>>2]=0;cd(G,B,q);b=B;d=H+128|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=16391154;c[b+4>>2]=-896696315;b=q+8|0;c[b>>2]=1756600169;c[b+4>>2]=-255470060;b=q+16|0;c[b>>2]=-1391639528;c[b+4>>2]=236982897;b=q+24|0;c[b>>2]=-1160227098;c[b+4>>2]=69799781;b=q+32|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[b+16>>2]=0;c[b+20>>2]=0;c[b+24>>2]=0;c[b+28>>2]=0;cd(F,B,q);b=I+64|0;d=G;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=I+128|0;d=F;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));ok(h+192|0,I|0,192)|0;ok(B|0,h|0,384)|0;ok(q|0,i|0,384)|0;Tc(g,B,q);ok(f|0,A|0,192)|0;ok(q|0,A+192|0,192)|0;bd(B,q);ok(f+192|0,B|0,192)|0;ok(B|0,f|0,384)|0;ok(q|0,n|0,384)|0;Tc(K,B,q);Zc(J,K,3);Zc(H,K+192|0,3);b=B;d=H;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=1313266045;c[b+4>>2]=911414808;b=q+8|0;c[b>>2]=-724996705;c[b+4>>2]=183964318;b=q+16|0;c[b>>2]=-904918603;c[b+4>>2]=1704830767;b=q+24|0;c[b>>2]=-2086531805;c[b+4>>2]=135359881;b=q+32|0;c[b>>2]=-1013180103;c[b+4>>2]=-1310766345;b=q+40|0;c[b>>2]=-1972125825;c[b+4>>2]=1033831047;b=q+48|0;c[b>>2]=-1934685472;c[b+4>>2]=-1692262254;b=q+56|0;c[b>>2]=-269462362;c[b+4>>2]=644367637;cd(I,B,q);b=B;d=H+64|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=1313266045;c[b+4>>2]=911414808;b=q+8|0;c[b>>2]=-724996705;c[b+4>>2]=183964318;b=q+16|0;c[b>>2]=-904918603;c[b+4>>2]=1704830767;b=q+24|0;c[b>>2]=-2086531805;c[b+4>>2]=135359881;b=q+32|0;c[b>>2]=-1013180103;c[b+4>>2]=-1310766345;b=q+40|0;c[b>>2]=-1972125825;c[b+4>>2]=1033831047;b=q+48|0;c[b>>2]=-1934685472;c[b+4>>2]=-1692262254;b=q+56|0;c[b>>2]=-269462362;c[b+4>>2]=644367637;cd(G,B,q);b=B;d=H+128|0;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=q;c[b>>2]=1313266045;c[b+4>>2]=911414808;b=q+8|0;c[b>>2]=-724996705;c[b+4>>2]=183964318;b=q+16|0;c[b>>2]=-904918603;c[b+4>>2]=1704830767;b=q+24|0;c[b>>2]=-2086531805;c[b+4>>2]=135359881;b=q+32|0;c[b>>2]=-1013180103;c[b+4>>2]=-1310766345;b=q+40|0;c[b>>2]=-1972125825;c[b+4>>2]=1033831047;b=q+48|0;c[b>>2]=-1934685472;c[b+4>>2]=-1692262254;b=q+56|0;c[b>>2]=-269462362;c[b+4>>2]=644367637;cd(F,B,q);b=I+64|0;d=G;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));b=I+128|0;d=F;e=b+64|0;do{c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}while((b|0)<(e|0));ok(J+192|0,I|0,192)|0;ok(B|0,J|0,384)|0;ok(q|0,g|0,384)|0;Tc(C,B,q);ok(a+8|0,C|0,384)|0;H=1;J=0;K=a;I=K;c[I>>2]=H;K=K+4|0;c[K>>2]=J;l=L;return}else {H=0;J=0;K=a;I=K;c[I>>2]=H;K=K+4|0;c[K>>2]=J;l=L;return}}function Sc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;r=l;l=l+2128|0;g=r+1928|0;h=r+1736|0;i=r+1544|0;j=r+1352|0;m=r+968|0;n=r+776|0;o=r+584|0;p=r+392|0;d=r+200|0;e=r;_c(p,b);f=b+192|0;_c(o,f);q=h;s=o+128|0;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));k=g;c[k>>2]=1091403767;c[k+4>>2]=-167360562;k=g+8|0;c[k>>2]=-753151983;c[k+4>>2]=792555341;k=g+16|0;c[k>>2]=960546513;c[k+4>>2]=692269950;k=g+24|0;c[k>>2]=-1478256553;c[k+4>>2]=496343272;k=g+32|0;c[k>>2]=-980480611;c[k+4>>2]=-748862579;k=g+40|0;c[k>>2]=-171504835;c[k+4>>2]=175696680;k=g+48|0;c[k>>2]=2021213740;c[k+4>>2]=1718526831;k=g+56|0;c[k>>2]=-1710760145;c[k+4>>2]=235567041;cd(m,h,g);k=o+64|0;q=m+64|0;s=o;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));q=m+128|0;s=k;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));q=h;s=p;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));q=g;s=m;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));fd(d,h,g);q=h;s=p+64|0;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));q=g;s=o;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));fd(j,h,g);q=h;s=p+128|0;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));q=g;s=k;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));fd(i,h,g);q=d+64|0;s=j;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));q=d+128|0;s=i;t=q+64|0;do{c[q>>2]=c[s>>2];q=q+4|0;s=s+4|0;}while((q|0)<(t|0));$c(e,d);t=e;if(!((c[t>>2]|0)==1&(c[t+4>>2]|0)==0)){p=0;s=0;t=a;q=t;c[q>>2]=p;t=t+4|0;c[t>>2]=s;l=r;return}p=e+8|0;ok(n|0,p|0,192)|0;ok(h|0,b|0,192)|0;ok(g|0,p|0,192)|0;ad(m,h,g);ok(h|0,f|0,192)|0;ok(g|0,n|0,192)|0;ad(i,h,g);bd(j,i);ok(m+192|0,j|0,192)|0;ok(a+8|0,m|0,384)|0;p=1;s=0;t=a;q=t;c[q>>2]=p;t=t+4|0;c[t>>2]=s;l=r;return}function Tc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;x=l;l=l+2432|0;r=x+2240|0;s=x+2048|0;t=x+1984|0;u=x+1920|0;v=x+1728|0;k=x+1536|0;m=x+1344|0;e=x+1152|0;f=x+960|0;n=x+768|0;o=x+576|0;p=x+384|0;q=x+192|0;g=x;ok(s|0,b|0,192)|0;ok(r|0,d|0,192)|0;ad(g,s,r);h=b+192|0;ok(s|0,h|0,192)|0;i=d+192|0;ok(r|0,i|0,192)|0;ad(q,s,r);w=s;y=q+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));j=r;c[j>>2]=1091403767;c[j+4>>2]=-167360562;j=r+8|0;c[j>>2]=-753151983;c[j+4>>2]=792555341;j=r+16|0;c[j>>2]=960546513;c[j+4>>2]=692269950;j=r+24|0;c[j>>2]=-1478256553;c[j+4>>2]=496343272;j=r+32|0;c[j>>2]=-980480611;c[j+4>>2]=-748862579;j=r+40|0;c[j>>2]=-171504835;c[j+4>>2]=175696680;j=r+48|0;c[j>>2]=2021213740;c[j+4>>2]=1718526831;j=r+56|0;c[j>>2]=-1710760145;c[j+4>>2]=235567041;cd(k,s,r);j=q+64|0;w=k+64|0;y=q;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=k+128|0;y=j;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));ok(v|0,g|0,192)|0;w=s;y=k;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=g;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(p,s,r);w=s;y=q;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(u,s,r);w=s;y=j;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(t,s,r);w=p+64|0;y=u;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=p+128|0;y=t;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));ok(k|0,b|0,192)|0;ok(v|0,h|0,192)|0;w=s;y=b;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=h;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(e,s,r);w=s;y=k+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(u,s,r);w=s;y=k+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(t,s,r);w=e+64|0;y=u;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=e+128|0;y=t;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));ok(k|0,d|0,192)|0;ok(v|0,i|0,192)|0;w=s;y=d;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=i;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(m,s,r);w=s;y=k+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(u,s,r);w=s;y=k+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));gd(t,s,r);w=m+64|0;y=u;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=m+128|0;y=t;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));ad(f,e,m);ok(v|0,g|0,192)|0;w=s;y=f;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=g;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));fd(n,s,r);w=s;y=f+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));fd(u,s,r);w=s;y=f+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));fd(t,s,r);b=n+64|0;w=b;y=u;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));e=n+128|0;w=e;y=t;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));ok(v|0,q|0,192)|0;w=s;y=n;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=q;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));fd(o,s,r);w=s;y=b;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+64|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));fd(u,s,r);w=s;y=e;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=r;y=v+128|0;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));fd(t,s,r);w=o+64|0;y=u;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));w=o+128|0;y=t;z=w+64|0;do{c[w>>2]=c[y>>2];w=w+4|0;y=y+4|0;}while((w|0)<(z|0));ok(a|0,p|0,192)|0;ok(a+192|0,o|0,192)|0;l=x;return}function Uc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0;k=l;l=l+1568|0;f=k+1184|0;g=k+800|0;h=k+768|0;i=k+384|0;j=k;d=i;c[d>>2]=-980480611;c[d+4>>2]=-748862579;d=i+8|0;c[d>>2]=-171504835;c[d+4>>2]=175696680;d=i+16|0;c[d>>2]=2021213740;c[d+4>>2]=1718526831;d=i+24|0;c[d>>2]=-1710760145;c[d+4>>2]=235567041;hk(i+32|0,0,160)|0;hk(i+192|0,0,192)|0;d=h;c[d>>2]=1248397809;c[d+4>>2]=1156158132;d=h+8|0;c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;d=256;while(1){if(!d)break;d=d+-1|0;if(d>>>0>255)break;m=h+(d>>>6<<3)|0;o=c[m>>2]|0;m=c[m+4>>2]|0;n=nk(1,0,d&63|0)|0;if(!((o&n|0)==0&(m&y|0)==0)){e=8;break}}a:do if((e|0)==8)b:while(1){ok(g|0,b|0,384)|0;ok(f|0,i|0,384)|0;Tc(i,g,f);while(1){if(!d)break a;d=d+-1|0;if(d>>>0>255)break a;o=h+(d>>>6<<3)|0;m=c[o>>2]|0;o=c[o+4>>2]|0;n=nk(1,0,d&63|0)|0;o=(m&n|0)==0&(o&y|0)==0;Vc(f,i);ok(i|0,f|0,384)|0;if(!o){e=8;continue b}}}while(0);ok(j|0,i|0,384)|0;ok(a|0,j|0,192)|0;ok(f|0,j+192|0,192)|0;bd(g,f);ok(a+192|0,g|0,192)|0;l=k;return}function Vc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0;R=l;l=l+2560|0;o=R+2368|0;z=R+2176|0;I=R+2112|0;L=R+2048|0;M=R+1984|0;N=R+1920|0;O=R+1856|0;P=R+1792|0;d=R+1728|0;e=R+1664|0;f=R+1600|0;g=R+1536|0;h=R+1472|0;i=R+1408|0;j=R+1344|0;k=R+1280|0;m=R+1216|0;n=R+1152|0;p=R+1088|0;q=R+1024|0;r=R+960|0;s=R+896|0;t=R+832|0;u=R+768|0;v=R+704|0;w=R+640|0;x=R+576|0;y=R+512|0;A=R+448|0;B=R+384|0;C=R+320|0;D=R+256|0;E=R+192|0;F=R+128|0;G=R+64|0;H=R;Q=H;S=b;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=G;S=b+64|0;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=F;S=b+128|0;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));J=b+192|0;Q=E;S=J;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));K=b+256|0;Q=D;S=K;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=C;S=b+320|0;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=z;S=b;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=K;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));cd(B,z,o);Q=z;S=H;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=D;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(M,z,o);Q=z;S=D;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;c[Q>>2]=1091403767;c[Q+4>>2]=-167360562;Q=o+8|0;c[Q>>2]=-753151983;c[Q+4>>2]=792555341;Q=o+16|0;c[Q>>2]=960546513;c[Q+4>>2]=692269950;Q=o+24|0;c[Q>>2]=-1478256553;c[Q+4>>2]=496343272;Q=o+32|0;c[Q>>2]=-980480611;c[Q+4>>2]=-748862579;Q=o+40|0;c[Q>>2]=-171504835;c[Q+4>>2]=175696680;Q=o+48|0;c[Q>>2]=2021213740;c[Q+4>>2]=1718526831;Q=o+56|0;c[Q>>2]=-1710760145;c[Q+4>>2]=235567041;cd(I,z,o);Q=o;S=H;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(L,I,o);cd(N,M,L);Q=o;S=B;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));fd(O,N,o);Q=z;S=B;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;c[Q>>2]=1091403767;c[Q+4>>2]=-167360562;Q=o+8|0;c[Q>>2]=-753151983;c[Q+4>>2]=792555341;Q=o+16|0;c[Q>>2]=960546513;c[Q+4>>2]=692269950;Q=o+24|0;c[Q>>2]=-1478256553;c[Q+4>>2]=496343272;Q=o+32|0;c[Q>>2]=-980480611;c[Q+4>>2]=-748862579;Q=o+40|0;c[Q>>2]=-171504835;c[Q+4>>2]=175696680;Q=o+48|0;c[Q>>2]=2021213740;c[Q+4>>2]=1718526831;Q=o+56|0;c[Q>>2]=-1710760145;c[Q+4>>2]=235567041;cd(I,z,o);fd(A,O,I);Q=z;S=B;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=B;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(y,z,o);Q=z;S=J;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=F;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));cd(x,z,o);Q=z;S=E;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=F;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(M,z,o);Q=z;S=F;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;c[Q>>2]=1091403767;c[Q+4>>2]=-167360562;Q=o+8|0;c[Q>>2]=-753151983;c[Q+4>>2]=792555341;Q=o+16|0;c[Q>>2]=960546513;c[Q+4>>2]=692269950;Q=o+24|0;c[Q>>2]=-1478256553;c[Q+4>>2]=496343272;Q=o+32|0;c[Q>>2]=-980480611;c[Q+4>>2]=-748862579;Q=o+40|0;c[Q>>2]=-171504835;c[Q+4>>2]=175696680;Q=o+48|0;c[Q>>2]=2021213740;c[Q+4>>2]=1718526831;Q=o+56|0;c[Q>>2]=-1710760145;c[Q+4>>2]=235567041;cd(I,z,o);Q=o;S=E;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(L,I,o);cd(N,M,L);Q=o;S=x;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));fd(O,N,o);Q=z;S=x;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;c[Q>>2]=1091403767;c[Q+4>>2]=-167360562;Q=o+8|0;c[Q>>2]=-753151983;c[Q+4>>2]=792555341;Q=o+16|0;c[Q>>2]=960546513;c[Q+4>>2]=692269950;Q=o+24|0;c[Q>>2]=-1478256553;c[Q+4>>2]=496343272;Q=o+32|0;c[Q>>2]=-980480611;c[Q+4>>2]=-748862579;Q=o+40|0;c[Q>>2]=-171504835;c[Q+4>>2]=175696680;Q=o+48|0;c[Q>>2]=2021213740;c[Q+4>>2]=1718526831;Q=o+56|0;c[Q>>2]=-1710760145;c[Q+4>>2]=235567041;cd(I,z,o);fd(w,O,I);Q=z;S=x;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=x;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(v,z,o);Q=z;S=G;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=C;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));cd(u,z,o);Q=z;S=G;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=C;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(M,z,o);Q=z;S=C;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;c[Q>>2]=1091403767;c[Q+4>>2]=-167360562;Q=o+8|0;c[Q>>2]=-753151983;c[Q+4>>2]=792555341;Q=o+16|0;c[Q>>2]=960546513;c[Q+4>>2]=692269950;Q=o+24|0;c[Q>>2]=-1478256553;c[Q+4>>2]=496343272;Q=o+32|0;c[Q>>2]=-980480611;c[Q+4>>2]=-748862579;Q=o+40|0;c[Q>>2]=-171504835;c[Q+4>>2]=175696680;Q=o+48|0;c[Q>>2]=2021213740;c[Q+4>>2]=1718526831;Q=o+56|0;c[Q>>2]=-1710760145;c[Q+4>>2]=235567041;cd(I,z,o);Q=o;S=G;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(L,I,o);cd(N,M,L);Q=o;S=u;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));fd(O,N,o);Q=z;S=u;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;c[Q>>2]=1091403767;c[Q+4>>2]=-167360562;Q=o+8|0;c[Q>>2]=-753151983;c[Q+4>>2]=792555341;Q=o+16|0;c[Q>>2]=960546513;c[Q+4>>2]=692269950;Q=o+24|0;c[Q>>2]=-1478256553;c[Q+4>>2]=496343272;Q=o+32|0;c[Q>>2]=-980480611;c[Q+4>>2]=-748862579;Q=o+40|0;c[Q>>2]=-171504835;c[Q+4>>2]=175696680;Q=o+48|0;c[Q>>2]=2021213740;c[Q+4>>2]=1718526831;Q=o+56|0;c[Q>>2]=-1710760145;c[Q+4>>2]=235567041;cd(I,z,o);fd(t,O,I);Q=z;S=u;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=u;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(s,z,o);Q=z;S=A;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=H;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));fd(r,z,o);Q=z;S=r;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=r;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(q,z,o);Q=z;S=q;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=A;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(p,z,o);Q=z;S=y;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=D;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(n,z,o);Q=z;S=n;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=n;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(m,z,o);Q=z;S=m;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=y;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(k,z,o);Q=z;S=s;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;c[Q>>2]=1091403767;c[Q+4>>2]=-167360562;Q=o+8|0;c[Q>>2]=-753151983;c[Q+4>>2]=792555341;Q=o+16|0;c[Q>>2]=960546513;c[Q+4>>2]=692269950;Q=o+24|0;c[Q>>2]=-1478256553;c[Q+4>>2]=496343272;Q=o+32|0;c[Q>>2]=-980480611;c[Q+4>>2]=-748862579;Q=o+40|0;c[Q>>2]=-171504835;c[Q+4>>2]=175696680;Q=o+48|0;c[Q>>2]=2021213740;c[Q+4>>2]=1718526831;Q=o+56|0;c[Q>>2]=-1710760145;c[Q+4>>2]=235567041;cd(j,z,o);Q=z;S=j;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=E;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(i,z,o);Q=z;S=i;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=i;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(h,z,o);Q=z;S=h;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=j;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(g,z,o);Q=z;S=t;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=F;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));fd(f,z,o);Q=z;S=f;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=f;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(e,z,o);Q=z;S=e;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=t;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(d,z,o);Q=z;S=w;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=G;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));fd(P,z,o);Q=z;S=P;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=P;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(O,z,o);Q=z;S=O;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=w;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(N,z,o);Q=z;S=v;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=C;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(M,z,o);Q=z;S=M;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=M;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(L,z,o);Q=z;S=L;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=v;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));gd(I,z,o);Q=z;S=p;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=z+64|0;S=N;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=z+128|0;S=d;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o;S=g;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o+64|0;S=k;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));Q=o+128|0;S=I;T=Q+64|0;do{c[Q>>2]=c[S>>2];Q=Q+4|0;S=S+4|0;}while((Q|0)<(T|0));ok(a|0,z|0,192)|0;ok(a+192|0,o|0,192)|0;l=R;return}function Wc(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0;la=l;l=l+3584|0;V=la+3392|0;ea=la+3200|0;ha=la+3136|0;ia=la+3072|0;ja=la+3008|0;g=la+2944|0;h=la+2880|0;i=la+2816|0;j=la+2752|0;k=la+2688|0;m=la+2624|0;n=la+2560|0;o=la+2496|0;p=la+2432|0;q=la+2368|0;r=la+2304|0;s=la+2240|0;t=la+2176|0;u=la+2112|0;v=la+2048|0;w=la+1984|0;x=la+1920|0;y=la+1856|0;z=la+1792|0;A=la+1728|0;B=la+1664|0;C=la+1600|0;D=la+1536|0;E=la+1472|0;F=la+1408|0;G=la+1344|0;H=la+1280|0;I=la+1216|0;J=la+1152|0;K=la+1088|0;L=la+1024|0;M=la+960|0;N=la+896|0;O=la+832|0;P=la+768|0;Q=la+704|0;R=la+640|0;S=la+576|0;T=la+512|0;U=la+448|0;W=la+384|0;X=la+320|0;Y=la+256|0;Z=la+192|0;_=la+128|0;$=la+64|0;aa=la;ka=aa;ma=b;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ba=b+64|0;ka=$;ma=ba;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ca=b+128|0;ka=_;ma=ca;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));da=b+192|0;ka=Z;ma=da;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fa=b+256|0;ka=Y;ma=fa;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ga=b+320|0;ka=X;ma=ga;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=W;ma=d;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=U;ma=f;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=T;ma=e;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=ea;ma=b;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=d;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(S,ea,V);ka=ea;ma=ca;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=f;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(R,ea,V);ka=ea;ma=fa;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=e;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(Q,ea,V);ka=ea;ma=aa;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=Y;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(P,ea,V);ka=ea;ma=aa;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=_;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(O,ea,V);ka=ea;ma=ba;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=da;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(ha,ea,V);ka=V;ma=ga;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(N,ha,V);ka=ea;ma=$;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=U;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(M,ea,V);ka=ea;ma=M;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=Q;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(L,ea,V);ka=ea;ma=L;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;c[ka>>2]=1091403767;c[ka+4>>2]=-167360562;ka=V+8|0;c[ka>>2]=-753151983;c[ka+4>>2]=792555341;ka=V+16|0;c[ka>>2]=960546513;c[ka+4>>2]=692269950;ka=V+24|0;c[ka>>2]=-1478256553;c[ka+4>>2]=496343272;ka=V+32|0;c[ka>>2]=-980480611;c[ka+4>>2]=-748862579;ka=V+40|0;c[ka>>2]=-171504835;c[ka+4>>2]=175696680;ka=V+48|0;c[ka>>2]=2021213740;c[ka+4>>2]=1718526831;ka=V+56|0;c[ka>>2]=-1710760145;c[ka+4>>2]=235567041;cd(ha,ea,V);ka=V;ma=S;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(K,ha,V);ka=J;ma=K;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=ea;ma=X;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=T;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(I,ea,V);ka=ea;ma=M;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=I;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(H,ea,V);ka=ea;ma=I;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=R;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(G,ea,V);ka=ea;ma=G;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;c[ka>>2]=1091403767;c[ka+4>>2]=-167360562;ka=V+8|0;c[ka>>2]=-753151983;c[ka+4>>2]=792555341;ka=V+16|0;c[ka>>2]=960546513;c[ka+4>>2]=692269950;ka=V+24|0;c[ka>>2]=-1478256553;c[ka+4>>2]=496343272;ka=V+32|0;c[ka>>2]=-980480611;c[ka+4>>2]=-748862579;ka=V+40|0;c[ka>>2]=-171504835;c[ka+4>>2]=175696680;ka=V+48|0;c[ka>>2]=2021213740;c[ka+4>>2]=1718526831;ka=V+56|0;c[ka>>2]=-1710760145;c[ka+4>>2]=235567041;cd(F,ea,V);ka=ea;ma=$;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=W;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(E,ea,V);ka=ea;ma=H;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=E;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(D,ea,V);ka=ea;ma=F;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=E;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(C,ea,V);ka=B;ma=C;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=ea;ma=W;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=U;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(A,ea,V);ka=ea;ma=O;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=A;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(ha,ea,V);ka=V;ma=S;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fd(ia,ha,V);ka=V;ma=R;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fd(z,ia,V);ka=ea;ma=Z;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=T;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(y,ea,V);ka=ea;ma=D;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=y;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(x,ea,V);ka=ea;ma=z;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=y;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(w,ea,V);ka=ea;ma=_;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=Y;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(v,ea,V);ka=u;ma=w;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=ea;ma=U;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=T;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(t,ea,V);ka=ea;ma=v;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=t;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(ha,ea,V);ka=V;ma=R;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fd(ia,ha,V);ka=V;ma=Q;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fd(s,ia,V);ka=ea;ma=s;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;c[ka>>2]=1091403767;c[ka+4>>2]=-167360562;ka=V+8|0;c[ka>>2]=-753151983;c[ka+4>>2]=792555341;ka=V+16|0;c[ka>>2]=960546513;c[ka+4>>2]=692269950;ka=V+24|0;c[ka>>2]=-1478256553;c[ka+4>>2]=496343272;ka=V+32|0;c[ka>>2]=-980480611;c[ka+4>>2]=-748862579;ka=V+40|0;c[ka>>2]=-171504835;c[ka+4>>2]=175696680;ka=V+48|0;c[ka>>2]=2021213740;c[ka+4>>2]=1718526831;ka=V+56|0;c[ka>>2]=-1710760145;c[ka+4>>2]=235567041;cd(r,ea,V);ka=ea;ma=Z;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=W;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(q,ea,V);ka=ea;ma=x;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=q;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(p,ea,V);ka=ea;ma=r;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=q;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(o,ea,V);ka=n;ma=o;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=ea;ma=X;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=U;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(m,ea,V);ka=ea;ma=p;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=m;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(k,ea,V);ka=ea;ma=m;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;c[ka>>2]=1091403767;c[ka+4>>2]=-167360562;ka=V+8|0;c[ka>>2]=-753151983;c[ka+4>>2]=792555341;ka=V+16|0;c[ka>>2]=960546513;c[ka+4>>2]=692269950;ka=V+24|0;c[ka>>2]=-1478256553;c[ka+4>>2]=496343272;ka=V+32|0;c[ka>>2]=-980480611;c[ka+4>>2]=-748862579;ka=V+40|0;c[ka>>2]=-171504835;c[ka+4>>2]=175696680;ka=V+48|0;c[ka>>2]=2021213740;c[ka+4>>2]=1718526831;ka=V+56|0;c[ka>>2]=-1710760145;c[ka+4>>2]=235567041;cd(j,ea,V);ka=ea;ma=W;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=T;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(i,ea,V);ka=ea;ma=P;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=i;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(ha,ea,V);ka=V;ma=S;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fd(ia,ha,V);ka=V;ma=Q;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fd(h,ia,V);ka=ea;ma=j;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=h;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(g,ea,V);ka=ea;ma=W;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=U;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(ha,ea,V);ka=V;ma=T;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));gd(ja,ha,V);ka=ea;ma=N;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=ja;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));cd(ha,ea,V);ka=V;ma=k;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));fd(ia,ha,V);ka=ea;ma=J;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=ea+64|0;ma=B;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=ea+128|0;ma=u;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V;ma=n;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V+64|0;ma=g;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ka=V+128|0;ma=ia;na=ka+64|0;do{c[ka>>2]=c[ma>>2];ka=ka+4|0;ma=ma+4|0;}while((ka|0)<(na|0));ok(a|0,ea|0,192)|0;ok(a+192|0,V|0,192)|0;l=la;return}function Xc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;t=l;l=l+2048|0;k=t+1856|0;m=t+1664|0;n=t+1600|0;o=t+1536|0;p=t+1344|0;q=t+1152|0;r=t+960|0;g=t+768|0;d=t+576|0;h=t+384|0;i=t+192|0;j=t;ok(m|0,b|0,192)|0;e=b+192|0;ok(k|0,e|0,192)|0;ad(j,m,k);s=m;u=b+320|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));f=k;c[f>>2]=1091403767;c[f+4>>2]=-167360562;f=k+8|0;c[f>>2]=-753151983;c[f+4>>2]=792555341;f=k+16|0;c[f>>2]=960546513;c[f+4>>2]=692269950;f=k+24|0;c[f>>2]=-1478256553;c[f+4>>2]=496343272;f=k+32|0;c[f>>2]=-980480611;c[f+4>>2]=-748862579;f=k+40|0;c[f>>2]=-171504835;c[f+4>>2]=175696680;f=k+48|0;c[f>>2]=2021213740;c[f+4>>2]=1718526831;f=k+56|0;c[f>>2]=-1710760145;c[f+4>>2]=235567041;cd(q,m,k);f=b+256|0;s=q+64|0;u=e;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=q+128|0;u=f;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));ok(p|0,b|0,192)|0;s=m;u=q;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(g,m,k);s=m;u=e;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+64|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(o,m,k);s=m;u=f;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(n,m,k);s=g+64|0;u=o;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=g+128|0;u=n;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));ok(q|0,b|0,192)|0;ok(p|0,e|0,192)|0;s=m;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=e;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(r,m,k);s=m;u=q+64|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+64|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(o,m,k);s=m;u=q+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(n,m,k);s=r+64|0;u=o;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=r+128|0;u=n;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));ad(d,g,r);ok(p|0,j|0,192)|0;s=m;u=d;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=j;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));fd(h,m,k);s=m;u=d+64|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+64|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));fd(o,m,k);s=m;u=d+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));fd(n,m,k);d=h+64|0;s=d;u=o;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));e=h+128|0;s=e;u=n;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=j+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));b=k;c[b>>2]=1091403767;c[b+4>>2]=-167360562;b=k+8|0;c[b>>2]=-753151983;c[b+4>>2]=792555341;b=k+16|0;c[b>>2]=960546513;c[b+4>>2]=692269950;b=k+24|0;c[b>>2]=-1478256553;c[b+4>>2]=496343272;b=k+32|0;c[b>>2]=-980480611;c[b+4>>2]=-748862579;b=k+40|0;c[b>>2]=-171504835;c[b+4>>2]=175696680;b=k+48|0;c[b>>2]=2021213740;c[b+4>>2]=1718526831;b=k+56|0;c[b>>2]=-1710760145;c[b+4>>2]=235567041;cd(p,m,k);b=j+64|0;s=p+64|0;u=j;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=p+128|0;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=h;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));fd(i,m,k);s=m;u=d;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=j;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));fd(o,m,k);s=m;u=e;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));fd(n,m,k);s=i+64|0;u=o;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=i+128|0;u=n;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));ok(q|0,j|0,192)|0;ok(p|0,j|0,192)|0;s=m;u=q;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=j;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(r,m,k);s=m;u=q+64|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+64|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(o,m,k);s=m;u=q+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=k;u=p+128|0;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));gd(n,m,k);s=r+64|0;u=o;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=r+128|0;u=n;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));ok(a|0,i|0,192)|0;ok(a+192|0,r|0,192)|0;l=t;return}function Yc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;i=l;l=l+16|0;g=i;h=a+4|0;f=c[h>>2]|0;e=f*192|0;if(f|0){b=f*384|0;if((b|0)<0)$i(2072);b=_b(c[a>>2]|0,e,8,b,8,g)|0;if(!b){d=g+4|0;j=c[d>>2]|0;d=c[d+4>>2]|0;c[g>>2]=c[g>>2];e=g+4|0;c[e>>2]=j;c[e+4>>2]=d;Yb(g);}e=b;g=a;j=f<<1;c[g>>2]=e;c[h>>2]=j;l=i;return}hd(g,192,8,4);if((c[g>>2]|0)==1){b=c[g+4>>2]|0;if(b|0?(d=Xb(b,c[g+8>>2]|0,g)|0,d|0):0){f=d;g=a;j=4;c[g>>2]=f;c[h>>2]=j;l=i;return}}c[g>>2]=1;c[g+4>>2]=6611;c[g+8>>2]=30;Yb(g);}function Zc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0;r=l;l=l+384|0;i=r+320|0;k=r+288|0;m=r+256|0;n=r+192|0;o=r+128|0;f=r+64|0;p=r;h=(d&1|0)==0;if(h){q=p;e=b;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=n;e=b+64|0;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));j=f;}else {c[p>>2]=c[b>>2];c[p+4>>2]=c[b+4>>2];c[p+8>>2]=c[b+8>>2];c[p+12>>2]=c[b+12>>2];c[p+16>>2]=c[b+16>>2];c[p+20>>2]=c[b+20>>2];c[p+24>>2]=c[b+24>>2];c[p+28>>2]=c[b+28>>2];j=b+32|0;c[k>>2]=c[j>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[k+16>>2]=c[j+16>>2];c[k+20>>2]=c[j+20>>2];c[k+24>>2]=c[j+24>>2];c[k+28>>2]=c[j+28>>2];j=i;c[j>>2]=317583274;c[j+4>>2]=1757628553;j=i+8|0;c[j>>2]=1923792719;c[j+4>>2]=-1928822936;j=i+16|0;c[j>>2]=151523889;c[j+4>>2]=1373741639;j=i+24|0;c[j>>2]=1193918714;c[j+4>>2]=576313009;Mc(k,i,136,-460954743,-2016278654);c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[m+8>>2]=c[k+8>>2];c[m+12>>2]=c[k+12>>2];c[m+16>>2]=c[k+16>>2];c[m+20>>2]=c[k+20>>2];c[m+24>>2]=c[k+24>>2];c[m+28>>2]=c[k+28>>2];j=p+32|0;c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];c[j+8>>2]=c[m+8>>2];c[j+12>>2]=c[m+12>>2];c[j+16>>2]=c[m+16>>2];c[j+20>>2]=c[m+20>>2];c[j+24>>2]=c[m+24>>2];c[j+28>>2]=c[m+28>>2];j=b+64|0;c[n>>2]=c[j>>2];c[n+4>>2]=c[j+4>>2];c[n+8>>2]=c[j+8>>2];c[n+12>>2]=c[j+12>>2];c[n+16>>2]=c[j+16>>2];c[n+20>>2]=c[j+20>>2];c[n+24>>2]=c[j+24>>2];c[n+28>>2]=c[j+28>>2];j=b+96|0;c[k>>2]=c[j>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[k+16>>2]=c[j+16>>2];c[k+20>>2]=c[j+20>>2];c[k+24>>2]=c[j+24>>2];c[k+28>>2]=c[j+28>>2];j=i;c[j>>2]=317583274;c[j+4>>2]=1757628553;j=i+8|0;c[j>>2]=1923792719;c[j+4>>2]=-1928822936;j=i+16|0;c[j>>2]=151523889;c[j+4>>2]=1373741639;j=i+24|0;c[j>>2]=1193918714;c[j+4>>2]=576313009;Mc(k,i,136,-460954743,-2016278654);c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[m+8>>2]=c[k+8>>2];c[m+12>>2]=c[k+12>>2];c[m+16>>2]=c[k+16>>2];c[m+20>>2]=c[k+20>>2];c[m+24>>2]=c[k+24>>2];c[m+28>>2]=c[k+28>>2];j=n+32|0;c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];c[j+8>>2]=c[m+8>>2];c[j+12>>2]=c[m+12>>2];c[j+16>>2]=c[m+16>>2];c[j+20>>2]=c[m+20>>2];c[j+24>>2]=c[m+24>>2];c[j+28>>2]=c[m+28>>2];j=f;}d=((d>>>0)%6|0)&255;switch(d&7){case 0:{q=i;c[q>>2]=-980480611;c[q+4>>2]=-748862579;q=i+8|0;c[q>>2]=-171504835;c[q+4>>2]=175696680;q=i+16|0;c[q>>2]=2021213740;c[q+4>>2]=1718526831;q=i+24|0;c[q>>2]=-1710760145;c[q+4>>2]=235567041;q=i+32|0;c[q>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q+16>>2]=0;c[q+20>>2]=0;c[q+24>>2]=0;c[q+28>>2]=0;break}case 1:{q=i;c[q>>2]=1164159792;c[q+4>>2]=-1250477296;q=i+8|0;c[q>>2]=-1448450988;c[q+4>>2]=880775624;q=i+16|0;c[q>>2]=606996881;c[q+4>>2]=2046849319;q=i+24|0;c[q>>2]=293737708;c[q+4>>2]=425114840;q=i+32|0;c[q>>2]=-1599453353;c[q+4>>2]=1854185246;q=i+40|0;c[q>>2]=-1980198591;c[q+4>>2]=-1440973971;q=i+48|0;c[q>>2]=-85931462;c[q+4>>2]=-1226370099;q=i+56|0;c[q>>2]=1317202883;c[q+4>>2]=644435899;break}case 2:{q=i;c[q>>2]=333974428;c[q+4>>2]=860932238;q=i+8|0;c[q>>2]=-614574407;c[q+4>>2]=2110674300;q=i+16|0;c[q>>2]=-1240115638;c[q+4>>2]=1610724536;q=i+24|0;c[q>>2]=33691616;c[q+4>>2]=646112791;q=i+32|0;c[q>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q+16>>2]=0;c[q+20>>2]=0;c[q+24>>2]=0;c[q+28>>2]=0;break}case 3:{q=i;c[q>>2]=380464045;c[q+4>>2]=-911269129;q=i+8|0;c[q>>2]=1252418226;c[q+4>>2]=-1290700758;q=i+16|0;c[q>>2]=-498546700;c[q+4>>2]=435072868;q=i+24|0;c[q>>2]=-482107518;c[q+4>>2]=539442807;q=i+32|0;c[q>>2]=-137456724;c[q+4>>2]=-1396692896;q=i+40|0;c[q>>2]=2074569548;c[q+4>>2]=959698305;q=i+48|0;c[q>>2]=1147962471;c[q+4>>2]=1776687243;q=i+56|0;c[q>>2]=1142410325;c[q+4>>2]=172360557;break}default:jd(6441,19,2096);}cd(f,n,i);e=b+128|0;if(h){q=n;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0))}else {c[n>>2]=c[e>>2];c[n+4>>2]=c[e+4>>2];c[n+8>>2]=c[e+8>>2];c[n+12>>2]=c[e+12>>2];c[n+16>>2]=c[e+16>>2];c[n+20>>2]=c[e+20>>2];c[n+24>>2]=c[e+24>>2];c[n+28>>2]=c[e+28>>2];q=b+160|0;c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];c[k+16>>2]=c[q+16>>2];c[k+20>>2]=c[q+20>>2];c[k+24>>2]=c[q+24>>2];c[k+28>>2]=c[q+28>>2];q=i;c[q>>2]=317583274;c[q+4>>2]=1757628553;q=i+8|0;c[q>>2]=1923792719;c[q+4>>2]=-1928822936;q=i+16|0;c[q>>2]=151523889;c[q+4>>2]=1373741639;q=i+24|0;c[q>>2]=1193918714;c[q+4>>2]=576313009;Mc(k,i,136,-460954743,-2016278654);c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[m+8>>2]=c[k+8>>2];c[m+12>>2]=c[k+12>>2];c[m+16>>2]=c[k+16>>2];c[m+20>>2]=c[k+20>>2];c[m+24>>2]=c[k+24>>2];c[m+28>>2]=c[k+28>>2];q=n+32|0;c[q>>2]=c[m>>2];c[q+4>>2]=c[m+4>>2];c[q+8>>2]=c[m+8>>2];c[q+12>>2]=c[m+12>>2];c[q+16>>2]=c[m+16>>2];c[q+20>>2]=c[m+20>>2];c[q+24>>2]=c[m+24>>2];c[q+28>>2]=c[m+28>>2];}switch(d&7){case 0:{q=i;c[q>>2]=-980480611;c[q+4>>2]=-748862579;q=i+8|0;c[q>>2]=-171504835;c[q+4>>2]=175696680;q=i+16|0;c[q>>2]=2021213740;c[q+4>>2]=1718526831;q=i+24|0;c[q>>2]=-1710760145;c[q+4>>2]=235567041;q=i+32|0;c[q>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q+16>>2]=0;c[q+20>>2]=0;c[q+24>>2]=0;c[q+28>>2]=0;cd(o,n,i);q=a;e=p;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+64|0;e=j;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+128|0;e=o;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));l=r;return}case 1:{q=i;c[q>>2]=-2076524910;c[q+4>>2]=1935791999;q=i+8|0;c[q>>2]=657723899;c[q+4>>2]=-1514460205;q=i+16|0;c[q>>2]=1262363545;c[q+4>>2]=-1668014287;q=i+24|0;c[q>>2]=-1147153428;c[q+4>>2]=366976221;q=i+32|0;c[q>>2]=1272498505;c[q+4>>2]=1574829333;q=i+40|0;c[q>>2]=-1539024032;c[q+4>>2]=1657481637;q=i+48|0;c[q>>2]=209572537;c[q+4>>2]=935102218;q=i+56|0;c[q>>2]=829550845;c[q+4>>2]=612567709;cd(o,n,i);q=a;e=p;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+64|0;e=j;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+128|0;e=o;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));l=r;return}case 2:{q=i;c[q>>2]=-679288491;c[q+4>>2]=1905462289;q=i+8|0;c[q>>2]=-4312285;c[q+4>>2]=-1497656196;q=i+16|0;c[q>>2]=-730590140;c[q+4>>2]=-1439681724;q=i+24|0;c[q>>2]=643385667;c[q+4>>2]=742080269;q=i+32|0;c[q>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q+16>>2]=0;c[q+20>>2]=0;c[q+24>>2]=0;c[q+28>>2]=0;cd(o,n,i);q=a;e=p;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+64|0;e=j;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+128|0;e=o;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));l=r;return}case 3:{q=i;c[q>>2]=2070373087;c[q+4>>2]=1149932453;q=i+8|0;c[q>>2]=687729375;c[q+4>>2]=-1076482571;q=i+16|0;c[q>>2]=245093498;c[q+4>>2]=-665258544;q=i+24|0;c[q>>2]=880208984;c[q+4>>2]=112213325;q=i+32|0;c[q>>2]=-1127663919;c[q+4>>2]=723114740;q=i+40|0;c[q>>2]=1458842015;c[q+4>>2]=-1583001990;q=i+48|0;c[q>>2]=1524543217;c[q+4>>2]=-1254887712;q=i+56|0;c[q>>2]=-2065850190;c[q+4>>2]=386695467;cd(o,n,i);q=a;e=p;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+64|0;e=j;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));q=a+128|0;e=o;g=q+64|0;do{c[q>>2]=c[e>>2];q=q+4|0;e=e+4|0;}while((q|0)<(g|0));l=r;return}default:jd(6441,19,2112);}}function _c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;v=l;l=l+960|0;m=v+896|0;n=v+832|0;o=v+768|0;p=v+704|0;q=v+640|0;r=v+576|0;s=v+512|0;t=v+448|0;e=v+384|0;f=v+320|0;g=v+256|0;h=v+192|0;i=v+128|0;d=v+64|0;j=v;dd(j,b);u=n;w=b;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));k=b+64|0;u=m;w=k;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));cd(d,n,m);u=n;w=d;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=m;w=d;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));gd(i,n,m);u=n;w=b;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=m;w=k;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));fd(o,n,m);b=b+128|0;u=m;w=b;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));gd(p,o,m);dd(h,p);u=n;w=k;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=m;w=b;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));cd(g,n,m);u=n;w=g;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=m;w=g;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));gd(f,n,m);dd(e,b);u=p;w=j;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=n;w=f;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=m;c[u>>2]=1091403767;c[u+4>>2]=-167360562;u=m+8|0;c[u>>2]=-753151983;c[u+4>>2]=792555341;u=m+16|0;c[u>>2]=960546513;c[u+4>>2]=692269950;u=m+24|0;c[u>>2]=-1478256553;c[u+4>>2]=496343272;u=m+32|0;c[u>>2]=-980480611;c[u+4>>2]=-748862579;u=m+40|0;c[u>>2]=-171504835;c[u+4>>2]=175696680;u=m+48|0;c[u>>2]=2021213740;c[u+4>>2]=1718526831;u=m+56|0;c[u>>2]=-1710760145;c[u+4>>2]=235567041;cd(o,n,m);gd(t,p,o);u=p;w=i;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=n;w=e;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=m;c[u>>2]=1091403767;c[u+4>>2]=-167360562;u=m+8|0;c[u>>2]=-753151983;c[u+4>>2]=792555341;u=m+16|0;c[u>>2]=960546513;c[u+4>>2]=692269950;u=m+24|0;c[u>>2]=-1478256553;c[u+4>>2]=496343272;u=m+32|0;c[u>>2]=-980480611;c[u+4>>2]=-748862579;u=m+40|0;c[u>>2]=-171504835;c[u+4>>2]=175696680;u=m+48|0;c[u>>2]=2021213740;c[u+4>>2]=1718526831;u=m+56|0;c[u>>2]=-1710760145;c[u+4>>2]=235567041;cd(o,n,m);gd(s,p,o);u=n;w=i;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=m;w=h;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));gd(o,n,m);u=m;w=f;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));gd(p,o,m);u=m;w=j;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));fd(q,p,m);u=m;w=e;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));fd(r,q,m);u=a;w=t;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=a+64|0;w=s;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));u=a+128|0;w=r;x=u+64|0;do{c[u>>2]=c[w>>2];u=u+4|0;w=w+4|0;}while((u|0)<(x|0));l=v;return}function $c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;t=l;l=l+912|0;m=t+840|0;n=t+776|0;o=t+712|0;p=t+648|0;q=t+456|0;r=t+392|0;g=t+328|0;h=t+264|0;d=t+192|0;i=t+128|0;j=t+64|0;k=t;dd(g,b);e=b+64|0;s=p;u=e;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));f=b+128|0;s=n;u=f;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;c[s>>2]=1091403767;c[s+4>>2]=-167360562;s=m+8|0;c[s>>2]=-753151983;c[s+4>>2]=792555341;s=m+16|0;c[s>>2]=960546513;c[s+4>>2]=692269950;s=m+24|0;c[s>>2]=-1478256553;c[s+4>>2]=496343272;s=m+32|0;c[s>>2]=-980480611;c[s+4>>2]=-748862579;s=m+40|0;c[s>>2]=-171504835;c[s+4>>2]=175696680;s=m+48|0;c[s>>2]=2021213740;c[s+4>>2]=1718526831;s=m+56|0;c[s>>2]=-1710760145;c[s+4>>2]=235567041;cd(o,n,m);cd(q,p,o);fd(k,g,q);dd(p,f);s=n;u=p;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;c[s>>2]=1091403767;c[s+4>>2]=-167360562;s=m+8|0;c[s>>2]=-753151983;c[s+4>>2]=792555341;s=m+16|0;c[s>>2]=960546513;c[s+4>>2]=692269950;s=m+24|0;c[s>>2]=-1478256553;c[s+4>>2]=496343272;s=m+32|0;c[s>>2]=-980480611;c[s+4>>2]=-748862579;s=m+40|0;c[s>>2]=-171504835;c[s+4>>2]=175696680;s=m+48|0;c[s>>2]=2021213740;c[s+4>>2]=1718526831;s=m+56|0;c[s>>2]=-1710760145;c[s+4>>2]=235567041;cd(q,n,m);s=n;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=e;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(o,n,m);fd(j,q,o);dd(p,e);s=n;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=f;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(o,n,m);fd(i,p,o);s=n;u=f;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=j;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(p,n,m);s=n;u=e;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=i;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(o,n,m);gd(g,p,o);s=n;u=g;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;c[s>>2]=1091403767;c[s+4>>2]=-167360562;s=m+8|0;c[s>>2]=-753151983;c[s+4>>2]=792555341;s=m+16|0;c[s>>2]=960546513;c[s+4>>2]=692269950;s=m+24|0;c[s>>2]=-1478256553;c[s+4>>2]=496343272;s=m+32|0;c[s>>2]=-980480611;c[s+4>>2]=-748862579;s=m+40|0;c[s>>2]=-171504835;c[s+4>>2]=175696680;s=m+48|0;c[s>>2]=2021213740;c[s+4>>2]=1718526831;s=m+56|0;c[s>>2]=-1710760145;c[s+4>>2]=235567041;cd(q,n,m);s=n;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=k;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(o,n,m);gd(h,q,o);ed(d,h);v=d;if(!((c[v>>2]|0)==1&(c[v+4>>2]|0)==0)){r=0;u=0;v=a;s=v;c[s>>2]=r;v=v+4|0;c[v>>2]=u;l=t;return}b=d+8|0;s=r;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=n;u=b;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=k;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(q,n,m);s=n;u=r;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=j;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(p,n,m);s=n;u=r;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=m;u=i;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));cd(o,n,m);s=q+64|0;u=p;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));s=q+128|0;u=o;v=s+64|0;do{c[s>>2]=c[u>>2];s=s+4|0;u=u+4|0;}while((s|0)<(v|0));ok(a+8|0,q|0,192)|0;r=1;u=0;v=a;s=v;c[s>>2]=r;v=v+4|0;c[v>>2]=u;l=t;return}function ad(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;y=l;l=l+896|0;q=y+832|0;r=y+768|0;s=y+704|0;t=y+640|0;u=y+576|0;v=y+512|0;w=y+448|0;e=y+384|0;f=y+320|0;g=y+256|0;h=y+192|0;i=y+128|0;j=y+64|0;k=y;x=r;z=b;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;z=d;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));cd(k,r,q);m=b+64|0;x=r;z=m;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));n=d+64|0;x=q;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));cd(j,r,q);o=b+128|0;x=r;z=o;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));p=d+128|0;x=q;z=p;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));cd(i,r,q);x=r;z=m;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;z=o;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(t,r,q);x=r;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;z=p;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(s,r,q);cd(u,t,s);x=q;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));fd(v,u,q);x=q;z=i;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));fd(g,v,q);x=r;z=g;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;c[x>>2]=1091403767;c[x+4>>2]=-167360562;x=q+8|0;c[x>>2]=-753151983;c[x+4>>2]=792555341;x=q+16|0;c[x>>2]=960546513;c[x+4>>2]=692269950;x=q+24|0;c[x>>2]=-1478256553;c[x+4>>2]=496343272;x=q+32|0;c[x>>2]=-980480611;c[x+4>>2]=-748862579;x=q+40|0;c[x>>2]=-171504835;c[x+4>>2]=175696680;x=q+48|0;c[x>>2]=2021213740;c[x+4>>2]=1718526831;x=q+56|0;c[x>>2]=-1710760145;c[x+4>>2]=235567041;cd(w,r,q);x=q;z=k;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(h,w,q);x=r;z=b;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;z=m;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(t,r,q);x=r;z=d;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;z=n;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(s,r,q);cd(u,t,s);x=q;z=k;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));fd(v,u,q);x=q;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));fd(w,v,q);x=r;z=i;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;c[x>>2]=1091403767;c[x+4>>2]=-167360562;x=q+8|0;c[x>>2]=-753151983;c[x+4>>2]=792555341;x=q+16|0;c[x>>2]=960546513;c[x+4>>2]=692269950;x=q+24|0;c[x>>2]=-1478256553;c[x+4>>2]=496343272;x=q+32|0;c[x>>2]=-980480611;c[x+4>>2]=-748862579;x=q+40|0;c[x>>2]=-171504835;c[x+4>>2]=175696680;x=q+48|0;c[x>>2]=2021213740;c[x+4>>2]=1718526831;x=q+56|0;c[x>>2]=-1710760145;c[x+4>>2]=235567041;cd(s,r,q);gd(f,w,s);x=r;z=b;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;z=o;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(t,r,q);x=r;z=d;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=q;z=p;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(s,r,q);cd(u,t,s);x=q;z=k;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));fd(v,u,q);x=q;z=j;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));gd(w,v,q);x=q;z=i;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));fd(e,w,q);x=a;z=h;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=a+64|0;z=f;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));x=a+128|0;z=e;A=x+64|0;do{c[x>>2]=c[z>>2];x=x+4|0;z=z+4|0;}while((x|0)<(A|0));l=y;return}function bd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0;n=l;l=l+352|0;e=n+320|0;f=n+288|0;g=n+256|0;h=n+192|0;i=n+128|0;j=n+64|0;k=n;m=h;o=b;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];c[f+8>>2]=c[b+8>>2];c[f+12>>2]=c[b+12>>2];c[f+16>>2]=c[b+16>>2];c[f+20>>2]=c[b+20>>2];c[f+24>>2]=c[b+24>>2];c[f+28>>2]=c[b+28>>2];c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[e+24>>2]=0;c[e+28>>2]=0;if((Ic(f,e)|0)<<24>>24==1){c[e>>2]=c[34];c[e+4>>2]=c[35];c[e+8>>2]=c[36];c[e+12>>2]=c[37];c[e+16>>2]=c[38];c[e+20>>2]=c[39];c[e+24>>2]=c[40];c[e+28>>2]=c[41];Pc(e,f);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];};c[k>>2]=c[f>>2];c[k+4>>2]=c[f+4>>2];c[k+8>>2]=c[f+8>>2];c[k+12>>2]=c[f+12>>2];c[k+16>>2]=c[f+16>>2];c[k+20>>2]=c[f+20>>2];c[k+24>>2]=c[f+24>>2];c[k+28>>2]=c[f+28>>2];p=h+32|0;c[f>>2]=c[p>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];c[f+12>>2]=c[p+12>>2];c[f+16>>2]=c[p+16>>2];c[f+20>>2]=c[p+20>>2];c[f+24>>2]=c[p+24>>2];c[f+28>>2]=c[p+28>>2];c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[e+24>>2]=0;c[e+28>>2]=0;if((Ic(f,e)|0)<<24>>24==1){c[e>>2]=c[34];c[e+4>>2]=c[35];c[e+8>>2]=c[36];c[e+12>>2]=c[37];c[e+16>>2]=c[38];c[e+20>>2]=c[39];c[e+24>>2]=c[40];c[e+28>>2]=c[41];Pc(e,f);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];};c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];c[g+28>>2]=c[f+28>>2];d=k+32|0;c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];c[d+16>>2]=c[g+16>>2];c[d+20>>2]=c[g+20>>2];c[d+24>>2]=c[g+24>>2];c[d+28>>2]=c[g+28>>2];d=b+64|0;m=h;o=d;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[f+16>>2]=c[d+16>>2];c[f+20>>2]=c[d+20>>2];c[f+24>>2]=c[d+24>>2];c[f+28>>2]=c[d+28>>2];c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[e+24>>2]=0;c[e+28>>2]=0;if((Ic(f,e)|0)<<24>>24==1){c[e>>2]=c[34];c[e+4>>2]=c[35];c[e+8>>2]=c[36];c[e+12>>2]=c[37];c[e+16>>2]=c[38];c[e+20>>2]=c[39];c[e+24>>2]=c[40];c[e+28>>2]=c[41];Pc(e,f);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];};c[j>>2]=c[f>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];c[j+28>>2]=c[f+28>>2];p=h+32|0;c[f>>2]=c[p>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];c[f+12>>2]=c[p+12>>2];c[f+16>>2]=c[p+16>>2];c[f+20>>2]=c[p+20>>2];c[f+24>>2]=c[p+24>>2];c[f+28>>2]=c[p+28>>2];c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[e+24>>2]=0;c[e+28>>2]=0;if((Ic(f,e)|0)<<24>>24==1){c[e>>2]=c[34];c[e+4>>2]=c[35];c[e+8>>2]=c[36];c[e+12>>2]=c[37];c[e+16>>2]=c[38];c[e+20>>2]=c[39];c[e+24>>2]=c[40];c[e+28>>2]=c[41];Pc(e,f);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];};c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];c[g+28>>2]=c[f+28>>2];m=j+32|0;c[m>>2]=c[g>>2];c[m+4>>2]=c[g+4>>2];c[m+8>>2]=c[g+8>>2];c[m+12>>2]=c[g+12>>2];c[m+16>>2]=c[g+16>>2];c[m+20>>2]=c[g+20>>2];c[m+24>>2]=c[g+24>>2];c[m+28>>2]=c[g+28>>2];b=b+128|0;m=h;o=b;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];c[f+8>>2]=c[b+8>>2];c[f+12>>2]=c[b+12>>2];c[f+16>>2]=c[b+16>>2];c[f+20>>2]=c[b+20>>2];c[f+24>>2]=c[b+24>>2];c[f+28>>2]=c[b+28>>2];c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[e+24>>2]=0;c[e+28>>2]=0;if((Ic(f,e)|0)<<24>>24==1){c[e>>2]=c[34];c[e+4>>2]=c[35];c[e+8>>2]=c[36];c[e+12>>2]=c[37];c[e+16>>2]=c[38];c[e+20>>2]=c[39];c[e+24>>2]=c[40];c[e+28>>2]=c[41];Pc(e,f);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];};c[i>>2]=c[f>>2];c[i+4>>2]=c[f+4>>2];c[i+8>>2]=c[f+8>>2];c[i+12>>2]=c[f+12>>2];c[i+16>>2]=c[f+16>>2];c[i+20>>2]=c[f+20>>2];c[i+24>>2]=c[f+24>>2];c[i+28>>2]=c[f+28>>2];p=h+32|0;c[f>>2]=c[p>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];c[f+12>>2]=c[p+12>>2];c[f+16>>2]=c[p+16>>2];c[f+20>>2]=c[p+20>>2];c[f+24>>2]=c[p+24>>2];c[f+28>>2]=c[p+28>>2];c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[e+24>>2]=0;c[e+28>>2]=0;if((Ic(f,e)|0)<<24>>24!=1){c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];c[g+28>>2]=c[f+28>>2];m=i+32|0;c[m>>2]=c[g>>2];c[m+4>>2]=c[g+4>>2];c[m+8>>2]=c[g+8>>2];c[m+12>>2]=c[g+12>>2];c[m+16>>2]=c[g+16>>2];c[m+20>>2]=c[g+20>>2];c[m+24>>2]=c[g+24>>2];c[m+28>>2]=c[g+28>>2];m=a;o=k;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=a+64|0;o=j;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=a+128|0;o=i;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));l=n;return};c[e>>2]=c[34];c[e+4>>2]=c[35];c[e+8>>2]=c[36];c[e+12>>2]=c[37];c[e+16>>2]=c[38];c[e+20>>2]=c[39];c[e+24>>2]=c[40];c[e+28>>2]=c[41];Pc(e,f);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];c[g+28>>2]=c[f+28>>2];m=i+32|0;c[m>>2]=c[g>>2];c[m+4>>2]=c[g+4>>2];c[m+8>>2]=c[g+8>>2];c[m+12>>2]=c[g+12>>2];c[m+16>>2]=c[g+16>>2];c[m+20>>2]=c[g+20>>2];c[m+24>>2]=c[g+24>>2];c[m+28>>2]=c[g+28>>2];m=a;o=k;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=a+64|0;o=j;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));m=a+128|0;o=i;p=m+64|0;do{c[m>>2]=c[o>>2];m=m+4|0;o=o+4|0;}while((m|0)<(p|0));l=n;return}function cd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0;e=l;l=l+288|0;h=e+256|0;o=e+224|0;n=e+192|0;m=e+160|0;j=e+128|0;g=e+96|0;f=e+64|0;i=e+32|0;k=e;c[o>>2]=c[b>>2];c[o+4>>2]=c[b+4>>2];c[o+8>>2]=c[b+8>>2];c[o+12>>2]=c[b+12>>2];c[o+16>>2]=c[b+16>>2];c[o+20>>2]=c[b+20>>2];c[o+24>>2]=c[b+24>>2];c[o+28>>2]=c[b+28>>2];c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];c[h+12>>2]=c[d+12>>2];c[h+16>>2]=c[d+16>>2];c[h+20>>2]=c[d+20>>2];c[h+24>>2]=c[d+24>>2];c[h+28>>2]=c[d+28>>2];Mc(o,h,136,-460954743,-2016278654);c[k>>2]=c[o>>2];c[k+4>>2]=c[o+4>>2];c[k+8>>2]=c[o+8>>2];c[k+12>>2]=c[o+12>>2];c[k+16>>2]=c[o+16>>2];c[k+20>>2]=c[o+20>>2];c[k+24>>2]=c[o+24>>2];c[k+28>>2]=c[o+28>>2];q=b+32|0;c[o>>2]=c[q>>2];c[o+4>>2]=c[q+4>>2];c[o+8>>2]=c[q+8>>2];c[o+12>>2]=c[q+12>>2];c[o+16>>2]=c[q+16>>2];c[o+20>>2]=c[q+20>>2];c[o+24>>2]=c[q+24>>2];c[o+28>>2]=c[q+28>>2];p=d+32|0;c[h>>2]=c[p>>2];c[h+4>>2]=c[p+4>>2];c[h+8>>2]=c[p+8>>2];c[h+12>>2]=c[p+12>>2];c[h+16>>2]=c[p+16>>2];c[h+20>>2]=c[p+20>>2];c[h+24>>2]=c[p+24>>2];c[h+28>>2]=c[p+28>>2];Mc(o,h,136,-460954743,-2016278654);c[i>>2]=c[o>>2];c[i+4>>2]=c[o+4>>2];c[i+8>>2]=c[o+8>>2];c[i+12>>2]=c[o+12>>2];c[i+16>>2]=c[o+16>>2];c[i+20>>2]=c[o+20>>2];c[i+24>>2]=c[o+24>>2];c[i+28>>2]=c[o+28>>2];c[o>>2]=c[i>>2];c[o+4>>2]=c[i+4>>2];c[o+8>>2]=c[i+8>>2];c[o+12>>2]=c[i+12>>2];c[o+16>>2]=c[i+16>>2];c[o+20>>2]=c[i+20>>2];c[o+24>>2]=c[i+24>>2];c[o+28>>2]=c[i+28>>2];r=h;c[r>>2]=317583274;c[r+4>>2]=1757628553;r=h+8|0;c[r>>2]=1923792719;c[r+4>>2]=-1928822936;r=h+16|0;c[r>>2]=151523889;c[r+4>>2]=1373741639;r=h+24|0;c[r>>2]=1193918714;c[r+4>>2]=576313009;Mc(o,h,136,-460954743,-2016278654);c[n>>2]=c[o>>2];c[n+4>>2]=c[o+4>>2];c[n+8>>2]=c[o+8>>2];c[n+12>>2]=c[o+12>>2];c[n+16>>2]=c[o+16>>2];c[n+20>>2]=c[o+20>>2];c[n+24>>2]=c[o+24>>2];c[n+28>>2]=c[o+28>>2];c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[h+16>>2]=c[k+16>>2];c[h+20>>2]=c[k+20>>2];c[h+24>>2]=c[k+24>>2];c[h+28>>2]=c[k+28>>2];Kc(n,h,136);c[a>>2]=c[n>>2];c[a+4>>2]=c[n+4>>2];c[a+8>>2]=c[n+8>>2];c[a+12>>2]=c[n+12>>2];c[a+16>>2]=c[n+16>>2];c[a+20>>2]=c[n+20>>2];c[a+24>>2]=c[n+24>>2];c[a+28>>2]=c[n+28>>2];c[o>>2]=c[b>>2];c[o+4>>2]=c[b+4>>2];c[o+8>>2]=c[b+8>>2];c[o+12>>2]=c[b+12>>2];c[o+16>>2]=c[b+16>>2];c[o+20>>2]=c[b+20>>2];c[o+24>>2]=c[b+24>>2];c[o+28>>2]=c[b+28>>2];c[h>>2]=c[q>>2];c[h+4>>2]=c[q+4>>2];c[h+8>>2]=c[q+8>>2];c[h+12>>2]=c[q+12>>2];c[h+16>>2]=c[q+16>>2];c[h+20>>2]=c[q+20>>2];c[h+24>>2]=c[q+24>>2];c[h+28>>2]=c[q+28>>2];Kc(o,h,136);c[m>>2]=c[o>>2];c[m+4>>2]=c[o+4>>2];c[m+8>>2]=c[o+8>>2];c[m+12>>2]=c[o+12>>2];c[m+16>>2]=c[o+16>>2];c[m+20>>2]=c[o+20>>2];c[m+24>>2]=c[o+24>>2];c[m+28>>2]=c[o+28>>2];c[o>>2]=c[d>>2];c[o+4>>2]=c[d+4>>2];c[o+8>>2]=c[d+8>>2];c[o+12>>2]=c[d+12>>2];c[o+16>>2]=c[d+16>>2];c[o+20>>2]=c[d+20>>2];c[o+24>>2]=c[d+24>>2];c[o+28>>2]=c[d+28>>2];c[h>>2]=c[p>>2];c[h+4>>2]=c[p+4>>2];c[h+8>>2]=c[p+8>>2];c[h+12>>2]=c[p+12>>2];c[h+16>>2]=c[p+16>>2];c[h+20>>2]=c[p+20>>2];c[h+24>>2]=c[p+24>>2];c[h+28>>2]=c[p+28>>2];Kc(o,h,136);c[n>>2]=c[o>>2];c[n+4>>2]=c[o+4>>2];c[n+8>>2]=c[o+8>>2];c[n+12>>2]=c[o+12>>2];c[n+16>>2]=c[o+16>>2];c[n+20>>2]=c[o+20>>2];c[n+24>>2]=c[o+24>>2];c[n+28>>2]=c[o+28>>2];Mc(m,n,136,-460954743,-2016278654);c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];c[j+8>>2]=c[m+8>>2];c[j+12>>2]=c[m+12>>2];c[j+16>>2]=c[m+16>>2];c[j+20>>2]=c[m+20>>2];c[j+24>>2]=c[m+24>>2];c[j+28>>2]=c[m+28>>2];c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[h+16>>2]=c[k+16>>2];c[h+20>>2]=c[k+20>>2];c[h+24>>2]=c[k+24>>2];c[h+28>>2]=c[k+28>>2];Lc(j,h,136);c[g>>2]=c[j>>2];c[g+4>>2]=c[j+4>>2];c[g+8>>2]=c[j+8>>2];c[g+12>>2]=c[j+12>>2];c[g+16>>2]=c[j+16>>2];c[g+20>>2]=c[j+20>>2];c[g+24>>2]=c[j+24>>2];c[g+28>>2]=c[j+28>>2];c[h>>2]=c[i>>2];c[h+4>>2]=c[i+4>>2];c[h+8>>2]=c[i+8>>2];c[h+12>>2]=c[i+12>>2];c[h+16>>2]=c[i+16>>2];c[h+20>>2]=c[i+20>>2];c[h+24>>2]=c[i+24>>2];c[h+28>>2]=c[i+28>>2];Lc(g,h,136);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[f+16>>2]=c[g+16>>2];c[f+20>>2]=c[g+20>>2];c[f+24>>2]=c[g+24>>2];c[f+28>>2]=c[g+28>>2];d=a+32|0;c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];c[d+8>>2]=c[f+8>>2];c[d+12>>2]=c[f+12>>2];c[d+16>>2]=c[f+16>>2];c[d+20>>2]=c[f+20>>2];c[d+24>>2]=c[f+24>>2];c[d+28>>2]=c[f+28>>2];l=e;return}function dd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0;d=l;l=l+224|0;g=d+192|0;f=d+160|0;e=d+128|0;k=d+96|0;j=d+64|0;i=d+32|0;h=d;c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];c[f+8>>2]=c[b+8>>2];c[f+12>>2]=c[b+12>>2];c[f+16>>2]=c[b+16>>2];c[f+20>>2]=c[b+20>>2];c[f+24>>2]=c[b+24>>2];c[f+28>>2]=c[b+28>>2];m=b+32|0;c[g>>2]=c[m>>2];c[g+4>>2]=c[m+4>>2];c[g+8>>2]=c[m+8>>2];c[g+12>>2]=c[m+12>>2];c[g+16>>2]=c[m+16>>2];c[g+20>>2]=c[m+20>>2];c[g+24>>2]=c[m+24>>2];c[g+28>>2]=c[m+28>>2];Mc(f,g,136,-460954743,-2016278654);c[h>>2]=c[f>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];c[h+28>>2]=c[f+28>>2];c[f>>2]=c[m>>2];c[f+4>>2]=c[m+4>>2];c[f+8>>2]=c[m+8>>2];c[f+12>>2]=c[m+12>>2];c[f+16>>2]=c[m+16>>2];c[f+20>>2]=c[m+20>>2];c[f+24>>2]=c[m+24>>2];c[f+28>>2]=c[m+28>>2];n=g;c[n>>2]=317583274;c[n+4>>2]=1757628553;n=g+8|0;c[n>>2]=1923792719;c[n+4>>2]=-1928822936;n=g+16|0;c[n>>2]=151523889;c[n+4>>2]=1373741639;n=g+24|0;c[n>>2]=1193918714;c[n+4>>2]=576313009;Mc(f,g,136,-460954743,-2016278654);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];c[e+16>>2]=c[f+16>>2];c[e+20>>2]=c[f+20>>2];c[e+24>>2]=c[f+24>>2];c[e+28>>2]=c[f+28>>2];c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];Kc(e,g,136);c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[k+16>>2]=c[e+16>>2];c[k+20>>2]=c[e+20>>2];c[k+24>>2]=c[e+24>>2];c[k+28>>2]=c[e+28>>2];c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];c[f+8>>2]=c[b+8>>2];c[f+12>>2]=c[b+12>>2];c[f+16>>2]=c[b+16>>2];c[f+20>>2]=c[b+20>>2];c[f+24>>2]=c[b+24>>2];c[f+28>>2]=c[b+28>>2];c[g>>2]=c[m>>2];c[g+4>>2]=c[m+4>>2];c[g+8>>2]=c[m+8>>2];c[g+12>>2]=c[m+12>>2];c[g+16>>2]=c[m+16>>2];c[g+20>>2]=c[m+20>>2];c[g+24>>2]=c[m+24>>2];c[g+28>>2]=c[m+28>>2];Kc(f,g,136);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];c[e+16>>2]=c[f+16>>2];c[e+20>>2]=c[f+20>>2];c[e+24>>2]=c[f+24>>2];c[e+28>>2]=c[f+28>>2];Mc(k,e,136,-460954743,-2016278654);c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];c[j+16>>2]=c[k+16>>2];c[j+20>>2]=c[k+20>>2];c[j+24>>2]=c[k+24>>2];c[j+28>>2]=c[k+28>>2];c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];c[g+8>>2]=c[h+8>>2];c[g+12>>2]=c[h+12>>2];c[g+16>>2]=c[h+16>>2];c[g+20>>2]=c[h+20>>2];c[g+24>>2]=c[h+24>>2];c[g+28>>2]=c[h+28>>2];Lc(j,g,136);c[i>>2]=c[j>>2];c[i+4>>2]=c[j+4>>2];c[i+8>>2]=c[j+8>>2];c[i+12>>2]=c[j+12>>2];c[i+16>>2]=c[j+16>>2];c[i+20>>2]=c[j+20>>2];c[i+24>>2]=c[j+24>>2];c[i+28>>2]=c[j+28>>2];c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[f+28>>2]=c[h+28>>2];b=g;c[b>>2]=317583274;c[b+4>>2]=1757628553;b=g+8|0;c[b>>2]=1923792719;c[b+4>>2]=-1928822936;b=g+16|0;c[b>>2]=151523889;c[b+4>>2]=1373741639;b=g+24|0;c[b>>2]=1193918714;c[b+4>>2]=576313009;Mc(f,g,136,-460954743,-2016278654);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];c[e+16>>2]=c[f+16>>2];c[e+20>>2]=c[f+20>>2];c[e+24>>2]=c[f+24>>2];c[e+28>>2]=c[f+28>>2];Lc(i,e,136);c[a>>2]=c[i>>2];c[a+4>>2]=c[i+4>>2];c[a+8>>2]=c[i+8>>2];c[a+12>>2]=c[i+12>>2];c[a+16>>2]=c[i+16>>2];c[a+20>>2]=c[i+20>>2];c[a+24>>2]=c[i+24>>2];c[a+28>>2]=c[i+28>>2];c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[f+28>>2]=c[h+28>>2];c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];c[g+8>>2]=c[h+8>>2];c[g+12>>2]=c[h+12>>2];c[g+16>>2]=c[h+16>>2];c[g+20>>2]=c[h+20>>2];c[g+24>>2]=c[h+24>>2];c[g+28>>2]=c[h+28>>2];Kc(f,g,136);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];c[e+16>>2]=c[f+16>>2];c[e+20>>2]=c[f+20>>2];c[e+24>>2]=c[f+24>>2];c[e+28>>2]=c[f+28>>2];b=a+32|0;c[b>>2]=c[e>>2];c[b+4>>2]=c[e+4>>2];c[b+8>>2]=c[e+8>>2];c[b+12>>2]=c[e+12>>2];c[b+16>>2]=c[e+16>>2];c[b+20>>2]=c[e+20>>2];c[b+24>>2]=c[e+24>>2];c[b+28>>2]=c[e+28>>2];l=d;return}function ed(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0;n=l;l=l+288|0;f=n+256|0;g=n+224|0;h=n+192|0;i=n+160|0;d=n+96|0;m=n+64|0;j=n+32|0;k=n;c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];c[f+8>>2]=c[b+8>>2];c[f+12>>2]=c[b+12>>2];c[f+16>>2]=c[b+16>>2];c[f+20>>2]=c[b+20>>2];c[f+24>>2]=c[b+24>>2];c[f+28>>2]=c[b+28>>2];Mc(g,f,136,-460954743,-2016278654);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];c[d+16>>2]=c[g+16>>2];c[d+20>>2]=c[g+20>>2];c[d+24>>2]=c[g+24>>2];c[d+28>>2]=c[g+28>>2];e=b+32|0;c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[g+16>>2]=c[e+16>>2];c[g+20>>2]=c[e+20>>2];c[g+24>>2]=c[e+24>>2];c[g+28>>2]=c[e+28>>2];c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[f+16>>2]=c[e+16>>2];c[f+20>>2]=c[e+20>>2];c[f+24>>2]=c[e+24>>2];c[f+28>>2]=c[e+28>>2];Mc(g,f,136,-460954743,-2016278654);c[h>>2]=c[g>>2];c[h+4>>2]=c[g+4>>2];c[h+8>>2]=c[g+8>>2];c[h+12>>2]=c[g+12>>2];c[h+16>>2]=c[g+16>>2];c[h+20>>2]=c[g+20>>2];c[h+24>>2]=c[g+24>>2];c[h+28>>2]=c[g+28>>2];o=f;c[o>>2]=317583274;c[o+4>>2]=1757628553;o=f+8|0;c[o>>2]=1923792719;c[o+4>>2]=-1928822936;o=f+16|0;c[o>>2]=151523889;c[o+4>>2]=1373741639;o=f+24|0;c[o>>2]=1193918714;c[o+4>>2]=576313009;Mc(h,f,136,-460954743,-2016278654);c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];c[i+8>>2]=c[h+8>>2];c[i+12>>2]=c[h+12>>2];c[i+16>>2]=c[h+16>>2];c[i+20>>2]=c[h+20>>2];c[i+24>>2]=c[h+24>>2];c[i+28>>2]=c[h+28>>2];Lc(d,i,136);c[j>>2]=c[d>>2];c[j+4>>2]=c[d+4>>2];c[j+8>>2]=c[d+8>>2];c[j+12>>2]=c[d+12>>2];c[j+16>>2]=c[d+16>>2];c[j+20>>2]=c[d+20>>2];c[j+24>>2]=c[d+24>>2];c[j+28>>2]=c[d+28>>2];o=j;if((((c[o>>2]|0)==0&(c[o+4>>2]|0)==0?(o=j+8|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0)?(o=j+16|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0)?(o=j+24|0,(c[o>>2]|0)==0&(c[o+4>>2]|0)==0):0){k=0;m=0;o=a;a=o;c[a>>2]=k;o=o+4|0;c[o>>2]=m;l=n;return}Oc(j,136);Mc(j,104,136,-460954743,-2016278654);c[k>>2]=c[j>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[k+16>>2]=c[j+16>>2];c[k+20>>2]=c[j+20>>2];c[k+24>>2]=c[j+24>>2];c[k+28>>2]=c[j+28>>2];c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[m+8>>2]=c[k+8>>2];c[m+12>>2]=c[k+12>>2];c[m+16>>2]=c[k+16>>2];c[m+20>>2]=c[k+20>>2];c[m+24>>2]=c[k+24>>2];c[m+28>>2]=c[k+28>>2];c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];c[f>>2]=c[k>>2];c[f+4>>2]=c[k+4>>2];c[f+8>>2]=c[k+8>>2];c[f+12>>2]=c[k+12>>2];c[f+16>>2]=c[k+16>>2];c[f+20>>2]=c[k+20>>2];c[f+24>>2]=c[k+24>>2];c[f+28>>2]=c[k+28>>2];Mc(g,f,136,-460954743,-2016278654);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];c[d+16>>2]=c[g+16>>2];c[d+20>>2]=c[g+20>>2];c[d+24>>2]=c[g+24>>2];c[d+28>>2]=c[g+28>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[g+16>>2]=c[e+16>>2];c[g+20>>2]=c[e+20>>2];c[g+24>>2]=c[e+24>>2];c[g+28>>2]=c[e+28>>2];c[f>>2]=c[m>>2];c[f+4>>2]=c[m+4>>2];c[f+8>>2]=c[m+8>>2];c[f+12>>2]=c[m+12>>2];c[f+16>>2]=c[m+16>>2];c[f+20>>2]=c[m+20>>2];c[f+24>>2]=c[m+24>>2];c[f+28>>2]=c[m+28>>2];Mc(g,f,136,-460954743,-2016278654);c[h>>2]=c[g>>2];c[h+4>>2]=c[g+4>>2];c[h+8>>2]=c[g+8>>2];c[h+12>>2]=c[g+12>>2];c[h+16>>2]=c[g+16>>2];c[h+20>>2]=c[g+20>>2];c[h+24>>2]=c[g+24>>2];c[h+28>>2]=c[g+28>>2];Nc(h,136);c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];c[i+8>>2]=c[h+8>>2];c[i+12>>2]=c[h+12>>2];c[i+16>>2]=c[h+16>>2];c[i+20>>2]=c[h+20>>2];c[i+24>>2]=c[h+24>>2];c[i+28>>2]=c[h+28>>2];e=d+32|0;c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];c[e+8>>2]=c[i+8>>2];c[e+12>>2]=c[i+12>>2];c[e+16>>2]=c[i+16>>2];c[e+20>>2]=c[i+20>>2];c[e+24>>2]=c[i+24>>2];c[e+28>>2]=c[i+28>>2];e=a+8|0;b=e+64|0;do{c[e>>2]=c[d>>2];e=e+4|0;d=d+4|0;}while((e|0)<(b|0));k=1;m=0;o=a;a=o;c[a>>2]=k;o=o+4|0;c[o>>2]=m;l=n;return}function fd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=l;l=l+96|0;h=e+64|0;g=e+32|0;f=e;c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];c[h+12>>2]=c[d+12>>2];c[h+16>>2]=c[d+16>>2];c[h+20>>2]=c[d+20>>2];c[h+24>>2]=c[d+24>>2];c[h+28>>2]=c[d+28>>2];Lc(g,h,136);c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[a+16>>2]=c[g+16>>2];c[a+20>>2]=c[g+20>>2];c[a+24>>2]=c[g+24>>2];c[a+28>>2]=c[g+28>>2];b=b+32|0;c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];d=d+32|0;c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];c[h+12>>2]=c[d+12>>2];c[h+16>>2]=c[d+16>>2];c[h+20>>2]=c[d+20>>2];c[h+24>>2]=c[d+24>>2];c[h+28>>2]=c[d+28>>2];Lc(g,h,136);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[f+16>>2]=c[g+16>>2];c[f+20>>2]=c[g+20>>2];c[f+24>>2]=c[g+24>>2];c[f+28>>2]=c[g+28>>2];d=a+32|0;c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];c[d+8>>2]=c[f+8>>2];c[d+12>>2]=c[f+12>>2];c[d+16>>2]=c[f+16>>2];c[d+20>>2]=c[f+20>>2];c[d+24>>2]=c[f+24>>2];c[d+28>>2]=c[f+28>>2];l=e;return}function gd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=l;l=l+96|0;h=e+64|0;g=e+32|0;f=e;c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];c[h+12>>2]=c[d+12>>2];c[h+16>>2]=c[d+16>>2];c[h+20>>2]=c[d+20>>2];c[h+24>>2]=c[d+24>>2];c[h+28>>2]=c[d+28>>2];Kc(g,h,136);c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[a+16>>2]=c[g+16>>2];c[a+20>>2]=c[g+20>>2];c[a+24>>2]=c[g+24>>2];c[a+28>>2]=c[g+28>>2];b=b+32|0;c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[g+16>>2]=c[b+16>>2];c[g+20>>2]=c[b+20>>2];c[g+24>>2]=c[b+24>>2];c[g+28>>2]=c[b+28>>2];d=d+32|0;c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];c[h+12>>2]=c[d+12>>2];c[h+16>>2]=c[d+16>>2];c[h+20>>2]=c[d+20>>2];c[h+24>>2]=c[d+24>>2];c[h+28>>2]=c[d+28>>2];Kc(g,h,136);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[f+16>>2]=c[g+16>>2];c[f+20>>2]=c[g+20>>2];c[f+24>>2]=c[g+24>>2];c[f+28>>2]=c[g+28>>2];d=a+32|0;c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];c[d+8>>2]=c[f+8>>2];c[d+12>>2]=c[f+12>>2];c[d+16>>2]=c[f+16>>2];c[d+20>>2]=c[f+20>>2];c[d+24>>2]=c[f+24>>2];c[d+28>>2]=c[f+28>>2];l=e;return}function hd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;g=0-d|0;f=b+((b+-1+d&g)-b)|0;if(f>>>0<b>>>0){c[a>>2]=0;return}b=N(f,e)|0;h=(e|0)==0;if(h?0:((b>>>0)/((h?1:e)>>>0)|0|0)!=(f|0)){c[a>>2]=0;return}if((d+-1&(d|-2147483648)|0)!=0|b>>>0>g>>>0)$i(2128);c[a>>2]=1;c[a+4>>2]=b;c[a+8>>2]=d;c[a+12>>2]=f;return}function id(a){a=a|0;return}function jd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=l;l=l+16|0;f=Xb(8,4,e)|0;if(!f)Yb(e);else {c[f>>2]=a;c[f+4>>2]=b;ye(f,2152,d);}}function kd(a){a=a|0;y=286299353;return 1890621284}function ld(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0;p=l;l=l+32|0;g=p+12|0;o=p;i=e<<1;if((i|0)<0)$i(2256);if(i){h=Xb(i,1,g)|0;if(!h){c[g>>2]=0;Yb(g);}else f=h;}else f=1;c[o>>2]=f;j=o+4|0;c[j>>2]=i;k=o+8|0;c[k>>2]=0;m=d+e|0;if(!e){c[b>>2]=c[o>>2];c[b+4>>2]=c[o+4>>2];c[b+8>>2]=c[o+8>>2];l=p;return}f=0;h=i;while(1){e=d+1|0;d=a[d>>0]|0;g=a[2168+((d&255)>>>4&255)>>0]|0;if((f|0)==(h|0)){n=0;Z(43,o|0);i=n;n=0;if(i&1){f=7;break}f=c[k>>2]|0;}a[(c[o>>2]|0)+f>>0]=g;f=(c[k>>2]|0)+1|0;c[k>>2]=f;g=a[2168+(d&15)>>0]|0;if((f|0)==(c[j>>2]|0)){n=0;Z(43,o|0);i=n;n=0;if(i&1){f=7;break}f=c[k>>2]|0;}a[(c[o>>2]|0)+f>>0]=g;f=(c[k>>2]|0)+1|0;c[k>>2]=f;if((e|0)==(m|0)){f=17;break}d=e;h=c[j>>2]|0;}if((f|0)==7){p=na()|0;md(o);za(p|0);}else if((f|0)==17){c[b>>2]=c[o>>2];c[b+4>>2]=c[o+4>>2];c[b+8>>2]=c[o+8>>2];l=p;return}}function md(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function nd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=l;l=l+64|0;d=i+32|0;e=i+8|0;f=i+4|0;g=i;h=c[a>>2]|0;if((h|0)==1114112){c[d>>2]=2184;c[d+4>>2]=1;c[d+8>>2]=0;c[d+16>>2]=15892;c[d+20>>2]=0;h=si(b,d)|0;l=i;return h|0}else {c[g>>2]=h;c[f>>2]=c[a+4>>2];c[d>>2]=g;c[d+4>>2]=38;c[d+8>>2]=f;c[d+12>>2]=39;c[e>>2]=2192;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=d;c[e+20>>2]=2;h=si(b,e)|0;l=i;return h|0}return 0}function od(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=l;l=l+48|0;q=u+24|0;r=u+12|0;t=u;i=e>>>1;if(i){h=Xb(i,1,q)|0;if(!h){c[q>>2]=0;Yb(q);}else g=h;}else g=1;c[t>>2]=g;s=t+4|0;c[s>>2]=i;o=t+8|0;c[o>>2]=0;p=d+e|0;g=0;j=0;i=0;h=d;a:while(1){if((h|0)==(p|0)){f=0;g=7;break}else m=j;while(1){k=h;h=h+1|0;k=a[k>>0]|0;j=m;m=m+1|0;if((k+-65&255)<6){j=-55;break}if((k+-97&255)<6){j=-87;break}if((k+-48&255)<10){j=-48;break}switch(k<<24>>24){case 9:case 10:case 13:case 32:break;default:{i=j;g=10;break a}}if((h|0)==(p|0)){f=0;g=7;break a}else i=i&15;}if((h|0)==(p|0)){f=1;g=7;break}k=j+k<<24>>24|i<<4&255;while(1){j=h;h=h+1|0;j=a[j>>0]|0;i=m;m=m+1|0;if((j+-65&255)<6){i=-55;break}if((j+-97&255)<6){i=-87;break}if((j+-48&255)<10){i=-48;break}switch(j<<24>>24){case 9:case 10:case 13:case 32:break;default:{g=10;break a}}if((h|0)==(p|0)){f=1;g=7;break a}else k=k&15;}i=i+j<<24>>24|k<<4&255;if((g|0)==(c[s>>2]|0)){n=0;Z(43,t|0);k=n;n=0;if(k&1){g=6;break}g=c[o>>2]|0;}a[(c[t>>2]|0)+g>>0]=i;g=(c[o>>2]|0)+1|0;c[o>>2]=g;j=m;}if((g|0)==6){u=na()|0;md(t);za(u|0);}else if((g|0)==7){if(f){c[b>>2]=1;c[b+4>>2]=1114112;f=c[s>>2]|0;if(f|0)Zb(c[t>>2]|0,f,1);}else {c[q>>2]=c[t>>2];c[q+4>>2]=c[t+4>>2];c[q+8>>2]=c[t+8>>2];s=c[q>>2]|0;t=s+(c[q+8>>2]|0)|0;d=c[q+4>>2]|0;c[q>>2]=s;c[q+4>>2]=d;c[q+8>>2]=s;c[q+12>>2]=t;pd(r,q);c[b>>2]=0;t=b+4|0;c[t>>2]=c[r>>2];c[t+4>>2]=c[r+4>>2];c[t+8>>2]=c[r+8>>2];}l=u;return}else if((g|0)==10){do if((i|0)==0|(i|0)==(e|0))f=d+i|0;else {if(i>>>0<e>>>0?(f=d+i|0,(a[f>>0]|0)>-65):0)break;n=0;ea(5,d|0,e|0,i|0,e|0);n=0;u=na()|0;md(t);za(u|0);}while(0);m=d+i+(e-i)|0;e=(f|0)==(m|0);g=e?f:d+i+1|0;do if(!e){j=a[f>>0]|0;if(j<<24>>24<=-1){k=j&31;if((g|0)==(m|0)){f=0;h=m;}else {f=a[g>>0]&63;h=g+1|0;}g=f&255;f=g|k<<6;if((j&255)>223){if((h|0)==(m|0)){f=0;h=m;}else {f=a[h>>0]&63;h=h+1|0;}g=f&255|g<<6;f=g|k<<12;if((j&255)>239){if((h|0)==(m|0))f=0;else f=a[h>>0]&63;f=g<<6|k<<18&1835008|f&255;if((f|0)==1114112)break}}}else f=j&255;c[b>>2]=1;c[b+4>>2]=f;c[b+8>>2]=i;f=c[s>>2]|0;if(f|0)Zb(c[t>>2]|0,f,1);l=u;return}while(0);n=0;Z(44,2208);n=0;u=na()|0;md(t);za(u|0);}}function pd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;h=l;l=l+32|0;i=h+16|0;j=h;d=c[b>>2]|0;if((d|0)==(c[b+8>>2]|0)){i=c[b+4>>2]|0;j=(c[b+12>>2]|0)-d|0;c[a>>2]=d;c[a+4>>2]=i;c[a+8>>2]=j;l=h;return}c[j>>2]=1;c[j+4>>2]=0;g=j+8|0;c[g>>2]=0;c[i>>2]=c[b>>2];c[i+4>>2]=c[b+4>>2];c[i+8>>2]=c[b+8>>2];c[i+12>>2]=c[b+12>>2];d=i+8|0;b=c[d>>2]|0;e=c[i+12>>2]|0;f=e-b|0;n=0;aa(20,j|0,0,f|0);k=n;n=0;if(k&1){d=na()|0;n=0;Z(45,i|0);k=n;n=0;if(!(k&1)){k=d;qd(j);za(k|0);}k=na()|0;qd(j);za(k|0);}else {k=c[g>>2]|0;ok((c[j>>2]|0)+k|0,b|0,f|0)|0;c[g>>2]=k+f;c[d>>2]=e;d=c[i+4>>2]|0;if(d|0)Zb(c[i>>2]|0,d,1);c[a>>2]=c[j>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];l=h;return}}function qd(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function rd(a){a=a|0;var b=0,d=0;b=a+8|0;d=c[a+12>>2]|0;if((c[b>>2]|0)!=(d|0))c[b>>2]=d;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function sd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;g=l;l=l+16|0;e=g;f=a+4|0;b=c[f>>2]|0;if(b|0){d=b<<1;if((d|0)<0)$i(2256);b=_b(c[a>>2]|0,b,1,d,1,e)|0;if(!b){i=e+4|0;j=c[i>>2]|0;i=c[i+4>>2]|0;c[e>>2]=c[e>>2];h=e+4|0;c[h>>2]=j;c[h+4>>2]=i;Yb(e);}h=b;i=a;j=d;c[i>>2]=h;c[f>>2]=j;l=g;return}ud(e,1,1,4);if((c[e>>2]|0)==1){b=c[e+4>>2]|0;if(b|0?(d=Xb(b,c[e+8>>2]|0,e)|0,d|0):0){h=d;i=a;j=4;c[i>>2]=h;c[f>>2]=j;l=g;return}}c[e>>2]=1;c[e+4>>2]=6818;c[e+8>>2]=30;Yb(e);}function td(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+16|0;h=j;i=a+4|0;e=c[i>>2]|0;if((e-b|0)>>>0>=d>>>0){l=j;return}d=b+d|0;if(d>>>0<b>>>0)cj(6768,17);g=e<<1;g=d>>>0>=g>>>0?d:g;ud(h,1,1,g);if((c[h>>2]|0)!=1)$i(2232);d=c[h+4>>2]|0;b=c[h+8>>2]|0;if((d|0)<0)$i(2256);e=c[i>>2]|0;if(!e){b=Xb(d,b,h)|0;d=(b|0)==0&1;e=0;f=0;}else {b=_b(c[a>>2]|0,e,1,d,b,h)|0;e=(b|0)==0;f=h+4|0;d=e&1;b=e?c[h>>2]|0:b;e=c[f>>2]|0;f=c[f+4>>2]|0;}if((d|0)==1){c[h>>2]=b;d=h+4|0;c[d>>2]=e;c[d+4>>2]=f;Yb(h);}c[a>>2]=b;c[i>>2]=g;l=j;return}function ud(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;g=0-d|0;f=b+((b+-1+d&g)-b)|0;if(f>>>0<b>>>0){c[a>>2]=0;return}b=N(f,e)|0;h=(e|0)==0;if(h?0:((b>>>0)/((h?1:e)>>>0)|0|0)!=(f|0)){c[a>>2]=0;return}if((d+-1&(d|-2147483648)|0)!=0|b>>>0>g>>>0)$i(2280);c[a>>2]=1;c[a+4>>2]=b;c[a+8>>2]=d;c[a+12>>2]=f;return}function vd(a){a=a|0;y=286299353;return 1890621284}function wd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;j=l;l=l+16|0;f=j;g=b+8|0;i=g;h=c[i>>2]|0;i=c[i+4>>2]|0;e=c[b>>2]|0;k=ti(b)|0;d=c[b>>2]|0;if(k){d=d|8;c[b>>2]=d;if(!(c[g>>2]|0)){c[g>>2]=1;c[b+12>>2]=10;}}c[b>>2]=d|4;c[f>>2]=c[a>>2];k=_h(f,b)|0;c[g>>2]=h;c[g+4>>2]=i;c[b>>2]=e;l=j;return k|0}function xd(a,b){a=a|0;b=b|0;return $h(c[a>>2]|0,b)|0}function yd(a,b){a=a|0;b=b|0;return ci(c[a>>2]|0,b)|0}function zd(a,b){a=a|0;b=b|0;return di(c[a>>2]|0,b)|0}function Ad(a,b){a=a|0;b=b|0;return zi(c[a>>2]|0,c[a+4>>2]|0,b)|0}function Bd(a,b){a=a|0;b=b|0;return bi(c[a>>2]|0,b)|0}function Cd(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Dd(a){a=a|0;Zb(a,12,4);return}function Ed(a,b){a=a|0;b=b|0;return mf(c[a>>2]|0,b)|0}function Fd(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0;n=l;l=l+16|0;k=n;m=c[b>>2]|0;b=d>>>0<65536;if(d>>>0<128){e=m+8|0;b=c[e>>2]|0;if((b|0)==(c[m+4>>2]|0)){Bg(m);b=c[e>>2]|0;}a[(c[m>>2]|0)+b>>0]=d;c[e>>2]=(c[e>>2]|0)+1;l=n;return 0}c[k>>2]=0;if(d>>>0<2048){i=31;f=0;g=-64;e=1;b=2;}else {if(b){e=15;f=0;g=-32;h=1;j=2;b=3;}else {a[k>>0]=d>>>18&255|-16;e=63;f=1;g=-128;h=2;j=3;b=4;}a[k+f>>0]=e&d>>>12&255|g;i=63;f=h;g=-128;e=j;}a[k+f>>0]=i&d>>>6&255|g;a[k+e>>0]=d&63|-128;j=m+8|0;Cg(m,c[j>>2]|0,b);d=c[j>>2]|0;c[j>>2]=d+b;ok((c[m>>2]|0)+d|0,k|0,b|0)|0;l=n;return 0}function Gd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=c[a>>2];c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,2672,e)|0;l=d;return b|0}function Hd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=c[a>>2];c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,3764,e)|0;l=d;return b|0}function Id(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=e+8|0;Cg(e,c[f>>2]|0,d);a=c[f>>2]|0;c[f>>2]=a+d;ok((c[e>>2]|0)+a|0,b|0,d|0)|0;return 0}function Jd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=l;l=l+16|0;i=h;b=c[b>>2]|0;qh(i,c[b>>2]|0,d,e);if((a[i>>0]|0)==3){i=0;l=h;return i|0}g=i;f=c[g>>2]|0;g=c[g+4>>2]|0;d=b+4|0;e=f&255;if((a[d>>0]|0)!=3?(n=0,Z(46,d|0),b=n,n=0,b&1):0){b=na()|0;h=d;c[h>>2]=f;c[h+4>>2]=g;if(e<<24>>24!=3)za(b|0);jf(i);za(b|0);}i=d;c[i>>2]=f;c[i+4>>2]=g;i=1;l=h;return i|0}function Kd(a,b){a=a|0;b=b|0;c[a>>2]=0;return}function Ld(a){a=a|0;y=1307671337;return -1091417412}function Md(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=l;l=l+32|0;e=f+8|0;d=f;c[e>>2]=c[a>>2];c[e+4>>2]=c[a+4>>2];c[e+8>>2]=c[a+8>>2];c[e+12>>2]=c[a+12>>2];c[e+16>>2]=c[a+16>>2];c[e+20>>2]=c[a+20>>2];rh(d,f+32|0,e);e=c[d+4>>2]|0;switch((c[d>>2]&255)<<24>>24){case 0:case 1:case 3:{l=f;return}default:{}}b=e;d=e;a=b+4|0;n=0;Z(c[c[a>>2]>>2]|0,c[d>>2]|0);g=n;n=0;if(g&1){g=na()|0;Cd(c[d>>2]|0,c[a>>2]|0);Dd(b);za(g|0);}a=c[a>>2]|0;b=c[a+4>>2]|0;if(b|0)Zb(c[e>>2]|0,b,c[a+8>>2]|0);Zb(e,12,4);l=f;return}function Nd(a){a=a|0;var b=0,d=0;b=l;l=l+32|0;d=b+24|0;c[d>>2]=a;c[d+4>>2]=40;c[b>>2]=2304;c[b+4>>2]=2;c[b+8>>2]=5180;c[b+12>>2]=1;c[b+16>>2]=d;c[b+20>>2]=1;Md(b);Ha();}function Od(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0;m=l;l=l+48|0;i=m;j=m+40|0;h=m+24|0;k=m+12|0;g=m+32|0;c[g>>2]=b;c[g+4>>2]=d;Oh(i,6943,4);c[j>>2]=pg(i)|0;n=0;Z(47,3804);d=n;n=0;if(d&1){m=na()|0;Vg(j);za(m|0);}d=c[j>>2]|0;b=i;c[b>>2]=0;c[b+4>>2]=0;c[i+8>>2]=d;lh(3804,i);zh(e,f);c[h>>2]=0;c[j>>2]=0;c[i>>2]=g;if(!(Hh(48,i,h,j)|0)){b=0;d=c[i>>2]|0;}else {b=fb[c[600]&7]()|0;if(!b)Ue(10081,57);if((c[b>>2]|0)==1){b=b+4|0;d=c[b>>2]|0;}else {d=fb[c[2404>>2]&7]()|0;g=b;c[g>>2]=1;c[g+4>>2]=d;b=b+4|0;}d=d+-1|0;a[b>>0]=d;a[b+1>>0]=d>>8;a[b+2>>0]=d>>16;a[b+3>>0]=d>>24;d=c[j>>2]|0;c[k+4>>2]=c[h>>2];b=1;}c[k>>2]=b;c[k+4+(b<<2)>>2]=d;do if((c[3956]|0)!=3){a[j>>0]=1;c[i>>2]=j;n=0;ea(6,15824,0,i|0,3084);j=n;n=0;if(!(j&1))break;m=na()|0;Pd(k);za(m|0);}while(0);j=c[k>>2]|0;f=c[k+4>>2]|0;d=c[k+8>>2]|0;e=(j|0)==1?101:f;b=f;if(!j){l=m;return e|0}n=0;Z(c[d>>2]|0,b|0);k=n;n=0;if(k&1){m=na()|0;Qd(b,d);za(m|0);}b=c[d+4>>2]|0;if(!b){l=m;return e|0}Zb(f,b,c[d+8>>2]|0);l=m;return e|0}function Pd(a){a=a|0;var b=0,d=0;if(!(c[a>>2]|0))return;d=a+4|0;a=a+8|0;n=0;Z(c[c[a>>2]>>2]|0,c[d>>2]|0);b=n;n=0;if(b&1){b=na()|0;Qd(c[d>>2]|0,c[a>>2]|0);za(b|0);}a=c[a>>2]|0;b=c[a+4>>2]|0;if(!b)return;Zb(c[d>>2]|0,b,c[a+8>>2]|0);return}function Qd(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Rd(){return 0}function Sd(a,b){a=a|0;b=b|0;c[a>>2]=6947;c[a+4>>2]=39;return}function Td(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=l;l=l+48|0;g=d+40|0;f=d+24|0;e=d;c[g>>2]=6947;c[g+4>>2]=39;c[f>>2]=g;c[f+4>>2]=41;c[f+8>>2]=a;c[f+12>>2]=42;c[e>>2]=2320;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;b=si(b,e)|0;l=d;return b|0}function Ud(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=l;l=l+32|0;g=i+12|0;h=i+24|0;f=i;c[f>>2]=0;c[f+4>>2]=d;c[f+8>>2]=e;d=$a(43,f|0)|0;switch(d|0){case 9:case 5:case 3:{g=c[f>>2]|0;c[b>>2]=0;h=0;h=b+4+(h<<2)|0;c[h>>2]=g;l=i;return}default:{}}e=Xb(4,4,g)|0;if(!e)Yb(g);c[e>>2]=d;d=Xb(12,4,g)|0;if(!d)Yb(g);c[d>>2]=e;c[d+4>>2]=2696;a[d+8>>0]=16;g=d+9|0;a[g>>0]=a[h>>0]|0;a[g+1>>0]=a[h+1>>0]|0;a[g+2>>0]=a[h+2>>0]|0;c[b>>2]=1;c[b+4>>2]=2;h=1;g=d;h=b+4+(h<<2)|0;c[h>>2]=g;l=i;return}function Vd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=l;l=l+16|0;d=f;c[d>>2]=0;a=ra(a|0,d|0)|0;a=(((a|0)!=0&(c[d>>2]|0)==0)<<31>>31)+a|0;d=ha(a|0)|0;e=c[b>>2]|0;if(e>>>0>=(c[b+8>>2]|0)>>>0){l=f;return 0}g=c[b+4>>2]|0;c[g+(e<<3)>>2]=a;c[g+(e<<3)+4>>2]=d;c[b>>2]=(c[b>>2]|0)+1;l=f;return 0}function Wd(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0;h=l;l=l+32|0;g=h;e=h+16|0;c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;do if((Ta(d|0,e|0)|0)!=0?(n=c[e+8>>2]|0,(n|0)!=0):0){e=Hj(n)|0;if((e|0)==-1)kj(-1,0);else {Fi(g,n,e);k=(c[g>>2]|0)==1;i=k?0:c[g+4>>2]|0;j=0;k=k?0:0;m=c[g+8>>2]|0;break}}else {i=0;j=0;k=0;m=0;}while(0);o=c[f>>2]|0;n=c[f+12>>2]|0;p=c[o>>2]|0;o=c[o+4>>2]|0;e=c[c[f+4>>2]>>2]|0;f=c[c[f+8>>2]>>2]|0;d=c[f>>2]|0;f=c[f+4>>2]|0;q=g;c[q>>2]=i|j;c[q+4>>2]=k|m;xg(b,p,o,e,d,f,g,a[n>>0]|0);l=h;return}function Xd(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;P=l;l=l+96|0;j=P;O=P+80|0;e=P+64|0;c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;if(!(Ta(d|0,e|0)|0)){a[b>>0]=3;l=P;return}e=c[e+8>>2]|0;if(!e){a[b>>0]=3;l=P;return}g=Hj(e)|0;if((g|0)==-1)kj(-1,0);Fi(j,e,g);e=c[j+4>>2]|0;g=c[j+8>>2]|0;if((c[j>>2]|0)==1|(e|0)==0){a[b>>0]=3;l=P;return}Ni(j,e,g,6988,28);D=c[j>>2]|0;do if((D|0)==1){e=j+8|0;g=c[j+48>>2]|0;d=c[j+52>>2]|0;h=c[j+56>>2]|0;i=c[j+60>>2]|0;if((c[j+36>>2]|0)==-1){Yd(O,e,g,d,h,i,1);break}else {Yd(O,e,g,d,h,i,0);break}}else {M=j+28|0;E=j+48|0;F=j+52|0;N=j+36|0;G=j+56|0;H=j+60|0;I=j+8|0;J=j+16|0;K=j+24|0;L=j+12|0;C=j+4|0;e=0;a:while(1){if((e|0)==1){B=c[F>>2]|0;h=c[E>>2]|0;q=c[G>>2]|0;z=c[H>>2]|0;r=z+-1|0;t=I;s=c[t>>2]|0;t=c[t+4>>2]|0;u=c[J>>2]|0;d=c[K>>2]|0;v=z-d|0;g=c[M>>2]|0;i=c[N>>2]|0;if((g|0)==(B|0)){d=61;break}A=(i|0)==-1;j=r+g|0;b:do if(j>>>0<B>>>0){e=z+g|0;w=e+r|0;x=w>>>0<B>>>0;m=d+g|0;n=m+r|0;o=n>>>0<B>>>0;p=g+1-u|0;d=g;while(1){c:while(1){while(1){if((g|0)!=(d|0)){g=i;break b}k=nk(1,0,a[h+j>>0]&63|0)|0;if(!((k&s|0)==0&(y&t|0)==0))break;i=A?i:0;if(x){d=e;j=w;}else {d=B;g=i;break b}}d=A?u:i>>>0>=u>>>0?i:u;while(1){if(d>>>0>=z>>>0)break c;if(d>>>0>4294967294)break c;j=d+g|0;if(j>>>0>=B>>>0){d=45;break a}if((a[q+d>>0]|0)==(a[h+j>>0]|0))d=d+1|0;else break}d=p+d|0;i=A?i:0;j=d+r|0;if(j>>>0>=B>>>0){d=B;g=i;break b}}d=A?0:i;j=u;do{k=j;j=j+-1|0;if(d>>>0>=k>>>0){d=49;break a}if(j>>>0>=z>>>0){d=56;break a}k=j+g|0;if(k>>>0>=B>>>0){d=52;break a}}while((a[q+j>>0]|0)==(a[h+k>>0]|0));i=A?i:v;if(o){d=m;j=n;}else {d=B;g=i;break}}}else {d=B;g=i;}while(0);d:do if((d|0)==0|(B|0)==(d|0))e=d;else {e=d;do{if(B>>>0>e>>>0?(a[h+e>>0]|0)>-65:0)break d;e=e+1|0;}while(!((e|0)==0|(B|0)==(e|0)))}while(0);c[M>>2]=d>>>0>=e>>>0?d:e;c[N>>2]=g;g=B;}else {g=c[F>>2]|0;h=c[E>>2]|0;}k=(a[L>>0]|0)!=0;a[L>>0]=(k^1)&1;m=c[C>>2]|0;if(!((m|0)==0|(g|0)==(m|0))){if(g>>>0<=m>>>0){d=13;break}e=h+m|0;if((a[e>>0]|0)<=-65){d=13;break}}else e=h+m|0;j=h+m+(g-m)|0;B=(e|0)==(j|0);g=B?e:h+m+1|0;do if(!B){h=a[e>>0]|0;if(h<<24>>24>-1){e=h&255;break}i=h&31;if((g|0)==(j|0)){e=0;d=j;}else {e=a[g>>0]&63;d=g+1|0;}g=e&255;e=g|i<<6;if((h&255)>223){if((d|0)==(j|0)){e=0;d=j;}else {e=a[d>>0]&63;d=d+1|0;}g=e&255|g<<6;e=g|i<<12;if((h&255)>239){if((d|0)==(j|0))e=0;else e=a[d>>0]&63;e=g<<6|i<<18&1835008|e&255;}}}else e=1114112;while(0);if(k){g=m;e=m;d=63;break}if((e|0)==1114112){d=62;break}c[C>>2]=(e>>>0<128?1:e>>>0<2048?2:e>>>0<65536?3:4)+m;e=D;}if((d|0)==13)Ii(h,g,m,g);else if((d|0)==45)bj(2336,j,B);else if((d|0)==49){c[N>>2]=i;c[M>>2]=e;if(A)d=63;else {c[N>>2]=0;d=63;}}else if((d|0)==52)bj(2336,k,B);else if((d|0)==56)bj(2352,j,z);else if((d|0)==61){c[M>>2]=B;d=62;}if((d|0)==62){c[O>>2]=0;break}else if((d|0)==63){c[O>>2]=1;c[O+4>>2]=g;c[O+8>>2]=e;break}}while(0);if((c[O>>2]|0)!=1){a[b>>0]=3;l=P;return}a[f>>0]=1;a[b>>0]=3;l=P;return}function Yd(b,d,e,f,g,h,i){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;t=d+20|0;r=h+-1|0;k=c[t>>2]|0;j=k+r|0;a:do if(j>>>0<f>>>0){s=d+28|0;p=d;o=c[p>>2]|0;p=c[p+4>>2]|0;q=c[d+8>>2]|0;m=c[d+16>>2]|0;n=h-m|0;d=k;b:while(1){c:while(1){l=d;while(1){k=nk(1,0,a[e+j>>0]&63|0)|0;if(!((k&o|0)==0&(y&p|0)==0))break;d=l+h|0;c[t>>2]=d;if(!i)c[s>>2]=0;j=d+r|0;if(j>>>0>=f>>>0)break a;else l=d;}if(i)d=q;else {d=c[s>>2]|0;d=d>>>0>=q>>>0?d:q;}do{if(d>>>0>=h>>>0)break c;j=d;d=d+1|0;if(j>>>0>4294967294)break c;k=l+j|0;if(k>>>0>=f>>>0){d=17;break b}}while((a[g+j>>0]|0)==(a[e+k>>0]|0));d=d+l-q|0;c[t>>2]=d;if(!i)c[s>>2]=0;j=d+r|0;if(j>>>0>=f>>>0)break a}d=i?0:c[s>>2]|0;j=q;do{k=j;j=j+-1|0;if(d>>>0>=k>>>0){d=23;break b}if(j>>>0>=h>>>0){d=33;break b}k=j+l|0;if(k>>>0>=f>>>0){d=26;break b}}while((a[g+j>>0]|0)==(a[e+k>>0]|0));d=m+l|0;c[t>>2]=d;if(!i)c[s>>2]=n;j=d+r|0;if(j>>>0>=f>>>0)break a}if((d|0)==17)bj(2336,k,f);else if((d|0)==23){d=l+h|0;c[t>>2]=d;if(!i)c[s>>2]=0;c[b>>2]=1;c[b+4>>2]=l;c[b+8>>2]=d;return}else if((d|0)==26)bj(2336,k,f);else if((d|0)==33)bj(2352,j,h);}while(0);c[t>>2]=f;c[b>>2]=0;return}function Zd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+16|0;f=d+12|0;e=d;vi(e,b,7086,11);c[f>>2]=a;Si(e,f,2368)|0;b=Ti(e)|0;l=d;return b|0}function _d(a){a=a|0;return}function $d(a,b){a=a|0;b=b|0;return Mh(c[a>>2]|0,b)|0}function ae(a,b){a=a|0;b=b|0;return Lf(c[a>>2]|0,c[a+4>>2]|0,b)|0}function be(a){a=a|0;return}function ce(){var a=0,b=0,d=0,e=0;e=l;l=l+16|0;b=e;a=c[602]|0;if(!a)a=_g(2408)|0;a=Ca(a|0)|0;switch(a|0){case 0:{d=Xb(12,4,b)|0;if(!d)Yb(b);c[d>>2]=2408;b=d+4|0;a=b;c[a>>2]=0;c[a+4>>2]=0;a=c[602]|0;if(!a)a=_g(2408)|0;Sa(a|0,d|0)|0;d=b;l=e;return d|0}case 1:{d=0;l=e;return d|0}default:{d=a+4|0;l=e;return d|0}}return 0}function de(){return 0}function ee(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=l;l=l+16|0;d=g;c[d>>2]=a;f=c[a>>2]|0;b=c[f>>2]|0;if(!b){n=0;b=$(11,f|0)|0;h=n;n=0;if(h&1){na()|0;fe(d);Za();}else e=b;}else e=b;Sa(e|0,1)|0;Zb(a,12,4);b=c[f>>2]|0;if(b|0){h=b;Sa(h|0,0)|0;l=g;return}n=0;b=$(11,f|0)|0;h=n;n=0;if(!(h&1)){h=b;Sa(h|0,0)|0;l=g;return}na()|0;Za();}function fe(a){a=a|0;Zb(c[a>>2]|0,12,4);return}function ge(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function he(a){a=a|0;return}function ie(a){a=a|0;var b=0,d=0;b=a+4|0;n=0;Z(c[c[b>>2]>>2]|0,c[a>>2]|0);d=n;n=0;if(d&1){d=na()|0;je(c[a>>2]|0,c[b>>2]|0);za(d|0);}b=c[b>>2]|0;d=c[b+4>>2]|0;if(!d)return;Zb(c[a>>2]|0,d,c[b+8>>2]|0);return}function je(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function ke(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function le(a){a=a|0;var b=0,d=0,e=0,f=0;f=l;l=l+16|0;e=f;b=c[a>>2]|0;if(!b)b=_g(a)|0;b=Ca(b|0)|0;switch(b|0){case 0:{d=Xb(20,4,e)|0;if(!d)Yb(e);c[d>>2]=a;c[d+8>>2]=3;b=c[a>>2]|0;if(!b)b=_g(a)|0;Sa(b|0,d|0)|0;a=d+4|0;l=f;return a|0}case 1:{a=0;l=f;return a|0}default:{a=b+4|0;l=f;return a|0}}return 0}function me(a){a=a|0;var b=0,d=0,e=0,f=0;f=l;l=l+16|0;d=f;b=c[a>>2]|0;if(!b)b=_g(a)|0;b=Ca(b|0)|0;switch(b|0){case 0:{e=Xb(20,4,d)|0;if(!e)Yb(d);c[e>>2]=a;d=e+4|0;c[d>>2]=0;b=c[a>>2]|0;if(!b)b=_g(a)|0;Sa(b|0,e|0)|0;a=d;l=f;return a|0}case 1:{a=0;l=f;return a|0}default:{a=b+4|0;l=f;return a|0}}return 0}function ne(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=l;l=l+16|0;d=h+4|0;f=h;c[f>>2]=a;g=c[a>>2]|0;b=c[g>>2]|0;if(!b){n=0;b=$(11,g|0)|0;i=n;n=0;if(i&1){na()|0;oe(f);Za();}else e=b;}else e=b;Sa(e|0,1)|0;c[d>>2]=a;n=0;Z(49,d|0);i=n;n=0;if(!(i&1)){a=c[g>>2]|0;if(a|0){i=a;Sa(i|0,0)|0;l=h;return}n=0;a=$(11,g|0)|0;i=n;n=0;if(!(i&1)){i=a;Sa(i|0,0)|0;l=h;return}}na()|0;Za();}function oe(a){a=a|0;var b=0,d=0,e=0;b=c[a>>2]|0;if(c[b+4>>2]|0?(e=b+12|0,d=c[e>>2]|0,d|0):0){b=b+16|0;n=0;Z(c[c[b>>2]>>2]|0,d|0);d=n;n=0;if(d&1){d=na()|0;pe(c[e>>2]|0,c[b>>2]|0);qe(c[a>>2]|0);za(d|0);}b=c[b>>2]|0;d=c[b+4>>2]|0;if(d|0)Zb(c[e>>2]|0,d,c[b+8>>2]|0);}Zb(c[a>>2]|0,20,4);return}function pe(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function qe(a){a=a|0;Zb(a,20,4);return}function re(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=l;l=l+16|0;d=h;c[d>>2]=a;g=c[a>>2]|0;b=c[g>>2]|0;if(!b){n=0;b=$(11,g|0)|0;i=n;n=0;if(i&1){na()|0;te(d);Za();}else f=b;}else f=b;Sa(f|0,1)|0;if(((c[a+8>>2]&2|0)==0?(e=a+16|0,f=c[e>>2]|0,i=c[f>>2]|0,c[f>>2]=i-1,(i|0)==1):0)?(n=0,Z(50,e|0),i=n,n=0,i&1):0){na()|0;se(a);Za();}Zb(a,20,4);b=c[g>>2]|0;if(b|0){i=b;Sa(i|0,0)|0;l=h;return}n=0;b=$(11,g|0)|0;i=n;n=0;if(!(i&1)){i=b;Sa(i|0,0)|0;l=h;return}na()|0;Za();}function se(a){a=a|0;Zb(a,20,4);return}function te(a){a=a|0;var b=0,d=0,e=0;b=c[a>>2]|0;if(((c[b+8>>2]&2|0)==0?(d=b+16|0,e=c[d>>2]|0,b=c[e>>2]|0,c[e>>2]=b-1,(b|0)==1):0)?(n=0,Z(50,d|0),e=n,n=0,e&1):0){e=na()|0;se(c[a>>2]|0);za(e|0);}Zb(c[a>>2]|0,20,4);return}function ue(a){a=a|0;return a|0}function ve(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=l;l=l+16|0;f=Xb(8,4,e)|0;if(!f)Yb(e);else {c[f>>2]=a;c[f+4>>2]=b;ye(f,2432,d);}}function we(a,b){a=a|0;b=b|0;var d=0,e=0;e=l;l=l+48|0;d=e+16|0;c[e>>2]=1;c[e+4>>2]=0;c[e+8>>2]=0;c[d>>2]=c[a>>2];c[d+4>>2]=c[a+4>>2];c[d+8>>2]=c[a+8>>2];c[d+12>>2]=c[a+12>>2];c[d+16>>2]=c[a+16>>2];c[d+20>>2]=c[a+20>>2];n=0;ca(44,e|0,d|0)|0;a=n;n=0;if(a&1){d=na()|0;ge(e);za(d|0);}else {c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];c[d+8>>2]=c[e+8>>2];xe(d,b);}}function xe(a,b){a=a|0;b=b|0;var d=0,e=0;e=l;l=l+32|0;d=e+12|0;c[e>>2]=c[a>>2];c[e+4>>2]=c[a+4>>2];c[e+8>>2]=c[a+8>>2];a=Xb(12,4,d)|0;if(!a)Yb(d);else {c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];ye(a,2416,b);}}function ye(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0;r=l;l=l+80|0;p=r+56|0;q=r+32|0;k=r+8|0;c[r>>2]=b;c[r+4>>2]=d;m=c[e>>2]|0;i=c[e+4>>2]|0;j=c[e+8>>2]|0;f=c[e+12>>2]|0;g=b;h=d;n=0;e=Y(1)|0;t=n;n=0;a:do if(!(t&1)){if(!e){n=0;_(22,10081,57);n=0;break}if((c[e>>2]|0)==1){t=e+4|0;e=(c[t>>2]|0)+1|0;c[t>>2]=e;if(e>>>0>2){c[k>>2]=2504;c[k+4>>2]=1;c[k+8>>2]=0;c[k+16>>2]=15892;c[k+20>>2]=0;n=0;Z(51,k|0);t=n;n=0;if(t&1)break;Za();}else s=e;}else {s=e;c[s>>2]=1;c[s+4>>2]=0;c[e+4>>2]=1;s=1;}c[q>>2]=g;c[q+4>>2]=h;c[q+8>>2]=m;c[q+12>>2]=i;c[q+16>>2]=j;c[q+20>>2]=f;e=ya(15608)|0;switch(e|0){case 11:{n=0;aa(21,7225,36,2472);n=0;break a}case 35:break;default:o=9;}do if((o|0)==9){if(a[15644]|0){if(e|0)break;ma(15608)|0;break}c[3910]=(c[3910]|0)+1;e=c[3913]|0;if(!e){n=0;Z(52,q|0);t=n;n=0;if(t&1)break a}else {n=0;_(c[e+12>>2]|0,c[3912]|0,q|0);t=n;n=0;if(t&1)break a}c[3910]=(c[3910]|0)-1;ma(15608)|0;if(s>>>0<=1)Ae(b,d);c[p>>2]=2512;c[p+4>>2]=1;c[p+8>>2]=0;c[p+16>>2]=15892;c[p+20>>2]=0;n=0;Z(51,p|0);t=n;n=0;if(t&1)break a;Za();}while(0);n=0;aa(21,7261,41,2488);n=0;}while(0);t=na()|0;ie(r);za(t|0);}function ze(b){b=b|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0;z=l;l=l+112|0;w=z+88|0;u=z+80|0;A=z;v=z+56|0;m=z+48|0;x=z+40|0;t=z+97|0;p=z+32|0;q=z+28|0;i=z+24|0;j=z+16|0;k=z+96|0;e=ce()|0;if(!e)Ue(10081,57);if((c[e>>2]|0)==1)if((c[e+4>>2]|0)>>>0>1)e=2;else s=7;else {s=e;c[s>>2]=1;c[s+4>>2]=0;c[e+4>>2]=0;s=7;}if((s|0)==7)e=wg()|0;a[k>>0]=e;f=c[b+12>>2]|0;c[j>>2]=c[b+8>>2];c[j+4>>2]=f;c[i>>2]=c[b+16>>2];c[q>>2]=c[b+20>>2];f=c[b>>2]|0;e=c[(c[b+4>>2]|0)+12>>2]|0;b=ib[e&15](f)|0;if((b|0)==1890621284&(y|0)==286299353){e=c[f+4>>2]|0;c[p>>2]=c[f>>2];}else {b=ib[e&15](f)|0;if((b|0)==2033335871&(y|0)==160875347){e=c[f+8>>2]|0;b=c[f>>2]|0;}else {e=8;b=7345;}c[p>>2]=b;}c[p+4>>2]=e;a[t>>0]=1;e=ph(3804)|0;c[x>>2]=e;a:do if(!e){o=0;h=0;g=0;s=20;}else {e=e+16|0;f=(c[e>>2]|0)==0;e=f?0:e;do if(!f){f=c[e+4>>2]|0;b=f+-1|0;if(!f){n=0;_(14,b|0,0);n=0;break a}else {e=c[e>>2]|0;break}}else {b=0;e=0;}while(0);o=e;h=e;g=b;s=20;}while(0);do if((s|0)==20?(r=(o|0)==0,c[m>>2]=r?7353:h,c[m+4>>2]=r?9:g,c[v>>2]=m,c[v+4>>2]=p,c[v+8>>2]=j,c[v+12>>2]=i,c[v+16>>2]=q,c[v+20>>2]=k,n=0,r=$(12,2520)|0,s=n,n=0,!(s&1)):0){if(!r){n=0;_(22,10081,57);n=0;break}if((c[r>>2]|0)!=1){n=0;e=ca(45,2528,r|0)|0;s=n;n=0;if(s&1)break}else e=r+4|0;if(c[e>>2]|0){n=0;_(23,9967,16);n=0;break}b=e+4|0;h=b;g=h;g=d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24;h=h+4|0;h=d[h>>0]|d[h+1>>0]<<8|d[h+2>>0]<<16|d[h+3>>0]<<24;a[b>>0]=0;a[b+1>>0]=0;a[b+2>>0]=0;a[b+3>>0]=0;a[e>>0]=0;a[e+1>>0]=0;a[e+2>>0]=0;a[e+3>>0]=0;e=(a[t>>0]|0)==1?t+1|0:0;b=A;c[b>>2]=g;c[b+4>>2]=h;b=A+8|0;c[b>>2]=e;f=h;do if(!g)if((e|0)!=0?(n=0,aa(22,v|0,b|0,2536),w=n,n=0,w&1):0){e=na()|0;b=1;s=30;}else {f=1;s=41;}else {c[u>>2]=g;c[u+4>>2]=f;n=0;aa(22,v|0,g|0,f|0);v=n;n=0;if(v&1){e=na()|0;De(u);b=0;s=30;break}c[w>>2]=g;c[w+4>>2]=h;n=0;_(24,2528,w|0);v=n;n=0;if(v&1){e=na()|0;Ee(w);b=0;s=30;break}f=c[w>>2]|0;if(f|0){e=c[w+4>>2]|0;n=0;Z(c[e>>2]|0,f|0);w=n;n=0;if(w&1){s=na()|0;pe(f,e);b=0;e=s;s=30;break}b=c[e+4>>2]|0;if(b|0)Zb(f,b,c[e+8>>2]|0);}f=0;s=41;}while(0);do if((s|0)==30)Be(x);else if((s|0)==41){e=c[x>>2]|0;if((e|0?(w=c[e>>2]|0,c[e>>2]=w-1,(w|0)==1):0)?(n=0,Z(50,x|0),x=n,n=0,x&1):0){e=na()|0;b=f<<24>>24!=0;break}b=c[A>>2]|0;if(f<<24>>24==0|(b|0)==0){l=z;return}e=A+4|0;n=0;Z(c[c[e>>2]>>2]|0,b|0);x=n;n=0;if(x&1){z=na()|0;pe(c[A>>2]|0,c[e>>2]|0);za(z|0);}e=c[e>>2]|0;b=c[e+4>>2]|0;if(!b){l=z;return}Zb(c[A>>2]|0,b,c[e+8>>2]|0);l=z;return}while(0);if(!(c[A>>2]|0)){Ee(A);A=e;za(A|0);}if(!b){A=e;za(A|0);}De(A);A=e;za(A|0);}while(0);A=na()|0;Be(x);za(A|0);}function Ae(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=l;l=l+48|0;e=f+32|0;d=f+8|0;c[f>>2]=Ih(a,b)|0;c[e>>2]=f;c[e+4>>2]=46;c[d>>2]=2448;c[d+4>>2]=1;c[d+8>>2]=5180;c[d+12>>2]=1;c[d+16>>2]=e;c[d+20>>2]=1;Nd(d);}function Be(a){a=a|0;var b=0,d=0;b=c[a>>2]|0;if(!b)return;d=c[b>>2]|0;c[b>>2]=d-1;if((d|0)!=1)return;Te(a);return}function Ce(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0;m=l;l=l+80|0;i=m+32|0;k=m+8|0;f=m;o=c[b+4>>2]|0;g=c[b+8>>2]|0;h=c[b+12>>2]|0;j=c[b+16>>2]|0;c[i>>2]=c[b>>2];c[i+4>>2]=41;c[i+8>>2]=o;c[i+12>>2]=41;c[i+16>>2]=g;c[i+20>>2]=41;c[i+24>>2]=h;c[i+28>>2]=46;c[i+32>>2]=j;c[i+36>>2]=46;c[k>>2]=2568;c[k+4>>2]=6;c[k+8>>2]=4840;c[k+12>>2]=5;c[k+16>>2]=i;c[k+20>>2]=5;j=c[e+24>>2]|0;jb[j&31](f,d,k);switch(a[f>>0]&3){case 0:case 1:case 3:break;default:{h=c[f+4>>2]|0;f=h+4|0;n=0;Z(c[c[f>>2]>>2]|0,c[h>>2]|0);o=n;n=0;if(o&1){o=na()|0;Fe(c[h>>2]|0,c[f>>2]|0);Ge(h);za(o|0);}f=c[f>>2]|0;g=c[f+4>>2]|0;if(g|0)Zb(c[h>>2]|0,g,c[f+8>>2]|0);Zb(h,12,4);}}f=a[c[b+20>>2]>>0]|0;if(f<<24>>24!=4){tg(i,d,e,f);switch(a[i>>0]&3){case 0:case 1:case 3:break;default:{h=c[i+4>>2]|0;f=h+4|0;n=0;Z(c[c[f>>2]>>2]|0,c[h>>2]|0);o=n;n=0;if(o&1){o=na()|0;Fe(c[h>>2]|0,c[f>>2]|0);Ge(h);za(o|0);}f=c[f>>2]|0;g=c[f+4>>2]|0;if(g|0)Zb(c[h>>2]|0,g,c[f+8>>2]|0);Zb(h,12,4);}}l=m;return}f=a[7362]|0;if(f<<24>>24==1)a[7362]=0;if(!(f<<24>>24)){l=m;return}c[i>>2]=2616;c[i+4>>2]=1;c[i+8>>2]=0;c[i+16>>2]=15892;c[i+20>>2]=0;jb[j&31](k,d,i);switch(a[k>>0]&3){case 0:case 1:case 3:break;default:{h=c[k+4>>2]|0;f=h+4|0;n=0;Z(c[c[f>>2]>>2]|0,c[h>>2]|0);o=n;n=0;if(o&1){o=na()|0;Fe(c[h>>2]|0,c[f>>2]|0);Ge(h);za(o|0);}f=c[f>>2]|0;g=c[f+4>>2]|0;if(g|0)Zb(c[h>>2]|0,g,c[f+8>>2]|0);Zb(h,12,4);}}l=m;return}function De(a){a=a|0;var b=0,d=0;b=a+4|0;n=0;Z(c[c[b>>2]>>2]|0,c[a>>2]|0);d=n;n=0;if(d&1){d=na()|0;pe(c[a>>2]|0,c[b>>2]|0);za(d|0);}b=c[b>>2]|0;d=c[b+4>>2]|0;if(!d)return;Zb(c[a>>2]|0,d,c[b+8>>2]|0);return}function Ee(a){a=a|0;var b=0,d=0;b=c[a>>2]|0;if(!b)return;d=a+4|0;n=0;Z(c[c[d>>2]>>2]|0,b|0);b=n;n=0;if(b&1){b=na()|0;pe(c[a>>2]|0,c[d>>2]|0);za(b|0);}d=c[d>>2]|0;b=c[d+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,c[d+8>>2]|0);return}function Fe(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Ge(a){a=a|0;Zb(a,12,4);return}function He(a){a=a|0;return}function Ie(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;b=dk(2,d,(e|0)>-1?e:2147483647)|0;if((b|0)==-1){e=1;b=0;d=c[(Bj()|0)>>2]|0;}else {e=0;d=0;}c[a>>2]=e;a=a+4|0;c[a>>2]=b;c[a+4>>2]=d;return}function Je(b,c){b=b|0;c=c|0;a[b>>0]=3;return}function Ke(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;qh(a,c[b>>2]|0,d,e);return}function Le(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=l;l=l+32|0;f=e;b=c[b>>2]|0;c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[f+16>>2]=c[d+16>>2];c[f+20>>2]=c[d+20>>2];rh(a,b,f);l=e;return}function Me(){return me(2520)|0}function Ne(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;return}function Oe(a){a=a|0;var b=0;b=c[a>>2]|0;c[a>>2]=vg(c[b>>2]|0,c[b+4>>2]|0)|0;return}function Pe(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=l;l=l+16|0;g=c[b+4>>2]|0;c[f>>2]=c[b>>2];c[f+4>>2]=g;c[f+8>>2]=d;c[f+12>>2]=e;we(a,f);}function Qe(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+160|0;g=j;h=j+8|0;i=j+24|0;e=i;f=e+128|0;do{a[e>>0]=0;e=e+1|0;}while((e|0)<(f|0));if((ck(d,i,128)|0)<0)ve(7207,18,2456);d=Hj(i)|0;if((d|0)==-1)kj(-1,0);Fi(h,i,d);if((c[h>>2]|0)==1){h=h+4|0;i=c[h+4>>2]|0;j=g;c[j>>2]=c[h>>2];c[j+4>>2]=i;bf(7097,43,g);}else {Oh(b,c[h+4>>2]|0,c[h+8>>2]|0);l=j;return}}function Re(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0;r=l;l=l+80|0;f=r;m=r+56|0;p=r+44|0;i=r+8|0;j=r+24|0;s=r+16|0;Kg(p,d,e);e=c[p>>2]|0;d=Lj(e,0,c[p+8>>2]|0)|0;if(!d){c[m>>2]=c[p>>2];c[m+4>>2]=c[p+4>>2];c[m+8>>2]=c[p+8>>2];Df(f,m);g=0;h=c[f>>2]|0;e=c[f+4>>2]|0;d=0;f=0;}else {f=p+4|0;g=1;h=d-e|0;d=c[f>>2]|0;f=c[f+4>>2]|0;}c[j>>2]=g;c[j+4>>2]=h;c[j+8>>2]=e;k=j+12|0;c[k>>2]=d;c[k+4>>2]=f;k=h;if((g|0)==1){s=j+4|0;c[m>>2]=c[s>>2];c[m+4>>2]=c[s+4>>2];c[m+8>>2]=c[s+8>>2];c[m+12>>2]=c[s+12>>2];n=0;_(25,i|0,m|0);s=n;n=0;if(s&1){s=na()|0;za(s|0);}else {q=i;p=c[q>>2]|0;q=c[q+4>>2]|0;c[b>>2]=1;s=b+4|0;c[s>>2]=p;c[s+4>>2]=q;l=r;return}}c[s>>2]=h;i=s+4|0;c[i>>2]=e;ik(15656)|0;f=Ka(h|0)|0;a:do if(!f){d=0;e=0;f=0;}else {g=Hj(f)|0;do if((g|0)!=-1){if((g|0)<0){n=0;Z(44,3740);n=0;q=25;break}if(g){d=Xb(g,1,m)|0;if(!d){c[m>>2]=0;Yb(m);}else o=d;}else o=1;c[p>>2]=o;d=p+4|0;c[d>>2]=g;e=p+8|0;c[e>>2]=0;n=0;aa(23,p|0,0,g|0);o=n;n=0;if(o&1){d=na()|0;n=0;Z(53,p|0);r=n;n=0;if(r&1){q=25;break}else break}else {q=c[e>>2]|0;c[e>>2]=q+g;ok((c[p>>2]|0)+q|0,f|0,g|0)|0;f=d;d=c[p>>2]|0;e=c[f>>2]|0;f=c[f+4>>2]|0;break a}}else {n=0;_(14,-1,0);n=0;q=25;}while(0);if((q|0)==25)d=na()|0;Se(s);s=d;za(s|0);}while(0);mk(15656)|0;c[b>>2]=0;c[b+4>>2]=d;d=b+8|0;c[d>>2]=e;c[d+4>>2]=f;a[k>>0]=0;d=c[i>>2]|0;if(d|0)Zb(c[s>>2]|0,d,1);l=r;return}function Se(b){b=b|0;var d=0;a[c[b>>2]>>0]=0;d=c[b+4>>2]|0;if(!d)return;Zb(c[b>>2]|0,d,1);return}function Te(b){b=b|0;var d=0,e=0,f=0,g=0;d=c[b>>2]|0;e=d+16|0;f=c[e>>2]|0;if(f|0?(a[f>>0]=0,g=c[d+20>>2]|0,g|0):0)Zb(c[e>>2]|0,g,1);f=d+28|0;Ga(c[f>>2]|0)|0;Zb(c[f>>2]|0,28,4);f=d+36|0;Ya(c[f>>2]|0)|0;Zb(c[f>>2]|0,48,4);f=(c[b>>2]|0)+4|0;g=c[f>>2]|0;c[f>>2]=g-1;if((g|0)!=1)return;Zb(d,48,8);return}function Ue(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=l;l=l+48|0;e=f+32|0;d=f+8|0;g=f;c[g>>2]=a;c[g+4>>2]=b;c[e>>2]=g;c[e+4>>2]=41;c[e+8>>2]=f+48;c[e+12>>2]=47;c[d>>2]=2624;c[d+4>>2]=2;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=e;c[d+20>>2]=2;aj(d,2640);}function Ve(b){b=b|0;var d=0,e=0,f=0,g=0;e=(c[b>>2]|0)+4|0;if(!(a[b+4>>0]|0)){d=fb[c[600]&7]()|0;if(!d)Ue(10081,57);if((c[d>>2]|0)==1){d=d+4|0;f=c[d>>2]|0;}else {f=fb[c[2404>>2]&7]()|0;g=d;c[g>>2]=1;c[g+4>>2]=f;d=d+4|0;}a[d>>0]=f;a[d+1>>0]=f>>8;a[d+2>>0]=f>>16;a[d+3>>0]=f>>24;if(f|0)a[e>>0]=1;}mk(c[c[b>>2]>>2]|0)|0;return}function We(a){a=a|0;var b=0;b=c[a+8>>2]|0;if(!b)return;Zb(c[a+4>>2]|0,b,1);return}function Xe(b){b=b|0;var d=0,e=0,f=0,g=0;e=(c[b>>2]|0)+4|0;if(!(a[b+4>>0]|0)){d=fb[c[600]&7]()|0;if(!d)Ue(10081,57);if((c[d>>2]|0)==1){d=d+4|0;f=c[d>>2]|0;}else {f=fb[c[2404>>2]&7]()|0;g=d;c[g>>2]=1;c[g+4>>2]=f;d=d+4|0;}a[d>>0]=f;a[d+1>>0]=f>>8;a[d+2>>0]=f>>16;a[d+3>>0]=f>>24;if(f|0)a[e>>0]=1;}mk(c[c[b>>2]>>2]|0)|0;return}function Ye(a){a=a|0;Ya(c[a>>2]|0)|0;Zb(c[a>>2]|0,48,4);return}function Ze(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=l;l=l+64|0;g=i+32|0;f=i+8|0;h=i+48|0;c[i>>2]=b;c[i+4>>2]=d;a[h>>0]=e;c[g>>2]=i;c[g+4>>2]=41;c[g+8>>2]=h;c[g+12>>2]=48;c[f>>2]=2624;c[f+4>>2]=2;c[f+8>>2]=5264;c[f+12>>2]=2;c[f+16>>2]=g;c[f+20>>2]=2;aj(f,2640);}function _e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=l;l=l+48|0;e=f+32|0;d=f+8|0;g=f;c[g>>2]=a;c[g+4>>2]=b;c[e>>2]=g;c[e+4>>2]=41;c[e+8>>2]=f+48;c[e+12>>2]=49;c[d>>2]=2624;c[d+4>>2]=2;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=e;c[d+20>>2]=2;aj(d,2640);}function $e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=l;l=l+48|0;e=f+32|0;d=f+8|0;g=f;c[g>>2]=a;c[g+4>>2]=b;c[e>>2]=g;c[e+4>>2]=41;c[e+8>>2]=f+48;c[e+12>>2]=50;c[d>>2]=2624;c[d+4>>2]=2;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=e;c[d+20>>2]=2;aj(d,2640);}function af(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=l;l=l+48|0;f=g+32|0;e=g+8|0;c[g>>2]=a;c[g+4>>2]=b;c[f>>2]=g;c[f+4>>2]=41;c[f+8>>2]=d;c[f+12>>2]=51;c[e>>2]=2624;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;n=0;_(9,e|0,2640);n=0;b=na()|0;We(d);za(b|0);}function bf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=l;l=l+48|0;f=g+32|0;e=g+8|0;c[g>>2]=a;c[g+4>>2]=b;c[f>>2]=g;c[f+4>>2]=41;c[f+8>>2]=d;c[f+12>>2]=37;c[e>>2]=2624;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;aj(e,2640);}function cf(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;j=l;l=l+64|0;i=j+40|0;h=j+16|0;g=j+8|0;c[j>>2]=b;c[j+4>>2]=d;c[g>>2]=e;a[g+4>>0]=f&1;c[i>>2]=j;c[i+4>>2]=41;c[i+8>>2]=g;c[i+12>>2]=52;c[h>>2]=2624;c[h+4>>2]=2;c[h+8>>2]=5264;c[h+12>>2]=2;c[h+16>>2]=i;c[h+20>>2]=2;n=0;_(9,h|0,2640);n=0;f=na()|0;Xe(g);za(f|0);}function df(a){a=a|0;return}function ef(a){a=a|0;return}function ff(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function gf(a){a=a|0;return}function hf(a){a=a|0;var b=0,e=0,f=0;if((d[a>>0]|0)<2)return;e=a+4|0;f=c[e>>2]|0;a=f+4|0;n=0;Z(c[c[a>>2]>>2]|0,c[f>>2]|0);b=n;n=0;if(b&1){b=na()|0;kf(c[f>>2]|0,c[a>>2]|0);lf(c[e>>2]|0);za(b|0);}a=c[a>>2]|0;b=c[a+4>>2]|0;if(b|0)Zb(c[f>>2]|0,b,c[a+8>>2]|0);Zb(c[e>>2]|0,12,4);return}function jf(b){b=b|0;if((a[b>>0]|0)==3)return;hf(b);return}function kf(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function lf(a){a=a|0;Zb(a,12,4);return}function mf(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0;k=l;l=l+16|0;m=k;j=k+8|0;c[j>>2]=0;if(d>>>0<128){a[j>>0]=d;e=1;}else {do if(d>>>0>=2048)if(d>>>0<65536){a[j>>0]=d>>>12&15|-32;f=63;g=1;h=-128;i=2;e=3;break}else {a[j>>0]=d>>>18&255|-16;a[j+1>>0]=d>>>12&63|-128;f=63;g=2;h=-128;i=3;e=4;break}else {f=31;g=0;h=-64;i=1;e=2;}while(0);a[j+g>>0]=f&d>>>6&255|h;a[j+i>>0]=d&63|-128;}qh(m,c[b>>2]|0,j,e);if((a[m>>0]|0)==3){m=0;l=k;return m|0}h=m;g=c[h>>2]|0;h=c[h+4>>2]|0;d=b+4|0;f=g&255;if((a[d>>0]|0)!=3?(n=0,Z(46,d|0),b=n,n=0,b&1):0){e=na()|0;k=d;c[k>>2]=g;c[k+4>>2]=h;if(f<<24>>24!=3)za(e|0);jf(m);za(e|0);}m=d;c[m>>2]=g;c[m+4>>2]=h;m=1;l=k;return m|0}function nf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=a;c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,2672,e)|0;l=d;return b|0}function of(a){a=a|0;var b=0;b=c[a+8>>2]|0;if(!b)return;Zb(c[a+4>>2]|0,b,1);return}function pf(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function qf(a){a=a|0;return}function rf(a,b){a=a|0;b=b|0;return sf(c[a>>2]|0,b)|0}function sf(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;h=l;l=l+32|0;g=h+8|0;e=h;f=h+20|0;switch(a[b>>0]&3){case 0:{f=b+4|0;ui(e,d,7824,2);b=Qi(e,7826,4,f,2760)|0;Qe(g,c[f>>2]|0);n=0;b=da(1,b|0,7830,7,g|0,2816)|0;f=n;n=0;if(f&1){h=na()|0;tf(g);za(h|0);}n=0;b=$(13,b|0)|0;f=n;n=0;if(f&1){h=na()|0;tf(g);za(h|0);}d=c[g+4>>2]|0;if(d|0)Zb(c[g>>2]|0,d,1);g=b;l=h;return g|0}case 1:{a[f>>0]=a[b+1>>0]|0;vi(g,d,7837,4);g=Ti(Si(g,f,2832)|0)|0;l=h;return g|0}case 2:{vi(g,d,7841,6);g=Ti(Si(g,b+4|0,2848)|0)|0;l=h;return g|0}default:{}}return 0}function tf(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function uf(a){a=a|0;var b=0,d=0,e=0;e=c[a>>2]|0;b=e+4|0;n=0;Z(c[c[b>>2]>>2]|0,c[e>>2]|0);d=n;n=0;if(d&1){d=na()|0;kf(c[e>>2]|0,c[b>>2]|0);lf(c[a>>2]|0);za(d|0);}d=c[b>>2]|0;b=c[d+4>>2]|0;if(!b){e=c[a>>2]|0;Zb(e,12,4);return}Zb(c[e>>2]|0,b,c[d+8>>2]|0);e=c[a>>2]|0;Zb(e,12,4);return}function vf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+16|0;f=d+8|0;e=d;a=c[a>>2]|0;ui(e,b,7841,6);c[f>>2]=a+8;Qi(e,7847,4,f,2864)|0;c[f>>2]=a;Qi(e,7851,5,f,2880)|0;b=Ri(e)|0;l=d;return b|0}function wf(a){a=a|0;return}function xf(a,b){a=a|0;b=b|0;a=c[a>>2]|0;return lb[c[(c[a+4>>2]|0)+28>>2]&127](c[a>>2]|0,b)|0}function yf(a){a=a|0;return}function zf(a,b){a=a|0;b=b|0;return Af(c[a>>2]|0,b)|0}function Af(b,c){b=b|0;c=c|0;var d=0,e=0;e=l;l=l+16|0;d=e;do switch(a[b>>0]&31){case 0:{vi(d,c,7856,8);d=Ti(d)|0;l=e;return d|0}case 1:{vi(d,c,7864,16);d=Ti(d)|0;l=e;return d|0}case 2:{vi(d,c,7880,17);d=Ti(d)|0;l=e;return d|0}case 3:{vi(d,c,7897,15);d=Ti(d)|0;l=e;return d|0}case 4:{vi(d,c,7912,17);d=Ti(d)|0;l=e;return d|0}case 5:{vi(d,c,7929,12);d=Ti(d)|0;l=e;return d|0}case 6:{vi(d,c,7941,9);d=Ti(d)|0;l=e;return d|0}case 7:{vi(d,c,7950,16);d=Ti(d)|0;l=e;return d|0}case 8:{vi(d,c,7966,10);d=Ti(d)|0;l=e;return d|0}case 9:{vi(d,c,7976,13);d=Ti(d)|0;l=e;return d|0}case 10:{vi(d,c,7989,10);d=Ti(d)|0;l=e;return d|0}case 11:{vi(d,c,7999,12);d=Ti(d)|0;l=e;return d|0}case 12:{vi(d,c,8011,11);d=Ti(d)|0;l=e;return d|0}case 13:{vi(d,c,8022,8);d=Ti(d)|0;l=e;return d|0}case 14:{vi(d,c,8030,9);d=Ti(d)|0;l=e;return d|0}case 15:{vi(d,c,8039,11);d=Ti(d)|0;l=e;return d|0}case 16:{vi(d,c,8050,5);d=Ti(d)|0;l=e;return d|0}case 17:{vi(d,c,8055,13);d=Ti(d)|0;l=e;return d|0}case 18:{vi(d,c,8068,15);d=Ti(d)|0;l=e;return d|0}default:{}}while(0);return 0}function Bf(a){a=a|0;return}function Cf(a,b){a=a|0;b=b|0;return yi(c[a>>2]|0,c[a+8>>2]|0,b)|0}function Df(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=l;l=l+32|0;g=k+12|0;h=k;f=d+8|0;n=0;aa(24,d|0,c[f>>2]|0,1);e=n;n=0;if(e&1){k=na()|0;pf(d);za(k|0);}e=c[f>>2]|0;do if((e|0)==(c[d+4>>2]|0)){n=0;Z(54,d|0);e=n;n=0;if(e&1){k=na()|0;pf(d);za(k|0);}else {e=c[f>>2]|0;break}}while(0);a[(c[d>>2]|0)+e>>0]=0;c[f>>2]=(c[f>>2]|0)+1;c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];d=c[h+8>>2]|0;f=h+4|0;e=c[f>>2]|0;if(e>>>0<d>>>0){n=0;Z(44,3692);n=0;k=na()|0;Eg(h);za(k|0);}do if(d){if((e|0)==(d|0)){i=c[h>>2]|0;j=d;c[b>>2]=i;b=b+4|0;c[b>>2]=j;l=k;return}e=_b(c[h>>2]|0,e,1,d,1,g)|0;if(!e){d=g+4|0;e=c[d>>2]|0;d=c[d+4>>2]|0;c[g>>2]=c[g>>2];h=g+4|0;c[h>>2]=e;c[h+4>>2]=d;Yb(g);}else {c[h>>2]=e;i=d;j=e;break}}else {if(e|0)Zb(c[h>>2]|0,e,1);c[h>>2]=1;i=0;j=1;}while(0);c[f>>2]=i;h=j;j=i;c[b>>2]=h;b=b+4|0;c[b>>2]=j;l=k;return}function Ef(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+48|0;e=j+24|0;f=j;g=j+12|0;n=0;aa(25,g|0,7684,33);i=n;n=0;if(i&1){j=na()|0;of(d);za(j|0);};c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];h=Xb(12,4,e)|0;if(!h)Yb(e);c[h>>2]=c[f>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];i=Xb(12,4,e)|0;if(!i)Yb(e);c[i>>2]=h;c[i+4>>2]=2728;a[i+8>>0]=11;h=i+9|0;a[h>>0]=a[f>>0]|0;a[h+1>>0]=a[f+1>>0]|0;a[h+2>>0]=a[f+2>>0]|0;a[b>>0]=2;h=b+1|0;a[h>>0]=a[g>>0]|0;a[h+1>>0]=a[g+1>>0]|0;a[h+2>>0]=a[g+2>>0]|0;c[b+4>>2]=i;b=c[d+8>>2]|0;if(!b){l=j;return}Zb(c[d+4>>2]|0,b,1);l=j;return}function Ff(a,b){a=a|0;b=b|0;var d=0;d=(Hj(b)|0)+1|0;c[a>>2]=b;c[a+4>>2]=d;return}function Gf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=c+-1|0;if(!c)kj(d,0);else {Fi(a,b,d);return}}function Hf(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;j=l;l=l+48|0;g=j+24|0;h=j;i=j+12|0;Nh(i,e,f);c[h>>2]=c[i>>2];c[h+4>>2]=c[i+4>>2];c[h+8>>2]=c[i+8>>2];e=Xb(12,4,g)|0;if(!e)Yb(g);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];c[e+8>>2]=c[h+8>>2];f=Xb(12,4,g)|0;if(!f)Yb(g);else {c[f>>2]=e;c[f+4>>2]=2728;a[f+8>>0]=d;g=f+9|0;a[g>>0]=a[h>>0]|0;a[g+1>>0]=a[h+1>>0]|0;a[g+2>>0]=a[h+2>>0]|0;a[b>>0]=2;h=b+1|0;a[h>>0]=a[i>>0]|0;a[h+1>>0]=a[i+1>>0]|0;a[h+2>>0]=a[i+2>>0]|0;c[b+4>>2]=f;l=j;return}}function If(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=l;l=l+80|0;e=k+56|0;h=k+32|0;j=k+8|0;i=k;switch(a[b>>0]&3){case 0:{b=c[b+4>>2]|0;c[i>>2]=b;Qe(j,b);c[e>>2]=j;c[e+4>>2]=53;c[e+8>>2]=i;c[e+12>>2]=54;c[h>>2]=2896;c[h+4>>2]=3;c[h+8>>2]=5264;c[h+12>>2]=2;c[h+16>>2]=e;c[h+20>>2]=2;n=0;b=ca(55,d|0,h|0)|0;i=n;n=0;if(i&1){k=na()|0;tf(j);za(k|0);}d=c[j+4>>2]|0;if(d|0)Zb(c[j>>2]|0,d,1);j=b;l=k;return j|0}case 1:{do switch(a[b+1>>0]&31){case 0:{f=8123;g=16;break}case 1:{f=8403;g=17;break}case 2:{f=8139;g=18;break}case 3:{f=8157;g=16;break}case 4:{f=8173;g=18;break}case 5:{f=8191;g=13;break}case 6:{f=8204;g=14;break}case 7:{f=8218;g=21;break}case 8:{f=8239;g=11;break}case 9:{f=8250;g=21;break}case 10:{f=8271;g=21;break}case 11:{f=8292;g=23;break}case 12:{f=8315;g=12;break}case 13:{f=8327;g=9;break}case 14:{f=8336;g=10;break}case 15:{f=8346;g=21;break}case 16:{f=8367;g=14;break}case 17:{f=8381;g=22;break}case 18:{ve(8083,40,2920);break}default:{}}while(0);c[e>>2]=f;c[e+4>>2]=g;c[h>>2]=e;c[h+4>>2]=41;c[j>>2]=2936;c[j+4>>2]=1;c[j+8>>2]=5180;c[j+12>>2]=1;c[j+16>>2]=h;c[j+20>>2]=1;j=si(d,j)|0;l=k;return j|0}case 2:{j=c[b+4>>2]|0;j=lb[c[(c[j+4>>2]|0)+24>>2]&127](c[j>>2]|0,d)|0;l=k;return j|0}default:{}}return 0}function Jf(a,b){a=a|0;b=b|0;return zi(c[a>>2]|0,c[a+8>>2]|0,b)|0}function Kf(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=l;l=l+16|0;i=h;qh(i,c[b>>2]|0,d,e);if((a[i>>0]|0)==3){i=0;l=h;return i|0}g=i;f=c[g>>2]|0;g=c[g+4>>2]|0;e=b+4|0;b=f&255;if((a[e>>0]|0)!=3?(n=0,Z(46,e|0),d=n,n=0,d&1):0){d=na()|0;h=e;c[h>>2]=f;c[h+4>>2]=g;if(b<<24>>24!=3)za(d|0);jf(i);za(d|0);}i=e;c[i>>2]=f;c[i+4>>2]=g;i=1;l=h;return i|0}function Lf(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;J=l;l=l+112|0;f=J+16|0;g=J;E=J+64|0;F=J+40|0;G=J+32|0;H=J+24|0;if(ri(e,3612,1)|0){I=1;l=J;return I|0}Wh(g,b,d);Xh(f,c[g>>2]|0,c[g+4>>2]|0);b=c[f+4>>2]|0;c[H>>2]=c[f>>2];c[H+4>>2]=b;Yh(E,H);b=c[E>>2]|0;a:do if(b|0){o=E+4|0;p=E+8|0;q=E+12|0;r=E+8|0;s=E+4|0;t=E+8|0;u=E+24|0;v=E+4|0;w=F+4|0;x=F+8|0;y=F+12|0;z=F+16|0;A=F+20|0;B=E+12|0;C=E+16|0;b:while(1){m=c[p>>2]|0;n=c[q>>2]|0;k=b+(c[o>>2]|0)|0;c[E>>2]=b;c[s>>2]=k;c[t>>2]=4;c[u>>2]=4;b=4;while(1){c:while(1){if((b|0)!=4?(D=jj(r)|0,(D|0)!=1114112):0){b=D;break}b=c[E>>2]|0;i=c[s>>2]|0;if((b|0)==(i|0)){I=29;break}d=b+1|0;c[E>>2]=d;j=a[b>>0]|0;if(j<<24>>24<=-1){k=j&31;if((d|0)==(i|0)){b=0;f=i;}else {f=b+2|0;c[E>>2]=f;b=a[d>>0]&63;}g=b&255;d=g|k<<6;if((j&255)>223){if((f|0)==(i|0)){b=0;h=i;}else {h=f+1|0;c[E>>2]=h;b=a[f>>0]&63;}f=b&255|g<<6;d=f|k<<12;if((j&255)>239){if((h|0)==(i|0))b=0;else {c[E>>2]=h+1;b=a[h>>0]&63;}d=f<<6|k<<18&1835008|b&255;}}}else d=j&255;d:do if((d|0)<34)switch(d|0){case 9:{f=0;b=2;g=116;d=0;break d}case 13:{f=0;b=2;g=114;d=0;break d}case 10:{f=0;b=2;g=110;d=0;break d}default:{I=28;break d}}else {e:do if((d|0)>=92)if((d|0)<1114112)switch(d|0){case 92:break e;default:{I=28;break d}}else switch(d|0){case 1114112:{I=29;break c}default:{I=28;break d}}else switch(d|0){case 34:case 39:break;default:{I=28;break d}}while(0);f=0;b=2;g=d;d=0;}while(0);if((I|0)==28){I=0;if(pj(d)|0){f=0;b=1;g=d;d=0;}else {f=5;b=3;g=d;d=(Q(d|1|0)|0)>>>2^7;}}c[t>>2]=b;c[B>>2]=g;k=C;c[k>>2]=d;c[k+4>>2]=f;}if((I|0)==29){I=0;if((c[u>>2]|0)==4)break;b=jj(u)|0;if((b|0)==1114112)break}if(xi(e,b)|0){I=36;break b}b=c[r>>2]|0;}d=m+n|0;if(n|0){b=m;do{c[G>>2]=b;c[E>>2]=G;c[v>>2]=56;c[F>>2]=2944;c[w>>2]=1;c[x>>2]=2952;c[y>>2]=1;c[z>>2]=E;c[A>>2]=1;if(si(e,F)|0){I=40;break b}b=b+1|0;}while((b|0)!=(d|0))}Yh(E,H);b=c[E>>2]|0;if(!b)break a}I=1;l=J;return I|0}while(0);I=ri(e,3612,1)|0;l=J;return I|0}function Mf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+16|0;f=d+12|0;e=d;vi(e,b,8465,8);c[f>>2]=a;Si(e,f,2988)|0;c[f>>2]=a+4;Si(e,f,3004)|0;b=Ti(e)|0;l=d;return b|0}function Nf(a){a=a|0;return}function Of(a){a=a|0;return}function Pf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+16|0;f=d+8|0;e=d;ui(e,b,7815,5);c[f>>2]=a;Qi(e,7820,4,f,2800)|0;b=Ri(e)|0;l=d;return b|0}function Qf(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0;k=l;l=l+80|0;b=k+56|0;d=k+32|0;e=k+24|0;f=k+20|0;g=k+16|0;h=k+12|0;i=k+8|0;n=k+4|0;j=k;m=Ia(j|0)|0;c[n>>2]=m;c[f>>2]=n;c[e>>2]=15856;if(m|0){c[b>>2]=f;c[b+4>>2]=57;c[b+8>>2]=e;c[b+12>>2]=57;c[d>>2]=2776;c[d+4>>2]=3;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=b;c[d+20>>2]=2;we(d,3020);}n=Ba(j|0,1)|0;c[i>>2]=n;c[f>>2]=i;c[e>>2]=15856;if(n|0){c[b>>2]=f;c[b+4>>2]=57;c[b+8>>2]=e;c[b+12>>2]=57;c[d>>2]=2776;c[d+4>>2]=3;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=b;c[d+20>>2]=2;we(d,3036);}n=qa(a|0,j|0)|0;c[h>>2]=n;c[f>>2]=h;c[e>>2]=15856;if(n|0){c[b>>2]=f;c[b+4>>2]=57;c[b+8>>2]=e;c[b+12>>2]=57;c[d>>2]=2776;c[d+4>>2]=3;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=b;c[d+20>>2]=2;we(d,3052);}n=La(j|0)|0;c[g>>2]=n;c[f>>2]=g;c[e>>2]=15856;if(!n){l=k;return}else {c[b>>2]=f;c[b+4>>2]=57;c[b+8>>2]=e;c[b+12>>2]=57;c[d>>2]=2776;c[d+4>>2]=3;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=b;c[d+20>>2]=2;we(d,3068);}}function Rf(a){a=a|0;return}function Sf(b,d){b=b|0;d=d|0;b=c[b>>2]|0;d=a[b>>0]|0;a[b>>0]=0;if(!(d<<24>>24))$i(3104);ik(15864)|0;n=0;Z(55,15860);d=n;n=0;if(d&1){d=na()|0;c[3965]=0;za(d|0);}else {c[3965]=0;mk(15864)|0;Zg();return}}function Tf(b,d){b=b|0;d=d|0;d=a[b>>0]|0;a[b>>0]=0;if(!(d<<24>>24))$i(3104);ik(15864)|0;n=0;Z(55,15860);d=n;n=0;if(d&1){d=na()|0;c[3965]=0;za(d|0);}else {c[3965]=0;mk(15864)|0;Zg();return}}function Uf(a){a=a|0;var b=0,e=0,f=0;if((d[a>>0]|0)<2)return;e=a+4|0;f=c[e>>2]|0;a=f+4|0;n=0;Z(c[c[a>>2]>>2]|0,c[f>>2]|0);b=n;n=0;if(b&1){b=na()|0;Vf(c[f>>2]|0,c[a>>2]|0);Wf(c[e>>2]|0);za(b|0);}a=c[a>>2]|0;b=c[a+4>>2]|0;if(b|0)Zb(c[f>>2]|0,b,c[a+8>>2]|0);Zb(c[e>>2]|0,12,4);return}function Vf(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Wf(a){a=a|0;Zb(a,12,4);return}function Xf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;i=l;l=l+80|0;e=i+56|0;f=i+32|0;g=i;j=i+16|0;h=i+8|0;c[h>>2]=b;c[h+4>>2]=d;Re(j,b,d);b=j+4|0;if((c[j>>2]|0)==1){a=b;i=c[a+4>>2]|0;j=g;c[j>>2]=c[a>>2];c[j+4>>2]=i;c[e>>2]=h;c[e+4>>2]=58;c[e+8>>2]=g;c[e+12>>2]=59;c[f>>2]=3152;c[f+4>>2]=2;c[f+8>>2]=5264;c[f+12>>2]=2;c[f+16>>2]=e;c[f+20>>2]=2;n=0;_(26,f|0,3168);n=0;j=na()|0;Uf(g);za(j|0);}else {c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];l=i;return}}function Yf(a,b){a=a|0;b=b|0;c[a>>2]=0;return}function Zf(a){a=a|0;y=1536465966;return -1196322623}function _f(a,b){a=a|0;b=b|0;var d=0;d=c[b+8>>2]|0;c[a>>2]=c[b>>2];c[a+4>>2]=d;return}function $f(a,b){a=a|0;b=b|0;return zi(c[a>>2]|0,c[a+8>>2]|0,b)|0}function ag(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0;q=l;l=l+32|0;p=q+16|0;j=q;k=j+8|0;m=j+4|0;i=j|2;h=c[b>>2]|0;a:while(1){switch(h|0){case 3:{o=8;break a}case 1:{if(!d){o=4;break a}break}case 0:break;default:{if((h&3|0)!=2){o=11;break a}g=ph(3804)|0;c[p>>2]=g;if(!g){o=13;break a}c[j>>2]=g;a[k>>0]=0;c[m>>2]=0;while(1){if((h&3|0)!=2){o=16;break}c[m>>2]=h&-4;g=c[b>>2]|0;if((g|0)==(h|0))c[b>>2]=i;if((g|0)==(h|0))break;else h=g;}if((o|0)==16){o=0;g=c[j>>2]|0;if(g|0?(r=c[g>>2]|0,c[g>>2]=r-1,(r|0)==1):0)Te(j);continue a}while(1){if(a[k>>0]|0)break;n=0;ba(2);r=n;n=0;if(r&1){o=27;break a}}g=c[b>>2]|0;h=c[j>>2]|0;if(h|0?(r=c[h>>2]|0,c[h>>2]=r-1,(r|0)==1):0)Te(j);h=g;continue a}}g=c[b>>2]|0;if((g|0)==(h|0))c[b>>2]=2;if((g|0)==(h|0)){o=9;break}else h=g;}if((o|0)==4)ve(8671,42,3184);else if((o|0)==8){l=q;return}else if((o|0)==9){g=p+4|0;a[g>>0]=1;c[p>>2]=b;n=0;_(c[f+12>>2]|0,e|0,(h|0)==1|0);r=n;n=0;if(r&1){r=na()|0;dg(p);za(r|0);}else {a[g>>0]=0;bg(p);l=q;return}}else if((o|0)==11)ve(8713,47,3200);else if((o|0)==13){n=0;_(21,8847,94);n=0;r=na()|0;lg(p);za(r|0);}else if((o|0)==27){r=na()|0;cg(j);za(r|0);}}function bg(b){b=b|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0;j=l;l=l+64|0;h=j+40|0;i=j+16|0;f=j+8|0;g=j+4|0;k=j;m=c[b>>2]|0;e=c[m>>2]|0;c[m>>2]=(a[b+4>>0]|0)==0?3:1;b=e&3;c[k>>2]=b;c[g>>2]=k;c[f>>2]=3216;if((b|0)!=2){c[h>>2]=g;c[h+4>>2]=16;c[h+8>>2]=f;c[h+12>>2]=16;c[i>>2]=3128;c[i+4>>2]=3;c[i+8>>2]=5264;c[i+12>>2]=2;c[i+16>>2]=h;c[i+20>>2]=2;we(i,3220);}b=e&-4;if(!b){l=j;return}while(1){e=b;b=c[b+4>>2]|0;f=d[e>>0]|d[e+1>>0]<<8|d[e+2>>0]<<16|d[e+3>>0]<<24;a[e>>0]=0;a[e+1>>0]=0;a[e+2>>0]=0;a[e+3>>0]=0;c[h>>2]=f;if(!f){b=7;break}c[i>>2]=f;a[e+8>>0]=1;n=0;Z(56,i|0);m=n;n=0;if(m&1){b=12;break}k=c[i>>2]|0;m=c[k>>2]|0;c[k>>2]=m-1;if((m|0)==1)Te(i);if(!b){b=5;break}}if((b|0)==5){l=j;return}else if((b|0)==7){n=0;Z(44,3104);n=0;m=na()|0;eg(h);za(m|0);}else if((b|0)==12){m=na()|0;fg(i);za(m|0);}}function cg(a){a=a|0;var b=0,d=0;b=c[a>>2]|0;if(!b)return;d=c[b>>2]|0;c[b>>2]=d-1;if((d|0)!=1)return;Te(a);return}function dg(a){a=a|0;bg(a);return}function eg(a){a=a|0;var b=0,d=0;b=c[a>>2]|0;if(!b)return;d=c[b>>2]|0;c[b>>2]=d-1;if((d|0)!=1)return;Te(a);return}function fg(a){a=a|0;var b=0,d=0;d=c[a>>2]|0;b=c[d>>2]|0;c[d>>2]=b-1;if((b|0)!=1)return;Te(a);return}function gg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+16|0;f=d+12|0;e=d;vi(e,b,8793,11);c[f>>2]=a;Si(e,f,3236)|0;b=Ti(e)|0;l=d;return b|0}function hg(a){a=a|0;return}function ig(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function jg(a){a=a|0;Zb(a,12,4);return}function kg(b){b=b|0;var d=0,e=0,f=0,g=0;e=(c[b>>2]|0)+4|0;if(!(a[b+4>>0]|0)){d=fb[c[600]&7]()|0;if(!d)Ue(10081,57);if((c[d>>2]|0)==1){d=d+4|0;f=c[d>>2]|0;}else {f=fb[c[2404>>2]&7]()|0;g=d;c[g>>2]=1;c[g+4>>2]=f;d=d+4|0;}a[d>>0]=f;a[d+1>>0]=f>>8;a[d+2>>0]=f>>16;a[d+3>>0]=f>>24;if(f|0)a[e>>0]=1;}mk(c[c[b>>2]>>2]|0)|0;return}function lg(a){a=a|0;var b=0,d=0;b=c[a>>2]|0;if(!b)return;d=c[b>>2]|0;c[b>>2]=d-1;if((d|0)!=1)return;Te(a);return}function mg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=c[b>>2]|0;f=c[b+4>>2]|0;g=0-f|0;b=e+((e+-1+f&g)-e)|0;if(b>>>0<e>>>0){c[a>>2]=0;return}e=N(b,d)|0;h=(d|0)==0;if(h?0:((e>>>0)/((h?1:d)>>>0)|0|0)!=(b|0)){c[a>>2]=0;return}if((f+-1&(f|-2147483648)|0)!=0|e>>>0>g>>>0)$i(3300);c[a>>2]=1;c[a+4>>2]=e;c[a+8>>2]=f;c[a+12>>2]=b;return}function ng(){var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0;m=l;l=l+32|0;k=m+16|0;j=m+8|0;o=m;b=ph(3804)|0;c[k>>2]=b;if(!b){n=0;_(21,8847,94);n=0;o=na()|0;lg(k);za(o|0);}c[o>>2]=b;d=b+24|0;b=c[d>>2]|0;if((b|0)==2)c[d>>2]=0;a:do if((b|0)!=2){f=c[o>>2]|0;e=f+28|0;ik(c[e>>2]|0)|0;f=f+32|0;n=0;d=Y(c[600]|0)|0;i=n;n=0;do if(!(i&1)){if(!d){n=0;_(22,10081,57);n=0;break}if((c[d>>2]|0)==1){d=d+4|0;b=c[d>>2]|0;}else {n=0;b=Y(c[601]|0)|0;i=n;n=0;if(i&1)break;i=d;c[i>>2]=1;c[i+4>>2]=b;d=d+4|0;}a[d>>0]=b;a[d+1>>0]=b>>8;a[d+2>>0]=b>>16;a[d+3>>0]=b>>24;d=(b|0)!=0;if(a[f>>0]|0){n=0;ea(7,8804,43,e|0,d|0);n=0;break}c[j>>2]=e;b=j+4|0;a[b>>0]=d&1;d=(c[o>>2]|0)+24|0;e=c[d>>2]|0;if(!e)c[d>>2]=1;b:do if(!e){i=k+4|0;while(1){d=c[o>>2]|0;e=c[j>>2]|0;f=a[b>>0]|0;c[k>>2]=e;a[i>>0]=f;e=c[e>>2]|0;f=e;g=d+40|0;h=c[g>>2]|0;if(!h)c[g>>2]=f;if(!((h|0)==0|(h|0)==(f|0))){d=34;break}fa(c[d+36>>2]|0,e|0)|0;e=c[k>>2]|0;f=a[i>>0]|0;if(a[e+4>>0]|0){d=36;break}c[j>>2]=e;a[b>>0]=f;d=(c[o>>2]|0)+24|0;e=c[d>>2]|0;if((e|0)==2)c[d>>2]=0;if((e|0)==2)break b}if((d|0)==34){n=0;aa(21,7600,54,2656);n=0;b=na()|0;n=0;Z(57,k|0);m=n;n=0;if(m&1)d=39;}else if((d|0)==36){n=0;ea(7,8804,43,e|0,f<<24>>24!=0|0);n=0;d=39;}if((d|0)==39)b=na()|0;m=b;og(o);za(m|0);}else {if((e|0)==2)break;n=0;aa(21,9180,23,3324);n=0;m=na()|0;kg(j);og(o);za(m|0);}while(0);e=c[j>>2]|0;f=e+4|0;if(!(a[b>>0]|0)){n=0;d=Y(c[600]|0)|0;k=n;n=0;if(k&1)break;if(!d){n=0;_(22,10081,57);n=0;break}if((c[d>>2]|0)==1){d=d+4|0;b=c[d>>2]|0;}else {n=0;b=Y(c[601]|0)|0;k=n;n=0;if(k&1)break;k=d;c[k>>2]=1;c[k+4>>2]=b;d=d+4|0;}a[d>>0]=b;a[d+1>>0]=b>>8;a[d+2>>0]=b>>16;a[d+3>>0]=b>>24;if(b|0)a[f>>0]=1;}mk(c[e>>2]|0)|0;break a}while(0);m=na()|0;og(o);za(m|0);}while(0);j=c[o>>2]|0;k=c[j>>2]|0;c[j>>2]=k-1;if((k|0)!=1){l=m;return};Te(o);l=m;return}function og(a){a=a|0;var b=0,d=0;d=c[a>>2]|0;b=c[d>>2]|0;c[d>>2]=b-1;if((b|0)!=1)return;Te(a);return}function pg(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0;k=l;l=l+64|0;d=k;j=k+40|0;m=k+28|0;o=k+16|0;p=k+8|0;c[o>>2]=c[a>>2];c[o+4>>2]=c[a+4>>2];c[o+8>>2]=c[a+8>>2];do if(c[o>>2]|0){c[j>>2]=c[o>>2];c[j+4>>2]=c[o+4>>2];c[j+8>>2]=c[o+8>>2];Sh(m,j);b=c[m>>2]|0;a=Lj(b,0,c[m+8>>2]|0)|0;if(!a){c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];c[j+8>>2]=c[m+8>>2];Df(d,j);e=c[d>>2]|0;f=c[d+4>>2]|0;break}else {h=m+4|0;g=c[h>>2]|0;h=c[h+4>>2]|0;c[j>>2]=a-b;c[j+4>>2]=b;i=j+8|0;c[i>>2]=g;c[i+4>>2]=h;af(9203,47,j);}}else {e=0;f=0;}while(0);c[p>>2]=e;c[p+4>>2]=f;ik(15736)|0;h=15600;g=c[h>>2]|0;h=c[h+4>>2]|0;if(!((g|0)==-1&(h|0)==-1)){f=gk(g|0,h|0,1,0)|0;i=15600;c[i>>2]=f;c[i+4>>2]=y;mk(15736)|0;n=0;Z(58,o|0);i=n;n=0;if(!(i&1)){i=Xb(48,4,j)|0;if(!i)Yb(j);a=i;b=15684;d=a+48|0;do{c[a>>2]=c[b>>2];a=a+4|0;b=b+4|0;}while((a|0)<(d|0));c[m>>2]=i;c[m+4>>2]=0;n=0;Z(60,i|0);f=n;n=0;if(!(f&1)){b=p;a=c[b>>2]|0;b=c[b+4>>2]|0;e=o;d=c[e>>2]|0;e=c[e+4>>2]|0;f=Xb(48,8,j)|0;if(!f)Yb(j);else {c[f>>2]=1;c[f+4>>2]=1;p=f+8|0;c[p>>2]=g;c[p+4>>2]=h;p=f+16|0;c[p>>2]=a;c[p+4>>2]=b;c[f+24>>2]=0;p=f+28|0;c[p>>2]=d;c[p+4>>2]=e;c[f+36>>2]=i;c[f+40>>2]=0;l=k;return f|0}}a=na()|0;n=0;Z(59,m|0);m=n;n=0;if(m&1)a=na()|0;rg(o);o=a;qg(p);za(o|0);}}else {mk(15736)|0;n=0;aa(21,9250,55,3340);n=0;}o=na()|0;qg(p);za(o|0);return 0}function qg(b){b=b|0;var d=0;d=c[b>>2]|0;if(!d)return;a[d>>0]=0;d=c[b+4>>2]|0;if(!d)return;Zb(c[b>>2]|0,d,1);return}function rg(a){a=a|0;Ga(c[a>>2]|0)|0;Zb(c[a>>2]|0,28,4);return}function sg(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0;o=l;l=l+16|0;j=o;d=(c[b>>2]|0)+24|0;e=c[d>>2]|0;if(!e)c[d>>2]=2;if(!e){l=o;return}m=j+4|0;h=c[600]|0;i=c[601]|0;d=e;a:while(1){switch(d|0){case 2:{k=12;break a}case 1:break;default:{k=10;break a}}f=c[b>>2]|0;g=f+28|0;ik(c[g>>2]|0)|0;d=fb[h&7]()|0;if(!d){k=7;break}if((c[d>>2]|0)==1){d=d+4|0;e=c[d>>2]|0;}else {e=fb[i&7]()|0;p=d;c[p>>2]=1;c[p+4>>2]=e;d=d+4|0;}a[d>>0]=e;a[d+1>>0]=e>>8;a[d+2>>0]=e>>16;a[d+3>>0]=e>>24;d=(e|0)!=0;if(a[f+32>>0]|0){k=9;break}c[j>>2]=g;a[m>>0]=d&1;d=f+24|0;e=c[d>>2]|0;if((e|0)==1)c[d>>2]=2;if((e|0)==1){k=25;break}switch(e|0){case 2:break a;case 0:break;default:{k=23;break a}}e=c[j>>2]|0;f=e+4|0;if(!(a[m>>0]|0)){d=fb[h&7]()|0;if(!d){k=19;break}if((c[d>>2]|0)==1){d=d+4|0;g=c[d>>2]|0;}else {g=fb[i&7]()|0;p=d;c[p>>2]=1;c[p+4>>2]=g;d=d+4|0;}a[d>>0]=g;a[d+1>>0]=g>>8;a[d+2>>0]=g>>16;a[d+3>>0]=g>>24;if(g|0)a[f>>0]=1;}mk(c[e>>2]|0)|0;e=(c[b>>2]|0)+24|0;d=c[e>>2]|0;if(!d)c[e>>2]=2;if(!d){k=12;break}}if((k|0)==7)Ue(10081,57);else if((k|0)==9)cf(8804,43,g,d);else if((k|0)==10)ve(8975,28,3252);else if((k|0)==12){l=o;return}else if((k|0)==19)Ue(10081,57);else if((k|0)==23){n=0;aa(21,8975,28,3268);n=0;p=na()|0;kg(j);za(p|0);}else if((k|0)==25)Fa(c[(c[b>>2]|0)+36>>2]|0)|0;f=c[j>>2]|0;g=f+4|0;if(!(a[m>>0]|0)){d=fb[c[600]&7]()|0;if(!d)Ue(10081,57);if((c[d>>2]|0)==1){d=d+4|0;e=c[d>>2]|0;}else {e=fb[c[2404>>2]&7]()|0;p=d;c[p>>2]=1;c[p+4>>2]=e;d=d+4|0;}a[d>>0]=e;a[d+1>>0]=e>>8;a[d+2>>0]=e>>16;a[d+3>>0]=e>>24;if(e|0)a[g>>0]=1;}mk(c[f>>2]|0)|0;l=o;return}function tg(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;x=l;l=l+864|0;s=x+849|0;t=x+824|0;u=x;v=x+820|0;w=x+816|0;p=x+16|0;q=x+848|0;r=x+8|0;ik(15764)|0;c[r>>2]=d;n=r+4|0;c[n>>2]=e;a[q>>0]=f;hk(p|0,0,800)|0;Ud(t,p,100);d=t+4|0;o=c[d>>2]|0;a:do if((c[t>>2]|0)==1){e=kk(o|0,c[d+4>>2]|0,8)|0;f=y;d=o&255;}else {if(o>>>0>100)kj(o,100);c[v>>2]=s;if(f<<24>>24!=2){m=p+(o<<3)|0;h=m;c[u>>2]=v;i=t+4|0;j=t+4|0;k=t+4|0;g=t+4|0;f=p;d=0;while(1){e=f;if(((h-f|0)/8|0)>>>0<=3){h=21;break}ug(t,u,d,e);d=c[i>>2]|0;if((c[t>>2]|0)==1){h=29;break}ug(t,u,d,e+8|0);d=c[j>>2]|0;if((c[t>>2]|0)==1){h=29;break}ug(t,u,d,e+16|0);d=c[k>>2]|0;if((c[t>>2]|0)==1){h=29;break}ug(t,u,d,e+24|0);d=c[g>>2]|0;if((c[t>>2]|0)==1){h=29;break}else f=e+32|0;}b:do if((h|0)==21){f=t+4|0;if((e|0)!=(m|0))do{ug(t,u,d,e);e=e+8|0;d=c[f>>2]|0;if((c[t>>2]|0)==1){h=29;break b}}while((e|0)!=(m|0));d=o;}while(0);e=o-d|0;if(e>>>0<o>>>0)if(e){f=c[r>>2]|0;g=c[n>>2]|0;c[t>>2]=3356;c[t+4>>2]=1;c[t+8>>2]=0;c[t+16>>2]=15892;c[t+20>>2]=0;jb[c[g+24>>2]&31](u,f,t);f=u;g=c[f>>2]|0;d=g&255;if(d<<24>>24==3)g=e;else {e=kk(g|0,c[f+4>>2]|0,8)|0;f=y;break}}else g=0;else h=31;}else h=31;if((h|0)==31)g=0;e=c[r>>2]|0;f=c[n>>2]|0;c[t>>2]=3364;c[t+4>>2]=1;c[t+8>>2]=0;c[t+16>>2]=15892;c[t+20>>2]=0;jb[c[f+24>>2]&31](u,e,t);e=u;f=c[e>>2]|0;d=f&255;if(d<<24>>24!=3){e=kk(f|0,c[e+4>>2]|0,8)|0;f=y;break}d=o-g|0;if(d>>>0>100)kj(d,100);i=p+(d<<3)|0;j=t+4|0;k=t+8|0;m=t+12|0;c:do if(d|0){e=p;h=0;g=p;while(1){c[w>>2]=h;c[v>>2]=e;d=c[e>>2]|0;f=c[e+4>>2]|0;c[t>>2]=r;c[j>>2]=w;c[k>>2]=v;c[m>>2]=q;Wd(u,d,f,t,s);f=u;e=c[f>>2]|0;f=c[f+4>>2]|0;d=e&255;if(d<<24>>24!=3)break;d=g+8|0;if((d|0)==(i|0))break c;else {e=d;h=h+1|0;g=d;}}e=kk(e|0,f|0,8)|0;f=y;break a}while(0);v=0;w=0;u=3;mk(15764)|0;v=v&16777215;v=nk(w|0,v|0,8)|0;w=y;u=u&255;u=v|u;v=b;c[v>>2]=u;b=b+4|0;c[b>>2]=w;l=x;return}while(0);v=f;w=e;u=d;mk(15764)|0;v=v&16777215;v=nk(w|0,v|0,8)|0;w=y;u=u&255;u=v|u;v=b;c[v>>2]=u;b=b+4|0;c[b>>2]=w;l=x;return}function ug(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;i=l;l=l+16|0;g=i;h=i+8|0;a[h>>0]=0;Xd(g,c[f>>2]|0,c[f+4>>2]|0,h,c[c[d>>2]>>2]|0);switch(a[g>>0]&3){case 0:case 1:case 3:{g=a[h>>0]|0;h=g&255;g=g^1;g=g&255;e=g+e|0;c[b>>2]=h;h=b+4|0;c[h>>2]=e;l=i;return}default:{}}g=c[g+4>>2]|0;d=g+4|0;n=0;Z(c[c[d>>2]>>2]|0,c[g>>2]|0);f=n;n=0;if(f&1){i=na()|0;ig(c[g>>2]|0,c[d>>2]|0);jg(g);za(i|0);}d=c[d>>2]|0;f=c[d+4>>2]|0;if(f|0)Zb(c[g>>2]|0,f,c[d+8>>2]|0);Zb(g,12,4);g=a[h>>0]|0;h=g&255;g=g^1;g=g&255;e=g+e|0;c[b>>2]=h;h=b+4|0;c[h>>2]=e;l=i;return}function vg(a,b){a=a|0;b=b|0;return ib[c[b+12>>2]&15](a)|0}function wg(){var b=0,d=0,e=0,f=0;f=l;l=l+32|0;d=f+12|0;b=f;switch(c[3933]|0){case 0:{Xf(b,9087,14);if(!(c[b>>2]|0)){d=1;b=4;}else {c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];e=c[d>>2]|0;a:do switch(c[d+8>>2]|0){case 1:{if((e|0)==9101)b=4;else b=(a[e>>0]|0)==48?4:3;break}case 4:{if((e|0)!=9102?Xj(e,9102,4)|0:0){b=3;break a}b=2;break}default:b=3;}while(0);d=c[d+4>>2]|0;if(d|0)Zb(e,d,1);d=b<<24>>24==4?1:b&255;}c[3933]=d;e=b;l=f;return e|0}case 2:{e=2;l=f;return e|0}case 3:{e=3;l=f;return e|0}case 1:{e=4;l=f;return e|0}default:ve(9047,40,3284);}return 0}
  function xg(b,d,e,f,g,h,i,j){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;H=l;l=l+160|0;o=H;F=H+96|0;A=H+120|0;z=H+8|0;m=H+152|0;n=H+144|0;c[n>>2]=f;c[m>>2]=g;c[m+4>>2]=h;w=j<<24>>24==3;do if(w){if(!g){a[b>>0]=3;l=H;return}c[F>>2]=n;c[F+4>>2]=39;c[A>>2]=3472;c[A+4>>2]=2;c[A+8>>2]=3488;c[A+12>>2]=1;c[A+16>>2]=F;c[A+20>>2]=1;jb[c[e+24>>2]&31](z,d,A);h=z;f=c[h>>2]|0;h=c[h+4>>2]|0;if((f&255)<<24>>24==3)break;c[b>>2]=f;c[b+4>>2]=h;l=H;return}else {mi(o,3372);f=c[o>>2]|0;h=c[o+4>>2]|0;c[F>>2]=n;c[F+4>>2]=39;c[F+8>>2]=m;c[F+12>>2]=60;c[F+16>>2]=f;c[F+20>>2]=h;c[A>>2]=3376;c[A+4>>2]=3;c[A+8>>2]=3400;c[A+12>>2]=2;c[A+16>>2]=F;c[A+20>>2]=3;jb[c[e+24>>2]&31](z,d,A);h=z;f=c[h>>2]|0;h=c[h+4>>2]|0;if((f&255)<<24>>24==3)break;c[b>>2]=f;c[b+4>>2]=h;l=H;return}while(0);u=c[i>>2]|0;do if(!u){k=c[e+20>>2]|0;nb[k&15](F,d,3524,9);h=F;f=c[h>>2]|0;h=c[h+4>>2]|0;if((f&255)<<24>>24!=3){c[b>>2]=f;c[b+4>>2]=h;l=H;return}}else {i=c[i+4>>2]|0;sh(F,u,i,9410,6);a:do if((c[F>>2]|0)==1){q=c[F+4>>2]|0;f=q+6|0;if(!((f|0)==0|(i|0)==(f|0))){if(i>>>0<=f>>>0)Ii(u,i,f,i);h=u+f|0;if((a[h>>0]|0)>-65)p=h;else Ii(u,i,f,i);}else p=u+f|0;o=u+f+(i-f)|0;f=p;while(1){t=(f|0)==(o|0);h=t?f:f+1|0;if(t|(f|0)==0)break;n=a[f>>0]|0;if(n<<24>>24<=-1){g=n&31;if((h|0)==(o|0)){f=0;h=o;}else {f=a[h>>0]&63;h=h+1|0;}j=f&255;f=j|g<<6;if((n&255)>223){if((h|0)==(o|0)){f=0;m=o;}else {f=a[h>>0]&63;m=h+1|0;}j=f&255|j<<6;f=j|g<<12;if((n&255)>239){if((m|0)==(o|0)){h=o;f=0;}else {h=m+1|0;f=a[m>>0]&63;}f=j<<6|g<<18&1835008|f&255;if((f|0)==1114112)break}else h=m;}}else f=n&255;if((f+-48|0)>>>0>9&(f+-65|0)>>>0>5){x=i;break a}else f=h;}if(!((q|0)==0|(q|0)==(i|0))){if(q>>>0>=i>>>0)Ii(u,i,0,q);if((a[u+q>>0]|0)<=-65)Ii(u,i,0,q);else x=q;}else x=q;}else x=i;while(0);do if(x>>>0>4)if((a[u+3>>0]|0)>-65){if((u|0)!=9417?Xj(9417,u,3)|0:0){B=57;break}h=x+-1|0;if(h){f=u+h|0;if((a[f>>0]|0)<=-65){B=57;break}}else f=u;if((f|0)!=9416?(a[f>>0]|0)!=69:0){if((x|0)==2){B=58;break}if(x>>>0>2){B=57;break}else {B=118;break}}if(h>>>0<3)Ii(u,x,3,h);if((a[u+h>>0]|0)>-65){f=3;B=64;}else Ii(u,x,3,h);}else B=57;else if((x|0)==4)B=57;else B=118;while(0);if((B|0)==57)if((a[u+2>>0]|0)>-65)B=58;else B=118;do if((B|0)==58){if((u|0)!=9420?Xj(9420,u,2)|0:0){B=118;break}h=x+-1|0;if(h){f=u+h|0;if((a[f>>0]|0)<=-65){B=118;break}}else f=u;if((f|0)!=9416?(a[f>>0]|0)!=69:0){B=118;break}if(h>>>0<2)Ii(u,x,2,h);if((a[u+2>>0]|0)<=-65)Ii(u,x,2,h);if((a[u+h>>0]|0)>-65){f=2;h=x;B=64;}else Ii(u,x,2,h);}while(0);b:do if((B|0)==64){f=u+f|0;h=h+-3|0;t=f+h|0;m=f;while(1){if((m|0)==(t|0))break;n=m+1|0;o=a[m>>0]|0;if(o<<24>>24<=-1){i=o&31;if((n|0)==(t|0)){j=0;g=t;}else {j=a[n>>0]&63;g=m+2|0;}m=j&255;j=m|i<<6;if((o&255)>223){if((g|0)==(t|0)){n=g;j=0;g=t;}else {s=g+1|0;n=s;j=a[g>>0]&63;g=s;}m=j&255|m<<6;j=m|i<<12;if((o&255)>239){if((g|0)==(t|0))j=0;else {n=g+1|0;j=a[g>>0]&63;}j=m<<6|i<<18&1835008|j&255;if((j|0)==1114112){v=n;B=93;break}else o=0;}else o=0;}else {o=0;n=g;}}else {j=o&255;o=0;}while(1){m=j+-48|0;if(m>>>0>=10){if(j>>>0<=127){m=n;j=o;break}if(!(Vh(j)|0)){m=n;j=o;break}}q=(o*10|0)+m|0;if((n|0)==(t|0)){m=t;j=q;break}m=n+1|0;i=a[n>>0]|0;if(i<<24>>24>-1){j=i&255;o=q;n=m;continue}p=i&31;if((m|0)==(t|0)){j=0;n=t;}else {j=a[m>>0]&63;n=n+2|0;}g=j&255;if((i&255)<=223){j=g|p<<6;o=q;continue}if((n|0)==(t|0)){m=n;j=0;o=t;}else {o=n+1|0;m=o;j=a[n>>0]&63;}n=j&255|g<<6;if((i&255)<=239){j=n|p<<12;o=q;n=m;continue}if((o|0)==(t|0))j=0;else {m=o+1|0;j=a[o>>0]&63;}j=n<<6|p<<18&1835008|j&255;if((j|0)==1114112){j=q;break}else {o=q;n=m;}}if(!j){v=m;B=93;break}s=j+-1|0;c:do if(!s)j=0;else {r=s;j=0;do{if((m|0)==(t|0)){m=t;break c}n=m+1|0;p=a[m>>0]|0;if(p<<24>>24<=-1){q=p&255;if((n|0)==(t|0)){n=0;g=t;}else {n=a[n>>0]&63;g=m+2|0;}o=n&255;if((p&255)>223){if((g|0)==(t|0)){m=g;n=0;i=t;}else {i=g+1|0;m=i;n=a[g>>0]&63;}g=n&255|o<<6;if((p&255)>239){if((i|0)==(t|0))n=0;else {m=i+1|0;n=a[i>>0]&63;}if((g<<6|q<<18&1835008|n&255|0)==1114112)break c}}else m=g;}else m=n;r=r+-1|0;j=j+1|0;}while((r|0)!=0)}while(0);if((j|0)!=(s|0)){B=118;break b}}if((B|0)==93?(v|0)!=(t|0):0){j=v+1|0;g=a[v>>0]|0;if(g<<24>>24>-1){B=118;break}if((j|0)==(t|0)){n=0;j=t;}else {n=a[j>>0]&63;j=v+2|0;}if((g&255)<=223){B=118;break}if((j|0)==(t|0)){m=0;j=t;}else {m=a[j>>0]&63;j=j+1|0;}if((g&255)<=239){B=118;break}if((j|0)==(t|0))j=0;else j=a[j>>0]&63;if(((m&255|(n&255)<<6)<<6|(g&255)<<18&1835008|j&255|0)!=1114112){B=118;break}}if(w){Ni(z,f,h,9422,3);g=z+64|0;c[g>>2]=0;o=z+68|0;c[o>>2]=h;j=z+72|0;a[j>>0]=1;i=z+73|0;a[i>>0]=0;m=z+80|0;c[m>>2]=1;yg(A,z);n=c[m>>2]|0;d:do switch(n|0){case 0:{c[F>>2]=0;break}case 1:{c[m>>2]=0;do if(!(a[i>>0]|0)){if(!(a[j>>0]|0)){m=c[o>>2]|0;j=c[g>>2]|0;if((m|0)==(j|0))break}else {j=c[g>>2]|0;m=c[o>>2]|0;}a[i>>0]=1;c[F>>2]=(c[z+48>>2]|0)+j;c[F+4>>2]=m-j;break d}while(0);c[F>>2]=0;break}default:{c[m>>2]=n+-1;yg(F,z);}}while(0);j=c[A>>2]|0;q=F;r=c[q>>2]|0;q=c[q+4>>2]|0;e:do if((j|0)!=0?(c[A+4>>2]|0)==16:0){p=j+16|0;while(1){A=(j|0)==(p|0);m=A?j:j+1|0;if(A|(j|0)==0)break;o=a[j>>0]|0;if(o<<24>>24<=-1){i=o&31;if((m|0)==(p|0)){n=0;j=p;}else {n=a[m>>0]&63;j=m+1|0;}n=n&255;m=n|i<<6;if((o&255)>223){if((j|0)==(p|0)){m=0;g=p;}else {m=a[j>>0]&63;g=j+1|0;}n=m&255|n<<6;m=n|i<<12;if((o&255)>239){if((g|0)==(p|0)){j=p;m=0;}else {j=g+1|0;m=a[g>>0]&63;}m=n<<6|i<<18&1835008|m&255;if((m|0)==1114112)break}else j=g;}}else {j=m;m=o&255;}if((m+-48|0)>>>0>=10)if((m+-97|0)>>>0>=26)if((m+-65|0)>>>0<26)n=-55;else break e;else n=-87;else n=-48;if((n+m|0)>>>0>15)break e}f=(r|0)==0;h=f?0:q;f=f?16465:r;}while(0)}if(!h)B=452;else {v=F+4|0;w=e+20|0;j=1;p=f;f:while(1){if(!j?(nb[c[w>>2]&15](F,d,3536,2),D=F,A=c[D>>2]|0,C=A&255,D=kk(A|0,c[D+4>>2]|0,8)|0,C<<24>>24!=3):0){G=y;k=D;E=C;break b}r=p;q=p+1|0;i=p+h|0;f=h;while(1){g=a[r>>0]|0;if(g<<24>>24<=-1){o=g&31;if((q|0)==(i|0)){j=0;n=q;}else {j=a[q>>0]&63;n=q+1|0;}m=j&255;j=m|o<<6;if((g&255)>223){if((n|0)==(i|0)){j=0;n=i;}else {j=a[n>>0]&63;n=n+1|0;}m=j&255|m<<6;j=m|o<<12;if((g&255)>239){if((n|0)==(i|0))j=0;else j=a[n>>0]&63;j=m<<6|o<<18&1835008|j&255;if((j|0)==1114112){B=166;break f}}}}else j=g&255;if((j+-48|0)>>>0>=10){if(j>>>0<=127)break;if(!(Vh(j)|0))break}switch(f|0){case 0:{f=0;B=188;break f}case 1:break;default:if((a[q>>0]|0)<=-65){B=188;break f}}f=f+-1|0;i=q+f|0;if(!f){B=166;break f}else {r=q;q=q+1|0;}}j=h-f|0;if(j|0){if(h>>>0<=j>>>0){B=173;break}if((a[p+j>>0]|0)<=-65){B=173;break}}fj(F,p,j);if((a[F>>0]|0)==1){B=175;break}m=c[v>>2]|0;if(!((m|0)==0|(f|0)==(m|0))){if(f>>>0<=m>>>0){B=180;break}h=r+m|0;if((a[h>>0]|0)>-65)u=h;else {B=180;break}}else u=r+m|0;h=f-m|0;if((m|0)!=2)if(m>>>0>2)if((a[r+2>>0]|0)>-65)B=184;else B=193;else {j=r;f=m;B=194;}else B=184;do if((B|0)==184){if((r|0)!=9425?Xj(9425,r,2)|0:0){B=193;break}if((a[q>>0]|0)<=-65){B=191;break f}j=q;f=m+-1|0;B=194;}while(0);if((B|0)==193){f=m;B=195;}else if((B|0)==194?(B=0,f|0):0){r=j;B=195;}g:do if((B|0)==195){h:while(1){j=(f|0)==1;if(!j?(a[r+1>>0]|0)<=-65:0)B=232;else B=197;i:do if((B|0)==197){B=0;do if((r|0)!=3540){if((a[r>>0]|0)==46)break;if(!j?(a[r+1>>0]|0)<=-65:0){B=232;break i}if((r|0)!=9427?(a[r>>0]|0)!=36:0){B=232;break i}n=(f|0)==4;do if(!n)if(f>>>0>4)if((a[r+4>>0]|0)>-65){B=230;break}else {B=303;break}else if((f|0)==3){j=1;B=304;break}else break h;else B=230;while(0);j:do if((B|0)==230){B=0;do if((r|0)!=9428){if(!(Xj(9428,r,4)|0))break;if(!n?(a[r+4>>0]|0)<=-65:0){B=303;break j}do if((r|0)!=9432){if(!(Xj(9432,r,4)|0))break;if(!n?(a[r+4>>0]|0)<=-65:0){B=303;break j}do if((r|0)!=9436){if(!(Xj(9436,r,4)|0))break;if(!n?(a[r+4>>0]|0)<=-65:0){B=303;break j}do if((r|0)!=9440){if(!(Xj(9440,r,4)|0))break;if(!n?(a[r+4>>0]|0)<=-65:0){B=303;break j}do if((r|0)!=9444){if(!(Xj(9444,r,4)|0))break;if(!n?(a[r+4>>0]|0)<=-65:0){B=303;break j}do if((r|0)!=9448){if(!(Xj(9448,r,4)|0))break;if(!n?(a[r+4>>0]|0)<=-65:0){B=303;break j}if((r|0)!=9452?Xj(9452,r,4)|0:0){B=303;break j}nb[c[w>>2]&15](F,d,3568,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}j=r+4|0;if(!n?(a[j>>0]|0)<=-65:0){B=308;break f}f=f+-4|0;break i}while(0);nb[c[w>>2]&15](F,d,3564,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}j=r+4|0;if(!n?(a[j>>0]|0)<=-65:0){B=299;break f}f=f+-4|0;break i}while(0);nb[c[w>>2]&15](F,d,3560,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}j=r+4|0;if(!n?(a[j>>0]|0)<=-65:0){B=290;break f}f=f+-4|0;break i}while(0);nb[c[w>>2]&15](F,d,3556,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}j=r+4|0;if(!n?(a[j>>0]|0)<=-65:0){B=281;break f}f=f+-4|0;break i}while(0);nb[c[w>>2]&15](F,d,3552,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}j=r+4|0;if(!n?(a[j>>0]|0)<=-65:0){B=272;break f}f=f+-4|0;break i}while(0);nb[c[w>>2]&15](F,d,3548,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}j=r+4|0;if(!n?(a[j>>0]|0)<=-65:0){B=263;break f}f=f+-4|0;break i}while(0);nb[c[w>>2]&15](F,d,3544,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}j=r+4|0;if(!n?(a[j>>0]|0)<=-65:0){B=254;break f}f=f+-4|0;break i}while(0);if((B|0)==303?(B=0,(a[r+3>>0]|0)>-65):0){j=0;B=304;}do if((B|0)==304){B=0;if((r|0)!=9456?Xj(9456,r,3)|0:0)break;nb[c[w>>2]&15](F,d,3572,1);n=F;A=c[n>>2]|0;m=A&255;n=kk(A|0,c[n+4>>2]|0,8)|0;if(m<<24>>24!=3){G=y;k=n;E=m;break b}if(!j){if(f>>>0<=3){B=320;break f}j=r+3|0;if((a[j>>0]|0)<=-65){B=320;break f}}else j=r+3|0;f=f+-3|0;break i}while(0);if((f|0)!=5){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)j=0;else break h}else j=1;do if((r|0)!=9459){if(!(Xj(9459,r,5)|0))break;if(!j){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)j=0;else break h}else j=1;do if((r|0)!=9464){if(!(Xj(9464,r,5)|0))break;if(!j){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)j=0;else break h}else j=1;do if((r|0)!=9469){if(!(Xj(9469,r,5)|0))break;if(!j){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)j=0;else break h}else j=1;do if((r|0)!=9474){if(!(Xj(9474,r,5)|0))break;if(!j){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)n=0;else break h}else n=1;do if((r|0)!=9479){if(!(Xj(9479,r,5)|0))break;if(!n){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)n=0;else break h}else n=1;do if((r|0)!=9484){if(!(Xj(9484,r,5)|0))break;if(!n){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)n=0;else break h}else n=1;do if((r|0)!=9489){if(!(Xj(9489,r,5)|0))break;if(!n){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)n=0;else break h}else n=1;do if((r|0)!=9494){if(!(Xj(9494,r,5)|0))break;if(!n){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)n=0;else break h}else n=1;do if((r|0)!=9499){if(!(Xj(9499,r,5)|0))break;if(!n){if(f>>>0<=5)break h;if((a[r+5>>0]|0)>-65)n=0;else break h}else n=1;if((r|0)!=9504?Xj(9504,r,5)|0:0)break h;nb[c[w>>2]&15](F,d,3612,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}if(!n){if(f>>>0<=5){B=436;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=436;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3608,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}if(!n){if(f>>>0<=5){B=428;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=428;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3604,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}if(!n){if(f>>>0<=5){B=416;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=416;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3600,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}if(!n){if(f>>>0<=5){B=404;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=404;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3596,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}if(!n){if(f>>>0<=5){B=392;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=392;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3592,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24!=3){G=y;k=m;E=j;break b}if(!n){if(f>>>0<=5){B=380;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=380;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3588,1);n=F;A=c[n>>2]|0;m=A&255;n=kk(A|0,c[n+4>>2]|0,8)|0;if(m<<24>>24!=3){G=y;k=n;E=m;break b}if(!j){if(f>>>0<=5){B=368;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=368;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3584,1);n=F;A=c[n>>2]|0;m=A&255;n=kk(A|0,c[n+4>>2]|0,8)|0;if(m<<24>>24!=3){G=y;k=n;E=m;break b}if(!j){if(f>>>0<=5){B=356;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=356;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3580,1);n=F;A=c[n>>2]|0;m=A&255;n=kk(A|0,c[n+4>>2]|0,8)|0;if(m<<24>>24!=3){G=y;k=n;E=m;break b}if(!j){if(f>>>0<=5){B=344;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=344;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);nb[c[w>>2]&15](F,d,3576,1);n=F;A=c[n>>2]|0;m=A&255;n=kk(A|0,c[n+4>>2]|0,8)|0;if(m<<24>>24!=3){G=y;k=n;E=m;break b}if(!j){if(f>>>0<=5){B=332;break f}j=r+5|0;if((a[j>>0]|0)<=-65){B=332;break f}}else j=r+5|0;f=f+-5|0;break i}while(0);m=r+1|0;do if(!j){g=a[m>>0]|0;if(g<<24>>24<=-65){B=201;break f}A=f+-1|0;o=m+A|0;A=(A|0)==0;j=A?m:r+2|0;if(A){B=219;break}do if(g<<24>>24>-1)j=g&255;else {i=g&31;if((j|0)==(o|0)){m=0;n=o;}else {m=a[j>>0]&63;n=j+1|0;}j=m&255;if((g&255)<=223){j=j|i<<6;break}if((n|0)==(o|0)){m=0;n=o;}else {m=a[n>>0]&63;n=n+1|0;}m=m&255|j<<6;if((g&255)<=239){j=m|i<<12;break}if((n|0)==(o|0))j=0;else j=a[n>>0]&63;j=m<<6|i<<18&1835008|j&255;}while(0);if((j|0)!=46){B=219;break}nb[c[w>>2]&15](F,d,3536,2);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24==3)m=2;else {G=y;k=m;E=j;break b}}else B=219;while(0);if((B|0)==219){B=0;nb[c[w>>2]&15](F,d,3540,1);m=F;A=c[m>>2]|0;j=A&255;m=kk(A|0,c[m+4>>2]|0,8)|0;if(j<<24>>24==3)m=1;else {G=y;k=m;E=j;break b}}if((f|0)!=(m|0)){if(f>>>0<=m>>>0){B=225;break f}j=r+m|0;if((a[j>>0]|0)<=-65){B=225;break f}}else j=r+f|0;f=f-m|0;}while(0);if((B|0)==232){B=0;q=r+f|0;s=r;t=0;k:while(1){j=s;A=(j|0)==(q|0);m=A?s:j+1|0;if((s|0)==0|A){g=f;break}i=a[j>>0]|0;do if(i<<24>>24<=-1){p=i&31;j=m;if((j|0)==(q|0)){j=0;n=q;}else {n=j+1|0;m=n;j=a[j>>0]&63;}o=j&255;if((i&255)<=223){g=m;j=o|p<<6;break}if((n|0)==(q|0)){j=0;g=q;}else {g=n+1|0;m=g;j=a[n>>0]&63;}n=j&255|o<<6;if((i&255)<=239){g=m;j=n|p<<12;break}if((g|0)==(q|0))j=0;else {m=g+1|0;j=a[g>>0]&63;}j=n<<6|p<<18&1835008|j&255;if((j|0)==1114112){g=f;break k}else g=m;}else {g=m;j=i&255;}while(0);m=t-s+g|0;switch(j&2097151|0){case 46:case 36:{B=246;break k}default:{s=g;t=m;}}}if((B|0)==246){B=0;g=(j|0)==1114112?f:t;}j=(g|0)==0|(f|0)==(g|0);if(!j){if(f>>>0<=g>>>0){B=442;break f}if((a[r+g>>0]|0)<=-65){B=442;break f}}nb[c[w>>2]&15](F,d,r,g);n=F;A=c[n>>2]|0;m=A&255;n=kk(A|0,c[n+4>>2]|0,8)|0;if(m<<24>>24!=3){G=y;k=n;E=m;break b}if(!j){if(f>>>0<=g>>>0){B=448;break f}j=r+g|0;if((a[j>>0]|0)<=-65){B=448;break f}}else j=r+g|0;f=f-g|0;}if(!f)break g;else {r=j;B=195;}}nb[c[w>>2]&15](F,d,r,f);j=F;A=c[j>>2]|0;f=A&255;j=kk(A|0,c[j+4>>2]|0,8)|0;if(f<<24>>24!=3){G=y;k=j;E=f;break b}}while(0);if(!h){B=452;break b}else {j=0;p=u;}}switch(B|0){case 166:{$i(3300);break}case 173:{Ii(p,h,0,j);break}case 175:{Ze(8804,43,a[F+1>>0]|0);break}case 180:{Ii(r,f,m,f);break}case 188:{Ii(r,f,1,f);break}case 191:{Ii(r,m,1,m);break}case 201:{Ii(r,f,1,f);break}case 225:{Ii(r,f,m,f);break}case 254:{Ii(r,f,4,f);break}case 263:{Ii(r,f,4,f);break}case 272:{Ii(r,f,4,f);break}case 281:{Ii(r,f,4,f);break}case 290:{Ii(r,f,4,f);break}case 299:{Ii(r,f,4,f);break}case 308:{Ii(r,f,4,f);break}case 320:{Ii(r,f,3,f);break}case 332:{Ii(r,f,5,f);break}case 344:{Ii(r,f,5,f);break}case 356:{Ii(r,f,5,f);break}case 368:{Ii(r,f,5,f);break}case 380:{Ii(r,f,5,f);break}case 392:{Ii(r,f,5,f);break}case 404:{Ii(r,f,5,f);break}case 416:{Ii(r,f,5,f);break}case 428:{Ii(r,f,5,f);break}case 436:{Ii(r,f,5,f);break}case 442:{Ii(r,f,0,g);break}case 448:{Ii(r,f,g,f);break}}}}while(0);if((B|0)==118){nb[c[e+20>>2]&15](F,d,u,x);k=F;G=c[k>>2]|0;f=G&255;k=kk(G|0,c[k+4>>2]|0,8)|0;if(f<<24>>24==3)B=452;else {G=y;E=f;}}if((B|0)==452){k=c[e+20>>2]|0;break}d=nk(k|0,G&16777215|0,8)|0;c[b>>2]=d|E&255;c[b+4>>2]=y;l=H;return}while(0);nb[k&15](b,d,3616,1);l=H;return}function yg(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=l;l=l+16|0;s=u;t=d+73|0;if(a[t>>0]|0){c[b>>2]=0;l=u;return}e=d+72|0;a:do if(!(a[e>>0]|0)){a[e>>0]=1;yg(s,d);r=c[s>>2]|0;e=r;if((r|0)!=0?(f=c[s+4>>2]|0,(f|0)!=0):0){c[b>>2]=e;c[b+4>>2]=f;}else g=7;do if((g|0)==7)if(!(a[t>>0]|0))break a;else {c[b>>2]=0;break}while(0);l=u;return}while(0);r=c[d+48>>2]|0;do if((c[d>>2]|0)==1){e=d+8|0;f=c[d+52>>2]|0;g=c[d+56>>2]|0;h=c[d+60>>2]|0;if((c[d+36>>2]|0)==-1){zg(s,e,r,f,g,h,1);break}else {zg(s,e,r,f,g,h,0);break}}else {n=d+8|0;o=d+4+9|0;p=c[d+52>>2]|0;e=a[o>>0]|0;q=c[n>>2]|0;while(1){m=e<<24>>24!=0;e=(m^1)&1;a[o>>0]=e;f=(q|0)==0;if(!(f|(p|0)==(q|0))){if(p>>>0<=q>>>0){g=18;break}if((a[r+q>>0]|0)<=-65){g=18;break}}do if(f)f=1114112;else {i=r+q|0;f=i+-1|0;k=a[f>>0]|0;if(k<<24>>24>-1){f=k&255;break}if((f|0)!=(r|0)){g=i+-2|0;j=a[g>>0]|0;f=j&31;if((j&-64)<<24>>24==-128){if((g|0)!=(r|0)){g=i+-3|0;h=a[g>>0]|0;f=h&15;if((h&-64)<<24>>24==-128){if((g|0)==(r|0))f=0;else f=a[i+-4>>0]&7;f=(f&255)<<6|h&63;}}else f=0;f=f<<6|j&63;}}else f=0;f=f<<6|k&63;}while(0);if(m){g=35;break}if((f|0)==1114112){g=34;break}m=q-(f>>>0<128?1:f>>>0<2048?2:f>>>0<65536?3:4)|0;c[n>>2]=m;q=m;}if((g|0)==18)Ii(r,p,0,q);else if((g|0)==34){c[s>>2]=0;break}else if((g|0)==35){c[s>>2]=1;c[s+4>>2]=q;c[s+8>>2]=q;break}}while(0);if((c[s>>2]|0)==1){f=c[s+8>>2]|0;d=d+68|0;e=(c[d>>2]|0)-f|0;c[d>>2]=c[s+4>>2];}else {a[t>>0]=1;e=c[d+64>>2]|0;f=e;e=(c[d+68>>2]|0)-e|0;}c[b>>2]=r+f;c[b+4>>2]=e;l=u;return}function zg(b,d,e,f,g,h,i){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;s=d+24|0;j=c[s>>2]|0;k=j-h|0;a:do if(k>>>0<f>>>0){r=d+32|0;p=d;o=c[p>>2]|0;p=c[p+4>>2]|0;q=c[d+12>>2]|0;n=c[d+16>>2]|0;d=k;b:while(1){c:while(1){k=d;while(1){m=nk(1,0,a[e+k>>0]&63|0)|0;if(!((m&o|0)==0&(y&p|0)==0))break;c[s>>2]=k;if(!i)c[r>>2]=h;d=k-h|0;if(d>>>0<f>>>0){j=k;k=d;}else break a}if(i)d=q;else {d=c[r>>2]|0;d=q>>>0<=d>>>0?q:d;}m=j-h|0;k=d;do{l=k;k=k+-1|0;if(!l)break c;if(k>>>0>=h>>>0){d=35;break b}l=k+m|0;if(l>>>0>=f>>>0){d=18;break b}}while((a[g+k>>0]|0)==(a[e+l>>0]|0));j=k+j-q|0;c[s>>2]=j;if(!i)c[r>>2]=h;d=j-h|0;if(d>>>0>=f>>>0)break a}d=i?h:c[r>>2]|0;k=q;while(1){if(k>>>0>=d>>>0){d=25;break b}if(k>>>0>4294967294){d=25;break b}if(k>>>0>=h>>>0){d=36;break b}l=m+k|0;if(l>>>0>=f>>>0){d=28;break b}if((a[g+k>>0]|0)==(a[e+l>>0]|0))k=k+1|0;else break}j=j-n|0;c[s>>2]=j;if(!i)c[r>>2]=n;d=j-h|0;if(d>>>0>=f>>>0)break a}if((d|0)==18)bj(3620,l,f);else if((d|0)==25){c[s>>2]=m;if(!i)c[r>>2]=h;c[b>>2]=1;c[b+4>>2]=m;c[b+8>>2]=j;return}else if((d|0)==28)bj(3620,l,f);else if((d|0)==35)bj(3636,k,h);else if((d|0)==36)bj(3652,k,h);}while(0);c[s>>2]=0;c[b>>2]=0;return}function Ag(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+32|0;h=j+16|0;f=j;i=a+4|0;if(((c[i>>2]|0)-b|0)>>>0>=d>>>0){l=j;return}g=b+d|0;if(g>>>0<b>>>0)cj(9586,17);c[h>>2]=1;c[h+4>>2]=1;mg(f,h,g);if((c[f>>2]|0)!=1)$i(3668);e=c[f+4>>2]|0;d=c[f+8>>2]|0;if((e|0)<0)$i(3740);b=c[i>>2]|0;if(!b){b=Xb(e,d,h)|0;d=(b|0)==0&1;e=0;f=0;}else {b=_b(c[a>>2]|0,b,1,e,d,h)|0;e=(b|0)==0;f=h+4|0;d=e&1;b=e?c[h>>2]|0:b;e=c[f>>2]|0;f=c[f+4>>2]|0;}if((d|0)==1){c[h>>2]=b;d=h+4|0;c[d>>2]=e;c[d+4>>2]=f;Yb(h);}c[a>>2]=b;c[i>>2]=g;l=j;return}function Bg(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;h=l;l=l+32|0;f=h+16|0;d=h;g=a+4|0;b=c[g>>2]|0;if(b|0){d=b<<1;if((d|0)<0)$i(3740);b=_b(c[a>>2]|0,b,1,d,1,f)|0;if(!b){i=f+4|0;j=c[i>>2]|0;i=c[i+4>>2]|0;c[f>>2]=c[f>>2];e=f+4|0;c[e>>2]=j;c[e+4>>2]=i;Yb(f);}f=b;i=a;j=d;c[i>>2]=f;c[g>>2]=j;l=h;return}c[f>>2]=1;c[f+4>>2]=1;mg(d,f,4);if((c[d>>2]|0)==1){b=c[d+4>>2]|0;if(b|0?(e=Xb(b,c[d+8>>2]|0,f)|0,e|0):0){f=e;i=a;j=4;c[i>>2]=f;c[g>>2]=j;l=h;return}}c[f>>2]=1;c[f+4>>2]=7654;c[f+8>>2]=30;Yb(f);}function Cg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+32|0;h=j+16|0;f=j;i=a+4|0;e=c[i>>2]|0;if((e-b|0)>>>0>=d>>>0){l=j;return}d=b+d|0;if(d>>>0<b>>>0)cj(9586,17);g=e<<1;g=d>>>0>=g>>>0?d:g;c[h>>2]=1;c[h+4>>2]=1;mg(f,h,g);if((c[f>>2]|0)!=1)$i(3716);e=c[f+4>>2]|0;d=c[f+8>>2]|0;if((e|0)<0)$i(3740);b=c[i>>2]|0;if(!b){b=Xb(e,d,h)|0;d=(b|0)==0&1;e=0;f=0;}else {b=_b(c[a>>2]|0,b,1,e,d,h)|0;e=(b|0)==0;f=h+4|0;d=e&1;b=e?c[h>>2]|0:b;e=c[f>>2]|0;f=c[f+4>>2]|0;}if((d|0)==1){c[h>>2]=b;d=h+4|0;c[d>>2]=e;c[d+4>>2]=f;Yb(h);}c[a>>2]=b;c[i>>2]=g;l=j;return}function Dg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+32|0;h=j+16|0;f=j;i=a+4|0;e=c[i>>2]|0;if((e-b|0)>>>0>=d>>>0){l=j;return}d=b+d|0;if(d>>>0<b>>>0)cj(9586,17);g=e<<1;g=d>>>0>=g>>>0?d:g;c[h>>2]=12;c[h+4>>2]=4;mg(f,h,g);if((c[f>>2]|0)!=1)$i(3716);e=c[f+4>>2]|0;d=c[f+8>>2]|0;if((e|0)<0)$i(3740);b=c[i>>2]|0;if(!b){b=Xb(e,d,h)|0;d=(b|0)==0&1;e=0;f=0;}else {b=_b(c[a>>2]|0,b*12|0,4,e,d,h)|0;e=(b|0)==0;f=h+4|0;d=e&1;b=e?c[h>>2]|0:b;e=c[f>>2]|0;f=c[f+4>>2]|0;}if((d|0)==1){c[h>>2]=b;d=h+4|0;c[d>>2]=e;c[d+4>>2]=f;Yb(h);}c[a>>2]=b;c[i>>2]=g;l=j;return}function Eg(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function Fg(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Gg(a){a=a|0;c[c[a>>2]>>2]=c[a+4>>2];return}function Hg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=l;l=l+16|0;d=f+8|0;e=f;g=c[a>>2]|0;a=c[g>>2]|0;g=c[g+8>>2]|0;wi(e,b);b=a+g|0;if(g|0)do{c[d>>2]=a;a=a+1|0;Vi(e,d,2384)|0;}while((a|0)!=(b|0));g=Wi(e)|0;l=f;return g|0}function Ig(a){a=a|0;var b=0,d=0,e=0;b=c[a>>2]|0;d=c[a+8>>2]|0;e=b+(d*12|0)|0;if(d|0)do{d=c[b+4>>2]|0;if(d|0)Zb(c[b>>2]|0,d,1);b=b+12|0;}while((b|0)!=(e|0));b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b*12|0,4);return}function Jg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0;t=l;l=l+48|0;m=t+36|0;p=t+24|0;q=t+16|0;r=t;c[r>>2]=4;c[r+4>>2]=0;s=r+8|0;c[s>>2]=0;h=c[b>>2]|0;d=c[b+4>>2]|0;e=c[b+8>>2]|0;f=(d|0)>(h|0);n=0;aa(26,r|0,0,(f?d-h|0:0)|0);o=n;n=0;if(o&1){t=na()|0;Ig(r);za(t|0);}g=c[r>>2]|0;b=c[s>>2]|0;c[q>>2]=s;o=q+4|0;c[o>>2]=b;c[p>>2]=h;k=p+4|0;c[k>>2]=d;j=p+8|0;c[j>>2]=e;if(!f){q=b;c[s>>2]=q;c[a>>2]=c[r>>2];c[a+4>>2]=c[r+4>>2];c[a+8>>2]=c[r+8>>2];l=t;return}i=m+4|0;g=g+(b*12|0)|0;while(1){f=h;h=h+1|0;c[p>>2]=h;n=0;aa(27,m|0,j|0,f|0);f=n;n=0;if(f&1){d=9;break}d=c[m>>2]|0;f=i;e=c[f>>2]|0;f=c[f+4>>2]|0;if(!d){d=10;break}c[g>>2]=d;d=g+4|0;c[d>>2]=e;c[d+4>>2]=f;b=b+1|0;if((h|0)>=(c[k>>2]|0)){d=10;break}else g=g+12|0;}if((d|0)==9){t=na()|0;c[o>>2]=b;Gg(q);Ig(r);za(t|0);}else if((d|0)==10){c[s>>2]=b;c[a>>2]=c[r>>2];c[a+4>>2]=c[r+4>>2];c[a+8>>2]=c[r+8>>2];l=t;return}}function Kg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;i=l;l=l+32|0;e=i+12|0;h=i;if((d|0)<0)$i(3740);if(d){f=Xb(d,1,e)|0;if(!f){c[e>>2]=0;Yb(e);}else g=f;}else g=1;c[h>>2]=g;c[h+4>>2]=d;e=h+8|0;c[e>>2]=0;n=0;aa(23,h|0,0,d|0);g=n;n=0;if(g&1){i=na()|0;Eg(h);za(i|0);}else {g=c[e>>2]|0;c[e>>2]=g+d;ok((c[h>>2]|0)+g|0,b|0,d|0)|0;c[a>>2]=c[h>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];l=i;return}}function Lg(a){a=a|0;var b=0,d=0,e=0;e=l;l=l+16|0;b=e;d=Xb(28,4,b)|0;if(!d)Yb(b);else {c[d>>2]=c[3948];c[d+4>>2]=c[3949];c[d+8>>2]=c[3950];c[d+12>>2]=c[3951];c[d+16>>2]=c[3952];c[d+20>>2]=c[3953];c[d+24>>2]=c[3954];Ra(b|0)|0;Ja(b|0,0)|0;_a(d|0,b|0)|0;sa(b|0)|0;b=a;c[b>>2]=d;c[b+4>>2]=0;l=e;return}}function Mg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;h=l;l=l+16|0;f=h;if(b>>>0>8|b>>>0>a>>>0){c[f>>2]=0;i=(wj(f,b,a)|0)==0;if(i){e=c[f>>2]|0;g=4;}}else {e=qj(a)|0;g=4;}if((g|0)==4?e|0:0){i=e;l=h;return i|0}c[d>>2]=0;c[d+4>>2]=a;c[d+8>>2]=b;i=0;l=h;return i|0}function Ng(a){a=a|0;var b=0,d=0,e=0,f=0;d=l;l=l+16|0;b=d;f=c[a+4>>2]|0;e=c[a+8>>2]|0;c[b>>2]=c[a>>2];c[b+4>>2]=f;c[b+8>>2]=e;n=0;_(27,d+12|0,b|0);n=0;na()|0;Za();}function Og(a,b,c){a=a|0;b=b|0;c=c|0;rj(a);return}function Pg(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0;i=l;l=l+16|0;h=i;do if((d|0)==(f|0)){if(!(d>>>0>8|d>>>0>e>>>0)){f=sj(a,e)|0;if(!f){h=0;f=d;break}l=i;return f|0}c[h>>2]=0;j=(wj(h,d,e)|0)!=0;f=c[h>>2]|0;if(j|(f|0)==0){h=0;f=d;}else {ok(f|0,a|0,(b>>>0<=e>>>0?b:e)|0)|0;rj(a);j=f;l=i;return j|0}}else {h=1;e=9672;f=36;}while(0);c[g>>2]=h;c[g+4>>2]=e;c[g+8>>2]=f;j=0;l=i;return j|0}function Qg(a){a=a|0;return}function Rg(){return le(3812)|0}function Sg(a){a=a|0;c[a>>2]=0;c[a+4>>2]=2;return}function Tg(a){a=a|0;y=160875347;return 2033335871}function Ug(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=a;c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,3764,e)|0;l=d;return b|0}function Vg(a){a=a|0;var b=0,d=0;d=c[a>>2]|0;b=c[d>>2]|0;c[d>>2]=b-1;if((b|0)!=1)return;Te(a);return}function Wg(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=a+8|0;g=a+12|0;b=c[f>>2]|0;a:do if((b|0)!=(c[g>>2]|0)){while(1){c[f>>2]=b+8;e=c[b>>2]|0;b=c[b+4>>2]|0;n=0;Z(c[b>>2]|0,e|0);d=n;n=0;if(d&1)break;d=c[b+4>>2]|0;if(d|0)Zb(e,d,c[b+8>>2]|0);b=c[f>>2]|0;if((b|0)==(c[g>>2]|0))break a}a=na()|0;Fg(e,b);za(a|0);}while(0);b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b<<3,4);return}function Xg(a,b){a=a|0;b=b|0;a=c[a>>2]|0;return yi(c[a>>2]|0,c[a+8>>2]|0,b)|0}function Yg(a){a=a|0;Zb(a,12,4);return}function Zg(){var a=0,b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0;p=l;l=l+16|0;m=p;g=m+8|0;h=m+4|0;i=m+4|0;o=m+8|0;j=m+12|0;a=0;a:while(1){b=a;b:while(1){if(b>>>0>=10){a=5;break a}a=b+1|0;if(b>>>0>4294967294){a=5;break a}ik(15828)|0;k=c[3955]|0;c[3955]=(b|0)==9?1:0;mk(15828)|0;switch(k|0){case 1:{a=7;break a}case 0:{b=a;break}default:break b}}c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[m+8>>2]=c[k+8>>2];b=c[m>>2]|0;f=c[g>>2]|0;d=b+(f<<3)|0;e=c[h>>2]|0;c[m>>2]=b;c[i>>2]=e;c[o>>2]=b;c[j>>2]=d;if(f|0){f=b;do{q=f;f=f+8|0;n=0;Z(c[(c[q+4>>2]|0)+12>>2]|0,c[q>>2]|0);q=n;n=0;if(q&1){a=9;break a}}while((f|0)!=(d|0));c[o>>2]=d;}if(e|0)Zb(b,e<<3,4);Zb(k,12,4);}if((a|0)==5){l=p;return}else if((a|0)==7)ve(9754,37,3788);else if((a|0)==9){q=na()|0;c[o>>2]=f;Wg(m);Yg(k);za(q|0);}}function _g(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0;m=l;l=l+64|0;b=m+32|0;e=m+28|0;f=m+24|0;g=m+20|0;h=m+16|0;i=m;j=a+4|0;d=c[j>>2]|0;c[h>>2]=0;d=ja(h|0,d|0)|0;c[g>>2]=d;c[f>>2]=g;c[e>>2]=15856;if(d|0){c[i>>2]=f;c[i+4>>2]=57;c[i+8>>2]=e;c[i+12>>2]=57;c[b>>2]=3820;c[b+4>>2]=3;c[b+8>>2]=5264;c[b+12>>2]=2;c[b+16>>2]=i;c[b+20>>2]=2;we(b,3844);}d=c[h>>2]|0;if(!d){j=c[j>>2]|0;c[h>>2]=0;j=ja(h|0,j|0)|0;c[g>>2]=j;c[f>>2]=g;c[e>>2]=15856;if(j|0){c[i>>2]=f;c[i+4>>2]=57;c[i+8>>2]=e;c[i+12>>2]=57;c[b>>2]=3820;c[b+4>>2]=3;c[b+8>>2]=5264;c[b+12>>2]=2;c[b+16>>2]=i;c[b+20>>2]=2;we(b,3844);}b=c[h>>2]|0;wa(0)|0;if(!b)ve(9791,26,3860);else k=b;}else k=d;b=c[a>>2]|0;if(!b)c[a>>2]=k;if(!b){l=m;return k|0}wa(k|0)|0;k=b;l=m;return k|0}function $g(b){b=b|0;b=b+4|0;if((a[b>>0]|0)==3)return;ah(b);return}function ah(a){a=a|0;var b=0,e=0,f=0;if((d[a>>0]|0)<2)return;e=a+4|0;f=c[e>>2]|0;a=f+4|0;n=0;Z(c[c[a>>2]>>2]|0,c[f>>2]|0);b=n;n=0;if(b&1){b=na()|0;bh(c[f>>2]|0,c[a>>2]|0);ch(c[e>>2]|0);za(b|0);}a=c[a>>2]|0;b=c[a+4>>2]|0;if(b|0)Zb(c[f>>2]|0,b,c[a+8>>2]|0);Zb(c[e>>2]|0,12,4);return}function bh(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function ch(a){a=a|0;Zb(a,12,4);return}function dh(a){a=a|0;var b=0,d=0;b=c[a>>2]|0;if(!b)return;d=a+4|0;n=0;Z(c[c[d>>2]>>2]|0,b|0);b=n;n=0;if(b&1){b=na()|0;eh(c[a>>2]|0,c[d>>2]|0);za(b|0);}d=c[d>>2]|0;b=c[d+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,c[d+8>>2]|0);return}function eh(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function fh(a){a=a|0;if(!(c[a>>2]|0))return;ah(a+4|0);return}function gh(b){b=b|0;b=c[b+4>>2]|0;a[b>>0]=0;a[b+1>>0]=0;a[b+2>>0]=0;a[b+3>>0]=0;return}function hh(a,b){a=a|0;b=b|0;var c=0;a=l;l=l+16|0;c=a;ui(c,b,10237,11);b=Ri(c)|0;l=a;return b|0}function ih(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0;i=l;l=l+16|0;m=i;gb[c[b+4>>2]&63](m);q=c[m>>2]|0;p=c[m+4>>2]|0;m=c[m+8>>2]|0;j=d[e>>0]|d[e+1>>0]<<8|d[e+2>>0]<<16|d[e+3>>0]<<24;g=e+4|0;o=e+8|0;h=d[o>>0]|d[o+1>>0]<<8|d[o+2>>0]<<16|d[o+3>>0]<<24;k=e+12|0;b=d[k>>0]|d[k+1>>0]<<8|d[k+2>>0]<<16|d[k+3>>0]<<24;a[e>>0]=1;a[e+1>>0]=0;a[e+2>>0]=0;a[e+3>>0]=0;a[g>>0]=q;a[g+1>>0]=q>>8;a[g+2>>0]=q>>16;a[g+3>>0]=q>>24;a[o>>0]=p;a[o+1>>0]=p>>8;a[o+2>>0]=p>>16;a[o+3>>0]=p>>24;a[k>>0]=m;a[k+1>>0]=m>>8;a[k+2>>0]=m>>16;a[k+3>>0]=m>>24;if(j|0?(f=h,h|0):0){n=0;Z(c[b>>2]|0,f|0);q=n;n=0;if(q&1){q=na()|0;eh(f,b);za(q|0);}f=c[b+4>>2]|0;if(f|0)Zb(h,f,c[b+8>>2]|0);}if((c[e>>2]|0)==1){l=i;return g|0}else $i(3876);return 0}function jh(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;i=l;l=l+64|0;b=i;e=i+48|0;f=i+32|0;g=fb[c[a>>2]&7]()|0;if(!g)Ue(10081,57);h=g+4|0;do if((c[h>>2]|0)==3){gb[c[a+4>>2]&63](f);c[b>>2]=c[g>>2];c[b+4>>2]=c[g+4>>2];c[b+8>>2]=c[g+8>>2];c[b+12>>2]=c[g+12>>2];c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];if((c[e+4>>2]&2|0)==0?(d=e+12|0,e=c[d>>2]|0,f=c[e>>2]|0,c[e>>2]=f-1,(f|0)==1):0)Te(d);if((c[h>>2]|0)==3)$i(3876);else break}while(0);a=c[g>>2]|0;if((a|0)==-1)_e(9983,24);h=c[h>>2]|0;c[g>>2]=a;if((h|0)==2){l=i;return}else ve(10199,38,3924);}function kh(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0;m=l;l=l+16|0;j=m+8|0;g=m;f=fb[c[b>>2]&7]()|0;if(!f)Ue(10081,57);if((c[f>>2]|0)==1)k=f+4|0;else k=ih(b,f)|0;i=e;h=i;h=d[h>>0]|d[h+1>>0]<<8|d[h+2>>0]<<16|d[h+3>>0]<<24;i=i+4|0;i=d[i>>0]|d[i+1>>0]<<8|d[i+2>>0]<<16|d[i+3>>0]<<24;a[e>>0]=0;a[e+1>>0]=0;a[e+2>>0]=0;a[e+3>>0]=0;e=g;c[e>>2]=h;c[e+4>>2]=i;if(c[k>>2]|0){n=0;_(23,9967,16);n=0;m=na()|0;dh(g);za(m|0);}a[k>>0]=-1;a[k+1>>0]=-1>>8;a[k+2>>0]=-1>>16;a[k+3>>0]=-1>>24;e=k+4|0;c[j>>2]=e;c[j+4>>2]=k;b=c[e>>2]|0;if(!b){j=e;g=j;c[g>>2]=h;j=j+4|0;c[j>>2]=i;a[k>>0]=0;a[k+1>>0]=0;a[k+2>>0]=0;a[k+3>>0]=0;l=m;return}f=k+8|0;n=0;Z(c[c[f>>2]>>2]|0,b|0);g=n;n=0;if(g&1){m=na()|0;eh(c[e>>2]|0,c[f>>2]|0);k=e;c[k>>2]=h;c[k+4>>2]=i;gh(j);za(m|0);}b=c[f>>2]|0;f=c[b+4>>2]|0;if(!f){j=e;g=j;c[g>>2]=h;j=j+4|0;c[j>>2]=i;a[k>>0]=0;a[k+1>>0]=0;a[k+2>>0]=0;a[k+3>>0]=0;l=m;return}Zb(c[e>>2]|0,f,c[b+8>>2]|0);j=e;g=j;c[g>>2]=h;j=j+4|0;c[j>>2]=i;a[k>>0]=0;a[k+1>>0]=0;a[k+2>>0]=0;a[k+3>>0]=0;l=m;return}function lh(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0;o=l;l=l+112|0;m=o+32|0;h=o+96|0;i=o+80|0;p=o+16|0;j=o;e=o+64|0;c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];c[e+8>>2]=c[d+8>>2];n=0;k=Y(c[b>>2]|0)|0;f=n;n=0;if(f&1){p=na()|0;oh(e);za(p|0);}if(!k){d=e+8|0;q=c[d>>2]|0;f=c[q>>2]|0;c[q>>2]=f-1;if((f|0)==1){Te(d);Ue(10081,57);}else Ue(10081,57);};c[j>>2]=c[e>>2];c[j+4>>2]=c[e+4>>2];c[j+8>>2]=c[e+8>>2];f=k+4|0;a:do if((c[f>>2]|0)==3){n=0;Z(c[b+4>>2]|0,i|0);q=n;n=0;do if(!(q&1)){c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[m+8>>2]=c[k+8>>2];c[m+12>>2]=c[k+12>>2];c[k>>2]=c[i>>2];c[k+4>>2]=c[i+4>>2];c[k+8>>2]=c[i+8>>2];c[k+12>>2]=c[i+12>>2];c[h>>2]=c[m>>2];c[h+4>>2]=c[m+4>>2];c[h+8>>2]=c[m+8>>2];c[h+12>>2]=c[m+12>>2];if(((c[h+4>>2]&2|0)==0?(g=h+12|0,i=c[g>>2]|0,q=c[i>>2]|0,c[i>>2]=q-1,(q|0)==1):0)?(n=0,Z(50,g|0),q=n,n=0,q&1):0)break;if((c[f>>2]|0)==3){n=0;Z(44,3876);n=0;break}else break a}while(0);q=na()|0;oh(j);za(q|0);}while(0);h=j;i=c[h+4>>2]|0;q=c[j+8>>2]|0;j=p;c[j>>2]=c[h>>2];c[j+4>>2]=i;c[p+8>>2]=q;if(c[k>>2]|0){n=0;_(23,9967,16);n=0;d=na()|0;n=0;Z(61,p|0);q=n;n=0;if(!(q&1)){q=d;za(q|0);}q=na()|0;za(q|0);}c[k>>2]=-1;c[m>>2]=f;e=m+4|0;c[e>>2]=k;if((c[f>>2]|0)==2){c[f>>2]=c[p>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];q=c[e>>2]|0;a[q>>0]=0;a[q+1>>0]=0;a[q+2>>0]=0;a[q+3>>0]=0;l=o;return}d=k+12|0;k=c[d>>2]|0;q=c[k>>2]|0;c[k>>2]=q-1;if((q|0)!=1){c[f>>2]=c[p>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];q=c[e>>2]|0;a[q>>0]=0;a[q+1>>0]=0;a[q+2>>0]=0;a[q+3>>0]=0;l=o;return};n=0;Z(50,d|0);q=n;n=0;if(!(q&1)){c[f>>2]=c[p>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];q=c[e>>2]|0;a[q>>0]=0;a[q+1>>0]=0;a[q+2>>0]=0;a[q+3>>0]=0;l=o;return}q=na()|0;c[f>>2]=c[p>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];mh(m);za(q|0);}function mh(b){b=b|0;b=c[b+4>>2]|0;a[b>>0]=0;a[b+1>>0]=0;a[b+2>>0]=0;a[b+3>>0]=0;return}function nh(a){a=a|0;var b=0,d=0;if((c[a>>2]|0)==2)return;a=a+8|0;d=c[a>>2]|0;b=c[d>>2]|0;c[d>>2]=b-1;if((b|0)!=1)return;Te(a);return}function oh(a){a=a|0;var b=0,d=0;a=a+8|0;d=c[a>>2]|0;b=c[d>>2]|0;c[d>>2]=b-1;if((b|0)!=1)return;Te(a);return}function ph(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,o=0;m=l;l=l+80|0;i=m;f=m+64|0;e=m+48|0;g=m+32|0;k=fb[c[b>>2]&7]()|0;if(!k){k=0;l=m;return k|0}j=k+4|0;do if((c[j>>2]|0)==3){gb[c[b+4>>2]&63](e);c[i>>2]=c[k>>2];c[i+4>>2]=c[k+4>>2];c[i+8>>2]=c[k+8>>2];c[i+12>>2]=c[k+12>>2];c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[f>>2]=c[i>>2];c[f+4>>2]=c[i+4>>2];c[f+8>>2]=c[i+8>>2];c[f+12>>2]=c[i+12>>2];if((c[f+4>>2]&2|0)==0?(d=f+12|0,o=c[d>>2]|0,b=c[o>>2]|0,c[o>>2]=b-1,(b|0)==1):0)Te(d);if((c[j>>2]|0)==3)$i(3876);else break}while(0);b=c[k>>2]|0;do if((b|0)==-1){n=0;_(28,9983,24);n=0;}else {o=c[j>>2]|0;c[k>>2]=b;if((o|0)==2){c[e>>2]=0;n=0;b=$(14,e|0)|0;o=n;n=0;if(o&1)break;c[g>>2]=0;c[g+8>>2]=b;if(c[k>>2]|0){n=0;_(23,9967,16);n=0;o=na()|0;nh(g);za(o|0);}c[k>>2]=-1;c[f>>2]=j;b=f+4|0;c[b>>2]=k;if(((c[j>>2]|0)!=2?(h=k+12|0,e=c[h>>2]|0,o=c[e>>2]|0,c[e>>2]=o-1,(o|0)==1):0)?(n=0,Z(50,h|0),o=n,n=0,o&1):0){o=na()|0;c[j>>2]=c[g>>2];c[j+4>>2]=c[g+4>>2];c[j+8>>2]=c[g+8>>2];mh(f);za(o|0);};c[j>>2]=c[g>>2];c[j+4>>2]=c[g+4>>2];c[j+8>>2]=c[g+8>>2];b=c[b>>2]|0;a[b>>0]=0;a[b+1>>0]=0;a[b+2>>0]=0;a[b+3>>0]=0;b=c[k>>2]|0;}if(b|0){n=0;_(23,9967,16);n=0;o=na()|0;za(o|0);}c[k>>2]=-1;c[i>>2]=j;c[i+4>>2]=k;if((c[j>>2]|0)==2){n=0;Z(44,3876);n=0;o=na()|0;mh(i);za(o|0);}b=k+12|0;j=c[b>>2]|0;o=c[j>>2]|0;c[j>>2]=o+1;if((o|0)<0)Za();o=c[b>>2]|0;c[k>>2]=0;l=m;return o|0}while(0);o=na()|0;za(o|0);return 0}function qh(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;s=l;l=l+32|0;p=s;q=s+8|0;a:do if(f|0){r=q+4|0;d=0;b:while(1){o=(f|0)>-1?f:2147483647;g=d;while(1){d=dk(2,e,o)|0;if((d|0)==-1){i=1;d=0;m=c[(Bj()|0)>>2]|0;}else {i=0;m=g;}c[q>>2]=i;h=r;c[h>>2]=d;c[h+4>>2]=m;h=d&255;j=m;k=m;if((i|0)!=1)break;g=kk(d|0,m|0,8)|0;switch(d&3){case 0:{if((m|0)!=4){u=12;break b}break}case 1:{t=g&255;u=18;break}case 2:{t=a[j+8>>0]|0;u=18;break}default:{u=15;break b}}if((u|0)==18?(u=0,t<<24>>24!=15):0){u=12;break b}if((h&255)>=2){d=m;g=j+4|0;n=0;Z(c[c[g>>2]>>2]|0,c[d>>2]|0);i=n;n=0;if(i&1){u=25;break b}d=c[g>>2]|0;g=c[d+4>>2]|0;if(g|0)Zb(c[m>>2]|0,g,c[d+8>>2]|0);Zb(k,12,4);}g=m;}if(!d){u=9;break}if(f>>>0<d>>>0){u=11;break}f=f-d|0;if(!f)break a;else {e=e+d|0;d=m;}}do if((u|0)==9){n=0;ea(8,p|0,14,10248,28);u=n;n=0;if(u&1){u=na()|0;fh(q);za(u|0);}else {r=p;t=c[r+4>>2]|0;u=b;c[u>>2]=c[r>>2];c[u+4>>2]=t;break}}else if((u|0)==11){n=0;_(8,d|0,f|0);n=0;u=na()|0;fh(q);za(u|0);}else if((u|0)==12){u=b;c[u>>2]=d;c[u+4>>2]=m;}else if((u|0)!=15)if((u|0)==25){u=na()|0;bh(c[d>>2]|0,c[g>>2]|0);ch(j);za(u|0);}while(0);l=s;return}while(0);a[b>>0]=3;l=s;return}function rh(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=l;l=l+48|0;f=h;i=h+24|0;g=h+8|0;c[g>>2]=d;d=g+4|0;a[d>>0]=3;c[i>>2]=c[e>>2];c[i+4>>2]=c[e+4>>2];c[i+8>>2]=c[e+8>>2];c[i+12>>2]=c[e+12>>2];c[i+16>>2]=c[e+16>>2];c[i+20>>2]=c[e+20>>2];n=0;e=W(10,g|0,3900,i|0)|0;i=n;n=0;if(i&1){i=na()|0;$g(g);za(i|0);}do if(e){d=g+4|0;if((a[d>>0]|0)!=3){f=d;g=c[f+4>>2]|0;i=b;c[i>>2]=c[f>>2];c[i+4>>2]=g;l=h;return}n=0;ea(8,f|0,16,10138,15);i=n;n=0;if(i&1){i=na()|0;$g(g);za(i|0);}else {e=f;f=c[e+4>>2]|0;i=b;c[i>>2]=c[e>>2];c[i+4>>2]=f;break}}else a[b>>0]=3;while(0);switch(a[d>>0]&3){case 0:case 1:case 3:{l=h;return}default:{}}b=g+8|0;f=c[b>>2]|0;d=f+4|0;n=0;Z(c[c[d>>2]>>2]|0,c[f>>2]|0);i=n;n=0;if(i&1){i=na()|0;bh(c[f>>2]|0,c[d>>2]|0);ch(c[b>>2]|0);za(i|0);}d=c[d>>2]|0;e=c[d+4>>2]|0;if(e|0)Zb(c[f>>2]|0,e,c[d+8>>2]|0);Zb(c[b>>2]|0,12,4);l=h;return}function sh(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;O=l;l=l+80|0;i=O;N=O+64|0;Ni(i,d,e,f,g);K=c[i>>2]|0;do if((K|0)==1){d=i+8|0;e=c[i+48>>2]|0;f=c[i+52>>2]|0;g=c[i+56>>2]|0;h=c[i+60>>2]|0;if((c[i+36>>2]|0)==-1){th(N,d,e,f,g,h,1);break}else {th(N,d,e,f,g,h,0);break}}else {M=i+28|0;C=i+48|0;D=i+52|0;L=i+36|0;E=i+56|0;F=i+60|0;G=i+8|0;H=i+16|0;I=i+24|0;J=i+12|0;B=i+4|0;d=0;a:while(1){if((d|0)==1){A=c[D>>2]|0;g=c[C>>2]|0;o=c[E>>2]|0;x=c[F>>2]|0;p=x+-1|0;r=G;q=c[r>>2]|0;r=c[r+4>>2]|0;s=c[H>>2]|0;f=c[I>>2]|0;t=x-f|0;e=c[M>>2]|0;h=c[L>>2]|0;if((e|0)==(A|0)){f=56;break}z=(h|0)==-1;i=p+e|0;b:do if(i>>>0<A>>>0){d=x+e|0;u=d+p|0;v=u>>>0<A>>>0;w=1-s+e|0;k=e+f|0;m=k+p|0;n=m>>>0<A>>>0;f=e;while(1){c:while(1){while(1){if((e|0)!=(f|0)){e=h;break b}j=nk(1,0,a[g+i>>0]&63|0)|0;if(!((j&q|0)==0&(y&r|0)==0))break;h=z?h:0;if(v){f=d;i=u;}else {f=A;e=h;break b}}f=z?s:h>>>0>=s>>>0?h:s;while(1){if(f>>>0>=x>>>0)break c;if(f>>>0>4294967294)break c;i=f+e|0;if(i>>>0>=A>>>0){f=40;break a}if((a[o+f>>0]|0)==(a[g+i>>0]|0))f=f+1|0;else break}f=w+f|0;h=z?h:0;i=f+p|0;if(i>>>0>=A>>>0){f=A;e=h;break b}}f=z?0:h;i=s;do{j=i;i=i+-1|0;if(f>>>0>=j>>>0){f=44;break a}if(i>>>0>=x>>>0){f=51;break a}j=i+e|0;if(j>>>0>=A>>>0){f=47;break a}}while((a[o+i>>0]|0)==(a[g+j>>0]|0));h=z?h:t;if(n){f=k;i=m;}else {f=A;e=h;break}}}else {f=A;e=h;}while(0);d:do if((f|0)==0|(A|0)==(f|0))d=f;else {d=f;do{if(A>>>0>d>>>0?(a[g+d>>0]|0)>-65:0)break d;d=d+1|0;}while(!((d|0)==0|(A|0)==(d|0)))}while(0);c[M>>2]=f>>>0>=d>>>0?f:d;c[L>>2]=e;e=A;}else {e=c[D>>2]|0;g=c[C>>2]|0;}j=(a[J>>0]|0)!=0;a[J>>0]=(j^1)&1;k=c[B>>2]|0;if(!((k|0)==0|(e|0)==(k|0))){if(e>>>0<=k>>>0){f=8;break}d=g+k|0;if((a[d>>0]|0)<=-65){f=8;break}}else d=g+k|0;i=g+k+(e-k)|0;A=(d|0)==(i|0);e=A?d:g+k+1|0;do if(!A){g=a[d>>0]|0;if(g<<24>>24>-1){d=g&255;break}h=g&31;if((e|0)==(i|0)){d=0;f=i;}else {d=a[e>>0]&63;f=e+1|0;}e=d&255;d=e|h<<6;if((g&255)>223){if((f|0)==(i|0)){d=0;f=i;}else {d=a[f>>0]&63;f=f+1|0;}e=d&255|e<<6;d=e|h<<12;if((g&255)>239){if((f|0)==(i|0))d=0;else d=a[f>>0]&63;d=e<<6|h<<18&1835008|d&255;}}}else d=1114112;while(0);if(j){e=k;d=k;f=58;break}if((d|0)==1114112){f=57;break}c[B>>2]=(d>>>0<128?1:d>>>0<2048?2:d>>>0<65536?3:4)+k;d=K;}if((f|0)==8)Ii(g,e,k,e);else if((f|0)==40)bj(3956,i,A);else if((f|0)==44){c[L>>2]=h;c[M>>2]=d;if(z)f=58;else {c[L>>2]=0;f=58;}}else if((f|0)==47)bj(3956,j,A);else if((f|0)==51)bj(3972,i,x);else if((f|0)==56){c[M>>2]=A;f=57;}if((f|0)==57){c[N>>2]=0;break}else if((f|0)==58){c[N>>2]=1;c[N+4>>2]=e;c[N+8>>2]=d;break}}while(0);if((c[N>>2]|0)!=1){N=0;c[b>>2]=N;l=O;return}c[b+4>>2]=c[N+4>>2];N=1;c[b>>2]=N;l=O;return}function th(b,d,e,f,g,h,i){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;t=d+20|0;r=h+-1|0;k=c[t>>2]|0;j=k+r|0;a:do if(j>>>0<f>>>0){s=d+28|0;p=d;o=c[p>>2]|0;p=c[p+4>>2]|0;q=c[d+8>>2]|0;m=c[d+16>>2]|0;n=h-m|0;d=k;b:while(1){c:while(1){l=d;while(1){k=nk(1,0,a[e+j>>0]&63|0)|0;if(!((k&o|0)==0&(y&p|0)==0))break;d=l+h|0;c[t>>2]=d;if(!i)c[s>>2]=0;j=d+r|0;if(j>>>0>=f>>>0)break a;else l=d;}if(i)d=q;else {d=c[s>>2]|0;d=d>>>0>=q>>>0?d:q;}do{if(d>>>0>=h>>>0)break c;j=d;d=d+1|0;if(j>>>0>4294967294)break c;k=l+j|0;if(k>>>0>=f>>>0){d=17;break b}}while((a[g+j>>0]|0)==(a[e+k>>0]|0));d=d+l-q|0;c[t>>2]=d;if(!i)c[s>>2]=0;j=d+r|0;if(j>>>0>=f>>>0)break a}d=i?0:c[s>>2]|0;j=q;do{k=j;j=j+-1|0;if(d>>>0>=k>>>0){d=23;break b}if(j>>>0>=h>>>0){d=33;break b}k=j+l|0;if(k>>>0>=f>>>0){d=26;break b}}while((a[g+j>>0]|0)==(a[e+k>>0]|0));d=m+l|0;c[t>>2]=d;if(!i)c[s>>2]=n;j=d+r|0;if(j>>>0>=f>>>0)break a}if((d|0)==17)bj(3956,k,f);else if((d|0)==23){d=l+h|0;c[t>>2]=d;if(!i)c[s>>2]=0;c[b>>2]=1;c[b+4>>2]=l;c[b+8>>2]=d;return}else if((d|0)==26)bj(3956,k,f);else if((d|0)==33)bj(3972,j,h);}while(0);c[t>>2]=f;c[b>>2]=0;return}function uh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;i=l;l=l+32|0;g=i+12|0;h=i;d=c[(c[c[b>>2]>>2]|0)+(d<<2)>>2]|0;e=Hj(d)|0;if((e|0)==-1)kj(-1,0);if((e|0)<0)$i(3740);if(e){b=Xb(e,1,g)|0;if(!b){c[g>>2]=0;Yb(g);}else f=b;}else f=1;c[h>>2]=f;c[h+4>>2]=e;b=h+8|0;c[b>>2]=0;n=0;aa(23,h|0,0,e|0);g=n;n=0;if(g&1){i=na()|0;vh(h);za(i|0);}else {g=c[b>>2]|0;c[b>>2]=g+e;ok((c[h>>2]|0)+g|0,d|0,e|0)|0;c[a>>2]=c[h>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];l=i;return}}function vh(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function wh(a){a=a|0;var b=0,d=0,e=0;b=c[a>>2]|0;d=c[a+8>>2]|0;e=b+(d*12|0)|0;if(d|0)do{d=c[b+4>>2]|0;if(d|0)Zb(c[b>>2]|0,d,1);b=b+12|0;}while((b|0)!=(e|0));b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b*12|0,4);return}function xh(a){a=a|0;var b=0,d=0,e=0,f=0;f=c[a>>2]|0;if(!f)return;b=c[f>>2]|0;d=c[f+8>>2]|0;e=b+(d*12|0)|0;if(d|0)do{d=c[b+4>>2]|0;if(d|0)Zb(c[b>>2]|0,d,1);b=b+12|0;}while((b|0)!=(e|0));b=c[f+4>>2]|0;if(b|0)Zb(c[f>>2]|0,b*12|0,4);Zb(c[a>>2]|0,12,4);return}function yh(a,b){a=a|0;b=b|0;return yi(10417,25,b)|0}function zh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=l;l=l+32|0;d=f+16|0;e=f;g=f+12|0;c[g>>2]=b;c[d>>2]=0;c[d+4>>2]=a;c[d+8>>2]=g;Jg(e,d);ik(15864)|0;if(c[3965]|0){n=0;aa(21,10313,34,3940);n=0;g=na()|0;wh(e);za(g|0);}a=Xb(12,4,d)|0;if(!a)Yb(d);else {c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[3965]=a;mk(15864)|0;l=f;return}}function Ah(a,b){a=a|0;b=b|0;a=l;l=l+16|0;c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];Bh(0,a);}function Bh(a,b){a=a|0;b=b|0;var d=0,e=0;d=l;l=l+32|0;e=d+24|0;a=d;c[e>>2]=b;c[e+4>>2]=61;c[a>>2]=3988;c[a+4>>2]=2;c[a+8>>2]=5180;c[a+12>>2]=1;c[a+16>>2]=e;c[a+20>>2]=1;Dh(d+32|0,a)|0;Za();}function Ch(a){a=a|0;return}function Dh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=a;c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,4004,e)|0;l=d;return b|0}function Eh(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+16|0;b=j;c[b>>2]=0;if(d>>>0<128){a[b>>0]=d;d=1;dk(2,b,d)|0;l=j;return 0}do if(d>>>0>=2048)if(d>>>0<65536){a[b>>0]=d>>>12&15|-32;e=63;f=1;g=-128;h=2;i=3;break}else {a[b>>0]=d>>>18&255|-16;a[b+1>>0]=d>>>12&63|-128;e=63;f=2;g=-128;h=3;i=4;break}else {e=31;f=0;g=-64;h=1;i=2;}while(0);a[b+f>>0]=e&d>>>6&255|g;a[b+h>>0]=d&63|-128;d=i;dk(2,b,d)|0;l=j;return 0}function Fh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=c[a>>2];c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,4004,e)|0;l=d;return b|0}function Gh(a,b,c){a=a|0;b=b|0;c=c|0;dk(2,b,c)|0;return 0}function Hh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;n=0;Z(a|0,b|0);b=n;n=0;if(!(b&1)){e=0;return e|0}a=Da(0)|0;if(!a){n=0;Z(44,4028);n=0;na()|0;Za();}f=c[a>>2]|0;b=c[a+4>>2]|0;va(a|0);c[d>>2]=f;c[e>>2]=b;e=1;return e|0}function Ih(a,b){a=a|0;b=b|0;return Lh(a,b)|0}function Jh(a,b){a=a|0;b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)return;Zb(a,d,c[b+8>>2]|0);return}function Kh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return la(a|0,b|0,c|0,d|0,e|0,f|0)|0}function Lh(a,b){a=a|0;b=b|0;var d=0;d=xa(8)|0;if(d|0){c[d>>2]=a;c[d+4>>2]=b;Ua(d|0,0,0);}n=0;Z(c[b>>2]|0,a|0);d=n;n=0;if(d&1){d=na()|0;Jh(a,b);za(d|0);}d=c[b+4>>2]|0;if(!d)return 3;Zb(a,d,c[b+8>>2]|0);return 3}function Mh(a,b){a=a|0;b=b|0;var d=0,e=0;e=l;l=l+16|0;d=e;do switch(c[a>>2]&15){case 0:{vi(d,b,10573,14);d=Ti(d)|0;l=e;return d|0}case 1:{vi(d,b,10587,29);d=Ti(d)|0;l=e;return d|0}case 2:{vi(d,b,10616,23);d=Ti(d)|0;l=e;return d|0}case 3:{vi(d,b,10639,23);d=Ti(d)|0;l=e;return d|0}case 4:{vi(d,b,10662,16);d=Ti(d)|0;l=e;return d|0}case 5:{vi(d,b,10678,17);d=Ti(d)|0;l=e;return d|0}case 6:{vi(d,b,10695,18);d=Ti(d)|0;l=e;return d|0}case 7:{vi(d,b,10713,20);d=Ti(d)|0;l=e;return d|0}case 8:{vi(d,b,10733,20);d=Ti(d)|0;l=e;return d|0}case 9:{vi(d,b,10753,12);d=Ti(d)|0;l=e;return d|0}default:{}}while(0);return 0}function Nh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=l;l=l+16|0;f=e;Qh(f,b,d);c[a>>2]=c[f>>2];c[a+4>>2]=c[f+4>>2];c[a+8>>2]=c[f+8>>2];l=e;return}function Oh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=l;l=l+16|0;f=e;Qh(f,b,d);c[a>>2]=c[f>>2];c[a+4>>2]=c[f+4>>2];c[a+8>>2]=c[f+8>>2];l=e;return}function Ph(a){a=a|0;var b=0;b=c[a+4>>2]|0;if(!b)return;Zb(c[a>>2]|0,b,1);return}function Qh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;i=l;l=l+32|0;e=i+12|0;h=i;if((d|0)<0)$i(4084);if(d){f=Xb(d,1,e)|0;if(!f){c[e>>2]=0;Yb(e);}else g=f;}else g=1;c[h>>2]=g;c[h+4>>2]=d;e=h+8|0;c[e>>2]=0;n=0;aa(28,h|0,0,d|0);g=n;n=0;if(g&1){i=na()|0;Ph(h);za(i|0);}else {g=c[e>>2]|0;c[e>>2]=g+d;ok((c[h>>2]|0)+g|0,b|0,d|0)|0;c[a>>2]=c[h>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];l=i;return}}function Rh(a,b){a=a|0;b=b|0;return zi(c[a>>2]|0,c[a+4>>2]|0,b)|0}function Sh(a,b){a=a|0;b=b|0;c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];return}function Th(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=l;l=l+48|0;g=d+32|0;f=d+24|0;e=d;a=(c[a>>2]|0)!=1;c[g>>2]=a?10765:10791;c[g+4>>2]=a?26:29;c[f>>2]=g;c[f+4>>2]=62;c[e>>2]=4076;c[e+4>>2]=1;c[e+8>>2]=5180;c[e+12>>2]=1;c[e+16>>2]=f;c[e+20>>2]=1;b=si(b,e)|0;l=d;return b|0}function Uh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+16|0;h=j;i=a+4|0;e=c[i>>2]|0;if((e-b|0)>>>0>=d>>>0){l=j;return}d=b+d|0;if(d>>>0<b>>>0)cj(10820,17);g=e<<1;g=d>>>0>=g>>>0?d:g;if((g|0)<0)$i(4084);if(!e){b=Xb(g,1,h)|0;d=(b|0)==0&1;e=0;f=0;}else {b=_b(c[a>>2]|0,e,1,g,1,h)|0;e=(b|0)==0;f=h+4|0;d=e&1;b=e?c[h>>2]|0:b;e=c[f>>2]|0;f=c[f+4>>2]|0;}if((d|0)==1){c[h>>2]=b;d=h+4|0;c[d>>2]=e;c[d+4>>2]=f;Yb(h);}c[a>>2]=b;c[i>>2]=g;l=j;return}function Vh(a){a=a|0;return Zh(a,168)|0}function Wh(a,b,d){a=a|0;b=b|0;d=d|0;c[a>>2]=b;c[a+4>>2]=d;return}function Xh(a,b,d){a=a|0;b=b|0;d=d|0;c[a>>2]=b;c[a+4>>2]=d;return}function Yh(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;m=d+4|0;n=c[m>>2]|0;if(!n){c[b>>2]=0;return}s=c[d>>2]|0;e=0;a:while(1){k=s+e|0;i=a[k>>0]|0;f=e+1|0;b:do if(i<<24>>24>-1)e=f;else switch(a[11498+(i&255)>>0]|0){case 2:{if(n>>>0<=f>>>0){u=15;break a}if((a[s+f>>0]&-64)<<24>>24!=-128){u=15;break a}e=e+2|0;break b}case 3:{if(n>>>0<=f>>>0){u=15;break a}g=a[s+f>>0]|0;h=(g&255)<192;if(((!(i<<24>>24==-32&(g&-32)<<24>>24==-96)?(j=g<<24>>24<0,!(h&((i+31&255)<12&j))):0)?!((g&255)<160&(i<<24>>24==-19&j)):0)?!(h&((i&-2)<<24>>24==-18&j)):0){u=15;break a}f=e+2|0;if(n>>>0<=f>>>0){u=15;break a}if((a[s+f>>0]&-64)<<24>>24!=-128){u=15;break a}e=e+3|0;break b}case 4:{if(n>>>0<=f>>>0){u=15;break a}g=a[s+f>>0]|0;if((!(i<<24>>24==-16&(g+112&255)<48)?(l=g<<24>>24<0,!((g&255)<192&((i+15&255)<3&l))):0)?!((g&255)<144&(i<<24>>24==-12&l)):0){u=15;break a}f=e+2|0;if(n>>>0<=f>>>0){u=15;break a}if((a[s+f>>0]&-64)<<24>>24!=-128){u=15;break a}f=e+3|0;if(n>>>0<=f>>>0){u=15;break a}if((a[s+f>>0]&-64)<<24>>24!=-128){u=15;break a}e=e+4|0;break b}default:{u=15;break a}}while(0);if(e>>>0>=n>>>0){o=16465;p=0;q=n;r=16465;t=0;break}}do if((u|0)==15){if(n>>>0<e>>>0)kj(e,n);if(f>>>0<e>>>0)lj(e,f);if(n>>>0<f>>>0)kj(f,n);else {o=s+f|0;p=n-f|0;q=e;r=k;t=f-e|0;break}}while(0);c[d>>2]=o;c[m>>2]=p;c[b>>2]=s;c[b+4>>2]=q;c[b+8>>2]=r;c[b+12>>2]=t;return}function Zh(a,b){a=a|0;b=b|0;var e=0,f=0,g=0;do if(a>>>0>=2048){if(a>>>0<65536){e=(a>>>6)+-32|0;if(e>>>0>=992)bj(4108,e,992);e=d[b+280+e>>0]|0;f=c[b+260>>2]|0;if(e>>>0<f>>>0){g=(c[b+256>>2]|0)+(e<<3)|0;break}else bj(4124,e,f);}e=(a>>>12)+-16|0;if(e>>>0>=256)bj(4108,e,256);f=c[b+268>>2]|0;e=(d[b+1272+e>>0]|0)<<6|a>>>6&63;if(e>>>0>=f>>>0)bj(4108,e,f);e=d[(c[b+264>>2]|0)+e>>0]|0;f=c[b+276>>2]|0;if(e>>>0<f>>>0){g=(c[b+272>>2]|0)+(e<<3)|0;break}else bj(4140,e,f);}else g=b+(a>>>6<<3)|0;while(0);f=c[g>>2]|0;g=c[g+4>>2]|0;b=nk(1,0,a&63|0)|0;return (f&b|0)!=0|(g&y|0)!=0|0}function _h(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+128|0;i=j;g=c[b>>2]|0;b=i;e=b+128|0;do{a[b>>0]=0;b=b+1|0;}while((b|0)<(e|0));f=128;h=i+128|0;e=g;while(1){h=h+-1|0;b=e&15;e=e>>>4;a[h>>0]=((b&255)<10?48:87)+b<<24>>24;b=f+-1|0;if(!e)break;else f=b;}if(b>>>0>128)lj(b,128);else {i=oi(d,1,11390,2,i+b|0,129-f|0)|0;l=j;return i|0}return 0}function $h(a,b){a=a|0;b=b|0;return ai(a,b)|0}function ai(d,e){d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0;j=l;l=l+48|0;i=j;d=c[d>>2]|0;if(d>>>0>9999){h=39;g=d;while(1){k=(g>>>0)%1e4|0;d=(g>>>0)/1e4|0;f=h+-4|0;m=i+f|0;n=b[4156+(((k>>>0)/100|0)<<1)>>1]|0;a[m>>0]=n;a[m+1>>0]=n>>8;h=i+(h+-2)|0;k=b[4156+(((k>>>0)%100|0)<<1)>>1]|0;a[h>>0]=k;a[h+1>>0]=k>>8;if(g>>>0>99999999){h=f;g=d;}else break}}else f=39;if((d|0)>99){f=f+-2|0;n=i+f|0;m=b[4156+(((d>>>0)%100|0)<<1)>>1]|0;a[n>>0]=m;a[n+1>>0]=m>>8;d=(d>>>0)/100|0;}if((d|0)<10){n=f+-1|0;a[i+n>>0]=(d&255)+48<<24>>24;m=i+n|0;n=39-n|0;n=oi(e,1,16465,0,m,n)|0;l=j;return n|0}else {n=f+-2|0;m=i+n|0;k=b[4156+(d<<1)>>1]|0;a[m>>0]=k;a[m+1>>0]=k>>8;m=i+n|0;n=39-n|0;n=oi(e,1,16465,0,m,n)|0;l=j;return n|0}return 0}function bi(b,c){b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=l;l=l+128|0;h=i;f=a[b>>0]|0;b=h;d=b+128|0;do{a[b>>0]=0;b=b+1|0;}while((b|0)<(d|0));e=128;g=h+128|0;d=f;while(1){g=g+-1|0;b=d&15;d=(d&255)>>>4;a[g>>0]=((b&255)<10?48:55)+b<<24>>24;b=e+-1|0;if(!(d<<24>>24))break;else e=b;}if(b>>>0>128)lj(b,128);else {h=oi(c,1,11390,2,h+b|0,129-e|0)|0;l=i;return h|0}return 0}function ci(c,d){c=c|0;d=d|0;var e=0,f=0,g=0,h=0;h=l;l=l+48|0;f=h;c=a[c>>0]|0;e=c&255;if((c&255)<=99)if((c&255)<10){c=38;g=4;}else {c=f+37|0;e=b[4156+(e<<1)>>1]|0;a[c>>0]=e;a[c+1>>0]=e>>8;c=37;}else {e=f+37|0;g=b[4156+(((c&255)%100|0)<<1&255)>>1]|0;a[e>>0]=g;a[e+1>>0]=g>>8;e=((c&255)/100|0)&255;c=36;g=4;}if((g|0)==4)a[f+c>>0]=(e&255)+48<<24>>24;g=oi(d,1,16465,0,f+c|0,39-c|0)|0;l=h;return g|0}function di(a,b){a=a|0;b=b|0;return ei(a,b)|0}function ei(d,e){d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0;k=l;l=l+48|0;j=k;d=c[d>>2]|0;i=(d|0)>-1;d=i?d:0-d|0;if(d>>>0>9999){h=39;g=d;while(1){m=(g>>>0)%1e4|0;f=(g>>>0)/1e4|0;d=h+-4|0;n=j+d|0;o=b[4156+(((m>>>0)/100|0)<<1)>>1]|0;a[n>>0]=o;a[n+1>>0]=o>>8;h=j+(h+-2)|0;m=b[4156+(((m>>>0)%100|0)<<1)>>1]|0;a[h>>0]=m;a[h+1>>0]=m>>8;if(g>>>0>99999999){h=d;g=f;}else break}}else {f=d;d=39;}if((f|0)>99){d=d+-2|0;o=j+d|0;n=b[4156+(((f>>>0)%100|0)<<1)>>1]|0;a[o>>0]=n;a[o+1>>0]=n>>8;f=(f>>>0)/100|0;}if((f|0)<10){o=d+-1|0;a[j+o>>0]=(f&255)+48<<24>>24;n=j+o|0;o=39-o|0;o=oi(e,i,16465,0,n,o)|0;l=k;return o|0}else {o=d+-2|0;n=j+o|0;m=b[4156+(f<<1)>>1]|0;a[n>>0]=m;a[n+1>>0]=m>>8;n=j+o|0;o=39-o|0;o=oi(e,i,16465,0,n,o)|0;l=k;return o|0}return 0}function fi(d,e){d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0;j=l;l=l+48|0;i=j;d=c[d>>2]|0;if(d>>>0>9999){h=39;g=d;while(1){k=(g>>>0)%1e4|0;d=(g>>>0)/1e4|0;f=h+-4|0;m=i+f|0;n=b[4156+(((k>>>0)/100|0)<<1)>>1]|0;a[m>>0]=n;a[m+1>>0]=n>>8;h=i+(h+-2)|0;k=b[4156+(((k>>>0)%100|0)<<1)>>1]|0;a[h>>0]=k;a[h+1>>0]=k>>8;if(g>>>0>99999999){h=f;g=d;}else break}}else f=39;if((d|0)>99){f=f+-2|0;n=i+f|0;m=b[4156+(((d>>>0)%100|0)<<1)>>1]|0;a[n>>0]=m;a[n+1>>0]=m>>8;d=(d>>>0)/100|0;}if((d|0)<10){n=f+-1|0;a[i+n>>0]=(d&255)+48<<24>>24;m=i+n|0;n=39-n|0;n=oi(e,1,16465,0,m,n)|0;l=j;return n|0}else {n=f+-2|0;m=i+n|0;k=b[4156+(d<<1)>>1]|0;a[m>>0]=k;a[m+1>>0]=k>>8;m=i+n|0;n=39-n|0;n=oi(e,1,16465,0,m,n)|0;l=j;return n|0}return 0}function gi(a){a=a|0;return}function hi(a,b,d){a=a|0;b=b|0;d=d|0;return Pi(c[a>>2]|0,b,d)|0}function ii(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=l;l=l+16|0;j=k;i=c[b>>2]|0;c[j>>2]=0;if(d>>>0<128){a[j>>0]=d;b=1;}else {do if(d>>>0>=2048)if(d>>>0<65536){a[j>>0]=d>>>12&15|-32;e=63;f=1;g=-128;h=2;b=3;break}else {a[j>>0]=d>>>18&255|-16;a[j+1>>0]=d>>>12&63|-128;e=63;f=2;g=-128;h=3;b=4;break}else {e=31;f=0;g=-64;h=1;b=2;}while(0);a[j+f>>0]=e&d>>>6&255|g;a[j+h>>0]=d&63|-128;}j=Pi(i,j,b)|0;l=k;return j|0}function ji(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=c[a>>2];c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,5092,e)|0;l=d;return b|0}function ki(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;x=l;l=l+64|0;f=x+56|0;t=x;g=c[e+16>>2]|0;u=c[e+20>>2]|0;h=g+(u<<3)|0;c[t>>2]=0;r=t+4|0;c[r>>2]=32;s=t+48|0;a[s>>0]=3;c[t+8>>2]=0;c[t+16>>2]=0;w=t+24|0;c[w>>2]=b;v=t+28|0;c[v>>2]=d;c[t+32>>2]=g;o=t+36|0;c[o>>2]=h;p=t+40|0;c[p>>2]=g;q=t+44|0;c[q>>2]=u;b=c[e>>2]|0;u=b+(c[e+4>>2]<<3)|0;c[f>>2]=b;c[f+4>>2]=u;d=c[e+8>>2]|0;do if(!d){while(1){if((g|0)==(h|0)){g=4;break}if((b|0)==(u|0)){b=u;g=4;break}s=b;b=b+8|0;if(db[c[(c[v>>2]|0)+12>>2]&15](c[w>>2]|0,c[s>>2]|0,c[s+4>>2]|0)|0){g=12;break}if(lb[c[g+4>>2]&127](c[g>>2]|0,t)|0){g=12;break}else g=g+8|0;}if((g|0)==4){c[f>>2]=b;g=6;break}else if((g|0)==12){c[f>>2]=b;break}}else {j=d+((c[e+12>>2]|0)*36|0)|0;k=t+8|0;m=t+16|0;n=t+32|0;i=d;a:while(1){if((i|0)==(j|0)){g=5;break}h=i;i=i+36|0;if((b|0)==(u|0)){b=u;g=5;break}e=b;b=b+8|0;if(db[c[(c[v>>2]|0)+12>>2]&15](c[w>>2]|0,c[e>>2]|0,c[e+4>>2]|0)|0){g=13;break}c[r>>2]=c[h+8>>2];a[s>>0]=a[h+32>>0]|0;c[t>>2]=c[h+12>>2];switch(c[h+24>>2]&3){case 0:{g=c[h+28>>2]|0;d=0;e=1;break}case 1:{e=c[h+28>>2]|0;d=c[q>>2]|0;if(e>>>0>=d>>>0){g=27;break a}g=c[p>>2]|0;if((c[g+(e<<3)+4>>2]|0)==63){g=c[c[g+(e<<3)>>2]>>2]|0;d=0;e=1;}else {g=0;d=0;e=0;}break}case 2:{g=c[n>>2]|0;if((g|0)!=(c[o>>2]|0)?(c[n>>2]=g+8,(c[g+4>>2]|0)==63):0){g=c[c[g>>2]>>2]|0;d=0;e=1;}else {g=0;d=0;e=0;}break}case 3:{g=0;d=0;e=0;break}default:{g=22;break a}}y=k;c[y>>2]=e;c[y+4>>2]=g|d;switch(c[h+16>>2]&3){case 0:{g=c[h+20>>2]|0;d=0;e=1;break}case 1:{e=c[h+20>>2]|0;d=c[q>>2]|0;if(e>>>0>=d>>>0){g=37;break a}g=c[p>>2]|0;if((c[g+(e<<3)+4>>2]|0)==63){g=c[c[g+(e<<3)>>2]>>2]|0;d=0;e=1;}else {g=0;d=0;e=0;}break}case 2:{g=c[n>>2]|0;if((g|0)!=(c[o>>2]|0)?(c[n>>2]=g+8,(c[g+4>>2]|0)==63):0){g=c[c[g>>2]>>2]|0;d=0;e=1;}else {g=0;d=0;e=0;}break}case 3:{g=0;d=0;e=0;break}default:{g=32;break a}}y=m;c[y>>2]=e;c[y+4>>2]=g|d;if((c[h>>2]|0)==1){d=c[h+4>>2]|0;e=c[q>>2]|0;if(d>>>0>=e>>>0){g=44;break}g=(c[p>>2]|0)+(d<<3)|0;}else {g=c[n>>2]|0;if((g|0)==(c[o>>2]|0)){g=40;break}c[n>>2]=g+8;}if(lb[c[g+4>>2]&127](c[g>>2]|0,t)|0){g=13;break}}if((g|0)==5){c[f>>2]=b;g=6;break}else if((g|0)==13){c[f>>2]=b;break}else if((g|0)!=22)if((g|0)==27)bj(4380,e,d);else if((g|0)!=32)if((g|0)==37)bj(4380,e,d);else if((g|0)==40)$i(4396);else if((g|0)==44)bj(4420,d,e);}while(0);do if((g|0)==6){if((b|0)!=(u|0)?(c[f>>2]=b+8,db[c[(c[v>>2]|0)+12>>2]&15](c[w>>2]|0,c[b>>2]|0,c[b+4>>2]|0)|0):0)break;y=0;l=x;return y|0}while(0);y=1;l=x;return y|0}function li(a,b){a=a|0;b=b|0;return ai(a,b)|0}function mi(a,b){a=a|0;b=b|0;c[a>>2]=b;c[a+4>>2]=63;return}function ni(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d;f=c[b+24>>2]|0;b=c[b+28>>2]|0;c[e>>2]=c[a>>2];c[e+4>>2]=c[a+4>>2];c[e+8>>2]=c[a+8>>2];c[e+12>>2]=c[a+12>>2];c[e+16>>2]=c[a+16>>2];c[e+20>>2]=c[a+20>>2];b=ki(f,b,e)|0;l=d;return b|0}function oi(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;w=l;l=l+48|0;v=w+28|0;s=w+16|0;n=w+32|0;o=w;m=w+8|0;c[m>>2]=e;c[m+4>>2]=f;c[o>>2]=1114112;if(d){d=c[b>>2]|0;if(!(d&1)){k=d;j=h;}else {c[o>>2]=43;k=d;j=h+1|0;}}else {c[o>>2]=45;k=c[b>>2]|0;j=h+1|0;}a[n>>0]=0;if(k&4){a[n>>0]=1;i=e+f|0;if(!f)d=0;else {d=0;do{d=((a[e>>0]&-64)<<24>>24==-128&1)+d|0;e=e+1|0;}while((e|0)!=(i|0))}j=j+f-d|0;}c[s>>2]=o;c[s+4>>2]=n;c[s+8>>2]=m;a:do if((c[b+8>>2]|0)==1){d=c[b+12>>2]|0;if(d>>>0<=j>>>0){if(pi(s,b)|0){u=41;break}d=db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,g,h)|0;u=38;break}if(!(k&8)){d=d-j|0;t=a[b+48>>0]|0;switch((t<<24>>24==3?1:t)&3){case 0:{q=d;p=0;break}case 3:case 1:{q=0;p=d;break}case 2:{q=(d+1|0)>>>1;p=d>>>1;break}default:{}}c[v>>2]=0;d=c[b+4>>2]|0;if(d>>>0<128){a[v>>0]=d;e=1;}else {do if(d>>>0>=2048)if(d>>>0<65536){a[v>>0]=d>>>12&15|-32;e=3;i=63;j=1;k=-128;f=2;break}else {a[v>>0]=d>>>18&255|-16;a[v+1>>0]=d>>>12&63|-128;e=4;i=63;j=2;k=-128;f=3;break}else {e=2;i=31;j=0;k=-64;f=1;}while(0);a[v+j>>0]=i&d>>>6&255|k;a[v+f>>0]=d&63|-128;}i=b+24|0;j=b+28|0;d=0;while(1){if(d>>>0>=p>>>0){u=29;break}if(d>>>0>4294967294){u=29;break}if(db[c[(c[j>>2]|0)+12>>2]&15](c[i>>2]|0,v,e)|0)break;else d=d+1|0;}b:do if(((u|0)==29?!(pi(s,b)|0):0)?!(db[c[(c[j>>2]|0)+12>>2]&15](c[i>>2]|0,g,h)|0):0){d=0;while(1){if(d>>>0>=q>>>0)break;if(d>>>0>4294967294)break;if(db[c[(c[j>>2]|0)+12>>2]&15](c[i>>2]|0,v,e)|0)break b;else d=d+1|0;}d=0;u=38;break a}while(0);d=1;u=38;break}else {e=b+4|0;c[e>>2]=48;i=b+48|0;a[i>>0]=1;if(pi(s,b)|0){u=41;break}d=d-j|0;s=a[i>>0]|0;switch((s<<24>>24==3?1:s)&3){case 0:{r=0;t=d;break}case 3:case 1:{r=d;t=0;break}case 2:{r=d>>>1;t=(d+1|0)>>>1;break}default:{}}c[v>>2]=0;d=c[e>>2]|0;if(d>>>0<128){a[v>>0]=d;j=1;}else {do if(d>>>0>=2048)if(d>>>0<65536){a[v>>0]=d>>>12&15|-32;e=63;i=1;k=-128;f=2;j=3;break}else {a[v>>0]=d>>>18&255|-16;a[v+1>>0]=d>>>12&63|-128;e=63;i=2;k=-128;f=3;j=4;break}else {e=31;i=0;k=-64;f=1;j=2;}while(0);a[v+i>>0]=e&d>>>6&255|k;a[v+f>>0]=d&63|-128;}i=b+24|0;e=b+28|0;d=0;while(1){if(d>>>0>=r>>>0){u=57;break}if(d>>>0>4294967294){u=57;break}if(db[c[(c[e>>2]|0)+12>>2]&15](c[i>>2]|0,v,j)|0)break;else d=d+1|0;}c:do if((u|0)==57?!(db[c[(c[e>>2]|0)+12>>2]&15](c[i>>2]|0,g,h)|0):0){d=0;while(1){if(d>>>0>=t>>>0)break;if(d>>>0>4294967294)break;if(db[c[(c[e>>2]|0)+12>>2]&15](c[i>>2]|0,v,j)|0)break c;else d=d+1|0;}d=0;u=38;break a}while(0);d=1;u=38;break}}else if(pi(s,b)|0)u=41;else {d=db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,g,h)|0;u=38;}while(0);if((u|0)==38){v=d;l=w;return v|0}else if((u|0)==41){v=1;l=w;return v|0}return 0}function pi(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0;o=l;l=l+16|0;k=o;j=c[c[b>>2]>>2]|0;if((j|0)!=1114112){m=c[d+24>>2]|0;n=c[d+28>>2]|0;c[k>>2]=0;if(j>>>0<128){a[k>>0]=j;e=1;}else {do if(j>>>0>=2048)if(j>>>0<65536){a[k>>0]=j>>>12&15|-32;f=63;g=1;h=-128;i=2;e=3;break}else {a[k>>0]=j>>>18&255|-16;a[k+1>>0]=j>>>12&63|-128;f=63;g=2;h=-128;i=3;e=4;break}else {f=31;g=0;h=-64;i=1;e=2;}while(0);a[k+g>>0]=f&j>>>6&255|h;a[k+i>>0]=j&63|-128;}if(db[c[n+12>>2]&15](m,k,e)|0){n=1;l=o;return n|0}}if(!(a[c[b+4>>2]>>0]|0)){n=0;l=o;return n|0}n=c[b+8>>2]|0;n=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,c[n>>2]|0,c[n+4>>2]|0)|0;l=o;return n|0}function qi(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=l;l=l+16|0;u=v;q=b+8|0;f=(c[b+16>>2]|0)==1;if((c[q>>2]|0)==1)if(f)s=7;else {m=e;g=d;}else if(f)s=7;else {u=db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,d,e)|0;l=v;return u|0}if((s|0)==7){g=c[b+20>>2]|0;n=d+e|0;c[u>>2]=0;o=u+4|0;c[o>>2]=d;k=u+8|0;c[k>>2]=n;f=u+12|0;c[f>>2]=g;p=d;a:do if(!g)if(!e)m=0;else {g=d+1|0;c[o>>2]=g;f=g;k=a[d>>0]|0;if(k<<24>>24<=-1){m=k&255;if((e|0)==1){g=0;h=n;}else {h=d+2|0;c[o>>2]=h;f=h;g=a[g>>0]&63;}i=g&255;if((k&255)>223){if((h|0)==(n|0)){g=0;j=n;}else {j=h+1|0;c[o>>2]=j;f=j;g=a[h>>0]&63;}h=g&255|i<<6;if((k&255)>239){if((j|0)==(n|0))g=0;else {f=j+1|0;c[o>>2]=f;g=a[j>>0]&63;}if((h<<6|m<<18&1835008|g&255|0)==1114112){m=e;break}}}}c[u>>2]=f-p;m=0;}else {c[f>>2]=0;j=u+4|0;if((Hi(j)|0)!=1114112){i=c[k>>2]|0;h=c[j>>2]|0;c[u>>2]=(c[u>>2]|0)+e-i+h;f=g;do{if((Hi(j)|0)==1114112){m=e;break a}f=f+-1|0;g=c[u>>2]|0;o=i;i=c[k>>2]|0;p=h;h=c[j>>2]|0;c[u>>2]=o-p+g-i+h;}while((f|0)!=0);if(!((g|0)==0|(g|0)==(e|0))){if(g>>>0>=e>>>0)Ii(d,e,0,g);if((a[d+g>>0]|0)<=-65)Ii(d,e,0,g);else m=g;}else m=g;}else m=e;}while(0);if((c[q>>2]|0)==1)g=d;else {u=db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,d,m)|0;l=v;return u|0}}k=c[b+12>>2]|0;j=d+m|0;i=(m|0)==0;if(i)f=0;else {h=g;f=0;do{f=((a[h>>0]&-64)<<24>>24==-128&1)+f|0;h=h+1|0;}while((h|0)!=(j|0))}if((m-f|0)>>>0>=k>>>0){u=db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,d,m)|0;l=v;return u|0}if(i)f=0;else {f=0;do{f=((a[g>>0]&-64)<<24>>24==-128&1)+f|0;g=g+1|0;}while((g|0)!=(j|0))}f=f-m+k|0;q=a[b+48>>0]|0;switch((q<<24>>24==3?0:q)&3){case 0:{r=0;t=f;break}case 3:case 1:{r=f;t=0;break}case 2:{r=f>>>1;t=(f+1|0)>>>1;break}default:{}}c[u>>2]=0;f=c[b+4>>2]|0;if(f>>>0<128){a[u>>0]=f;i=1;}else {do if(f>>>0>=2048)if(f>>>0<65536){a[u>>0]=f>>>12&15|-32;g=63;h=1;j=-128;k=2;i=3;break}else {a[u>>0]=f>>>18&255|-16;a[u+1>>0]=f>>>12&63|-128;g=63;h=2;j=-128;k=3;i=4;break}else {g=31;h=0;j=-64;k=1;i=2;}while(0);a[u+h>>0]=g&f>>>6&255|j;a[u+k>>0]=f&63|-128;}h=b+24|0;g=b+28|0;f=0;while(1){if(f>>>0>=r>>>0){s=47;break}if(f>>>0>4294967294){s=47;break}if(db[c[(c[g>>2]|0)+12>>2]&15](c[h>>2]|0,u,i)|0)break;else f=f+1|0;}b:do if((s|0)==47?!(db[c[(c[g>>2]|0)+12>>2]&15](c[h>>2]|0,d,m)|0):0){f=0;while(1){if(f>>>0>=t>>>0)break;if(f>>>0>4294967294)break;if(db[c[(c[g>>2]|0)+12>>2]&15](c[h>>2]|0,u,i)|0)break b;else f=f+1|0;}u=0;l=v;return u|0}while(0);u=1;l=v;return u|0}function ri(a,b,d){a=a|0;b=b|0;d=d|0;return db[c[(c[a+28>>2]|0)+12>>2]&15](c[a+24>>2]|0,b,d)|0}function si(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d;f=c[a+24>>2]|0;a=c[a+28>>2]|0;c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,a,e)|0;l=d;return b|0}function ti(a){a=a|0;return (c[a>>2]&4|0)!=0|0}function ui(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;f=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,e,f)|0;c[b>>2]=d;a[b+4>>0]=f&1;a[b+5>>0]=0;return}function vi(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;e=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,e,f)|0;c[b>>2]=d;a[b+8>>0]=e&1;c[b+4>>2]=0;a[b+9>>0]=(f|0)==0&1;return}function wi(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=l;l=l+32|0;f=e;h=c[d+24>>2]|0;g=c[d+28>>2]|0;c[f>>2]=5084;c[f+4>>2]=1;c[f+8>>2]=0;c[f+16>>2]=15892;c[f+20>>2]=0;f=(ki(h,g,f)|0)&1;c[b>>2]=d;a[b+4>>0]=f;a[b+5>>0]=0;l=e;return}function xi(a,b){a=a|0;b=b|0;return lb[c[(c[a+28>>2]|0)+16>>2]&127](c[a+24>>2]|0,b)|0}function yi(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;t=e+24|0;r=e+28|0;if(lb[c[(c[r>>2]|0)+16>>2]&127](c[t>>2]|0,34)|0){w=1;return w|0}p=b+d|0;q=p;do if(d){e=b+1|0;f=e;j=a[b>>0]|0;if(j<<24>>24<=-1){k=j&31;if((d|0)==1){e=0;g=p;}else {g=b+2|0;f=g;e=a[e>>0]&63;}h=e&255;e=h|k<<6;if((j&255)>223){if((g|0)==(p|0)){e=0;i=p;}else {i=g+1|0;f=i;e=a[g>>0]&63;}g=e&255|h<<6;e=g|k<<12;if((j&255)>239){if((i|0)==(p|0))e=0;else {f=i+1|0;e=a[i>>0]&63;}e=g<<6|k<<18&1835008|e&255;if((e|0)==1114112){e=0;w=17;break}}}}else e=j&255;o=f;g=f+d|0;f=e;m=0;e=0;a:while(1){n=g-q|0;switch(f&2097151|0){case 9:{l=116;g=2;i=0;j=0;break}case 13:{l=114;g=2;i=0;j=0;break}case 10:{l=110;g=2;i=0;j=0;break}case 34:case 39:case 92:{l=f;g=2;i=0;j=0;break}default:if(pj(f)|0){l=f;g=1;i=0;j=0;}else {l=f;g=3;i=5;j=(Q(f|1|0)|0)>>>2^7;}}switch(g&3){case 2:case 0:{w=38;break}case 1:break;case 3:{switch(i&7){case 0:{h=0;break}case 1:{h=1;break}case 2:{h=2;break}case 3:{h=3;break}case 4:{h=4;break}case 5:{h=5;break}default:{w=36;break a}}if((h+j|0)!=1)w=38;break}default:{w=29;break a}}if((w|0)==38){w=0;if(m>>>0<e>>>0){w=45;break}if(!((e|0)==0|(e|0)==(d|0))){if(e>>>0>=d>>>0){w=45;break}if((a[b+e>>0]|0)<=-65){w=45;break}}if(!((m|0)==0|(m|0)==(d|0))){if(m>>>0>=d>>>0){w=45;break}if((a[b+m>>0]|0)<=-65){w=45;break}}if(db[c[(c[r>>2]|0)+12>>2]&15](c[t>>2]|0,b+e|0,m-e|0)|0){e=1;w=15;break}k=(l|0)==1114112;h=j;b:while(1){c:do switch(g&3){case 0:break b;case 1:{if(k)break b;else {e=l;g=0;}break}case 2:{e=92;g=1;break}case 3:switch(i&7){case 0:break b;case 1:{e=125;i=i&-256;break c}case 2:{e=l>>>(h<<2&28)&15;e=((e&255)<10?48:87)+e|0;if(!h){i=i&-256|1;break c}else {h=h+-1|0;break c}}case 3:{e=123;i=i&-256|2;break c}case 4:{e=117;i=i&-256|3;break c}case 5:{e=92;i=i&-256|4;break c}default:{w=56;break a}}default:{w=49;break a}}while(0);if(lb[c[(c[r>>2]|0)+16>>2]&127](c[t>>2]|0,e)|0){e=1;w=15;break a}}e=(f>>>0<128?1:f>>>0<2048?2:f>>>0<65536?3:4)+m|0;}f=o;if((f|0)==(p|0)){w=16;break}g=f+1|0;h=g;if(!o){w=16;break}j=a[f>>0]|0;if(j<<24>>24<=-1){k=j&31;if((g|0)==(p|0)){f=0;i=p;g=h;}else {m=f+2|0;f=a[g>>0]&63;i=m;g=m;}h=f&255;f=h|k<<6;if((j&255)>223){if((i|0)==(p|0)){f=0;i=p;}else {g=i+1|0;f=a[i>>0]&63;i=g;}h=f&255|h<<6;f=h|k<<12;if((j&255)>239){if((i|0)==(p|0))f=0;else {f=a[i>>0]&63;g=i+1|0;}f=h<<6|k<<18&1835008|f&255;if((f|0)==1114112){w=16;break}}}}else {g=h;f=j&255;}m=q-o+n+g|0;o=g;g=m;m=n;}if((w|0)==15)return e|0;else if((w|0)==16){if((e|0)==0|(e|0)==(d|0)){w=17;break}if(e>>>0>=d>>>0)Ii(b,d,e,d);f=b+e|0;if((a[f>>0]|0)>-65){u=e;v=r;s=f;break}Ii(b,d,e,d);}else if((w|0)!=29)if((w|0)!=36)if((w|0)==45)Ii(b,d,e,m);}else {e=0;w=17;}while(0);if((w|0)==17){u=e;v=r;s=b+e|0;}if(db[c[(c[v>>2]|0)+12>>2]&15](c[t>>2]|0,s,d-u|0)|0){w=1;return w|0}w=lb[c[(c[r>>2]|0)+16>>2]&127](c[t>>2]|0,34)|0;return w|0}function zi(a,b,c){a=a|0;b=b|0;c=c|0;return qi(c,a,b)|0}function Ai(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=b+24|0;g=b+28|0;if(lb[c[(c[g>>2]|0)+16>>2]&127](c[h>>2]|0,39)|0){h=1;return h|0}b=c[a>>2]|0;switch(b&2097151|0){case 9:{f=116;d=0;a=0;b=2;break}case 13:{f=114;d=0;a=0;b=2;break}case 10:{f=110;d=0;a=0;b=2;break}case 34:case 39:case 92:{f=b;d=0;a=0;b=2;break}default:if(pj(b)|0){f=b;d=0;a=0;b=1;}else {f=b;d=(Q(b|1|0)|0)>>>2^7;a=5;b=3;}}e=a;a:while(1){b:do switch(b&3){case 0:{a=22;break a}case 1:{a=f;b=0;break}case 2:{a=92;b=1;break}case 3:switch(e&7){case 0:{a=22;break a}case 1:{a=125;e=e&-256;break b}case 2:{a=f>>>(d<<2&28)&15;a=((a&255)<10?48:87)+a|0;if(!d){e=e&-256|1;break b}else {d=d+-1|0;break b}}case 3:{a=123;e=e&-256|2;break b}case 4:{a=117;e=e&-256|3;break b}case 5:{a=92;e=e&-256|4;break b}default:{a=19;break a}}default:{a=11;break a}}while(0);if(lb[c[(c[g>>2]|0)+16>>2]&127](c[h>>2]|0,a)|0){b=1;a=9;break}}if((a|0)==9)return b|0;else if((a|0)!=11)if((a|0)!=19)if((a|0)==22){h=lb[c[(c[g>>2]|0)+16>>2]&127](c[h>>2]|0,39)|0;return h|0}return 0}function Bi(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=l;l=l+16|0;j=k;if((c[d+8>>2]|0)!=1?(c[d+16>>2]|0)!=1:0){j=lb[c[(c[d+28>>2]|0)+16>>2]&127](c[d+24>>2]|0,c[b>>2]|0)|0;l=k;return j|0}e=c[b>>2]|0;c[j>>2]=0;if(e>>>0<128){a[j>>0]=e;b=1;}else {do if(e>>>0>=2048)if(e>>>0<65536){a[j>>0]=e>>>12&15|-32;f=63;g=1;h=-128;i=2;b=3;break}else {a[j>>0]=e>>>18&255|-16;a[j+1>>0]=e>>>12&63|-128;f=63;g=2;h=-128;i=3;b=4;break}else {f=31;g=0;h=-64;i=1;b=2;}while(0);a[j+g>>0]=f&e>>>6&255|h;a[j+i>>0]=e&63|-128;}j=qi(d,j,b)|0;l=k;return j|0}function Ci(d,e){d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=l;l=l+48|0;g=i;d=a[c[d>>2]>>0]|0;f=d&255;if((d&255)<=99)if((d&255)<10){d=38;h=4;}else {d=g+37|0;f=b[4156+(f<<1)>>1]|0;a[d>>0]=f;a[d+1>>0]=f>>8;d=37;}else {f=g+37|0;h=b[4156+(((d&255)%100|0)<<1&255)>>1]|0;a[f>>0]=h;a[f+1>>0]=h>>8;f=((d&255)/100|0)&255;d=36;h=4;}if((h|0)==4)a[g+d>>0]=(f&255)+48<<24>>24;h=oi(e,1,16465,0,g+d|0,39-d|0)|0;l=i;return h|0}function Di(a,b){a=a|0;b=b|0;return ai(c[a>>2]|0,b)|0}function Ei(a,b){a=a|0;b=b|0;return qi(b,c[a>>2]|0,c[a+4>>2]|0)|0}function Fi(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=l;l=l+16|0;f=g;Gi(f,b,d);e=c[f>>2]|0;f=c[f+4>>2]|0;if(0==0&(f&255|0)==2){c[a>>2]=0;c[a+4>>2]=b;c[a+8>>2]=d;l=g;return}else {c[a>>2]=1;d=a+4|0;c[d>>2]=e;c[d+4>>2]=f;l=g;return}}function Gi(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0;j=e>>>0>7?e+-7|0:0;a:do if(e|0){i=0;b:while(1){f=d+i|0;h=a[f>>0]|0;c:do if(h<<24>>24>=0){if((f&3|4|0)!=4){f=i+1|0;break}d:do if(i>>>0<j>>>0){f=i;do{i=d+f|0;if((c[i+4>>2]|c[i>>2])&-2139062144|0)break d;f=f+8|0;}while(f>>>0<j>>>0)}else f=i;while(0);if(f>>>0<e>>>0)do{if((a[d+f>>0]|0)<=-1)break c;f=f+1|0;}while(f>>>0<e>>>0)}else {switch(a[11498+(h&255)>>0]|0){case 2:{f=i+1|0;if(f>>>0>=e>>>0){f=12;break b}if((a[d+f>>0]&-64)<<24>>24!=-128){f=15;break b}break}case 3:{f=i+1|0;if(f>>>0>=e>>>0){f=16;break b}f=a[d+f>>0]|0;g=(f&255)<192;if(((!(h<<24>>24==-32&(f&-32)<<24>>24==-96)?(k=f<<24>>24<0,!(g&((h+31&255)<12&k))):0)?!((f&255)<160&(h<<24>>24==-19&k)):0)?!(g&((h&-2)<<24>>24==-18&k)):0){f=19;break b}f=i+2|0;if(f>>>0>=e>>>0){f=23;break b}if((a[d+f>>0]&-64)<<24>>24!=-128){f=25;break b}break}case 4:{f=i+1|0;if(f>>>0>=e>>>0){f=26;break b}f=a[d+f>>0]|0;if((!(h<<24>>24==-16&(f+112&255)<48)?(l=f<<24>>24<0,!((f&255)<192&((h+15&255)<3&l))):0)?!((f&255)<144&(h<<24>>24==-12&l)):0){f=29;break b}f=i+2|0;if(f>>>0>=e>>>0){f=32;break b}if((a[d+f>>0]&-64)<<24>>24!=-128){f=34;break b}f=i+3|0;if(f>>>0>=e>>>0){f=36;break b}if((a[d+f>>0]&-64)<<24>>24!=-128){f=38;break b}break}default:{f=10;break b}}f=f+1|0;}while(0);if(f>>>0<e>>>0)i=f;else break a}switch(f|0){case 10:{c[b>>2]=i;a[b+4>>0]=1;a[b+5>>0]=1;return}case 12:{c[b>>2]=i;a[b+4>>0]=0;return}case 15:{c[b>>2]=i;a[b+4>>0]=1;a[b+5>>0]=1;return}case 16:{c[b>>2]=i;a[b+4>>0]=0;return}case 19:{c[b>>2]=i;a[b+4>>0]=1;a[b+5>>0]=1;return}case 23:{c[b>>2]=i;a[b+4>>0]=0;return}case 25:{c[b>>2]=i;a[b+4>>0]=1;a[b+5>>0]=2;return}case 26:{c[b>>2]=i;a[b+4>>0]=0;return}case 29:{c[b>>2]=i;a[b+4>>0]=1;a[b+5>>0]=1;return}case 32:{c[b>>2]=i;a[b+4>>0]=0;return}case 34:{c[b>>2]=i;a[b+4>>0]=1;a[b+5>>0]=2;return}case 36:{c[b>>2]=i;a[b+4>>0]=0;return}case 38:{c[b>>2]=i;a[b+4>>0]=1;a[b+5>>0]=3;return}}}while(0);a[b+4>>0]=2;return}function Hi(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=c[b>>2]|0;h=c[b+4>>2]|0;if((d|0)==(h|0)){j=1114112;return j|0}e=d+1|0;c[b>>2]=e;i=a[d>>0]|0;if(i<<24>>24>-1){j=i&255;return j|0}j=i&31;if((e|0)==(h|0)){d=0;e=h;}else {g=d+2|0;c[b>>2]=g;d=a[e>>0]&63;e=g;}f=d&255;if((i&255)<=223){j=f|j<<6;return j|0}if((e|0)==(h|0)){d=0;g=h;}else {g=e+1|0;c[b>>2]=g;d=a[e>>0]&63;}e=d&255|f<<6;if((i&255)<=239){j=e|j<<12;return j|0}if((g|0)==(h|0))d=0;else {c[b>>2]=g+1;d=a[g>>0]&63;}j=e<<6|j<<18&1835008|d&255;return j|0}function Ii(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;j=l;l=l+112|0;p=j+64|0;q=j+40|0;r=j+32|0;s=j+28|0;t=j+24|0;u=j+8|0;n=j;i=j+20|0;j=j+16|0;c[j>>2]=e;c[i>>2]=f;a:do if(d>>>0<257){g=d;h=0;}else {g=256;while(1){if(g>>>0<d>>>0?(a[b+g>>0]|0)>-65:0){h=1;break a}g=g+-1|0;if((g|0)==0|(g|0)==(d|0)){h=1;break}}}while(0);c[n>>2]=b;c[n+4>>2]=g;c[u>>2]=h?11754:16465;c[u+4>>2]=h?5:0;g=e>>>0>d>>>0;if(g|f>>>0>d>>>0){c[r>>2]=g?e:f;c[p>>2]=r;c[p+4>>2]=39;c[p+8>>2]=n;c[p+12>>2]=64;c[p+16>>2]=u;c[p+20>>2]=64;c[q>>2]=4436;c[q+4>>2]=3;c[q+8>>2]=4460;c[q+12>>2]=3;c[q+16>>2]=p;c[q+20>>2]=3;aj(q,4568);}if(e>>>0>f>>>0){c[p>>2]=j;c[p+4>>2]=39;c[p+8>>2]=i;c[p+12>>2]=39;c[p+16>>2]=n;c[p+20>>2]=64;c[p+24>>2]=u;c[p+28>>2]=64;c[q>>2]=4584;c[q+4>>2]=4;c[q+8>>2]=4616;c[q+12>>2]=4;c[q+16>>2]=p;c[q+20>>2]=4;aj(q,4760);}if(!((e|0)==0|(e|0)==(d|0))){if(e>>>0<d>>>0?(a[b+e>>0]|0)>-65:0)k=12;}else k=12;if((k|0)==12)e=f;c[t>>2]=e;g=(e|0)==0;b:do if(g|(e|0)==(d|0)){k=e;e=g;}else while(1){if(e>>>0<d>>>0?(a[b+e>>0]|0)>-65:0){k=e;e=0;break b}e=e+-1|0;g=(e|0)==0;if(g|(e|0)==(d|0)){k=e;e=g;break}}while(0);if(!(e|(k|0)==(d|0))){if(k>>>0>=d>>>0)Ii(b,d,k,d);e=b+k|0;if((a[e>>0]|0)>-65)m=e;else Ii(b,d,k,d);}else m=b+k|0;f=b+k+(d-k)|0;d=(m|0)==(f|0);g=d?m:b+k+1|0;if(d)$i(4776);i=a[m>>0]|0;if(i<<24>>24<=-1){j=i&31;if((g|0)==(f|0)){e=0;h=f;}else {e=a[g>>0]&63;h=g+1|0;}g=e&255;e=g|j<<6;if((i&255)>223){if((h|0)==(f|0)){e=0;h=f;}else {e=a[h>>0]&63;h=h+1|0;}g=e&255|g<<6;e=g|j<<12;if((i&255)>239){if((h|0)==(f|0))e=0;else e=a[h>>0]&63;e=g<<6|j<<18&1835008|e&255;if((e|0)==1114112)$i(4776);else o=e;}else o=e;}else o=e;}else o=i&255;c[s>>2]=o;c[r>>2]=k;c[r+4>>2]=(o>>>0<128?1:o>>>0<2048?2:o>>>0<65536?3:4)+k;c[p>>2]=t;c[p+4>>2]=39;c[p+8>>2]=s;c[p+12>>2]=65;c[p+16>>2]=r;c[p+20>>2]=66;c[p+24>>2]=n;c[p+28>>2]=64;c[p+32>>2]=u;c[p+36>>2]=64;c[q>>2]=4800;c[q+4>>2]=5;c[q+8>>2]=4840;c[q+12>>2]=5;c[q+16>>2]=p;c[q+20>>2]=5;aj(q,5020);}function Ji(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=l;l=l+48|0;s=v+32|0;t=v;c[s>>2]=0;if(f>>>0<128){a[s>>0]=f;g=1;}else {k=f>>>0<2048;do if(!k)if(f>>>0<65536){a[s>>0]=f>>>12&15|-32;g=63;h=1;i=-128;j=2;break}else {a[s>>0]=f>>>18&255|-16;a[s+1>>0]=f>>>12&63|-128;g=63;h=2;i=-128;j=3;break}else {g=31;h=0;i=-64;j=1;}while(0);a[s+h>>0]=g&f>>>6&255|i;a[s+j>>0]=f&63|-128;g=k?2:f>>>0<65536?3:4;}o=c[s>>2]|0;c[t>>2]=d;p=t+4|0;c[p>>2]=e;q=t+8|0;c[q>>2]=0;r=t+12|0;c[r>>2]=e;c[t+16>>2]=f;m=t+20|0;c[m>>2]=g;n=t+24|0;c[n>>2]=o;o=s+4|0;_i(s,a[g+-1+(t+24)>>0]|0,d,e);do if((c[s>>2]|0)==1){h=0;j=0;while(1){d=(c[o>>2]|0)+1+h|0;c[q>>2]=d;if(d>>>0>=g>>>0){f=d-g|0;i=c[p>>2]|0;e=d>>>0<f>>>0|i>>>0<d>>>0;h=(c[t>>2]|0)+f|0;k=e?j:g;if(!e){if(g>>>0>4){h=14;break}if((k|0)==(g|0)){if((h|0)==(n|0)){h=23;break}if(!(Xj(h,n,g)|0)){h=23;break}else j=g;}else j=g;}}else i=c[p>>2]|0;h=c[r>>2]|0;if(h>>>0<d>>>0|i>>>0<h>>>0){g=0;h=24;break}_i(s,a[g+-1+(t+24)>>0]|0,(c[t>>2]|0)+d|0,h-d|0);if((c[s>>2]|0)!=1){h=21;break}h=c[q>>2]|0;g=c[m>>2]|0;}if((h|0)==14)kj(g,4);else if((h|0)==21){u=c[r>>2]|0;break}else if((h|0)==23){c[b+4>>2]=f;u=1;c[b>>2]=u;l=v;return}else if((h|0)==24){c[b>>2]=g;l=v;return}}else u=e;while(0);c[q>>2]=u;u=0;c[b>>2]=u;l=v;return}function Ki(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;g=l;l=l+16|0;i=g+8|0;f=g;h=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,11985,9)|0;c[f>>2]=d;e=f+4|0;a[e>>0]=h&1;h=f+5|0;a[h>>0]=0;c[i>>2]=b;Qi(f,11994,11,i,5036)|0;c[i>>2]=b+4;Qi(f,12005,9,i,5052)|0;d=a[e>>0]|0;if(!(a[h>>0]|0)){i=d;i=i<<24>>24!=0;l=g;return i|0}if(!(d<<24>>24)){d=c[f>>2]|0;d=(db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,c[d>>2]&4|0?12053:12055,2)|0)&1;}else d=1;a[e>>0]=d;i=d;i=i<<24>>24!=0;l=g;return i|0}function Li(a){a=a|0;return}function Mi(a){a=a|0;return}function Ni(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,z=0,A=0,B=0;switch(g|0){case 0:{c[b+48>>2]=d;c[b+52>>2]=e;c[b+56>>2]=f;c[b+60>>2]=0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=e;a[b+12>>0]=1;a[b+13>>0]=1;return}case 1:{s=0;t=0;u=1;v=1;break}default:{p=0;h=1;x=3;}}a:do if((x|0)==3){b:while(1){x=0;j=1;c:while(1){n=h;o=0;m=h;while(1){n=a[f+n>>0]|0;h=o+p|0;if(h>>>0>=g>>>0){x=6;break b}h=a[f+h>>0]|0;if((n&255)<(h&255))break;if(n<<24>>24!=h<<24>>24)break c;n=o+1|0;w=(n|0)==(j|0);h=w?0:n;m=(w?n:0)+m|0;n=m+h|0;if(n>>>0>=g>>>0){q=p;r=j;break b}else o=h;}h=m+1+o|0;j=h-p|0;if(h>>>0>=g>>>0){q=p;r=j;break b}}h=m+1|0;if(h>>>0>=g>>>0){q=m;r=1;break}else {p=m;x=3;}}if((x|0)==6)bj(5068,h,g);h=1;p=0;d:while(1){j=1;e:while(1){n=h;o=0;m=h;while(1){n=a[f+n>>0]|0;h=o+p|0;if(h>>>0>=g>>>0)break d;h=a[f+h>>0]|0;if((n&255)>(h&255))break;if(n<<24>>24!=h<<24>>24)break e;n=o+1|0;w=(n|0)==(j|0);h=w?0:n;m=(w?n:0)+m|0;n=m+h|0;if(n>>>0>=g>>>0){s=q;t=p;u=r;v=j;break a}else o=h;}h=m+1+o|0;j=h-p|0;if(h>>>0>=g>>>0){s=q;t=p;u=r;v=j;break a}}h=m+1|0;if(h>>>0>=g>>>0){s=q;t=m;u=r;v=1;break a}else p=m;}bj(5068,h,g);}while(0);r=s>>>0>t>>>0;w=r?s:t;t=r?u:v;if(w>>>0>g>>>0)kj(w,g);h=t+w|0;if(h>>>0<t>>>0)lj(t,h);if(h>>>0>g>>>0)kj(h,g);s=f+t|0;if((s|0)!=(f|0)?(Xj(f,s,w)|0)!=0:0){m=g-w|0;n=m>>>0>=w>>>0;h=f+g|0;j=f;k=0;i=0;do{B=nk(1,0,a[j>>0]&63|0)|0;j=j+1|0;k=B|k;i=y|i;}while((j|0)!=(h|0));l=w;z=(n?m:w)+1|0;A=-1;B=-1;}else x=30;do if((x|0)==30){r=g+-1|0;h=1;o=0;p=1;m=0;while(1){if((p+o|0)>>>0>=g>>>0){x=40;break}j=g-o+~p|0;if(j>>>0>=g>>>0){x=33;break}n=a[f+j>>0]|0;j=r-o-m|0;if(j>>>0>=g>>>0){x=35;break}j=a[f+j>>0]|0;if((n&255)<(j&255)){n=o+1+p|0;h=n-m|0;j=0;}else {x=n<<24>>24==j<<24>>24;n=o+1|0;v=(n|0)==(h|0);h=x?h:1;j=x?(v?0:n):0;n=(x?(v?n:0):1)+p|0;m=x?m:p;}if((h|0)==(t|0)){x=40;break}else {o=j;p=n;}}if((x|0)==33)bj(5068,j,g);else if((x|0)==35)bj(5068,j,g);else if((x|0)==40){p=0;q=1;h=0;o=1;while(1){if((q+p|0)>>>0>=g>>>0){x=50;break}j=g-p+~q|0;if(j>>>0>=g>>>0){x=43;break}n=a[f+j>>0]|0;j=r-p-h|0;if(j>>>0>=g>>>0){x=45;break}j=a[f+j>>0]|0;if((n&255)>(j&255)){o=p+1+q|0;n=o-h|0;j=0;}else {x=n<<24>>24==j<<24>>24;v=p+1|0;u=(v|0)==(o|0);n=x?o:1;j=x?(u?0:v):0;o=(x?(u?v:0):1)+q|0;h=x?h:q;}if((n|0)==(t|0)){x=50;break}else {p=j;q=o;o=n;}}if((x|0)==43)bj(5068,j,g);else if((x|0)==45)bj(5068,j,g);else if((x|0)==50){l=g-(h>>>0>=m>>>0?h:m)|0;if(t>>>0>g>>>0)kj(t,g);if(!t){k=0;i=0;z=0;A=0;B=g;break}j=f;h=0;i=0;do{B=nk(1,0,a[j>>0]&63|0)|0;j=j+1|0;h=B|h;i=y|i;}while((j|0)!=(s|0));k=h;z=t;A=0;B=g;}}}while(0);c[b+48>>2]=d;c[b+52>>2]=e;c[b+56>>2]=f;c[b+60>>2]=g;c[b>>2]=1;g=b+8|0;c[g>>2]=k;c[g+4>>2]=i;c[b+16>>2]=w;c[b+20>>2]=l;c[b+24>>2]=z;c[b+28>>2]=0;c[b+32>>2]=e;c[b+36>>2]=A;c[b+40>>2]=B;return}function Oi(a){a=a|0;return}function Pi(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0;o=l;l=l+16|0;j=o;if(!e){n=0;l=o;return n|0}k=b+8|0;m=j+4|0;n=b+4|0;h=e;while(1){if(a[k>>0]|0?db[c[(c[n>>2]|0)+12>>2]&15](c[b>>2]|0,12048,4)|0:0){d=1;e=5;break}Ji(j,d,h,10);if((c[j>>2]|0)==1){i=c[m>>2]|0;a[k>>0]=1;i=i+1|0;}else {a[k>>0]=0;i=h;}e=c[b>>2]|0;f=c[n>>2]|0;g=(i|0)==0|(h|0)==(i|0);if(!g){if(h>>>0<=i>>>0){e=12;break}if((a[d+i>>0]|0)<=-65){e=12;break}}if(db[c[f+12>>2]&15](e,d,i)|0){d=1;e=5;break}if(!g){if(h>>>0<=i>>>0){e=18;break}e=d+i|0;if((a[e>>0]|0)>-65)d=e;else {e=18;break}}else d=d+i|0;e=h-i|0;if(!e){d=0;e=5;break}else h=e;}if((e|0)==5){l=o;return d|0}else if((e|0)==12)Ii(d,h,0,i);else if((e|0)==18)Ii(d,h,i,h);return 0}function Qi(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;q=l;l=l+96|0;n=q+32|0;o=q+16|0;i=q;p=q+8|0;c[p>>2]=d;j=p+4|0;c[j>>2]=e;k=b+4|0;if(a[k>>0]|0){o=1;p=b+5|0;o=o&1;a[k>>0]=o;a[p>>0]=1;l=q;return b|0}m=b+5|0;h=(a[m>>0]|0)!=0;e=h?3572:12062;h=h?1:2;c[i>>2]=e;c[i+4>>2]=h;d=c[b>>2]|0;do if(!(c[d>>2]&4)){c[o>>2]=i;c[o+4>>2]=64;c[o+8>>2]=p;c[o+12>>2]=64;j=c[d+24>>2]|0;p=c[d+28>>2]|0;c[n>>2]=5116;c[n+4>>2]=3;c[n+8>>2]=5264;c[n+12>>2]=2;c[n+16>>2]=o;c[n+20>>2]=2;if(ki(j,p,n)|0)e=8;else {d=lb[c[g+12>>2]&127](f,c[b>>2]|0)|0;e=13;}}else {z=c[d+28>>2]|0;c[o>>2]=c[d+24>>2];c[o+4>>2]=z;a[o+8>>0]=0;z=c[d+4>>2]|0;y=a[d+48>>0]|0;w=d+8|0;x=c[w>>2]|0;w=c[w+4>>2]|0;u=d+16|0;v=c[u>>2]|0;u=c[u+4>>2]|0;t=c[d+32>>2]|0;s=c[d+36>>2]|0;r=c[d+40>>2]|0;i=c[d+44>>2]|0;c[n>>2]=c[d>>2];c[n+4>>2]=z;a[n+48>>0]=y;d=n+8|0;c[d>>2]=x;c[d+4>>2]=w;d=n+16|0;c[d>>2]=v;c[d+4>>2]=u;c[n+24>>2]=o;c[n+28>>2]=4356;c[n+32>>2]=t;c[n+36>>2]=s;c[n+40>>2]=r;c[n+44>>2]=i;d=c[1092]|0;if(((!(db[d&15](o,e,h)|0)?!(db[d&15](o,12052,1)|0):0)?!(db[d&15](o,c[p>>2]|0,c[j>>2]|0)|0):0)?!(db[d&15](o,12064,2)|0):0){d=lb[c[g+12>>2]&127](f,n)|0;e=13;break}e=8;}while(0);if((e|0)==8){y=1;z=m;y=y&1;a[k>>0]=y;a[z>>0]=1;l=q;return b|0}else if((e|0)==13){y=d;z=m;y=y&1;a[k>>0]=y;a[z>>0]=1;l=q;return b|0}return 0}function Ri(b){b=b|0;var d=0,e=0;e=b+4|0;d=a[e>>0]|0;if(!(a[b+5>>0]|0)){e=d;e=e<<24>>24!=0;return e|0}if(!(d<<24>>24)){b=c[b>>2]|0;b=(db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,c[b>>2]&4|0?12053:12055,2)|0)&1;}else b=1;a[e>>0]=b;e=b;e=e<<24>>24!=0;return e|0}function Si(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;o=l;l=l+64|0;j=o+12|0;k=o;m=b+8|0;n=b+4|0;do if(!(a[m>>0]|0)){g=(c[n>>2]|0)!=0;i=g?3572:3564;f=g?3580:16465;g=g&1;h=c[b>>2]|0;if(!(c[h>>2]&4)){if(db[c[(c[h+28>>2]|0)+12>>2]&15](c[h+24>>2]|0,i,1)|0){f=1;break}k=c[b>>2]|0;if(db[c[(c[k+28>>2]|0)+12>>2]&15](c[k+24>>2]|0,f,g)|0){f=1;break}f=lb[c[e+12>>2]&127](d,c[b>>2]|0)|0;break}w=c[h+28>>2]|0;c[k>>2]=c[h+24>>2];c[k+4>>2]=w;a[k+8>>0]=0;w=c[h+4>>2]|0;v=a[h+48>>0]|0;t=h+8|0;u=c[t>>2]|0;t=c[t+4>>2]|0;r=h+16|0;s=c[r>>2]|0;r=c[r+4>>2]|0;q=c[h+32>>2]|0;p=c[h+36>>2]|0;g=c[h+40>>2]|0;f=c[h+44>>2]|0;c[j>>2]=c[h>>2];c[j+4>>2]=w;a[j+48>>0]=v;h=j+8|0;c[h>>2]=u;c[h+4>>2]=t;h=j+16|0;c[h>>2]=s;c[h+4>>2]=r;c[j+24>>2]=k;c[j+28>>2]=4356;c[j+32>>2]=q;c[j+36>>2]=p;c[j+40>>2]=g;c[j+44>>2]=f;f=c[1092]|0;if(!(db[f&15](k,i,1)|0)?!(db[f&15](k,12052,1)|0):0){f=lb[c[e+12>>2]&127](d,j)|0;break}f=1;}else f=1;while(0);a[m>>0]=f&1;c[n>>2]=(c[n>>2]|0)+1;l=o;return b|0}function Ti(b){b=b|0;var d=0,e=0,f=0,g=0;f=b+4|0;d=c[f>>2]|0;g=b+8|0;e=a[g>>0]|0;if(!d){g=e;g=g<<24>>24!=0;return g|0}do if(!(e<<24>>24)){e=c[b>>2]|0;if(c[e>>2]&4){if(db[c[(c[e+28>>2]|0)+12>>2]&15](c[e+24>>2]|0,12052,1)|0){d=1;break}d=c[f>>2]|0;}if(((d|0)==1?a[b+9>>0]|0:0)?(f=c[b>>2]|0,db[c[(c[f+28>>2]|0)+12>>2]&15](c[f+24>>2]|0,3572,1)|0):0){d=1;break}d=c[b>>2]|0;d=(db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12057,1)|0)&1;}else d=1;while(0);a[g>>0]=d;g=d;g=g<<24>>24!=0;return g|0}function Ui(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;j=l;l=l+64|0;g=j+12|0;h=j;i=b+4|0;if(a[i>>0]|0){d=1;e=b+5|0;d=d&1;a[i>>0]=d;a[e>>0]=1;l=j;return}f=c[b>>2]|0;if(c[f>>2]&4|0){u=c[f+28>>2]|0;c[h>>2]=c[f+24>>2];c[h+4>>2]=u;a[h+8>>0]=0;u=c[f+4>>2]|0;t=a[f+48>>0]|0;r=f+8|0;s=c[r>>2]|0;r=c[r+4>>2]|0;p=f+16|0;q=c[p>>2]|0;p=c[p+4>>2]|0;o=c[f+32>>2]|0;n=c[f+36>>2]|0;m=c[f+40>>2]|0;k=c[f+44>>2]|0;c[g>>2]=c[f>>2];c[g+4>>2]=u;a[g+48>>0]=t;f=g+8|0;c[f>>2]=s;c[f+4>>2]=r;f=g+16|0;c[f>>2]=q;c[f+4>>2]=p;c[g+24>>2]=h;c[g+28>>2]=4356;c[g+32>>2]=o;c[g+36>>2]=n;c[g+40>>2]=m;c[g+44>>2]=k;f=b+5|0;b=(a[f>>0]|0)!=0;if(db[c[4368>>2]&15](h,b?12058:12052,b?2:1)|0){t=1;u=f;t=t&1;a[i>>0]=t;a[u>>0]=1;l=j;return}else {t=lb[c[e+12>>2]&127](d,g)|0;u=f;t=t&1;a[i>>0]=t;a[u>>0]=1;l=j;return}}g=b+5|0;do if(a[g>>0]|0)if(db[c[(c[f+28>>2]|0)+12>>2]&15](c[f+24>>2]|0,12060,2)|0){t=1;u=g;t=t&1;a[i>>0]=t;a[u>>0]=1;l=j;return}else {f=c[b>>2]|0;break}while(0);t=lb[c[e+12>>2]&127](d,f)|0;u=g;t=t&1;a[i>>0]=t;a[u>>0]=1;l=j;return}function Vi(a,b,c){a=a|0;b=b|0;c=c|0;Ui(a,b,c);return a|0}function Wi(b){b=b|0;var d=0,e=0,f=0;d=c[b>>2]|0;if((c[d>>2]&4|0)!=0?(a[b+5>>0]|0)!=0:0)e=1;else e=0;f=b+4|0;if(a[f>>0]|0){a[f>>0]=1;f=1;return f|0}e=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,e?12052:16465,e&1)|0;a[f>>0]=e&1;if(e){f=1;return f|0}f=c[b>>2]|0;f=db[c[(c[f+28>>2]|0)+12>>2]&15](c[f+24>>2]|0,3592,1)|0;return f|0}function Xi(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=l;l=l+16|0;j=k;c[j>>2]=0;if(d>>>0<128){a[j>>0]=d;e=1;}else {do if(d>>>0>=2048)if(d>>>0<65536){a[j>>0]=d>>>12&15|-32;f=63;g=1;h=-128;i=2;e=3;break}else {a[j>>0]=d>>>18&255|-16;a[j+1>>0]=d>>>12&63|-128;f=63;g=2;h=-128;i=3;e=4;break}else {f=31;g=0;h=-64;i=1;e=2;}while(0);a[j+g>>0]=f&d>>>6&255|h;a[j+i>>0]=d&63|-128;}j=Pi(b,j,e)|0;l=k;return j|0}function Yi(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+32|0;e=d+8|0;f=d;c[f>>2]=a;c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[e+16>>2]=c[b+16>>2];c[e+20>>2]=c[b+20>>2];b=ki(f,5092,e)|0;l=d;return b|0}function Zi(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=l;l=l+48|0;e=d+16|0;f=d;c[f>>2]=a;c[f+4>>2]=67;c[f+8>>2]=a+4;c[f+12>>2]=67;a=c[b+24>>2]|0;b=c[b+28>>2]|0;c[e>>2]=5140;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;b=ki(a,b,e)|0;l=d;return b|0}function _i(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;k=e&3;g=4-k|0;a:do if((k|0)==0|(g|0)==0)g=0;else {j=g>>>0<=f>>>0?g:f;k=e+j|0;i=k;h=e;g=0;while(1){if((i-h|0)>>>0<=3){m=8;break}o=(a[h>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o)break;o=(a[h+1>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o)break;o=(a[h+2>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o)break;o=(a[h+3>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o)break;else h=h+4|0;}if((m|0)==8)while(1){if((h|0)==(k|0)){g=j;break a}o=(a[h>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o)break;else {h=h+1|0;m=8;}}c[b>>2]=1;c[b+4>>2]=g;return}while(0);h=d&255;h=h<<8|h;h=h<<16|h;if(f>>>0>7?(l=f+-8|0,g>>>0<=l>>>0):0){do{o=c[e+g>>2]^h;m=c[e+(g+4)>>2]^h;if((m&-2139062144^-2139062144)&m+-16843009|(o&-2139062144^-2139062144)&o+-16843009|0)break;g=g+8|0;}while(g>>>0<=l>>>0);if(g>>>0>f>>>0)lj(g,f);else n=g;}else n=g;h=e+n|0;j=h+(f-n)|0;i=j;g=0;while(1){if((i-h|0)>>>0<=3){m=24;break}o=(a[h>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o){m=26;break}o=(a[h+1>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o){m=26;break}o=(a[h+2>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o){m=26;break}o=(a[h+3>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o){m=26;break}else h=h+4|0;}b:do if((m|0)==24)while(1){m=0;if((h|0)==(j|0)){g=0;break b}o=(a[h>>0]|0)==d<<24>>24;g=((o^1)&1)+g|0;if(o){m=26;break}else {h=h+1|0;m=24;}}while(0);if((m|0)==26){c[b+4>>2]=g+n;g=1;}c[b>>2]=g;return}function $i(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=l;l=l+48|0;b=d+32|0;i=d+24|0;j=c[a+4>>2]|0;h=c[a+8>>2]|0;g=c[a+12>>2]|0;f=c[a+16>>2]|0;e=c[a+20>>2]|0;c[i>>2]=c[a>>2];c[i+4>>2]=j;c[d>>2]=i;c[d+4>>2]=1;c[d+8>>2]=0;c[d+16>>2]=15892;c[d+20>>2]=0;c[b>>2]=h;c[b+4>>2]=g;c[b+8>>2]=f;c[b+12>>2]=e;aj(d,b);}function aj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;h=l;l=l+64|0;e=h+56|0;f=h+32|0;g=h;h=h+8|0;j=c[b>>2]|0;i=c[b+4>>2]|0;d=c[b+8>>2]|0;b=c[b+12>>2]|0;c[h>>2]=c[a>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[g>>2]=j;c[g+4>>2]=i;c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];Pe(f,e,d,b);}function bj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;g=l;l=l+48|0;f=g+32|0;e=g+8|0;h=g+4|0;c[g>>2]=b;c[h>>2]=d;c[f>>2]=h;c[f+4>>2]=39;c[f+8>>2]=g;c[f+12>>2]=39;c[e>>2]=5156;c[e+4>>2]=2;c[e+8>>2]=5264;c[e+12>>2]=2;c[e+16>>2]=f;c[e+20>>2]=2;aj(e,a);}function cj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=l;l=l+48|0;e=f+32|0;d=f+8|0;c[f>>2]=a;c[f+4>>2]=b;c[e>>2]=f;c[e+4>>2]=64;c[d>>2]=5172;c[d+4>>2]=1;c[d+8>>2]=5180;c[d+12>>2]=1;c[d+16>>2]=e;c[d+20>>2]=1;aj(d,5216);}function dj(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=l;l=l+16|0;e=j+12|0;i=j;b=c[b>>2]|0;if((a[b>>0]|0)!=1){i=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12149,4)|0;l=j;return i|0}f=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12153,4)|0;c[i>>2]=d;h=i+8|0;a[h>>0]=f&1;f=i+4|0;c[f>>2]=0;g=i+9|0;a[g>>0]=0;c[e>>2]=b+1;Si(i,e,5232)|0;d=c[f>>2]|0;b=a[h>>0]|0;if(d){do if(!(b<<24>>24)){b=c[i>>2]|0;if(!(c[b>>2]&4))b=d;else {if(db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,12052,1)|0){b=1;break}b=c[f>>2]|0;}if(!((b|0)!=1|(a[g>>0]|0)==0)?(g=c[i>>2]|0,db[c[(c[g+28>>2]|0)+12>>2]&15](c[g+24>>2]|0,3572,1)|0):0){b=1;break}b=c[i>>2]|0;b=(db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,12057,1)|0)&1;}else b=1;while(0);a[h>>0]=b;}i=b<<24>>24!=0;l=j;return i|0}function ej(a){a=a|0;return}function fj(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,i=0;if(!f){a[b>>0]=1;a[b+1>>0]=0;return}i=(a[e>>0]|0)==43;g=i?e+1|0:e;e=(i<<31>>31)+f|0;if(!e){a[b>>0]=1;a[b+1>>0]=0;return}h=g+e|0;i=0;while(1){e=d[g>>0]|0;g=g+1|0;if((e+-48|0)>>>0>=10)if((e+-97|0)>>>0>=26)if((e+-65|0)>>>0<26)f=-55;else {e=10;break}else f=-87;else f=-48;f=f+e|0;if(f>>>0>=10){e=10;break}e=i*10|0;if(i>>>0>429496729){e=12;break}i=e+f|0;if(i>>>0<e>>>0){e=14;break}if((g|0)==(h|0)){e=16;break}}if((e|0)==10){a[b>>0]=1;a[b+1>>0]=1;return}else if((e|0)==12){a[b>>0]=1;a[b+1>>0]=2;return}else if((e|0)==14){a[b>>0]=1;a[b+1>>0]=2;return}else if((e|0)==16){a[b>>0]=0;c[b+4>>2]=i;return}}function gj(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;g=l;l=l+16|0;i=g+8|0;f=g;h=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12157,13)|0;c[f>>2]=d;e=f+4|0;a[e>>0]=h&1;h=f+5|0;a[h>>0]=0;c[i>>2]=b;Qi(f,12170,4,i,5248)|0;d=a[e>>0]|0;if(!(a[h>>0]|0)){i=d;i=i<<24>>24!=0;l=g;return i|0}if(!(d<<24>>24)){d=c[f>>2]|0;d=(db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,c[d>>2]&4|0?12053:12055,2)|0)&1;}else d=1;a[e>>0]=d;i=d;i=i<<24>>24!=0;l=g;return i|0}function hj(a){a=a|0;return}function ij(b,d){b=b|0;d=d|0;switch(a[c[b>>2]>>0]&3){case 0:{d=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12174,5)|0;return d|0}case 1:{d=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12179,12)|0;return d|0}case 2:{d=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12191,8)|0;return d|0}case 3:{d=db[c[(c[d+28>>2]|0)+12>>2]&15](c[d+24>>2]|0,12199,9)|0;return d|0}default:{}}return 0}function jj(b){b=b|0;var d=0,e=0,f=0,g=0;a:do switch(c[b>>2]&3){case 0:{d=1114112;break}case 1:{d=c[b+4>>2]|0;c[b>>2]=0;break}case 2:{c[b>>2]=1;d=92;break}case 3:{g=b+12|0;switch(a[g>>0]&7){case 0:{d=1114112;break a}case 1:{a[g>>0]=0;d=125;break a}case 2:{f=b+8|0;e=c[f>>2]|0;d=(c[b+4>>2]|0)>>>(e<<2&28)&15;d=((d&255)<10?48:87)+d|0;if(!e){a[g>>0]=1;break a}else {c[f>>2]=e+-1;break a}}case 3:{a[g>>0]=2;d=123;break a}case 4:{a[g>>0]=3;d=117;break a}case 5:{a[g>>0]=4;d=92;break a}default:{}}break}default:{}}while(0);return d|0}function kj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;g=l;l=l+48|0;e=g+32|0;d=g+8|0;f=g+4|0;c[g>>2]=a;c[f>>2]=b;c[e>>2]=g;c[e+4>>2]=39;c[e+8>>2]=f;c[e+12>>2]=39;c[d>>2]=5336;c[d+4>>2]=2;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=e;c[d+20>>2]=2;aj(d,5352);}function lj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;g=l;l=l+48|0;e=g+32|0;d=g+8|0;f=g+4|0;c[g>>2]=a;c[f>>2]=b;c[e>>2]=g;c[e+4>>2]=39;c[e+8>>2]=f;c[e+12>>2]=39;c[d>>2]=5368;c[d+4>>2]=2;c[d+8>>2]=5264;c[d+12>>2]=2;c[d+16>>2]=e;c[d+20>>2]=2;aj(d,5384);}function mj(a,b){a=a|0;b=b|0;return db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,13605,11)|0}function nj(a,b){a=a|0;b=b|0;return db[c[(c[b+28>>2]|0)+12>>2]&15](c[b+24>>2]|0,13616,14)|0}function oj(b,c,e,f,g,h,i){b=b|0;c=c|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;n=(b&65535)>>>8&255;o=c+(e<<1)|0;a:do if(e|0){k=b&255;m=0;b:while(1){j=c;c=c+2|0;e=a[j>>0]|0;j=d[j+1>>0]|0;l=j+m|0;if(n<<24>>24!=e<<24>>24)if((c|0)==(o|0)|(n&255)<(e&255))break a;else {m=l;continue}if(l>>>0<m>>>0){e=7;break}if(l>>>0>g>>>0){e=9;break}q=f+m|0;e=q+j|0;j=q;while(1){if((j|0)==(e|0))break;if((a[j>>0]|0)==k<<24>>24){p=0;e=15;break b}else j=j+1|0;}if((c|0)==(o|0))break a;else m=l;}if((e|0)==7)lj(m,l);else if((e|0)==9)kj(l,g);else if((e|0)==15)return p|0}while(0);m=h+i|0;if(!i){q=1;return q|0}l=h;j=h+1|0;k=b&65535;c=1;while(1){e=a[l>>0]|0;if(e<<24>>24<0){if((j|0)==(m|0)){e=18;break}e=d[j>>0]|(e&127)<<8;j=j+1|0;}else e=e&255;e=k-e|0;if((e|0)<0){p=c;e=15;break}c=c^1;if((j|0)==(m|0)){p=c;e=15;break}l=j;j=j+1|0;k=e;}if((e|0)==15)return p|0;else if((e|0)==18)$i(5400);return 0}function pj(a){a=a|0;var b=0;b=a&65535;if(a>>>0<65536){b=oj(b,12317,41,12399,304,12703,326)|0;return b|0}if(a>>>0<131072){b=oj(b,13029,33,13095,150,13245,360)|0;return b|0}if((a+-195102|0)>>>0<722658|((a+-191457|0)>>>0<3103|((a+-183970|0)>>>0<14|((a&2097150|0)==178206|((a+-173783|0)>>>0<41|(a+-177973|0)>>>0<11))))){b=0;return b|0}else return (a+-918e3|0)>>>0>196111|0;return 0}function qj(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;x=l;l=l+16|0;o=x;do if(a>>>0<245){k=a>>>0<11?16:a+11&-8;a=k>>>3;n=c[3973]|0;d=n>>>a;if(d&3|0){e=(d&1^1)+a|0;f=15932+(e<<1<<2)|0;b=f+8|0;a=c[b>>2]|0;g=a+8|0;d=c[g>>2]|0;if((f|0)==(d|0))c[3973]=n&~(1<<e);else {c[d+12>>2]=f;c[b>>2]=d;}w=e<<3;c[a+4>>2]=w|3;w=a+w+4|0;c[w>>2]=c[w>>2]|1;w=g;l=x;return w|0}m=c[3975]|0;if(k>>>0>m>>>0){if(d|0){h=2<<a;d=d<<a&(h|0-h);d=(d&0-d)+-1|0;h=d>>>12&16;d=d>>>h;a=d>>>5&8;d=d>>>a;f=d>>>2&4;d=d>>>f;b=d>>>1&2;d=d>>>b;e=d>>>1&1;e=(a|h|f|b|e)+(d>>>e)|0;d=15932+(e<<1<<2)|0;b=d+8|0;f=c[b>>2]|0;h=f+8|0;a=c[h>>2]|0;if((d|0)==(a|0)){a=n&~(1<<e);c[3973]=a;}else {c[a+12>>2]=d;c[b>>2]=a;a=n;}g=(e<<3)-k|0;c[f+4>>2]=k|3;f=f+k|0;c[f+4>>2]=g|1;c[f+g>>2]=g;if(m|0){e=c[3978]|0;b=m>>>3;d=15932+(b<<1<<2)|0;b=1<<b;if(!(a&b)){c[3973]=a|b;b=d+8|0;a=d;}else {a=d+8|0;b=a;a=c[a>>2]|0;}c[b>>2]=e;c[a+12>>2]=e;c[e+8>>2]=a;c[e+12>>2]=d;}c[3975]=g;c[3978]=f;w=h;l=x;return w|0}i=c[3974]|0;if(i){d=(i&0-i)+-1|0;h=d>>>12&16;d=d>>>h;g=d>>>5&8;d=d>>>g;j=d>>>2&4;d=d>>>j;a=d>>>1&2;d=d>>>a;e=d>>>1&1;e=c[16196+((g|h|j|a|e)+(d>>>e)<<2)>>2]|0;d=(c[e+4>>2]&-8)-k|0;a=c[e+16+(((c[e+16>>2]|0)==0&1)<<2)>>2]|0;if(!a){j=d;h=e;}else {do{h=(c[a+4>>2]&-8)-k|0;j=h>>>0<d>>>0;d=j?h:d;e=j?a:e;a=c[a+16+(((c[a+16>>2]|0)==0&1)<<2)>>2]|0;}while((a|0)!=0);j=d;h=e;}g=h+k|0;if(h>>>0<g>>>0){f=c[h+24>>2]|0;b=c[h+12>>2]|0;do if((b|0)==(h|0)){a=h+20|0;b=c[a>>2]|0;if(!b){a=h+16|0;b=c[a>>2]|0;if(!b){d=0;break}}while(1){e=b+20|0;d=c[e>>2]|0;if(d|0){b=d;a=e;continue}e=b+16|0;d=c[e>>2]|0;if(!d)break;else {b=d;a=e;}}c[a>>2]=0;d=b;}else {d=c[h+8>>2]|0;c[d+12>>2]=b;c[b+8>>2]=d;d=b;}while(0);do if(f|0){b=c[h+28>>2]|0;a=16196+(b<<2)|0;if((h|0)==(c[a>>2]|0)){c[a>>2]=d;if(!d){c[3974]=i&~(1<<b);break}}else {c[f+16+(((c[f+16>>2]|0)!=(h|0)&1)<<2)>>2]=d;if(!d)break}c[d+24>>2]=f;b=c[h+16>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d;}b=c[h+20>>2]|0;if(b|0){c[d+20>>2]=b;c[b+24>>2]=d;}}while(0);if(j>>>0<16){w=j+k|0;c[h+4>>2]=w|3;w=h+w+4|0;c[w>>2]=c[w>>2]|1;}else {c[h+4>>2]=k|3;c[g+4>>2]=j|1;c[g+j>>2]=j;if(m|0){e=c[3978]|0;b=m>>>3;d=15932+(b<<1<<2)|0;b=1<<b;if(!(n&b)){c[3973]=n|b;b=d+8|0;a=d;}else {a=d+8|0;b=a;a=c[a>>2]|0;}c[b>>2]=e;c[a+12>>2]=e;c[e+8>>2]=a;c[e+12>>2]=d;}c[3975]=j;c[3978]=g;}w=h+8|0;l=x;return w|0}else n=k;}else n=k;}else n=k;}else if(a>>>0<=4294967231){a=a+11|0;k=a&-8;e=c[3974]|0;if(e){d=0-k|0;a=a>>>8;if(a)if(k>>>0>16777215)j=31;else {n=(a+1048320|0)>>>16&8;v=a<<n;m=(v+520192|0)>>>16&4;v=v<<m;j=(v+245760|0)>>>16&2;j=14-(m|n|j)+(v<<j>>>15)|0;j=k>>>(j+7|0)&1|j<<1;}else j=0;a=c[16196+(j<<2)>>2]|0;a:do if(!a){f=0;a=0;v=57;}else {f=0;h=k<<((j|0)==31?0:25-(j>>>1)|0);i=a;a=0;while(1){g=(c[i+4>>2]&-8)-k|0;if(g>>>0<d>>>0)if(!g){d=0;f=i;a=i;v=61;break a}else {d=g;a=i;}g=c[i+20>>2]|0;i=c[i+16+(h>>>31<<2)>>2]|0;f=(g|0)==0|(g|0)==(i|0)?f:g;g=(i|0)==0;if(g){v=57;break}else h=h<<((g^1)&1);}}while(0);if((v|0)==57){if((f|0)==0&(a|0)==0){a=2<<j;a=e&(a|0-a);if(!a){n=k;break}a=(a&0-a)+-1|0;j=a>>>12&16;a=a>>>j;i=a>>>5&8;a=a>>>i;m=a>>>2&4;a=a>>>m;n=a>>>1&2;a=a>>>n;f=a>>>1&1;f=c[16196+((i|j|m|n|f)+(a>>>f)<<2)>>2]|0;a=0;}if(!f){i=d;j=a;}else v=61;}if((v|0)==61)while(1){v=0;m=(c[f+4>>2]&-8)-k|0;n=m>>>0<d>>>0;d=n?m:d;a=n?f:a;f=c[f+16+(((c[f+16>>2]|0)==0&1)<<2)>>2]|0;if(!f){i=d;j=a;break}else v=61;}if((j|0)!=0?i>>>0<((c[3975]|0)-k|0)>>>0:0){h=j+k|0;if(j>>>0>=h>>>0){w=0;l=x;return w|0}g=c[j+24>>2]|0;b=c[j+12>>2]|0;do if((b|0)==(j|0)){a=j+20|0;b=c[a>>2]|0;if(!b){a=j+16|0;b=c[a>>2]|0;if(!b){b=0;break}}while(1){f=b+20|0;d=c[f>>2]|0;if(d|0){b=d;a=f;continue}f=b+16|0;d=c[f>>2]|0;if(!d)break;else {b=d;a=f;}}c[a>>2]=0;}else {w=c[j+8>>2]|0;c[w+12>>2]=b;c[b+8>>2]=w;}while(0);do if(g){a=c[j+28>>2]|0;d=16196+(a<<2)|0;if((j|0)==(c[d>>2]|0)){c[d>>2]=b;if(!b){e=e&~(1<<a);c[3974]=e;break}}else {c[g+16+(((c[g+16>>2]|0)!=(j|0)&1)<<2)>>2]=b;if(!b)break}c[b+24>>2]=g;a=c[j+16>>2]|0;if(a|0){c[b+16>>2]=a;c[a+24>>2]=b;}a=c[j+20>>2]|0;if(a){c[b+20>>2]=a;c[a+24>>2]=b;}}while(0);do if(i>>>0>=16){c[j+4>>2]=k|3;c[h+4>>2]=i|1;c[h+i>>2]=i;b=i>>>3;if(i>>>0<256){d=15932+(b<<1<<2)|0;a=c[3973]|0;b=1<<b;if(!(a&b)){c[3973]=a|b;b=d+8|0;a=d;}else {a=d+8|0;b=a;a=c[a>>2]|0;}c[b>>2]=h;c[a+12>>2]=h;c[h+8>>2]=a;c[h+12>>2]=d;break}b=i>>>8;if(b)if(i>>>0>16777215)b=31;else {v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;b=(w+245760|0)>>>16&2;b=14-(u|v|b)+(w<<b>>>15)|0;b=i>>>(b+7|0)&1|b<<1;}else b=0;d=16196+(b<<2)|0;c[h+28>>2]=b;a=h+16|0;c[a+4>>2]=0;c[a>>2]=0;a=1<<b;if(!(e&a)){c[3974]=e|a;c[d>>2]=h;c[h+24>>2]=d;c[h+12>>2]=h;c[h+8>>2]=h;break}a=i<<((b|0)==31?0:25-(b>>>1)|0);d=c[d>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(i|0)){v=97;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=96;break}else {a=a<<1;d=b;}}if((v|0)==96){c[e>>2]=h;c[h+24>>2]=d;c[h+12>>2]=h;c[h+8>>2]=h;break}else if((v|0)==97){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=h;c[v>>2]=h;c[h+8>>2]=w;c[h+12>>2]=d;c[h+24>>2]=0;break}}else {w=i+k|0;c[j+4>>2]=w|3;w=j+w+4|0;c[w>>2]=c[w>>2]|1;}while(0);w=j+8|0;l=x;return w|0}else n=k;}else n=k;}else n=-1;while(0);d=c[3975]|0;if(d>>>0>=n>>>0){a=d-n|0;b=c[3978]|0;if(a>>>0>15){w=b+n|0;c[3978]=w;c[3975]=a;c[w+4>>2]=a|1;c[w+a>>2]=a;c[b+4>>2]=n|3;}else {c[3975]=0;c[3978]=0;c[b+4>>2]=d|3;w=b+d+4|0;c[w>>2]=c[w>>2]|1;}w=b+8|0;l=x;return w|0}h=c[3976]|0;if(h>>>0>n>>>0){u=h-n|0;c[3976]=u;w=c[3979]|0;v=w+n|0;c[3979]=v;c[v+4>>2]=u|1;c[w+4>>2]=n|3;w=w+8|0;l=x;return w|0}if(!(c[4091]|0)){c[4093]=4096;c[4092]=4096;c[4094]=-1;c[4095]=-1;c[4096]=0;c[4084]=0;a=o&-16^1431655768;c[o>>2]=a;c[4091]=a;a=4096;}else a=c[4093]|0;i=n+48|0;j=n+47|0;g=a+j|0;e=0-a|0;k=g&e;if(k>>>0<=n>>>0){w=0;l=x;return w|0}a=c[4083]|0;if(a|0?(m=c[4081]|0,o=m+k|0,o>>>0<=m>>>0|o>>>0>a>>>0):0){w=0;l=x;return w|0}b:do if(!(c[4084]&4)){d=c[3979]|0;c:do if(d){f=16340;while(1){a=c[f>>2]|0;if(a>>>0<=d>>>0?(r=f+4|0,(a+(c[r>>2]|0)|0)>>>0>d>>>0):0)break;a=c[f+8>>2]|0;if(!a){v=118;break c}else f=a;}b=g-h&e;if(b>>>0<2147483647){a=rk(b|0)|0;if((a|0)==((c[f>>2]|0)+(c[r>>2]|0)|0)){if((a|0)!=(-1|0)){h=a;g=b;v=135;break b}}else {e=a;v=126;}}else b=0;}else v=118;while(0);do if((v|0)==118){d=rk(0)|0;if((d|0)!=(-1|0)?(b=d,p=c[4092]|0,q=p+-1|0,b=((q&b|0)==0?0:(q+b&0-p)-b|0)+k|0,p=c[4081]|0,q=b+p|0,b>>>0>n>>>0&b>>>0<2147483647):0){r=c[4083]|0;if(r|0?q>>>0<=p>>>0|q>>>0>r>>>0:0){b=0;break}a=rk(b|0)|0;if((a|0)==(d|0)){h=d;g=b;v=135;break b}else {e=a;v=126;}}else b=0;}while(0);do if((v|0)==126){d=0-b|0;if(!(i>>>0>b>>>0&(b>>>0<2147483647&(e|0)!=(-1|0))))if((e|0)==(-1|0)){b=0;break}else {h=e;g=b;v=135;break b}a=c[4093]|0;a=j-b+a&0-a;if(a>>>0>=2147483647){h=e;g=b;v=135;break b}if((rk(a|0)|0)==(-1|0)){rk(d|0)|0;b=0;break}else {h=e;g=a+b|0;v=135;break b}}while(0);c[4084]=c[4084]|4;v=133;}else {b=0;v=133;}while(0);if(((v|0)==133?k>>>0<2147483647:0)?(s=rk(k|0)|0,r=rk(0)|0,u=r-s|0,t=u>>>0>(n+40|0)>>>0,!((s|0)==(-1|0)|t^1|s>>>0<r>>>0&((s|0)!=(-1|0)&(r|0)!=(-1|0))^1)):0){h=s;g=t?u:b;v=135;}if((v|0)==135){b=(c[4081]|0)+g|0;c[4081]=b;if(b>>>0>(c[4082]|0)>>>0)c[4082]=b;j=c[3979]|0;do if(j){f=16340;while(1){b=c[f>>2]|0;e=f+4|0;a=c[e>>2]|0;if((h|0)==(b+a|0)){v=145;break}d=c[f+8>>2]|0;if(!d)break;else f=d;}if(((v|0)==145?(c[f+12>>2]&8|0)==0:0)?j>>>0<h>>>0&j>>>0>=b>>>0:0){c[e>>2]=a+g;w=j+8|0;w=(w&7|0)==0?0:0-w&7;v=j+w|0;w=(c[3976]|0)+(g-w)|0;c[3979]=v;c[3976]=w;c[v+4>>2]=w|1;c[v+w+4>>2]=40;c[3980]=c[4095];break}if(h>>>0<(c[3977]|0)>>>0)c[3977]=h;d=h+g|0;a=16340;while(1){if((c[a>>2]|0)==(d|0)){v=153;break}b=c[a+8>>2]|0;if(!b)break;else a=b;}if((v|0)==153?(c[a+12>>2]&8|0)==0:0){c[a>>2]=h;m=a+4|0;c[m>>2]=(c[m>>2]|0)+g;m=h+8|0;m=h+((m&7|0)==0?0:0-m&7)|0;b=d+8|0;b=d+((b&7|0)==0?0:0-b&7)|0;k=m+n|0;i=b-m-n|0;c[m+4>>2]=n|3;do if((b|0)!=(j|0)){if((b|0)==(c[3978]|0)){w=(c[3975]|0)+i|0;c[3975]=w;c[3978]=k;c[k+4>>2]=w|1;c[k+w>>2]=w;break}a=c[b+4>>2]|0;if((a&3|0)==1){h=a&-8;e=a>>>3;d:do if(a>>>0<256){a=c[b+8>>2]|0;d=c[b+12>>2]|0;if((d|0)==(a|0)){c[3973]=c[3973]&~(1<<e);break}else {c[a+12>>2]=d;c[d+8>>2]=a;break}}else {g=c[b+24>>2]|0;a=c[b+12>>2]|0;do if((a|0)==(b|0)){e=b+16|0;d=e+4|0;a=c[d>>2]|0;if(!a){a=c[e>>2]|0;if(!a){a=0;break}else f=e;}else f=d;while(1){e=a+20|0;d=c[e>>2]|0;if(d|0){a=d;f=e;continue}e=a+16|0;d=c[e>>2]|0;if(!d)break;else {a=d;f=e;}}c[f>>2]=0;}else {w=c[b+8>>2]|0;c[w+12>>2]=a;c[a+8>>2]=w;}while(0);if(!g)break;d=c[b+28>>2]|0;e=16196+(d<<2)|0;do if((b|0)!=(c[e>>2]|0)){c[g+16+(((c[g+16>>2]|0)!=(b|0)&1)<<2)>>2]=a;if(!a)break d}else {c[e>>2]=a;if(a|0)break;c[3974]=c[3974]&~(1<<d);break d}while(0);c[a+24>>2]=g;e=b+16|0;d=c[e>>2]|0;if(d|0){c[a+16>>2]=d;c[d+24>>2]=a;}d=c[e+4>>2]|0;if(!d)break;c[a+20>>2]=d;c[d+24>>2]=a;}while(0);b=b+h|0;f=h+i|0;}else f=i;b=b+4|0;c[b>>2]=c[b>>2]&-2;c[k+4>>2]=f|1;c[k+f>>2]=f;b=f>>>3;if(f>>>0<256){d=15932+(b<<1<<2)|0;a=c[3973]|0;b=1<<b;if(!(a&b)){c[3973]=a|b;b=d+8|0;a=d;}else {a=d+8|0;b=a;a=c[a>>2]|0;}c[b>>2]=k;c[a+12>>2]=k;c[k+8>>2]=a;c[k+12>>2]=d;break}b=f>>>8;do if(!b)a=0;else {if(f>>>0>16777215){a=31;break}v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;a=(w+245760|0)>>>16&2;a=14-(u|v|a)+(w<<a>>>15)|0;a=f>>>(a+7|0)&1|a<<1;}while(0);e=16196+(a<<2)|0;c[k+28>>2]=a;b=k+16|0;c[b+4>>2]=0;c[b>>2]=0;b=c[3974]|0;d=1<<a;if(!(b&d)){c[3974]=b|d;c[e>>2]=k;c[k+24>>2]=e;c[k+12>>2]=k;c[k+8>>2]=k;break}a=f<<((a|0)==31?0:25-(a>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(f|0)){v=194;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=193;break}else {a=a<<1;d=b;}}if((v|0)==193){c[e>>2]=k;c[k+24>>2]=d;c[k+12>>2]=k;c[k+8>>2]=k;break}else if((v|0)==194){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=k;c[v>>2]=k;c[k+8>>2]=w;c[k+12>>2]=d;c[k+24>>2]=0;break}}else {w=(c[3976]|0)+i|0;c[3976]=w;c[3979]=k;c[k+4>>2]=w|1;}while(0);w=m+8|0;l=x;return w|0}a=16340;while(1){b=c[a>>2]|0;if(b>>>0<=j>>>0?(w=b+(c[a+4>>2]|0)|0,w>>>0>j>>>0):0)break;a=c[a+8>>2]|0;}f=w+-47|0;a=f+8|0;a=f+((a&7|0)==0?0:0-a&7)|0;f=j+16|0;a=a>>>0<f>>>0?j:a;b=a+8|0;d=h+8|0;d=(d&7|0)==0?0:0-d&7;v=h+d|0;d=g+-40-d|0;c[3979]=v;c[3976]=d;c[v+4>>2]=d|1;c[v+d+4>>2]=40;c[3980]=c[4095];d=a+4|0;c[d>>2]=27;c[b>>2]=c[4085];c[b+4>>2]=c[4086];c[b+8>>2]=c[4087];c[b+12>>2]=c[4088];c[4085]=h;c[4086]=g;c[4088]=0;c[4087]=b;b=a+24|0;do{v=b;b=b+4|0;c[b>>2]=7;}while((v+8|0)>>>0<w>>>0);if((a|0)!=(j|0)){g=a-j|0;c[d>>2]=c[d>>2]&-2;c[j+4>>2]=g|1;c[a>>2]=g;b=g>>>3;if(g>>>0<256){d=15932+(b<<1<<2)|0;a=c[3973]|0;b=1<<b;if(!(a&b)){c[3973]=a|b;b=d+8|0;a=d;}else {a=d+8|0;b=a;a=c[a>>2]|0;}c[b>>2]=j;c[a+12>>2]=j;c[j+8>>2]=a;c[j+12>>2]=d;break}b=g>>>8;if(b)if(g>>>0>16777215)d=31;else {v=(b+1048320|0)>>>16&8;w=b<<v;u=(w+520192|0)>>>16&4;w=w<<u;d=(w+245760|0)>>>16&2;d=14-(u|v|d)+(w<<d>>>15)|0;d=g>>>(d+7|0)&1|d<<1;}else d=0;e=16196+(d<<2)|0;c[j+28>>2]=d;c[j+20>>2]=0;c[f>>2]=0;b=c[3974]|0;a=1<<d;if(!(b&a)){c[3974]=b|a;c[e>>2]=j;c[j+24>>2]=e;c[j+12>>2]=j;c[j+8>>2]=j;break}a=g<<((d|0)==31?0:25-(d>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(g|0)){v=216;break}e=d+16+(a>>>31<<2)|0;b=c[e>>2]|0;if(!b){v=215;break}else {a=a<<1;d=b;}}if((v|0)==215){c[e>>2]=j;c[j+24>>2]=d;c[j+12>>2]=j;c[j+8>>2]=j;break}else if((v|0)==216){v=d+8|0;w=c[v>>2]|0;c[w+12>>2]=j;c[v>>2]=j;c[j+8>>2]=w;c[j+12>>2]=d;c[j+24>>2]=0;break}}}else {w=c[3977]|0;if((w|0)==0|h>>>0<w>>>0)c[3977]=h;c[4085]=h;c[4086]=g;c[4088]=0;c[3982]=c[4091];c[3981]=-1;b=0;do{w=15932+(b<<1<<2)|0;c[w+12>>2]=w;c[w+8>>2]=w;b=b+1|0;}while((b|0)!=32);w=h+8|0;w=(w&7|0)==0?0:0-w&7;v=h+w|0;w=g+-40-w|0;c[3979]=v;c[3976]=w;c[v+4>>2]=w|1;c[v+w+4>>2]=40;c[3980]=c[4095];}while(0);b=c[3976]|0;if(b>>>0>n>>>0){u=b-n|0;c[3976]=u;w=c[3979]|0;v=w+n|0;c[3979]=v;c[v+4>>2]=u|1;c[w+4>>2]=n|3;w=w+8|0;l=x;return w|0}}c[(Bj()|0)>>2]=12;w=0;l=x;return w|0}function rj(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;if(!a)return;d=a+-8|0;e=c[3977]|0;a=c[a+-4>>2]|0;b=a&-8;k=d+b|0;do if(!(a&1)){f=c[d>>2]|0;if(!(a&3))return;g=d+(0-f)|0;h=f+b|0;if(g>>>0<e>>>0)return;if((g|0)==(c[3978]|0)){b=k+4|0;a=c[b>>2]|0;if((a&3|0)!=3){i=g;j=g;b=h;break}c[3975]=h;c[b>>2]=a&-2;c[g+4>>2]=h|1;c[g+h>>2]=h;return}d=f>>>3;if(f>>>0<256){a=c[g+8>>2]|0;b=c[g+12>>2]|0;if((b|0)==(a|0)){c[3973]=c[3973]&~(1<<d);i=g;j=g;b=h;break}else {c[a+12>>2]=b;c[b+8>>2]=a;i=g;j=g;b=h;break}}f=c[g+24>>2]|0;a=c[g+12>>2]|0;do if((a|0)==(g|0)){d=g+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){d=0;break}else e=d;}else e=b;while(1){d=a+20|0;b=c[d>>2]|0;if(b|0){a=b;e=d;continue}d=a+16|0;b=c[d>>2]|0;if(!b)break;else {a=b;e=d;}}c[e>>2]=0;d=a;}else {d=c[g+8>>2]|0;c[d+12>>2]=a;c[a+8>>2]=d;d=a;}while(0);if(f){a=c[g+28>>2]|0;b=16196+(a<<2)|0;if((g|0)==(c[b>>2]|0)){c[b>>2]=d;if(!d){c[3974]=c[3974]&~(1<<a);i=g;j=g;b=h;break}}else {c[f+16+(((c[f+16>>2]|0)!=(g|0)&1)<<2)>>2]=d;if(!d){i=g;j=g;b=h;break}}c[d+24>>2]=f;b=g+16|0;a=c[b>>2]|0;if(a|0){c[d+16>>2]=a;c[a+24>>2]=d;}a=c[b+4>>2]|0;if(a){c[d+20>>2]=a;c[a+24>>2]=d;i=g;j=g;b=h;}else {i=g;j=g;b=h;}}else {i=g;j=g;b=h;}}else {i=d;j=d;}while(0);if(i>>>0>=k>>>0)return;a=k+4|0;e=c[a>>2]|0;if(!(e&1))return;if(!(e&2)){a=c[3978]|0;if((k|0)==(c[3979]|0)){k=(c[3976]|0)+b|0;c[3976]=k;c[3979]=j;c[j+4>>2]=k|1;if((j|0)!=(a|0))return;c[3978]=0;c[3975]=0;return}if((k|0)==(a|0)){k=(c[3975]|0)+b|0;c[3975]=k;c[3978]=i;c[j+4>>2]=k|1;c[i+k>>2]=k;return}f=(e&-8)+b|0;d=e>>>3;do if(e>>>0<256){b=c[k+8>>2]|0;a=c[k+12>>2]|0;if((a|0)==(b|0)){c[3973]=c[3973]&~(1<<d);break}else {c[b+12>>2]=a;c[a+8>>2]=b;break}}else {g=c[k+24>>2]|0;a=c[k+12>>2]|0;do if((a|0)==(k|0)){d=k+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){d=0;break}else e=d;}else e=b;while(1){d=a+20|0;b=c[d>>2]|0;if(b|0){a=b;e=d;continue}d=a+16|0;b=c[d>>2]|0;if(!b)break;else {a=b;e=d;}}c[e>>2]=0;d=a;}else {d=c[k+8>>2]|0;c[d+12>>2]=a;c[a+8>>2]=d;d=a;}while(0);if(g|0){a=c[k+28>>2]|0;b=16196+(a<<2)|0;if((k|0)==(c[b>>2]|0)){c[b>>2]=d;if(!d){c[3974]=c[3974]&~(1<<a);break}}else {c[g+16+(((c[g+16>>2]|0)!=(k|0)&1)<<2)>>2]=d;if(!d)break}c[d+24>>2]=g;b=k+16|0;a=c[b>>2]|0;if(a|0){c[d+16>>2]=a;c[a+24>>2]=d;}a=c[b+4>>2]|0;if(a|0){c[d+20>>2]=a;c[a+24>>2]=d;}}}while(0);c[j+4>>2]=f|1;c[i+f>>2]=f;if((j|0)==(c[3978]|0)){c[3975]=f;return}}else {c[a>>2]=e&-2;c[j+4>>2]=b|1;c[i+b>>2]=b;f=b;}a=f>>>3;if(f>>>0<256){d=15932+(a<<1<<2)|0;b=c[3973]|0;a=1<<a;if(!(b&a)){c[3973]=b|a;a=d+8|0;b=d;}else {b=d+8|0;a=b;b=c[b>>2]|0;}c[a>>2]=j;c[b+12>>2]=j;c[j+8>>2]=b;c[j+12>>2]=d;return}a=f>>>8;if(a)if(f>>>0>16777215)b=31;else {i=(a+1048320|0)>>>16&8;k=a<<i;h=(k+520192|0)>>>16&4;k=k<<h;b=(k+245760|0)>>>16&2;b=14-(h|i|b)+(k<<b>>>15)|0;b=f>>>(b+7|0)&1|b<<1;}else b=0;e=16196+(b<<2)|0;c[j+28>>2]=b;c[j+20>>2]=0;c[j+16>>2]=0;a=c[3974]|0;d=1<<b;do if(a&d){b=f<<((b|0)==31?0:25-(b>>>1)|0);d=c[e>>2]|0;while(1){if((c[d+4>>2]&-8|0)==(f|0)){a=73;break}e=d+16+(b>>>31<<2)|0;a=c[e>>2]|0;if(!a){a=72;break}else {b=b<<1;d=a;}}if((a|0)==72){c[e>>2]=j;c[j+24>>2]=d;c[j+12>>2]=j;c[j+8>>2]=j;break}else if((a|0)==73){i=d+8|0;k=c[i>>2]|0;c[k+12>>2]=j;c[i>>2]=j;c[j+8>>2]=k;c[j+12>>2]=d;c[j+24>>2]=0;break}}else {c[3974]=a|d;c[e>>2]=j;c[j+24>>2]=e;c[j+12>>2]=j;c[j+8>>2]=j;}while(0);k=(c[3981]|0)+-1|0;c[3981]=k;if(!k)a=16348;else return;while(1){a=c[a>>2]|0;if(!a)break;else a=a+8|0;}c[3981]=-1;return}function sj(a,b){a=a|0;b=b|0;var d=0,e=0;if(!a){a=qj(b)|0;return a|0}if(b>>>0>4294967231){c[(Bj()|0)>>2]=12;a=0;return a|0}d=tj(a+-8|0,b>>>0<11?16:b+11&-8)|0;if(d|0){a=d+8|0;return a|0}d=qj(b)|0;if(!d){a=0;return a|0}e=c[a+-4>>2]|0;e=(e&-8)-((e&3|0)==0?8:4)|0;ok(d|0,a|0,(e>>>0<b>>>0?e:b)|0)|0;rj(a);a=d;return a|0}function tj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=a+4|0;l=c[m>>2]|0;d=l&-8;i=a+d|0;if(!(l&3)){if(b>>>0<256){a=0;return a|0}if(d>>>0>=(b+4|0)>>>0?(d-b|0)>>>0<=c[4093]<<1>>>0:0)return a|0;a=0;return a|0}if(d>>>0>=b>>>0){d=d-b|0;if(d>>>0<=15)return a|0;k=a+b|0;c[m>>2]=l&1|b|2;c[k+4>>2]=d|3;b=k+d+4|0;c[b>>2]=c[b>>2]|1;uj(k,d);return a|0}if((i|0)==(c[3979]|0)){k=(c[3976]|0)+d|0;e=k-b|0;d=a+b|0;if(k>>>0<=b>>>0){a=0;return a|0}c[m>>2]=l&1|b|2;c[d+4>>2]=e|1;c[3979]=d;c[3976]=e;return a|0}if((i|0)==(c[3978]|0)){f=(c[3975]|0)+d|0;if(f>>>0<b>>>0){a=0;return a|0}d=f-b|0;e=l&1;if(d>>>0>15){l=a+b|0;k=l+d|0;c[m>>2]=e|b|2;c[l+4>>2]=d|1;c[k>>2]=d;e=k+4|0;c[e>>2]=c[e>>2]&-2;e=l;}else {c[m>>2]=e|f|2;e=a+f+4|0;c[e>>2]=c[e>>2]|1;e=0;d=0;}c[3975]=d;c[3978]=e;return a|0}e=c[i+4>>2]|0;if(e&2|0){a=0;return a|0}j=(e&-8)+d|0;if(j>>>0<b>>>0){a=0;return a|0}k=j-b|0;f=e>>>3;do if(e>>>0<256){e=c[i+8>>2]|0;d=c[i+12>>2]|0;if((d|0)==(e|0)){c[3973]=c[3973]&~(1<<f);break}else {c[e+12>>2]=d;c[d+8>>2]=e;break}}else {h=c[i+24>>2]|0;d=c[i+12>>2]|0;do if((d|0)==(i|0)){f=i+16|0;e=f+4|0;d=c[e>>2]|0;if(!d){d=c[f>>2]|0;if(!d){f=0;break}else g=f;}else g=e;while(1){f=d+20|0;e=c[f>>2]|0;if(e|0){d=e;g=f;continue}f=d+16|0;e=c[f>>2]|0;if(!e)break;else {d=e;g=f;}}c[g>>2]=0;f=d;}else {f=c[i+8>>2]|0;c[f+12>>2]=d;c[d+8>>2]=f;f=d;}while(0);if(h|0){d=c[i+28>>2]|0;e=16196+(d<<2)|0;if((i|0)==(c[e>>2]|0)){c[e>>2]=f;if(!f){c[3974]=c[3974]&~(1<<d);break}}else {c[h+16+(((c[h+16>>2]|0)!=(i|0)&1)<<2)>>2]=f;if(!f)break}c[f+24>>2]=h;e=i+16|0;d=c[e>>2]|0;if(d|0){c[f+16>>2]=d;c[d+24>>2]=f;}d=c[e+4>>2]|0;if(d|0){c[f+20>>2]=d;c[d+24>>2]=f;}}}while(0);d=l&1;if(k>>>0<16){c[m>>2]=j|d|2;b=a+j+4|0;c[b>>2]=c[b>>2]|1;return a|0}else {l=a+b|0;c[m>>2]=d|b|2;c[l+4>>2]=k|3;b=l+k+4|0;c[b>>2]=c[b>>2]|1;uj(l,k);return a|0}return 0}function uj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;j=a+b|0;d=c[a+4>>2]|0;do if(!(d&1)){e=c[a>>2]|0;if(!(d&3))return;g=a+(0-e)|0;h=e+b|0;if((g|0)==(c[3978]|0)){a=j+4|0;d=c[a>>2]|0;if((d&3|0)!=3){i=g;a=h;break}c[3975]=h;c[a>>2]=d&-2;c[g+4>>2]=h|1;c[g+h>>2]=h;return}b=e>>>3;if(e>>>0<256){d=c[g+8>>2]|0;a=c[g+12>>2]|0;if((a|0)==(d|0)){c[3973]=c[3973]&~(1<<b);i=g;a=h;break}else {c[d+12>>2]=a;c[a+8>>2]=d;i=g;a=h;break}}f=c[g+24>>2]|0;d=c[g+12>>2]|0;do if((d|0)==(g|0)){b=g+16|0;a=b+4|0;d=c[a>>2]|0;if(!d){d=c[b>>2]|0;if(!d){b=0;break}else e=b;}else e=a;while(1){b=d+20|0;a=c[b>>2]|0;if(a|0){d=a;e=b;continue}b=d+16|0;a=c[b>>2]|0;if(!a)break;else {d=a;e=b;}}c[e>>2]=0;b=d;}else {b=c[g+8>>2]|0;c[b+12>>2]=d;c[d+8>>2]=b;b=d;}while(0);if(f){d=c[g+28>>2]|0;a=16196+(d<<2)|0;if((g|0)==(c[a>>2]|0)){c[a>>2]=b;if(!b){c[3974]=c[3974]&~(1<<d);i=g;a=h;break}}else {c[f+16+(((c[f+16>>2]|0)!=(g|0)&1)<<2)>>2]=b;if(!b){i=g;a=h;break}}c[b+24>>2]=f;a=g+16|0;d=c[a>>2]|0;if(d|0){c[b+16>>2]=d;c[d+24>>2]=b;}d=c[a+4>>2]|0;if(d){c[b+20>>2]=d;c[d+24>>2]=b;i=g;a=h;}else {i=g;a=h;}}else {i=g;a=h;}}else {i=a;a=b;}while(0);d=j+4|0;e=c[d>>2]|0;if(!(e&2)){d=c[3978]|0;if((j|0)==(c[3979]|0)){j=(c[3976]|0)+a|0;c[3976]=j;c[3979]=i;c[i+4>>2]=j|1;if((i|0)!=(d|0))return;c[3978]=0;c[3975]=0;return}if((j|0)==(d|0)){j=(c[3975]|0)+a|0;c[3975]=j;c[3978]=i;c[i+4>>2]=j|1;c[i+j>>2]=j;return}f=(e&-8)+a|0;b=e>>>3;do if(e>>>0<256){a=c[j+8>>2]|0;d=c[j+12>>2]|0;if((d|0)==(a|0)){c[3973]=c[3973]&~(1<<b);break}else {c[a+12>>2]=d;c[d+8>>2]=a;break}}else {g=c[j+24>>2]|0;d=c[j+12>>2]|0;do if((d|0)==(j|0)){b=j+16|0;a=b+4|0;d=c[a>>2]|0;if(!d){d=c[b>>2]|0;if(!d){b=0;break}else e=b;}else e=a;while(1){b=d+20|0;a=c[b>>2]|0;if(a|0){d=a;e=b;continue}b=d+16|0;a=c[b>>2]|0;if(!a)break;else {d=a;e=b;}}c[e>>2]=0;b=d;}else {b=c[j+8>>2]|0;c[b+12>>2]=d;c[d+8>>2]=b;b=d;}while(0);if(g|0){d=c[j+28>>2]|0;a=16196+(d<<2)|0;if((j|0)==(c[a>>2]|0)){c[a>>2]=b;if(!b){c[3974]=c[3974]&~(1<<d);break}}else {c[g+16+(((c[g+16>>2]|0)!=(j|0)&1)<<2)>>2]=b;if(!b)break}c[b+24>>2]=g;a=j+16|0;d=c[a>>2]|0;if(d|0){c[b+16>>2]=d;c[d+24>>2]=b;}d=c[a+4>>2]|0;if(d|0){c[b+20>>2]=d;c[d+24>>2]=b;}}}while(0);c[i+4>>2]=f|1;c[i+f>>2]=f;if((i|0)==(c[3978]|0)){c[3975]=f;return}}else {c[d>>2]=e&-2;c[i+4>>2]=a|1;c[i+a>>2]=a;f=a;}d=f>>>3;if(f>>>0<256){b=15932+(d<<1<<2)|0;a=c[3973]|0;d=1<<d;if(!(a&d)){c[3973]=a|d;d=b+8|0;a=b;}else {a=b+8|0;d=a;a=c[a>>2]|0;}c[d>>2]=i;c[a+12>>2]=i;c[i+8>>2]=a;c[i+12>>2]=b;return}d=f>>>8;if(d)if(f>>>0>16777215)a=31;else {h=(d+1048320|0)>>>16&8;j=d<<h;g=(j+520192|0)>>>16&4;j=j<<g;a=(j+245760|0)>>>16&2;a=14-(g|h|a)+(j<<a>>>15)|0;a=f>>>(a+7|0)&1|a<<1;}else a=0;e=16196+(a<<2)|0;c[i+28>>2]=a;c[i+20>>2]=0;c[i+16>>2]=0;d=c[3974]|0;b=1<<a;if(!(d&b)){c[3974]=d|b;c[e>>2]=i;c[i+24>>2]=e;c[i+12>>2]=i;c[i+8>>2]=i;return}a=f<<((a|0)==31?0:25-(a>>>1)|0);b=c[e>>2]|0;while(1){if((c[b+4>>2]&-8|0)==(f|0)){d=69;break}e=b+16+(a>>>31<<2)|0;d=c[e>>2]|0;if(!d){d=68;break}else {a=a<<1;b=d;}}if((d|0)==68){c[e>>2]=i;c[i+24>>2]=b;c[i+12>>2]=i;c[i+8>>2]=i;return}else if((d|0)==69){h=b+8|0;j=c[h>>2]|0;c[j+12>>2]=i;c[h>>2]=i;c[i+8>>2]=j;c[i+12>>2]=b;c[i+24>>2]=0;return}}function vj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;a=a>>>0>16?a:16;if(a+-1&a){d=16;while(1)if(d>>>0<a>>>0)d=d<<1;else {a=d;break}}if((-64-a|0)>>>0<=b>>>0){c[(Bj()|0)>>2]=12;h=0;return h|0}g=b>>>0<11?16:b+11&-8;d=qj(g+12+a|0)|0;if(!d){h=0;return h|0}f=d+-8|0;do if(d&a+-1){e=(d+a+-1&0-a)+-8|0;b=f;e=(e-b|0)>>>0>15?e:e+a|0;b=e-b|0;a=d+-4|0;i=c[a>>2]|0;d=(i&-8)-b|0;if(!(i&3)){c[e>>2]=(c[f>>2]|0)+b;c[e+4>>2]=d;b=e;a=e;break}else {i=e+4|0;c[i>>2]=d|c[i>>2]&1|2;d=e+d+4|0;c[d>>2]=c[d>>2]|1;c[a>>2]=b|c[a>>2]&1|2;c[i>>2]=c[i>>2]|1;uj(f,b);b=e;a=e;break}}else {b=f;a=f;}while(0);d=a+4|0;a=c[d>>2]|0;if(a&3|0?(h=a&-8,h>>>0>(g+16|0)>>>0):0){i=h-g|0;h=b+g|0;c[d>>2]=g|a&1|2;c[h+4>>2]=i|3;g=h+i+4|0;c[g>>2]=c[g>>2]|1;uj(h,i);}i=b+8|0;return i|0}
  function wj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;do if((b|0)!=8){e=b>>>2;if((b&3|0)!=0|(e|0)==0){a=22;return a|0}if(e+1073741823&e|0){a=22;return a|0}if((-64-b|0)>>>0<d>>>0){a=12;return a|0}else {b=vj(b>>>0>16?b:16,d)|0;break}}else b=qj(d)|0;while(0);if(!b){a=12;return a|0}c[a>>2]=b;a=0;return a|0}function xj(){return 16388}function yj(a){a=a|0;var b=0,d=0;b=l;l=l+16|0;d=b;c[d>>2]=Ej(c[a+60>>2]|0)|0;a=Aj(Wa(6,d|0)|0)|0;l=b;return a|0}function zj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;f=l;l=l+32|0;g=f;e=f+20|0;c[g>>2]=c[a+60>>2];c[g+4>>2]=0;c[g+8>>2]=b;c[g+12>>2]=e;c[g+16>>2]=d;if((Aj(Oa(140,g|0)|0)|0)<0){c[e>>2]=-1;a=-1;}else a=c[e>>2]|0;l=f;return a|0}function Aj(a){a=a|0;if(a>>>0>4294963200){c[(Bj()|0)>>2]=0-a;a=-1;}return a|0}function Bj(){return (Cj()|0)+64|0}function Cj(){return Dj()|0}function Dj(){return 5424}function Ej(a){a=a|0;return a|0}function Fj(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;g=l;l=l+32|0;f=g;c[b+36>>2]=11;if((c[b>>2]&64|0)==0?(c[f>>2]=c[b+60>>2],c[f+4>>2]=21523,c[f+8>>2]=g+16,Ma(54,f|0)|0):0)a[b+75>>0]=-1;f=Gj(b,d,e)|0;l=g;return f|0}function Gj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,o=0,p=0;n=l;l=l+48|0;i=n+16|0;f=n;e=n+32|0;j=a+28|0;g=c[j>>2]|0;c[e>>2]=g;k=a+20|0;g=(c[k>>2]|0)-g|0;c[e+4>>2]=g;c[e+8>>2]=b;c[e+12>>2]=d;g=g+d|0;h=a+60|0;c[f>>2]=c[h>>2];c[f+4>>2]=e;c[f+8>>2]=2;b=Aj(ab(146,f|0)|0)|0;a:do if((g|0)!=(b|0)){f=2;while(1){if((b|0)<0)break;g=g-b|0;p=c[e+4>>2]|0;o=b>>>0>p>>>0;e=o?e+8|0:e;f=(o<<31>>31)+f|0;p=b-(o?p:0)|0;c[e>>2]=(c[e>>2]|0)+p;o=e+4|0;c[o>>2]=(c[o>>2]|0)-p;c[i>>2]=c[h>>2];c[i+4>>2]=e;c[i+8>>2]=f;b=Aj(ab(146,i|0)|0)|0;if((g|0)==(b|0)){m=3;break a}}c[a+16>>2]=0;c[j>>2]=0;c[k>>2]=0;c[a>>2]=c[a>>2]|32;if((f|0)==2)d=0;else d=d-(c[e+4>>2]|0)|0;}else m=3;while(0);if((m|0)==3){p=c[a+44>>2]|0;c[a+16>>2]=p+(c[a+48>>2]|0);c[j>>2]=p;c[k>>2]=p;}l=n;return d|0}function Hj(b){b=b|0;var d=0,e=0,f=0;f=b;a:do if(!(f&3)){d=b;e=4;}else {d=f;while(1){if(!(a[b>>0]|0))break a;b=b+1|0;d=b;if(!(d&3)){d=b;e=4;break}}}while(0);if((e|0)==4){while(1){b=c[d>>2]|0;if(!((b&-2139062144^-2139062144)&b+-16843009))d=d+4|0;else break}if((b&255)<<24>>24)do d=d+1|0;while((a[d>>0]|0)!=0)}return d-f|0}function Ij(a){a=a|0;return 0}function Jj(a){a=a|0;return}function Kj(a){a=a|0;return Nj(a,c[(Mj()|0)+188>>2]|0)|0}function Lj(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=d&255;f=(e|0)!=0;a:do if(f&(b&3|0)!=0){g=d&255;while(1){if((a[b>>0]|0)==g<<24>>24){i=6;break a}b=b+1|0;e=e+-1|0;f=(e|0)!=0;if(!(f&(b&3|0)!=0)){i=5;break}}}else i=5;while(0);if((i|0)==5)if(f)i=6;else e=0;b:do if((i|0)==6){g=d&255;if((a[b>>0]|0)!=g<<24>>24){f=N(h,16843009)|0;c:do if(e>>>0>3)while(1){h=c[b>>2]^f;if((h&-2139062144^-2139062144)&h+-16843009|0)break;b=b+4|0;e=e+-4|0;if(e>>>0<=3){i=11;break c}}else i=11;while(0);if((i|0)==11)if(!e){e=0;break}while(1){if((a[b>>0]|0)==g<<24>>24)break b;b=b+1|0;e=e+-1|0;if(!e){e=0;break}}}}while(0);return (e|0?b:0)|0}function Mj(){return Dj()|0}function Nj(b,e){b=b|0;e=e|0;var f=0,g=0;f=0;while(1){if((d[13704+f>>0]|0)==(b|0)){g=2;break}f=f+1|0;if((f|0)==87){f=87;b=13792;g=5;break}}if((g|0)==2)if(!f)f=13792;else {b=13792;g=5;}if((g|0)==5)while(1){do{g=b;b=b+1|0;}while((a[g>>0]|0)!=0);f=f+-1|0;if(!f){f=b;break}else g=5;}return Oj(f,c[e+20>>2]|0)|0}function Oj(a,b){a=a|0;b=b|0;return Pj(a,b)|0}function Pj(a,b){a=a|0;b=b|0;if(!b)b=0;else b=Qj(c[b>>2]|0,c[b+4>>2]|0,a)|0;return (b|0?b:a)|0}function Qj(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;o=(c[b>>2]|0)+1794895138|0;h=Rj(c[b+8>>2]|0,o)|0;f=Rj(c[b+12>>2]|0,o)|0;g=Rj(c[b+16>>2]|0,o)|0;a:do if((h>>>0<d>>>2>>>0?(n=d-(h<<2)|0,f>>>0<n>>>0&g>>>0<n>>>0):0)?((g|f)&3|0)==0:0){n=f>>>2;m=g>>>2;l=0;while(1){k=h>>>1;j=l+k|0;i=j<<1;g=i+n|0;f=Rj(c[b+(g<<2)>>2]|0,o)|0;g=Rj(c[b+(g+1<<2)>>2]|0,o)|0;if(!(g>>>0<d>>>0&f>>>0<(d-g|0)>>>0)){f=0;break a}if(a[b+(g+f)>>0]|0){f=0;break a}f=Sj(e,b+g|0)|0;if(!f)break;f=(f|0)<0;if((h|0)==1){f=0;break a}else {l=f?l:j;h=f?k:h-k|0;}}f=i+m|0;g=Rj(c[b+(f<<2)>>2]|0,o)|0;f=Rj(c[b+(f+1<<2)>>2]|0,o)|0;if(f>>>0<d>>>0&g>>>0<(d-f|0)>>>0)f=(a[b+(f+g)>>0]|0)==0?b+f|0:0;else f=0;}else f=0;while(0);return f|0}function Rj(a,b){a=a|0;b=b|0;var c=0;c=jk(a|0)|0;return ((b|0)==0?a:c)|0}function Sj(b,c){b=b|0;c=c|0;var d=0,e=0;d=a[b>>0]|0;e=a[c>>0]|0;if(!(d<<24>>24==0?1:d<<24>>24!=e<<24>>24))do{b=b+1|0;c=c+1|0;d=a[b>>0]|0;e=a[c>>0]|0;}while(!(d<<24>>24==0?1:d<<24>>24!=e<<24>>24));return (d&255)-(e&255)|0}function Tj(){Va(16452);return 16460}function Uj(){Na(16452);return}function Vj(a){a=a|0;var b=0,d=0;do if(a){if((c[a+76>>2]|0)<=-1){b=Wj(a)|0;break}d=(Ij(a)|0)==0;b=Wj(a)|0;if(!d)Jj(a);}else {if(!(c[1448]|0))b=0;else b=Vj(c[1448]|0)|0;a=c[(Tj()|0)>>2]|0;if(a)do{if((c[a+76>>2]|0)>-1)d=Ij(a)|0;else d=0;if((c[a+20>>2]|0)>>>0>(c[a+28>>2]|0)>>>0)b=Wj(a)|0|b;if(d|0)Jj(a);a=c[a+56>>2]|0;}while((a|0)!=0);Uj();}while(0);return b|0}function Wj(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;h=a+20|0;g=a+28|0;if((c[h>>2]|0)>>>0>(c[g>>2]|0)>>>0?(db[c[a+36>>2]&15](a,0,0)|0,(c[h>>2]|0)==0):0)b=-1;else {f=a+4|0;b=c[f>>2]|0;e=a+8|0;d=c[e>>2]|0;if(b>>>0<d>>>0)db[c[a+40>>2]&15](a,b-d|0,1)|0;c[a+16>>2]=0;c[g>>2]=0;c[h>>2]=0;c[e>>2]=0;c[f>>2]=0;b=0;}return b|0}function Xj(b,c,d){b=b|0;c=c|0;d=d|0;var e=0,f=0;a:do if(!d)b=0;else {while(1){e=a[b>>0]|0;f=a[c>>0]|0;if(e<<24>>24!=f<<24>>24)break;d=d+-1|0;if(!d){b=0;break a}else {b=b+1|0;c=c+1|0;}}b=(e&255)-(f&255)|0;}while(0);return b|0}function Yj(a){a=a|0;return Zj(a)|0}function Zj(a){a=a|0;return lk(a|0)|0}function _j(a){a=a|0;return $j(a)|0}function $j(a){a=a|0;return jk(a|0)|0}function ak(a){a=a|0;return bk(a)|0}function bk(a){a=a|0;return lk(a|0)|0}function ck(b,c,d){b=b|0;c=c|0;d=d|0;var e=0;e=Kj(b)|0;b=Hj(e)|0;if(b>>>0>=d>>>0){b=d+-1|0;if(!d)b=34;else {ok(c|0,e|0,b|0)|0;a[c+b>>0]=0;b=34;}}else {ok(c|0,e|0,b+1|0)|0;b=0;}return b|0}function dk(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=l;l=l+16|0;f=e;c[f>>2]=a;c[f+4>>2]=b;c[f+8>>2]=d;a=Aj(Xa(4,f|0)|0)|0;l=e;return a|0}function ek(){}function fk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (y=d,a-c>>>0|0)|0}function gk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return (y=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function hk(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=b+e|0;d=d&255;if((e|0)>=67){while(b&3){a[b>>0]=d;b=b+1|0;}f=h&-4|0;g=f-64|0;i=d|d<<8|d<<16|d<<24;while((b|0)<=(g|0)){c[b>>2]=i;c[b+4>>2]=i;c[b+8>>2]=i;c[b+12>>2]=i;c[b+16>>2]=i;c[b+20>>2]=i;c[b+24>>2]=i;c[b+28>>2]=i;c[b+32>>2]=i;c[b+36>>2]=i;c[b+40>>2]=i;c[b+44>>2]=i;c[b+48>>2]=i;c[b+52>>2]=i;c[b+56>>2]=i;c[b+60>>2]=i;b=b+64|0;}while((b|0)<(f|0)){c[b>>2]=i;b=b+4|0;}}while((b|0)<(h|0)){a[b>>0]=d;b=b+1|0;}return h-e|0}function ik(a){a=a|0;return 0}function jk(a){a=a|0;return (a&255)<<24|(a>>8&255)<<16|(a>>16&255)<<8|a>>>24|0}function kk(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){y=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}y=0;return b>>>c-32|0}function lk(a){a=a|0;return (a&255)<<8|a>>8&255|0}function mk(a){a=a|0;return 0}function nk(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){y=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}y=a<<c-32;return 0}function ok(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;if((e|0)>=8192)return Ea(b|0,d|0,e|0)|0;h=b|0;g=b+e|0;if((b&3)==(d&3)){while(b&3){if(!e)return h|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0;}e=g&-4|0;f=e-64|0;while((b|0)<=(f|0)){c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[b+28>>2]=c[d+28>>2];c[b+32>>2]=c[d+32>>2];c[b+36>>2]=c[d+36>>2];c[b+40>>2]=c[d+40>>2];c[b+44>>2]=c[d+44>>2];c[b+48>>2]=c[d+48>>2];c[b+52>>2]=c[d+52>>2];c[b+56>>2]=c[d+56>>2];c[b+60>>2]=c[d+60>>2];b=b+64|0;d=d+64|0;}while((b|0)<(e|0)){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}}else {e=g-4|0;while((b|0)<(e|0)){a[b>>0]=a[d>>0]|0;a[b+1>>0]=a[d+1>>0]|0;a[b+2>>0]=a[d+2>>0]|0;a[b+3>>0]=a[d+3>>0]|0;b=b+4|0;d=d+4|0;}}while((b|0)<(g|0)){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;}return h|0}function pk(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;e=b&65535;c=N(e,f)|0;d=a>>>16;a=(c>>>16)+(N(e,d)|0)|0;e=b>>>16;b=N(e,f)|0;return (y=(a>>>16)+(N(e,d)|0)+(((a&65535)+b|0)>>>16)|0,a+b<<16|c&65535|0)|0}function qk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;c=pk(e,f)|0;a=y;return (y=(N(b,f)|0)+(N(d,e)|0)+a|a&0,c|0|0)|0}function rk(a){a=a|0;var b=0,d=0;d=a+15&-16|0;b=c[i>>2]|0;a=b+d|0;if((d|0)>0&(a|0)<(b|0)|(a|0)<0){V()|0;ka(12);return -1}c[i>>2]=a;if((a|0)>(U()|0)?(T()|0)==0:0){c[i>>2]=b;ka(12);return -1}return b|0}function sk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return db[a&15](b|0,c|0,d|0)|0}function tk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;eb[a&3](b|0,c|0,d|0,e|0,f|0);}function uk(a){a=a|0;return fb[a&7]()|0}function vk(a,b){a=a|0;b=b|0;gb[a&63](b|0);}function wk(a,b,c){a=a|0;b=b|0;c=c|0;hb[a&31](b|0,c|0);}function xk(a,b){a=a|0;b=b|0;return ib[a&15](b|0)|0}function yk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;jb[a&31](b|0,c|0,d|0);}function zk(a){a=a|0;kb[a&3]();}function Ak(a,b,c){a=a|0;b=b|0;c=c|0;return lb[a&127](b|0,c|0)|0}function Bk(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return mb[a&1](b|0,c|0,d|0,e|0,f|0)|0}function Ck(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;nb[a&15](b|0,c|0,d|0,e|0);}function Dk(a,b,c){a=a|0;b=b|0;c=c|0;R(0);return 0}function Ek(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;R(1);}function Fk(){R(2);return 0}function Gk(a){a=a|0;R(3);}function Hk(a,b){a=a|0;b=b|0;R(4);}function Ik(a){a=a|0;R(5);return 0}function Jk(a,b,c){a=a|0;b=b|0;c=c|0;R(6);}function Kk(){R(7);}function Lk(a,b){a=a|0;b=b|0;R(8);return 0}function Mk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;R(9);return 0}function Nk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;R(10);}

  // EMSCRIPTEN_END_FUNCS
  var db=[Dk,Jd,Id,Kf,Gh,Pi,hi,Fj,zj,dc,ki,Gj,Dk,Dk,Dk,Dk];var eb=[Ek,Mc,Wc,Ek];var fb=[Fk,ce,de,Me,Rg,Fk,Fk,Fk];var gb=[Gk,Bb,id,_d,be,ee,ge,he,ne,Ne,He,df,ef,ff,gf,qf,tf,Bf,uf,yf,wf,Of,Nf,Rf,hg,Qg,Sg,re,$g,Ch,gi,Mi,Li,Oi,ej,hj,ac,fc,nc,vb,oc,Rb,Yc,sd,$i,rd,hf,jh,Oe,oe,Te,Md,ze,ke,Bg,xh,sg,Ve,Lg,Ye,Qf,nh,Gk,Gk];var hb=[Hk,Je,Sd,Kd,_f,Yf,Sf,Tf,lj,aj,Nb,lc,jc,kc,kj,mc,sc,dd,Nc,Xc,Rc,cj,Ue,$e,kh,Ef,we,Ah,_e,Hk,Hk,Hk];var ib=[Ik,Cb,Db,kd,Tg,vd,Ld,Zf,yj,ue,bc,_g,me,Ri,pg,Ik];var jb=[Jk,Le,Hb,$b,hc,ld,Ib,wb,gc,cc,ic,ec,rc,qc,pc,cd,Kc,Lc,Fc,bj,td,ve,Ce,Cg,Ag,Nh,Dg,uh,Uh,Jk,Jk,Jk];var kb=[Kk,Ub,ng,Kk];var lb=[Lk,$d,yd,Ed,Gd,Td,Zd,$f,gg,di,rf,Cf,Af,vf,zf,xf,xd,Hg,Xg,Fd,Hd,mf,nf,Eh,Fh,Xi,Yi,Di,dj,ii,ji,Ci,ij,Vb,Pf,tc,nd,Ki,Bi,ai,ni,Ad,Mh,Vd,Ug,ih,fi,hh,gj,mj,nj,Mf,yh,Jf,ei,si,Bd,zd,ae,If,wd,Th,Rh,li,Ei,Ai,Zi,$h,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk,Lk];var mb=[Mk,Qi];var nb=[Nk,Ie,Ke,xb,Jc,Ii,ag,cf,Hf,Nk,Nk,Nk,Nk,Nk,Nk,Nk];return {_main:Tb,dynCall_i:uk,stackSave:pb,_i64Subtract:fk,_rust_eh_personality:Kh,setThrew:sb,dynCall_viii:yk,_bitshift64Lshr:kk,_ec_pairing:Qb,_bitshift64Shl:nk,_fflush:Vj,_htonl:_j,___errno_location:Bj,_memset:hk,dynCall_ii:xk,_sbrk:rk,_memcpy:ok,stackAlloc:ob,___muldi3:qk,_ec_mul:Lb,dynCall_vi:vk,getTempRet0:ub,dynCall_vii:wk,_ntohs:ak,setTempRet0:tb,_i64Add:gk,dynCall_iiii:sk,_pthread_mutex_unlock:mk,_llvm_bswap_i16:lk,_emscripten_get_global_libc:xj,_htons:Yj,dynCall_viiii:Ck,dynCall_iiiiii:Bk,_llvm_bswap_i32:jk,dynCall_viiiii:tk,_free:rj,runPostSets:ek,establishStackSpace:rb,stackRestore:qb,_malloc:qj,dynCall_iii:Ak,_pthread_mutex_lock:ik,dynCall_v:zk,_ec_add:Pb}})


  // EMSCRIPTEN_END_ASM
  (Module.asmGlobalArg,Module.asmLibraryArg,buffer);Module["_main"]=asm["_main"];Module["stackSave"]=asm["stackSave"];Module["getTempRet0"]=asm["getTempRet0"];Module["_rust_eh_personality"]=asm["_rust_eh_personality"];Module["setThrew"]=asm["setThrew"];Module["_bitshift64Lshr"]=asm["_bitshift64Lshr"];Module["_ec_pairing"]=asm["_ec_pairing"];Module["_bitshift64Shl"]=asm["_bitshift64Shl"];Module["_fflush"]=asm["_fflush"];Module["setTempRet0"]=asm["setTempRet0"];Module["_memset"]=asm["_memset"];Module["_sbrk"]=asm["_sbrk"];Module["_memcpy"]=asm["_memcpy"];var _llvm_bswap_i32=Module["_llvm_bswap_i32"]=asm["_llvm_bswap_i32"];Module["___muldi3"]=asm["___muldi3"];Module["_ec_mul"]=asm["_ec_mul"];Module["stackAlloc"]=asm["stackAlloc"];Module["_i64Subtract"]=asm["_i64Subtract"];Module["_ntohs"]=asm["_ntohs"];Module["_htonl"]=asm["_htonl"];Module["_i64Add"]=asm["_i64Add"];Module["_pthread_mutex_unlock"]=asm["_pthread_mutex_unlock"];Module["_llvm_bswap_i16"]=asm["_llvm_bswap_i16"];Module["_emscripten_get_global_libc"]=asm["_emscripten_get_global_libc"];Module["_htons"]=asm["_htons"];Module["___errno_location"]=asm["___errno_location"];var _free=Module["_free"]=asm["_free"];Module["runPostSets"]=asm["runPostSets"];Module["establishStackSpace"]=asm["establishStackSpace"];Module["stackRestore"]=asm["stackRestore"];var _malloc=Module["_malloc"]=asm["_malloc"];Module["_pthread_mutex_lock"]=asm["_pthread_mutex_lock"];Module["_ec_add"]=asm["_ec_add"];Module["dynCall_iiii"]=asm["dynCall_iiii"];Module["dynCall_viiiii"]=asm["dynCall_viiiii"];Module["dynCall_i"]=asm["dynCall_i"];Module["dynCall_vi"]=asm["dynCall_vi"];Module["dynCall_vii"]=asm["dynCall_vii"];Module["dynCall_ii"]=asm["dynCall_ii"];Module["dynCall_viii"]=asm["dynCall_viii"];Module["dynCall_v"]=asm["dynCall_v"];Module["dynCall_iii"]=asm["dynCall_iii"];Module["dynCall_iiiiii"]=asm["dynCall_iiiiii"];Module["dynCall_viiii"]=asm["dynCall_viiii"];Runtime.stackAlloc=Module["stackAlloc"];Runtime.stackSave=Module["stackSave"];Runtime.stackRestore=Module["stackRestore"];Runtime.establishStackSpace=Module["establishStackSpace"];Runtime.setTempRet0=Module["setTempRet0"];Runtime.getTempRet0=Module["getTempRet0"];Module["asm"]=asm;if(memoryInitializer){if(typeof Module["locateFile"]==="function"){memoryInitializer=Module["locateFile"](memoryInitializer);}else if(Module["memoryInitializerPrefixURL"]){memoryInitializer=Module["memoryInitializerPrefixURL"]+memoryInitializer;}if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=Module["readBinary"](memoryInitializer);HEAPU8.set(data,Runtime.GLOBAL_BASE);}else {addRunDependency();var applyMemoryInitializer=(function(data){if(data.byteLength)data=new Uint8Array(data);HEAPU8.set(data,Runtime.GLOBAL_BASE);if(Module["memoryInitializerRequest"])delete Module["memoryInitializerRequest"].response;removeRunDependency();});function doBrowserLoad(){Module["readAsync"](memoryInitializer,applyMemoryInitializer,(function(){throw "could not load memory initializer "+memoryInitializer}));}var memoryInitializerBytes=tryParseAsDataURI(memoryInitializer);if(memoryInitializerBytes){applyMemoryInitializer(memoryInitializerBytes.buffer);}else if(Module["memoryInitializerRequest"]){function useRequest(){var request=Module["memoryInitializerRequest"];var response=request.response;if(request.status!==200&&request.status!==0){var data=tryParseAsDataURI(Module["memoryInitializerRequestURL"]);if(data){response=data.buffer;}else {console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: "+request.status+", retrying "+memoryInitializer);doBrowserLoad();return}}applyMemoryInitializer(response);}if(Module["memoryInitializerRequest"].response){setTimeout(useRequest,0);}else {Module["memoryInitializerRequest"].addEventListener("load",useRequest);}}else {doBrowserLoad();}}}function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status;}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller;};Module["callMain"]=Module.callMain=function callMain(args){args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++){argv.push(0);}}var argv=[allocate(intArrayFromString(Module["thisProgram"]),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),"i8",ALLOC_NORMAL));pad();}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);try{var ret=Module["_main"](argc,argv,0);exit(ret,true);}catch(e){if(e instanceof ExitStatus){return}else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else {var toLog=e;if(e&&typeof e==="object"&&e.stack){toLog=[e,e.stack];}Module.printErr("exception thrown: "+toLog);Module["quit"](1,e);}}finally{}};function run(args){args=args||Module["arguments"];if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(Module["_main"]&&shouldRunNow)Module["callMain"](args);postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("");}),1);doRun();}),1);}else {doRun();}}Module["run"]=Module.run=run;function exit(status,implicit){if(implicit&&Module["noExitRuntime"]){return}if(Module["noExitRuntime"]);else {ABORT=true;STACKTOP=initialStackTop;exitRuntime();if(Module["onExit"])Module["onExit"](status);}if(ENVIRONMENT_IS_NODE){browser$1$1["exit"](status);}Module["quit"](status,new ExitStatus(status));}Module["exit"]=Module.exit=exit;var abortDecorators=[];function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}if(what!==undefined){Module.print(what);Module.printErr(what);what=JSON.stringify(what);}else {what="";}ABORT=true;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";var output="abort("+what+") at "+stackTrace()+extra;if(abortDecorators){abortDecorators.forEach((function(decorator){output=decorator(output,what);}));}throw output}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}var shouldRunNow=true;if(Module["noInitialRun"]){shouldRunNow=false;}Module["arguments"]=[];run();module.exports=Module;
  }(index_asm));

  const bn128$3 = index_asm.exports;

  const ec_add = bn128$3.cwrap('ec_add', 'string', ['string']);
  const ec_mul = bn128$3.cwrap('ec_mul', 'string', ['string']);
  const ec_pairing = bn128$3.cwrap('ec_pairing', 'string', ['string']);

  function bn128add (input) {
    return Buffer$8.from(ec_add(input.toString('hex')), 'hex')
  }

  function bn128mul (input) {
    return Buffer$8.from(ec_mul(input.toString('hex')), 'hex')
  }

  function bn128pairing (input) {
    return Buffer$8.from(ec_pairing(input.toString('hex')), 'hex')
  }

  var rustbn_js = {
    add: bn128add,
    mul: bn128mul,
    pairing: bn128pairing
  };

  Object.defineProperty(_06Ecadd, "__esModule", { value: true });
  _06Ecadd.precompile06 = void 0;
  const util_1$F = dist$a;
  const evm_1$d = evm$1;
  const bn128$2 = rustbn_js;
  function precompile06(opts) {
      if ((0, util_1$F.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const inputData = opts.data;
      const gasUsed = opts._common.param('gasPrices', 'ecAdd');
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$d.OOGResult)(opts.gasLimit);
      }
      const returnData = bn128$2.add(inputData);
      // check ecadd success or failure by comparing the output length
      if (returnData.length !== 64) {
          return (0, evm_1$d.OOGResult)(opts.gasLimit);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: returnData,
      };
  }
  _06Ecadd.precompile06 = precompile06;

  var _07Ecmul = {};

  Object.defineProperty(_07Ecmul, "__esModule", { value: true });
  _07Ecmul.precompile07 = void 0;
  const util_1$E = dist$a;
  const evm_1$c = evm$1;
  const bn128$1 = rustbn_js;
  function precompile07(opts) {
      if ((0, util_1$E.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const inputData = opts.data;
      const gasUsed = opts._common.param('gasPrices', 'ecMul');
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$c.OOGResult)(opts.gasLimit);
      }
      const returnData = bn128$1.mul(inputData);
      // check ecmul success or failure by comparing the output length
      if (returnData.length !== 64) {
          return (0, evm_1$c.OOGResult)(opts.gasLimit);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: returnData,
      };
  }
  _07Ecmul.precompile07 = precompile07;

  var _08Ecpairing = {};

  Object.defineProperty(_08Ecpairing, "__esModule", { value: true });
  _08Ecpairing.precompile08 = void 0;
  const util_1$D = dist$a;
  const evm_1$b = evm$1;
  const bn128 = rustbn_js;
  function precompile08(opts) {
      if ((0, util_1$D.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const inputData = opts.data;
      // no need to care about non-divisible-by-192, because bn128.pairing will properly fail in that case
      const inputDataSize = BigInt(Math.floor(inputData.length / 192));
      const gasUsed = opts._common.param('gasPrices', 'ecPairing') +
          inputDataSize * opts._common.param('gasPrices', 'ecPairingWord');
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$b.OOGResult)(opts.gasLimit);
      }
      const returnData = bn128.pairing(inputData);
      // check ecpairing success or failure by comparing the output length
      if (returnData.length !== 32) {
          return (0, evm_1$b.OOGResult)(opts.gasLimit);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: returnData,
      };
  }
  _08Ecpairing.precompile08 = precompile08;

  var _09Blake2f = {};

  Object.defineProperty(_09Blake2f, "__esModule", { value: true });
  _09Blake2f.precompile09 = _09Blake2f.F = void 0;
  const util_1$C = dist$a;
  const evm_1$a = evm$1;
  const exceptions_1$a = exceptions;
  // The following blake2 code has been taken from (license: Creative Commons CC0):
  // https://github.com/dcposch/blakejs/blob/410c640d0f08d3b26904c6d1ab3d81df3619d282/blake2b.js
  // The modifications include:
  //  - Avoiding the use of context in F
  //  - F accepts number of rounds as parameter
  //  - Expect 2 64-byte t values, xor them both
  //  - Take modulo 10 for indices of SIGMA
  //  - Added type annotations
  //  - Moved previously global `v` and `m` variables inside the F function
  // 64-bit unsigned addition
  // Sets v[a,a+1] += v[b,b+1]
  // v should be a Uint32Array
  function ADD64AA(v, a, b) {
      const o0 = v[a] + v[b];
      let o1 = v[a + 1] + v[b + 1];
      if (o0 >= 0x100000000) {
          o1++;
      }
      v[a] = o0;
      v[a + 1] = o1;
  }
  // 64-bit unsigned addition
  // Sets v[a,a+1] += b
  // b0 is the low 32 bits of b, b1 represents the high 32 bits
  function ADD64AC(v, a, b0, b1) {
      let o0 = v[a] + b0;
      if (b0 < 0) {
          o0 += 0x100000000;
      }
      let o1 = v[a + 1] + b1;
      if (o0 >= 0x100000000) {
          o1++;
      }
      v[a] = o0;
      v[a + 1] = o1;
  }
  // G Mixing function
  // The ROTRs are inlined for speed
  function B2B_G(v, mw, a, b, c, d, ix, iy) {
      const x0 = mw[ix];
      const x1 = mw[ix + 1];
      const y0 = mw[iy];
      const y1 = mw[iy + 1];
      ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
      ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
      // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
      let xor0 = v[d] ^ v[a];
      let xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor1;
      v[d + 1] = xor0;
      ADD64AA(v, c, d);
      // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = (xor0 >>> 24) ^ (xor1 << 8);
      v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);
      ADD64AA(v, a, b);
      ADD64AC(v, a, y0, y1);
      // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
      xor0 = v[d] ^ v[a];
      xor1 = v[d + 1] ^ v[a + 1];
      v[d] = (xor0 >>> 16) ^ (xor1 << 16);
      v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);
      ADD64AA(v, c, d);
      // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = (xor1 >>> 31) ^ (xor0 << 1);
      v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
  }
  // Initialization Vector
  // prettier-ignore
  const BLAKE2B_IV32 = new Uint32Array([0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,]);
  // prettier-ignore
  const SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,];
  // These are offsets into a uint64 buffer.
  // Multiply them all by 2 to make them offsets into a uint32 buffer,
  // because this is Javascript and we don't have uint64s
  const SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {
      return x * 2;
  }));
  function F(h, m, t, f, rounds) {
      const v = new Uint32Array(32);
      let i = 0;
      // init work variables
      for (i = 0; i < 16; i++) {
          v[i] = h[i];
          v[i + 16] = BLAKE2B_IV32[i];
      }
      // 128 bits of offset
      v[24] = v[24] ^ t[0];
      v[25] = v[25] ^ t[1];
      v[26] = v[26] ^ t[2];
      v[27] = v[27] ^ t[3];
      // last block flag set ?
      if (f) {
          v[28] = ~v[28];
          v[29] = ~v[29];
      }
      // twelve rounds of mixing
      // uncomment the DebugPrint calls to log the computation
      // and match the RFC sample documentation
      // util.debugPrint('          m[16]', m, 64)
      for (i = 0; i < rounds; i++) {
          // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
          const ri = (i % 10) * 16;
          B2B_G(v, m, 0, 8, 16, 24, SIGMA82[ri + 0], SIGMA82[ri + 1]);
          B2B_G(v, m, 2, 10, 18, 26, SIGMA82[ri + 2], SIGMA82[ri + 3]);
          B2B_G(v, m, 4, 12, 20, 28, SIGMA82[ri + 4], SIGMA82[ri + 5]);
          B2B_G(v, m, 6, 14, 22, 30, SIGMA82[ri + 6], SIGMA82[ri + 7]);
          B2B_G(v, m, 0, 10, 20, 30, SIGMA82[ri + 8], SIGMA82[ri + 9]);
          B2B_G(v, m, 2, 12, 22, 24, SIGMA82[ri + 10], SIGMA82[ri + 11]);
          B2B_G(v, m, 4, 14, 16, 26, SIGMA82[ri + 12], SIGMA82[ri + 13]);
          B2B_G(v, m, 6, 8, 18, 28, SIGMA82[ri + 14], SIGMA82[ri + 15]);
      }
      for (i = 0; i < 16; i++) {
          h[i] = h[i] ^ v[i] ^ v[i + 16];
      }
  }
  _09Blake2f.F = F;
  function precompile09(opts) {
      if ((0, util_1$C.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const data = opts.data;
      if (data.length !== 213) {
          return {
              returnValue: Buffer$8.alloc(0),
              executionGasUsed: opts.gasLimit,
              exceptionError: new exceptions_1$a.EvmError(exceptions_1$a.ERROR.OUT_OF_RANGE),
          };
      }
      const lastByte = data.slice(212, 213)[0];
      if (lastByte !== 1 && lastByte !== 0) {
          return {
              returnValue: Buffer$8.alloc(0),
              executionGasUsed: opts.gasLimit,
              exceptionError: new exceptions_1$a.EvmError(exceptions_1$a.ERROR.OUT_OF_RANGE),
          };
      }
      const rounds = data.slice(0, 4).readUInt32BE(0);
      const hRaw = data.slice(4, 68);
      const mRaw = data.slice(68, 196);
      const tRaw = data.slice(196, 212);
      // final
      const f = lastByte === 1;
      let gasUsed = opts._common.param('gasPrices', 'blake2Round');
      gasUsed *= BigInt(rounds);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$a.OOGResult)(opts.gasLimit);
      }
      const h = new Uint32Array(16);
      for (let i = 0; i < 16; i++) {
          h[i] = hRaw.readUInt32LE(i * 4);
      }
      const m = new Uint32Array(32);
      for (let i = 0; i < 32; i++) {
          m[i] = mRaw.readUInt32LE(i * 4);
      }
      const t = new Uint32Array(4);
      for (let i = 0; i < 4; i++) {
          t[i] = tRaw.readUInt32LE(i * 4);
      }
      F(h, m, t, f, rounds);
      const output = Buffer$8.alloc(64);
      for (let i = 0; i < 16; i++) {
          output.writeUInt32LE(h[i], i * 4);
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: output,
      };
  }
  _09Blake2f.precompile09 = precompile09;

  var _0aBls12G1add = {};

  var bls12_381 = {};

  Object.defineProperty(bls12_381, "__esModule", { value: true });
  bls12_381.BLS12_381_ToG2Point = bls12_381.BLS12_381_ToG1Point = bls12_381.BLS12_381_ToFrPoint = bls12_381.BLS12_381_ToFpPoint = bls12_381.BLS12_381_ToFp2Point = bls12_381.BLS12_381_FromG2Point = bls12_381.BLS12_381_FromG1Point = bls12_381.gasDiscountPairs = void 0;
  const util_1$B = dist$a;
  const exceptions_1$9 = exceptions;
  // base field modulus as described in the EIP
  const fieldModulus = BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab');
  // gas discount pairs taken from EIP-2537 `Bls12381MultiExpGasDiscount` parameter
  bls12_381.gasDiscountPairs = [
      [1, 1200],
      [2, 888],
      [3, 764],
      [4, 641],
      [5, 594],
      [6, 547],
      [7, 500],
      [8, 453],
      [9, 438],
      [10, 423],
      [11, 408],
      [12, 394],
      [13, 379],
      [14, 364],
      [15, 349],
      [16, 334],
      [17, 330],
      [18, 326],
      [19, 322],
      [20, 318],
      [21, 314],
      [22, 310],
      [23, 306],
      [24, 302],
      [25, 298],
      [26, 294],
      [27, 289],
      [28, 285],
      [29, 281],
      [30, 277],
      [31, 273],
      [32, 269],
      [33, 268],
      [34, 266],
      [35, 265],
      [36, 263],
      [37, 262],
      [38, 260],
      [39, 259],
      [40, 257],
      [41, 256],
      [42, 254],
      [43, 253],
      [44, 251],
      [45, 250],
      [46, 248],
      [47, 247],
      [48, 245],
      [49, 244],
      [50, 242],
      [51, 241],
      [52, 239],
      [53, 238],
      [54, 236],
      [55, 235],
      [56, 233],
      [57, 232],
      [58, 231],
      [59, 229],
      [60, 228],
      [61, 226],
      [62, 225],
      [63, 223],
      [64, 222],
      [65, 221],
      [66, 220],
      [67, 219],
      [68, 219],
      [69, 218],
      [70, 217],
      [71, 216],
      [72, 216],
      [73, 215],
      [74, 214],
      [75, 213],
      [76, 213],
      [77, 212],
      [78, 211],
      [79, 211],
      [80, 210],
      [81, 209],
      [82, 208],
      [83, 208],
      [84, 207],
      [85, 206],
      [86, 205],
      [87, 205],
      [88, 204],
      [89, 203],
      [90, 202],
      [91, 202],
      [92, 201],
      [93, 200],
      [94, 199],
      [95, 199],
      [96, 198],
      [97, 197],
      [98, 196],
      [99, 196],
      [100, 195],
      [101, 194],
      [102, 193],
      [103, 193],
      [104, 192],
      [105, 191],
      [106, 191],
      [107, 190],
      [108, 189],
      [109, 188],
      [110, 188],
      [111, 187],
      [112, 186],
      [113, 185],
      [114, 185],
      [115, 184],
      [116, 183],
      [117, 182],
      [118, 182],
      [119, 181],
      [120, 180],
      [121, 179],
      [122, 179],
      [123, 178],
      [124, 177],
      [125, 176],
      [126, 176],
      [127, 175],
      [128, 174],
  ];
  // convert an input Buffer to a mcl G1 point
  // this does /NOT/ do any input checks. the input Buffer needs to be of length 128
  // it does raise an error if the point is not on the curve.
  function BLS12_381_ToG1Point$4(input, mcl) {
      const p_x = input.slice(16, 64).toString('hex');
      const p_y = input.slice(80, 128).toString('hex');
      const ZeroString48Bytes = '0'.repeat(96);
      if (p_x == p_y && p_x == ZeroString48Bytes) {
          return new mcl.G1();
      }
      const Fp_X = new mcl.Fp();
      const Fp_Y = new mcl.Fp();
      const One = new mcl.Fp();
      Fp_X.setStr(p_x, 16);
      Fp_Y.setStr(p_y, 16);
      One.setStr('1', 16);
      const G1 = new mcl.G1();
      G1.setX(Fp_X);
      G1.setY(Fp_Y);
      G1.setZ(One);
      if (G1.isValidOrder() === false) {
          throw new exceptions_1$9.EvmError(exceptions_1$9.ERROR.BLS_12_381_POINT_NOT_ON_CURVE);
      }
      // Check if these coordinates are actually on the curve.
      if (G1.isValid() === false) {
          throw new exceptions_1$9.EvmError(exceptions_1$9.ERROR.BLS_12_381_POINT_NOT_ON_CURVE);
      }
      return G1;
  }
  bls12_381.BLS12_381_ToG1Point = BLS12_381_ToG1Point$4;
  // input: a mcl G1 point
  // output: a 128-byte Buffer
  function BLS12_381_FromG1Point$4(input) {
      // TODO: figure out if there is a better way to decode these values.
      const decodeStr = input.getStr(16); //return a string of pattern "1 <x_coord> <y_coord>"
      const decoded = decodeStr.match(/"?[0-9a-f]+"?/g); // match above pattern.
      if (decodeStr == '0') {
          return Buffer$8.alloc(128, 0);
      }
      // note: decoded[0] == 1
      const xval = (0, util_1$B.padToEven)(decoded[1]);
      const yval = (0, util_1$B.padToEven)(decoded[2]);
      // convert to buffers.
      const xBuffer = Buffer$8.concat([Buffer$8.alloc(64 - xval.length / 2, 0), Buffer$8.from(xval, 'hex')]);
      const yBuffer = Buffer$8.concat([Buffer$8.alloc(64 - yval.length / 2, 0), Buffer$8.from(yval, 'hex')]);
      return Buffer$8.concat([xBuffer, yBuffer]);
  }
  bls12_381.BLS12_381_FromG1Point = BLS12_381_FromG1Point$4;
  // convert an input Buffer to a mcl G2 point
  // this does /NOT/ do any input checks. the input Buffer needs to be of length 256
  function BLS12_381_ToG2Point$4(input, mcl) {
      const p_x_1 = input.slice(0, 64);
      const p_x_2 = input.slice(64, 128);
      const p_y_1 = input.slice(128, 192);
      const p_y_2 = input.slice(192, 256);
      const ZeroBytes64 = Buffer$8.alloc(64, 0);
      // check if we have to do with a zero point
      if (p_x_1.equals(p_x_2) &&
          p_x_1.equals(p_y_1) &&
          p_x_1.equals(p_y_2) &&
          p_x_1.equals(ZeroBytes64)) {
          return new mcl.G2();
      }
      const Fp2X = BLS12_381_ToFp2Point$1(p_x_1, p_x_2, mcl);
      const Fp2Y = BLS12_381_ToFp2Point$1(p_y_1, p_y_2, mcl);
      const FpOne = new mcl.Fp();
      FpOne.setStr('1', 16);
      const FpZero = new mcl.Fp();
      FpZero.setStr('0', 16);
      const Fp2One = new mcl.Fp2();
      Fp2One.set_a(FpOne);
      Fp2One.set_b(FpZero);
      const mclPoint = new mcl.G2();
      mclPoint.setX(Fp2X);
      mclPoint.setY(Fp2Y);
      mclPoint.setZ(Fp2One);
      if (mclPoint.isValidOrder() === false) {
          throw new exceptions_1$9.EvmError(exceptions_1$9.ERROR.BLS_12_381_POINT_NOT_ON_CURVE);
      }
      if (mclPoint.isValid() === false) {
          throw new exceptions_1$9.EvmError(exceptions_1$9.ERROR.BLS_12_381_POINT_NOT_ON_CURVE);
      }
      return mclPoint;
  }
  bls12_381.BLS12_381_ToG2Point = BLS12_381_ToG2Point$4;
  // input: a mcl G2 point
  // output: a 256-byte Buffer
  function BLS12_381_FromG2Point$4(input) {
      // TODO: figure out if there is a better way to decode these values.
      const decodeStr = input.getStr(16); //return a string of pattern "1 <x_coord_1> <x_coord_2> <y_coord_1> <y_coord_2>"
      if (decodeStr == '0') {
          return Buffer$8.alloc(256, 0);
      }
      const decoded = decodeStr.match(/"?[0-9a-f]+"?/g); // match above pattern.
      // note: decoded[0] == 1
      const x_1 = (0, util_1$B.padToEven)(decoded[1]);
      const x_2 = (0, util_1$B.padToEven)(decoded[2]);
      const y_1 = (0, util_1$B.padToEven)(decoded[3]);
      const y_2 = (0, util_1$B.padToEven)(decoded[4]);
      // convert to buffers.
      const xBuffer1 = Buffer$8.concat([Buffer$8.alloc(64 - x_1.length / 2, 0), Buffer$8.from(x_1, 'hex')]);
      const xBuffer2 = Buffer$8.concat([Buffer$8.alloc(64 - x_2.length / 2, 0), Buffer$8.from(x_2, 'hex')]);
      const yBuffer1 = Buffer$8.concat([Buffer$8.alloc(64 - y_1.length / 2, 0), Buffer$8.from(y_1, 'hex')]);
      const yBuffer2 = Buffer$8.concat([Buffer$8.alloc(64 - y_2.length / 2, 0), Buffer$8.from(y_2, 'hex')]);
      return Buffer$8.concat([xBuffer1, xBuffer2, yBuffer1, yBuffer2]);
  }
  bls12_381.BLS12_381_FromG2Point = BLS12_381_FromG2Point$4;
  // input: a 32-byte hex scalar Buffer
  // output: a mcl Fr point
  function BLS12_381_ToFrPoint$4(input, mcl) {
      const mclHex = mcl.fromHexStr(input.toString('hex'));
      const Fr = new mcl.Fr();
      Fr.setBigEndianMod(mclHex);
      return Fr;
  }
  bls12_381.BLS12_381_ToFrPoint = BLS12_381_ToFrPoint$4;
  // input: a 64-byte buffer
  // output: a mcl Fp point
  function BLS12_381_ToFpPoint$1(fpCoordinate, mcl) {
      // check if point is in field
      if ((0, util_1$B.bufferToBigInt)(fpCoordinate) >= fieldModulus) {
          throw new exceptions_1$9.EvmError(exceptions_1$9.ERROR.BLS_12_381_FP_NOT_IN_FIELD);
      }
      const fp = new mcl.Fp();
      fp.setBigEndianMod(mcl.fromHexStr(fpCoordinate.toString('hex')));
      return fp;
  }
  bls12_381.BLS12_381_ToFpPoint = BLS12_381_ToFpPoint$1;
  // input: two 64-byte buffers
  // output: a mcl Fp2 point
  function BLS12_381_ToFp2Point$1(fpXCoordinate, fpYCoordinate, mcl) {
      // check if the coordinates are in the field
      if ((0, util_1$B.bufferToBigInt)(fpXCoordinate) >= fieldModulus) {
          throw new exceptions_1$9.EvmError(exceptions_1$9.ERROR.BLS_12_381_FP_NOT_IN_FIELD);
      }
      if ((0, util_1$B.bufferToBigInt)(fpYCoordinate) >= fieldModulus) {
          throw new exceptions_1$9.EvmError(exceptions_1$9.ERROR.BLS_12_381_FP_NOT_IN_FIELD);
      }
      const fp_x = new mcl.Fp();
      const fp_y = new mcl.Fp();
      const fp2 = new mcl.Fp2();
      fp_x.setStr(fpXCoordinate.slice(16).toString('hex'), 16);
      fp_y.setStr(fpYCoordinate.slice(16).toString('hex'), 16);
      fp2.set_a(fp_x);
      fp2.set_b(fp_y);
      return fp2;
  }
  bls12_381.BLS12_381_ToFp2Point = BLS12_381_ToFp2Point$1;

  Object.defineProperty(_0aBls12G1add, "__esModule", { value: true });
  _0aBls12G1add.precompile0a = void 0;
  const util_1$A = dist$a;
  const evm_1$9 = evm$1;
  const exceptions_1$8 = exceptions;
  const { BLS12_381_ToG1Point: BLS12_381_ToG1Point$3, BLS12_381_FromG1Point: BLS12_381_FromG1Point$3 } = bls12_381;
  async function precompile0a(opts) {
      if ((0, util_1$A.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      // note: the gas used is constant; even if the input is incorrect.
      const gasUsed = opts._common.paramByEIP('gasPrices', 'Bls12381G1AddGas', 2537) ?? BigInt(0);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$9.OOGResult)(opts.gasLimit);
      }
      if (inputData.length != 256) {
          return (0, evm_1$9.EvmErrorResult)(new exceptions_1$8.EvmError(exceptions_1$8.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // check if some parts of input are zero bytes.
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
          [128, 144],
          [192, 208],
      ];
      for (const index in zeroByteCheck) {
          const slicedBuffer = opts.data.slice(zeroByteCheck[index][0], zeroByteCheck[index][1]);
          if (!slicedBuffer.equals(zeroBytes16)) {
              return (0, evm_1$9.EvmErrorResult)(new exceptions_1$8.EvmError(exceptions_1$8.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
          }
      }
      // convert input to mcl G1 points, add them, and convert the output to a Buffer.
      let mclPoint1;
      let mclPoint2;
      try {
          mclPoint1 = BLS12_381_ToG1Point$3(opts.data.slice(0, 128), mcl);
          mclPoint2 = BLS12_381_ToG1Point$3(opts.data.slice(128, 256), mcl);
      }
      catch (e) {
          return (0, evm_1$9.EvmErrorResult)(e, opts.gasLimit);
      }
      const result = mcl.add(mclPoint1, mclPoint2);
      const returnValue = BLS12_381_FromG1Point$3(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _0aBls12G1add.precompile0a = precompile0a;

  var _0bBls12G1mul = {};

  Object.defineProperty(_0bBls12G1mul, "__esModule", { value: true });
  _0bBls12G1mul.precompile0b = void 0;
  const util_1$z = dist$a;
  const evm_1$8 = evm$1;
  const exceptions_1$7 = exceptions;
  const { BLS12_381_ToG1Point: BLS12_381_ToG1Point$2, BLS12_381_FromG1Point: BLS12_381_FromG1Point$2, BLS12_381_ToFrPoint: BLS12_381_ToFrPoint$3, } = bls12_381;
  async function precompile0b(opts) {
      if ((0, util_1$z.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      // note: the gas used is constant; even if the input is incorrect.
      const gasUsed = opts._common.paramByEIP('gasPrices', 'Bls12381G1MulGas', 2537) ?? BigInt(0);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$8.OOGResult)(opts.gasLimit);
      }
      if (inputData.length != 160) {
          return (0, evm_1$8.EvmErrorResult)(new exceptions_1$7.EvmError(exceptions_1$7.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // check if some parts of input are zero bytes.
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
      ];
      for (const index in zeroByteCheck) {
          const slicedBuffer = opts.data.slice(zeroByteCheck[index][0], zeroByteCheck[index][1]);
          if (!slicedBuffer.equals(zeroBytes16)) {
              return (0, evm_1$8.EvmErrorResult)(new exceptions_1$7.EvmError(exceptions_1$7.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
          }
      }
      // convert input to mcl G1 points, add them, and convert the output to a Buffer.
      let mclPoint;
      try {
          mclPoint = BLS12_381_ToG1Point$2(opts.data.slice(0, 128), mcl);
      }
      catch (e) {
          return (0, evm_1$8.EvmErrorResult)(e, opts.gasLimit);
      }
      const frPoint = BLS12_381_ToFrPoint$3(opts.data.slice(128, 160), mcl);
      const result = mcl.mul(mclPoint, frPoint);
      const returnValue = BLS12_381_FromG1Point$2(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _0bBls12G1mul.precompile0b = precompile0b;

  var _0cBls12G1multiexp = {};

  Object.defineProperty(_0cBls12G1multiexp, "__esModule", { value: true });
  _0cBls12G1multiexp.precompile0c = void 0;
  const util_1$y = dist$a;
  const evm_1$7 = evm$1;
  const exceptions_1$6 = exceptions;
  const { BLS12_381_ToG1Point: BLS12_381_ToG1Point$1, BLS12_381_ToFrPoint: BLS12_381_ToFrPoint$2, BLS12_381_FromG1Point: BLS12_381_FromG1Point$1, } = bls12_381;
  async function precompile0c(opts) {
      if ((0, util_1$y.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      if (inputData.length == 0) {
          return (0, evm_1$7.EvmErrorResult)(new exceptions_1$6.EvmError(exceptions_1$6.ERROR.BLS_12_381_INPUT_EMPTY), opts.gasLimit); // follow Geths implementation
      }
      const numPairs = Math.floor(inputData.length / 160);
      const gasUsedPerPair = opts._common.paramByEIP('gasPrices', 'Bls12381G1MulGas', 2537) ?? BigInt(0);
      const gasDiscountArray = opts._common.paramByEIP('gasPrices', 'Bls12381MultiExpGasDiscount', 2537);
      const gasDiscountMax = gasDiscountArray[gasDiscountArray.length - 1][1];
      let gasDiscountMultiplier;
      if (numPairs <= gasDiscountArray.length) {
          if (numPairs == 0) {
              gasDiscountMultiplier = 0; // this implicitly sets gasUsed to 0 as per the EIP.
          }
          else {
              gasDiscountMultiplier = gasDiscountArray[numPairs - 1][1];
          }
      }
      else {
          gasDiscountMultiplier = gasDiscountMax;
      }
      const gasUsed = (gasUsedPerPair * BigInt(numPairs) * BigInt(gasDiscountMultiplier)) / BigInt(1000);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$7.OOGResult)(opts.gasLimit);
      }
      if (inputData.length % 160 != 0) {
          return (0, evm_1$7.EvmErrorResult)(new exceptions_1$6.EvmError(exceptions_1$6.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // prepare pairing list and check for mandatory zero bytes
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
      ];
      const G1Array = [];
      const FrArray = [];
      for (let k = 0; k < inputData.length / 160; k++) {
          // zero bytes check
          const pairStart = 160 * k;
          for (const index in zeroByteCheck) {
              const slicedBuffer = opts.data.slice(zeroByteCheck[index][0] + pairStart, zeroByteCheck[index][1] + pairStart);
              if (!slicedBuffer.equals(zeroBytes16)) {
                  return (0, evm_1$7.EvmErrorResult)(new exceptions_1$6.EvmError(exceptions_1$6.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
              }
          }
          let G1;
          try {
              G1 = BLS12_381_ToG1Point$1(opts.data.slice(pairStart, pairStart + 128), mcl);
          }
          catch (e) {
              return (0, evm_1$7.EvmErrorResult)(e, opts.gasLimit);
          }
          const Fr = BLS12_381_ToFrPoint$2(opts.data.slice(pairStart + 128, pairStart + 160), mcl);
          G1Array.push(G1);
          FrArray.push(Fr);
      }
      const result = mcl.mulVec(G1Array, FrArray);
      const returnValue = BLS12_381_FromG1Point$1(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _0cBls12G1multiexp.precompile0c = precompile0c;

  var _0dBls12G2add = {};

  Object.defineProperty(_0dBls12G2add, "__esModule", { value: true });
  _0dBls12G2add.precompile0d = void 0;
  const util_1$x = dist$a;
  const evm_1$6 = evm$1;
  const exceptions_1$5 = exceptions;
  const { BLS12_381_ToG2Point: BLS12_381_ToG2Point$3, BLS12_381_FromG2Point: BLS12_381_FromG2Point$3 } = bls12_381;
  async function precompile0d(opts) {
      if ((0, util_1$x.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      // note: the gas used is constant; even if the input is incorrect.
      const gasUsed = opts._common.paramByEIP('gasPrices', 'Bls12381G2AddGas', 2537) ?? BigInt(0);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$6.OOGResult)(opts.gasLimit);
      }
      if (inputData.length != 512) {
          return (0, evm_1$6.EvmErrorResult)(new exceptions_1$5.EvmError(exceptions_1$5.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // check if some parts of input are zero bytes.
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
          [128, 144],
          [192, 208],
          [256, 272],
          [320, 336],
          [384, 400],
          [448, 464],
      ];
      for (const index in zeroByteCheck) {
          const slicedBuffer = opts.data.slice(zeroByteCheck[index][0], zeroByteCheck[index][1]);
          if (!slicedBuffer.equals(zeroBytes16)) {
              return (0, evm_1$6.EvmErrorResult)(new exceptions_1$5.EvmError(exceptions_1$5.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
          }
      }
      // TODO: verify that point is on G2
      // convert input to mcl G2 points, add them, and convert the output to a Buffer.
      let mclPoint1;
      let mclPoint2;
      try {
          mclPoint1 = BLS12_381_ToG2Point$3(opts.data.slice(0, 256), mcl);
          mclPoint2 = BLS12_381_ToG2Point$3(opts.data.slice(256, 512), mcl);
      }
      catch (e) {
          return (0, evm_1$6.EvmErrorResult)(e, opts.gasLimit);
      }
      const result = mcl.add(mclPoint1, mclPoint2);
      const returnValue = BLS12_381_FromG2Point$3(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _0dBls12G2add.precompile0d = precompile0d;

  var _0eBls12G2mul = {};

  Object.defineProperty(_0eBls12G2mul, "__esModule", { value: true });
  _0eBls12G2mul.precompile0e = void 0;
  const util_1$w = dist$a;
  const evm_1$5 = evm$1;
  const exceptions_1$4 = exceptions;
  const { BLS12_381_ToG2Point: BLS12_381_ToG2Point$2, BLS12_381_FromG2Point: BLS12_381_FromG2Point$2, BLS12_381_ToFrPoint: BLS12_381_ToFrPoint$1, } = bls12_381;
  async function precompile0e(opts) {
      if ((0, util_1$w.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      // note: the gas used is constant; even if the input is incorrect.
      const gasUsed = opts._common.paramByEIP('gasPrices', 'Bls12381G2MulGas', 2537) ?? BigInt(0);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$5.OOGResult)(opts.gasLimit);
      }
      if (inputData.length != 288) {
          return (0, evm_1$5.EvmErrorResult)(new exceptions_1$4.EvmError(exceptions_1$4.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // check if some parts of input are zero bytes.
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
          [128, 144],
          [192, 208],
      ];
      for (const index in zeroByteCheck) {
          const slicedBuffer = opts.data.slice(zeroByteCheck[index][0], zeroByteCheck[index][1]);
          if (!slicedBuffer.equals(zeroBytes16)) {
              return (0, evm_1$5.EvmErrorResult)(new exceptions_1$4.EvmError(exceptions_1$4.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
          }
      }
      // TODO: verify that point is on G2
      // convert input to mcl G2 point/Fr point, add them, and convert the output to a Buffer.
      let mclPoint;
      try {
          mclPoint = BLS12_381_ToG2Point$2(opts.data.slice(0, 256), mcl);
      }
      catch (e) {
          return (0, evm_1$5.EvmErrorResult)(e, opts.gasLimit);
      }
      const frPoint = BLS12_381_ToFrPoint$1(opts.data.slice(256, 288), mcl);
      const result = mcl.mul(mclPoint, frPoint);
      const returnValue = BLS12_381_FromG2Point$2(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _0eBls12G2mul.precompile0e = precompile0e;

  var _0fBls12G2multiexp = {};

  Object.defineProperty(_0fBls12G2multiexp, "__esModule", { value: true });
  _0fBls12G2multiexp.precompile0f = void 0;
  const util_1$v = dist$a;
  const evm_1$4 = evm$1;
  const exceptions_1$3 = exceptions;
  const bls12_381_1 = bls12_381;
  const { BLS12_381_ToG2Point: BLS12_381_ToG2Point$1, BLS12_381_ToFrPoint, BLS12_381_FromG2Point: BLS12_381_FromG2Point$1, } = bls12_381;
  async function precompile0f(opts) {
      if ((0, util_1$v.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      if (inputData.length == 0) {
          return (0, evm_1$4.EvmErrorResult)(new exceptions_1$3.EvmError(exceptions_1$3.ERROR.BLS_12_381_INPUT_EMPTY), opts.gasLimit); // follow Geths implementation
      }
      const numPairs = Math.floor(inputData.length / 288);
      const gasUsedPerPair = opts._common.paramByEIP('gasPrices', 'Bls12381G2MulGas', 2537) ?? BigInt(0);
      const gasDiscountArray = bls12_381_1.gasDiscountPairs;
      const gasDiscountMax = gasDiscountArray[gasDiscountArray.length - 1][1];
      let gasDiscountMultiplier;
      if (numPairs <= gasDiscountArray.length) {
          if (numPairs == 0) {
              gasDiscountMultiplier = 0; // this implicitly sets gasUsed to 0 as per the EIP.
          }
          else {
              gasDiscountMultiplier = gasDiscountArray[numPairs - 1][1];
          }
      }
      else {
          gasDiscountMultiplier = gasDiscountMax;
      }
      const gasUsed = (gasUsedPerPair * BigInt(numPairs) * BigInt(gasDiscountMultiplier)) / BigInt(1000);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$4.OOGResult)(opts.gasLimit);
      }
      if (inputData.length % 288 != 0) {
          return (0, evm_1$4.EvmErrorResult)(new exceptions_1$3.EvmError(exceptions_1$3.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // prepare pairing list and check for mandatory zero bytes
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
          [128, 144],
          [192, 208],
      ];
      const G2Array = [];
      const FrArray = [];
      for (let k = 0; k < inputData.length / 288; k++) {
          // zero bytes check
          const pairStart = 288 * k;
          for (const index in zeroByteCheck) {
              const slicedBuffer = opts.data.slice(zeroByteCheck[index][0] + pairStart, zeroByteCheck[index][1] + pairStart);
              if (!slicedBuffer.equals(zeroBytes16)) {
                  return (0, evm_1$4.EvmErrorResult)(new exceptions_1$3.EvmError(exceptions_1$3.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
              }
          }
          let G2;
          try {
              G2 = BLS12_381_ToG2Point$1(opts.data.slice(pairStart, pairStart + 256), mcl);
          }
          catch (e) {
              return (0, evm_1$4.EvmErrorResult)(e, opts.gasLimit);
          }
          const Fr = BLS12_381_ToFrPoint(opts.data.slice(pairStart + 256, pairStart + 288), mcl);
          G2Array.push(G2);
          FrArray.push(Fr);
      }
      const result = mcl.mulVec(G2Array, FrArray);
      const returnValue = BLS12_381_FromG2Point$1(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _0fBls12G2multiexp.precompile0f = precompile0f;

  var _10Bls12Pairing = {};

  Object.defineProperty(_10Bls12Pairing, "__esModule", { value: true });
  _10Bls12Pairing.precompile10 = void 0;
  const util_1$u = dist$a;
  const evm_1$3 = evm$1;
  const exceptions_1$2 = exceptions;
  const { BLS12_381_ToG1Point, BLS12_381_ToG2Point } = bls12_381;
  const zeroBuffer = Buffer$8.alloc(32, 0);
  const oneBuffer = Buffer$8.concat([Buffer$8.alloc(31, 0), Buffer$8.from('01', 'hex')]);
  async function precompile10(opts) {
      if ((0, util_1$u.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      const baseGas = opts._common.paramByEIP('gasPrices', 'Bls12381PairingBaseGas', 2537) ?? BigInt(0);
      if (inputData.length == 0) {
          return (0, evm_1$3.EvmErrorResult)(new exceptions_1$2.EvmError(exceptions_1$2.ERROR.BLS_12_381_INPUT_EMPTY), opts.gasLimit);
      }
      const gasUsedPerPair = opts._common.paramByEIP('gasPrices', 'Bls12381PairingPerPairGas', 2537) ?? BigInt(0);
      const gasUsed = baseGas + gasUsedPerPair * BigInt(Math.floor(inputData.length / 384));
      if (inputData.length % 384 != 0) {
          return (0, evm_1$3.EvmErrorResult)(new exceptions_1$2.EvmError(exceptions_1$2.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$3.OOGResult)(opts.gasLimit);
      }
      // prepare pairing list and check for mandatory zero bytes
      const pairs = [];
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
          [128, 144],
          [192, 208],
          [256, 272],
          [320, 336],
      ];
      for (let k = 0; k < inputData.length / 384; k++) {
          // zero bytes check
          const pairStart = 384 * k;
          for (const index in zeroByteCheck) {
              const slicedBuffer = opts.data.slice(zeroByteCheck[index][0] + pairStart, zeroByteCheck[index][1] + pairStart);
              if (!slicedBuffer.equals(zeroBytes16)) {
                  return (0, evm_1$3.EvmErrorResult)(new exceptions_1$2.EvmError(exceptions_1$2.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
              }
          }
          let G1;
          try {
              G1 = BLS12_381_ToG1Point(opts.data.slice(pairStart, pairStart + 128), mcl);
          }
          catch (e) {
              return (0, evm_1$3.EvmErrorResult)(e, opts.gasLimit);
          }
          const g2start = pairStart + 128;
          let G2;
          try {
              G2 = BLS12_381_ToG2Point(opts.data.slice(g2start, g2start + 256), mcl);
          }
          catch (e) {
              return (0, evm_1$3.EvmErrorResult)(e, opts.gasLimit);
          }
          pairs.push([G1, G2]);
      }
      // run the pairing check
      // reference (Nethermind): https://github.com/NethermindEth/nethermind/blob/374b036414722b9c8ad27e93d64840b8f63931b9/src/Nethermind/Nethermind.Evm/Precompiles/Bls/Mcl/PairingPrecompile.cs#L93
      let GT;
      for (let index = 0; index < pairs.length; index++) {
          const pair = pairs[index];
          const G1 = pair[0];
          const G2 = pair[1];
          if (index == 0) {
              GT = mcl.millerLoop(G1, G2);
          }
          else {
              GT = mcl.mul(GT, mcl.millerLoop(G1, G2));
          }
      }
      GT = mcl.finalExp(GT);
      let returnValue;
      if (GT.isOne() === true) {
          returnValue = oneBuffer;
      }
      else {
          returnValue = zeroBuffer;
      }
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _10Bls12Pairing.precompile10 = precompile10;

  var _11Bls12MapFpToG1 = {};

  Object.defineProperty(_11Bls12MapFpToG1, "__esModule", { value: true });
  _11Bls12MapFpToG1.precompile11 = void 0;
  const util_1$t = dist$a;
  const evm_1$2 = evm$1;
  const exceptions_1$1 = exceptions;
  const { BLS12_381_ToFpPoint, BLS12_381_FromG1Point } = bls12_381;
  async function precompile11(opts) {
      if ((0, util_1$t.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      // note: the gas used is constant; even if the input is incorrect.
      const gasUsed = opts._common.paramByEIP('gasPrices', 'Bls12381MapG1Gas', 2537) ?? BigInt(0);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$2.OOGResult)(opts.gasLimit);
      }
      if (inputData.length != 64) {
          return (0, evm_1$2.EvmErrorResult)(new exceptions_1$1.EvmError(exceptions_1$1.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // check if some parts of input are zero bytes.
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      if (!opts.data.slice(0, 16).equals(zeroBytes16)) {
          return (0, evm_1$2.EvmErrorResult)(new exceptions_1$1.EvmError(exceptions_1$1.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
      }
      // convert input to mcl Fp1 point
      let Fp1Point;
      try {
          Fp1Point = BLS12_381_ToFpPoint(opts.data.slice(0, 64), mcl);
      }
      catch (e) {
          return (0, evm_1$2.EvmErrorResult)(e, opts.gasLimit);
      }
      // map it to G1
      const result = Fp1Point.mapToG1();
      const returnValue = BLS12_381_FromG1Point(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _11Bls12MapFpToG1.precompile11 = precompile11;

  var _12Bls12MapFp2ToG2 = {};

  Object.defineProperty(_12Bls12MapFp2ToG2, "__esModule", { value: true });
  _12Bls12MapFp2ToG2.precompile12 = void 0;
  const util_1$s = dist$a;
  const evm_1$1 = evm$1;
  const exceptions_1 = exceptions;
  const { BLS12_381_ToFp2Point, BLS12_381_FromG2Point } = bls12_381;
  async function precompile12(opts) {
      if ((0, util_1$s.isFalsy)(opts.data))
          throw new Error('opts.data missing but required');
      const mcl = opts._EVM._mcl;
      const inputData = opts.data;
      // note: the gas used is constant; even if the input is incorrect.
      const gasUsed = opts._common.paramByEIP('gasPrices', 'Bls12381MapG2Gas', 2537) ?? BigInt(0);
      if (opts.gasLimit < gasUsed) {
          return (0, evm_1$1.OOGResult)(opts.gasLimit);
      }
      if (inputData.length != 128) {
          return (0, evm_1$1.EvmErrorResult)(new exceptions_1.EvmError(exceptions_1.ERROR.BLS_12_381_INVALID_INPUT_LENGTH), opts.gasLimit);
      }
      // check if some parts of input are zero bytes.
      const zeroBytes16 = Buffer$8.alloc(16, 0);
      const zeroByteCheck = [
          [0, 16],
          [64, 80],
      ];
      for (const index in zeroByteCheck) {
          const slicedBuffer = opts.data.slice(zeroByteCheck[index][0], zeroByteCheck[index][1]);
          if (!slicedBuffer.equals(zeroBytes16)) {
              return (0, evm_1$1.EvmErrorResult)(new exceptions_1.EvmError(exceptions_1.ERROR.BLS_12_381_POINT_NOT_ON_CURVE), opts.gasLimit);
          }
      }
      // convert input to mcl Fp2 point
      let Fp2Point;
      try {
          Fp2Point = BLS12_381_ToFp2Point(opts.data.slice(0, 64), opts.data.slice(64, 128), mcl);
      }
      catch (e) {
          return (0, evm_1$1.EvmErrorResult)(e, opts.gasLimit);
      }
      // map it to G2
      const result = Fp2Point.mapToG2();
      const returnValue = BLS12_381_FromG2Point(result);
      return {
          executionGasUsed: gasUsed,
          returnValue: returnValue,
      };
  }
  _12Bls12MapFp2ToG2.precompile12 = precompile12;

  Object.defineProperty(precompiles$1, "__esModule", { value: true });
  precompiles$1.ripemdPrecompileAddress = precompiles$1.precompiles = precompiles$1.getActivePrecompiles = void 0;
  const common_1$c = dist$8;
  const util_1$r = dist$a;
  const _01_ecrecover_1 = _01Ecrecover;
  const _02_sha256_1 = _02Sha256;
  const _03_ripemd160_1 = _03Ripemd160;
  const _04_identity_1 = _04Identity;
  const _05_modexp_1 = _05Modexp;
  const _06_ecadd_1 = _06Ecadd;
  const _07_ecmul_1 = _07Ecmul;
  const _08_ecpairing_1 = _08Ecpairing;
  const _09_blake2f_1 = _09Blake2f;
  const _0a_bls12_g1add_1 = _0aBls12G1add;
  const _0b_bls12_g1mul_1 = _0bBls12G1mul;
  const _0c_bls12_g1multiexp_1 = _0cBls12G1multiexp;
  const _0d_bls12_g2add_1 = _0dBls12G2add;
  const _0e_bls12_g2mul_1 = _0eBls12G2mul;
  const _0f_bls12_g2multiexp_1 = _0fBls12G2multiexp;
  const _10_bls12_pairing_1 = _10Bls12Pairing;
  const _11_bls12_map_fp_to_g1_1 = _11Bls12MapFpToG1;
  const _12_bls12_map_fp2_to_g2_1 = _12Bls12MapFp2ToG2;
  var PrecompileAvailabilityCheck;
  (function (PrecompileAvailabilityCheck) {
      PrecompileAvailabilityCheck[PrecompileAvailabilityCheck["EIP"] = 0] = "EIP";
      PrecompileAvailabilityCheck[PrecompileAvailabilityCheck["Hardfork"] = 1] = "Hardfork";
  })(PrecompileAvailabilityCheck || (PrecompileAvailabilityCheck = {}));
  const ripemdPrecompileAddress = '0000000000000000000000000000000000000003';
  precompiles$1.ripemdPrecompileAddress = ripemdPrecompileAddress;
  const precompiles = {
      '0000000000000000000000000000000000000001': _01_ecrecover_1.precompile01,
      '0000000000000000000000000000000000000002': _02_sha256_1.precompile02,
      [ripemdPrecompileAddress]: _03_ripemd160_1.precompile03,
      '0000000000000000000000000000000000000004': _04_identity_1.precompile04,
      '0000000000000000000000000000000000000005': _05_modexp_1.precompile05,
      '0000000000000000000000000000000000000006': _06_ecadd_1.precompile06,
      '0000000000000000000000000000000000000007': _07_ecmul_1.precompile07,
      '0000000000000000000000000000000000000008': _08_ecpairing_1.precompile08,
      '0000000000000000000000000000000000000009': _09_blake2f_1.precompile09,
      '000000000000000000000000000000000000000a': _0a_bls12_g1add_1.precompile0a,
      '000000000000000000000000000000000000000b': _0b_bls12_g1mul_1.precompile0b,
      '000000000000000000000000000000000000000c': _0c_bls12_g1multiexp_1.precompile0c,
      '000000000000000000000000000000000000000d': _0d_bls12_g2add_1.precompile0d,
      '000000000000000000000000000000000000000e': _0e_bls12_g2mul_1.precompile0e,
      '000000000000000000000000000000000000000f': _0f_bls12_g2multiexp_1.precompile0f,
      '0000000000000000000000000000000000000010': _10_bls12_pairing_1.precompile10,
      '0000000000000000000000000000000000000011': _11_bls12_map_fp_to_g1_1.precompile11,
      '0000000000000000000000000000000000000012': _12_bls12_map_fp2_to_g2_1.precompile12,
  };
  precompiles$1.precompiles = precompiles;
  const precompileAvailability = {
      '0000000000000000000000000000000000000001': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Chainstart,
      },
      '0000000000000000000000000000000000000002': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Chainstart,
      },
      [ripemdPrecompileAddress]: {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Chainstart,
      },
      '0000000000000000000000000000000000000004': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Chainstart,
      },
      '0000000000000000000000000000000000000005': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Byzantium,
      },
      '0000000000000000000000000000000000000006': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Byzantium,
      },
      '0000000000000000000000000000000000000007': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Byzantium,
      },
      '0000000000000000000000000000000000000008': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Byzantium,
      },
      '0000000000000000000000000000000000000009': {
          type: PrecompileAvailabilityCheck.Hardfork,
          param: common_1$c.Hardfork.Istanbul,
      },
      '000000000000000000000000000000000000000a': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '000000000000000000000000000000000000000b': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '000000000000000000000000000000000000000c': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '000000000000000000000000000000000000000d': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '000000000000000000000000000000000000000f': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '000000000000000000000000000000000000000e': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '0000000000000000000000000000000000000010': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '0000000000000000000000000000000000000011': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
      '0000000000000000000000000000000000000012': {
          type: PrecompileAvailabilityCheck.EIP,
          param: 2537,
      },
  };
  function getPrecompile(address, common) {
      const addr = address.buf.toString('hex');
      if ((0, util_1$r.isTruthy)(precompiles[addr])) {
          const availability = precompileAvailability[addr];
          if ((availability.type == PrecompileAvailabilityCheck.Hardfork &&
              common.gteHardfork(availability.param)) ||
              (availability.type == PrecompileAvailabilityCheck.EIP &&
                  common.eips().includes(availability.param))) {
              return precompiles[addr];
          }
      }
      return precompiles[''];
  }
  function getActivePrecompiles(common, customPrecompiles) {
      const precompileMap = new Map();
      if (customPrecompiles) {
          for (const precompile of customPrecompiles) {
              precompileMap.set(precompile.address.buf.toString('hex'), 'function' in precompile ? precompile.function : undefined);
          }
      }
      for (const addressString in precompiles) {
          if (precompileMap.has(addressString)) {
              continue;
          }
          const address = new util_1$r.Address(Buffer$8.from(addressString, 'hex'));
          const precompileFunc = getPrecompile(address, common);
          if ((0, util_1$r.isTruthy)(precompileFunc)) {
              precompileMap.set(addressString, precompileFunc);
          }
      }
      return precompileMap;
  }
  precompiles$1.getActivePrecompiles = getActivePrecompiles;

  var fails$e = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var fails$d = fails$e;

  var functionBindNative = !fails$d(function () {
    // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
    var test = (function () { /* empty */ }).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != 'function' || test.hasOwnProperty('prototype');
  });

  var NATIVE_BIND$3 = functionBindNative;

  var FunctionPrototype$2 = Function.prototype;
  var bind$5 = FunctionPrototype$2.bind;
  var call$b = FunctionPrototype$2.call;
  var uncurryThis$f = NATIVE_BIND$3 && bind$5.bind(call$b, call$b);

  var functionUncurryThis = NATIVE_BIND$3 ? function (fn) {
    return fn && uncurryThis$f(fn);
  } : function (fn) {
    return fn && function () {
      return call$b.apply(fn, arguments);
    };
  };

  var uncurryThis$e = functionUncurryThis;

  var toString$5 = uncurryThis$e({}.toString);
  var stringSlice$1 = uncurryThis$e(''.slice);

  var classofRaw$1 = function (it) {
    return stringSlice$1(toString$5(it), 8, -1);
  };

  var uncurryThis$d = functionUncurryThis;
  var fails$c = fails$e;
  var classof$8 = classofRaw$1;

  var $Object$4 = Object;
  var split = uncurryThis$d(''.split);

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var indexedObject = fails$c(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !$Object$4('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classof$8(it) == 'String' ? split(it, '') : $Object$4(it);
  } : $Object$4;

  var $TypeError$9 = TypeError;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible$3 = function (it) {
    if (it == undefined) throw $TypeError$9("Can't call method on " + it);
    return it;
  };

  // toObject with fallback for non-array-like ES3 strings
  var IndexedObject$1 = indexedObject;
  var requireObjectCoercible$2 = requireObjectCoercible$3;

  var toIndexedObject$6 = function (it) {
    return IndexedObject$1(requireObjectCoercible$2(it));
  };

  var iterators = {};

  var check = function (it) {
    return it && it.Math == Math && it;
  };

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global$b =
    // eslint-disable-next-line es-x/no-global-this -- safe
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func -- fallback
    (function () { return this; })() || Function('return this')();

  // `IsCallable` abstract operation
  // https://tc39.es/ecma262/#sec-iscallable
  var isCallable$f = function (argument) {
    return typeof argument == 'function';
  };

  var global$a = global$b;

  // eslint-disable-next-line es-x/no-object-defineproperty -- safe
  var defineProperty$4 = Object.defineProperty;

  var defineGlobalProperty$1 = function (key, value) {
    try {
      defineProperty$4(global$a, key, { value: value, configurable: true, writable: true });
    } catch (error) {
      global$a[key] = value;
    } return value;
  };

  var global$9 = global$b;
  var defineGlobalProperty = defineGlobalProperty$1;

  var SHARED = '__core-js_shared__';
  var store$3 = global$9[SHARED] || defineGlobalProperty(SHARED, {});

  var sharedStore = store$3;

  var uncurryThis$c = functionUncurryThis;
  var isCallable$e = isCallable$f;
  var store$2 = sharedStore;

  var functionToString = uncurryThis$c(Function.toString);

  // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
  if (!isCallable$e(store$2.inspectSource)) {
    store$2.inspectSource = function (it) {
      return functionToString(it);
    };
  }

  var inspectSource$2 = store$2.inspectSource;

  var global$8 = global$b;
  var isCallable$d = isCallable$f;
  var inspectSource$1 = inspectSource$2;

  var WeakMap$2 = global$8.WeakMap;

  var nativeWeakMap = isCallable$d(WeakMap$2) && /native code/.test(inspectSource$1(WeakMap$2));

  var isCallable$c = isCallable$f;

  var isObject$9 = function (it) {
    return typeof it == 'object' ? it !== null : isCallable$c(it);
  };

  var fails$b = fails$e;

  // Detect IE8's incomplete defineProperty implementation
  var descriptors = !fails$b(function () {
    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
  });

  var objectDefineProperty = {};

  var global$7 = global$b;
  var isObject$8 = isObject$9;

  var document$1 = global$7.document;
  // typeof document.createElement is 'object' in old IE
  var EXISTS$1 = isObject$8(document$1) && isObject$8(document$1.createElement);

  var documentCreateElement$1 = function (it) {
    return EXISTS$1 ? document$1.createElement(it) : {};
  };

  var DESCRIPTORS$9 = descriptors;
  var fails$a = fails$e;
  var createElement = documentCreateElement$1;

  // Thanks to IE8 for its funny defineProperty
  var ie8DomDefine = !DESCRIPTORS$9 && !fails$a(function () {
    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement('div'), 'a', {
      get: function () { return 7; }
    }).a != 7;
  });

  var DESCRIPTORS$8 = descriptors;
  var fails$9 = fails$e;

  // V8 ~ Chrome 36-
  // https://bugs.chromium.org/p/v8/issues/detail?id=3334
  var v8PrototypeDefineBug = DESCRIPTORS$8 && fails$9(function () {
    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
    return Object.defineProperty(function () { /* empty */ }, 'prototype', {
      value: 42,
      writable: false
    }).prototype != 42;
  });

  var isObject$7 = isObject$9;

  var $String$3 = String;
  var $TypeError$8 = TypeError;

  // `Assert: Type(argument) is Object`
  var anObject$7 = function (argument) {
    if (isObject$7(argument)) return argument;
    throw $TypeError$8($String$3(argument) + ' is not an object');
  };

  var NATIVE_BIND$2 = functionBindNative;

  var call$a = Function.prototype.call;

  var functionCall = NATIVE_BIND$2 ? call$a.bind(call$a) : function () {
    return call$a.apply(call$a, arguments);
  };

  var path$4 = {};

  var path$3 = path$4;
  var global$6 = global$b;
  var isCallable$b = isCallable$f;

  var aFunction = function (variable) {
    return isCallable$b(variable) ? variable : undefined;
  };

  var getBuiltIn$5 = function (namespace, method) {
    return arguments.length < 2 ? aFunction(path$3[namespace]) || aFunction(global$6[namespace])
      : path$3[namespace] && path$3[namespace][method] || global$6[namespace] && global$6[namespace][method];
  };

  var uncurryThis$b = functionUncurryThis;

  var objectIsPrototypeOf = uncurryThis$b({}.isPrototypeOf);

  var getBuiltIn$4 = getBuiltIn$5;

  var engineUserAgent = getBuiltIn$4('navigator', 'userAgent') || '';

  var global$5 = global$b;
  var userAgent = engineUserAgent;

  var process$1 = global$5.process;
  var Deno = global$5.Deno;
  var versions = process$1 && process$1.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }

  // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
  // so check `userAgent` even if `.v8` exists, but 0
  if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }

  var engineV8Version = version;

  /* eslint-disable es-x/no-symbol -- required for testing */

  var V8_VERSION = engineV8Version;
  var fails$8 = fails$e;

  // eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$8(function () {
    var symbol = Symbol();
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
      // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });

  /* eslint-disable es-x/no-symbol -- required for testing */

  var NATIVE_SYMBOL$1 = nativeSymbol;

  var useSymbolAsUid = NATIVE_SYMBOL$1
    && !Symbol.sham
    && typeof Symbol.iterator == 'symbol';

  var getBuiltIn$3 = getBuiltIn$5;
  var isCallable$a = isCallable$f;
  var isPrototypeOf$2 = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

  var $Object$3 = Object;

  var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    var $Symbol = getBuiltIn$3('Symbol');
    return isCallable$a($Symbol) && isPrototypeOf$2($Symbol.prototype, $Object$3(it));
  };

  var $String$2 = String;

  var tryToString$3 = function (argument) {
    try {
      return $String$2(argument);
    } catch (error) {
      return 'Object';
    }
  };

  var isCallable$9 = isCallable$f;
  var tryToString$2 = tryToString$3;

  var $TypeError$7 = TypeError;

  // `Assert: IsCallable(argument) is true`
  var aCallable$3 = function (argument) {
    if (isCallable$9(argument)) return argument;
    throw $TypeError$7(tryToString$2(argument) + ' is not a function');
  };

  var aCallable$2 = aCallable$3;

  // `GetMethod` abstract operation
  // https://tc39.es/ecma262/#sec-getmethod
  var getMethod$3 = function (V, P) {
    var func = V[P];
    return func == null ? undefined : aCallable$2(func);
  };

  var call$9 = functionCall;
  var isCallable$8 = isCallable$f;
  var isObject$6 = isObject$9;

  var $TypeError$6 = TypeError;

  // `OrdinaryToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-ordinarytoprimitive
  var ordinaryToPrimitive$1 = function (input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable$8(fn = input.toString) && !isObject$6(val = call$9(fn, input))) return val;
    if (isCallable$8(fn = input.valueOf) && !isObject$6(val = call$9(fn, input))) return val;
    if (pref !== 'string' && isCallable$8(fn = input.toString) && !isObject$6(val = call$9(fn, input))) return val;
    throw $TypeError$6("Can't convert object to primitive value");
  };

  var shared$3 = {exports: {}};

  var store$1 = sharedStore;

  (shared$3.exports = function (key, value) {
    return store$1[key] || (store$1[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.24.1',
    mode: 'pure' ,
    copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE',
    source: 'https://github.com/zloirock/core-js'
  });

  var requireObjectCoercible$1 = requireObjectCoercible$3;

  var $Object$2 = Object;

  // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject
  var toObject$3 = function (argument) {
    return $Object$2(requireObjectCoercible$1(argument));
  };

  var uncurryThis$a = functionUncurryThis;
  var toObject$2 = toObject$3;

  var hasOwnProperty$1 = uncurryThis$a({}.hasOwnProperty);

  // `HasOwnProperty` abstract operation
  // https://tc39.es/ecma262/#sec-hasownproperty
  // eslint-disable-next-line es-x/no-object-hasown -- safe
  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty$1(toObject$2(it), key);
  };

  var uncurryThis$9 = functionUncurryThis;

  var id$1 = 0;
  var postfix = Math.random();
  var toString$4 = uncurryThis$9(1.0.toString);

  var uid$3 = function (key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$4(++id$1 + postfix, 36);
  };

  var global$4 = global$b;
  var shared$2 = shared$3.exports;
  var hasOwn$8 = hasOwnProperty_1;
  var uid$2 = uid$3;
  var NATIVE_SYMBOL = nativeSymbol;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;

  var WellKnownSymbolsStore = shared$2('wks');
  var Symbol$1 = global$4.Symbol;
  var symbolFor = Symbol$1 && Symbol$1['for'];
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;

  var wellKnownSymbol$a = function (name) {
    if (!hasOwn$8(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
      var description = 'Symbol.' + name;
      if (NATIVE_SYMBOL && hasOwn$8(Symbol$1, name)) {
        WellKnownSymbolsStore[name] = Symbol$1[name];
      } else if (USE_SYMBOL_AS_UID && symbolFor) {
        WellKnownSymbolsStore[name] = symbolFor(description);
      } else {
        WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
      }
    } return WellKnownSymbolsStore[name];
  };

  var call$8 = functionCall;
  var isObject$5 = isObject$9;
  var isSymbol$1 = isSymbol$2;
  var getMethod$2 = getMethod$3;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$9 = wellKnownSymbol$a;

  var $TypeError$5 = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol$9('toPrimitive');

  // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive
  var toPrimitive$1 = function (input, pref) {
    if (!isObject$5(input) || isSymbol$1(input)) return input;
    var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === undefined) pref = 'default';
      result = call$8(exoticToPrim, input, pref);
      if (!isObject$5(result) || isSymbol$1(result)) return result;
      throw $TypeError$5("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
  };

  var toPrimitive = toPrimitive$1;
  var isSymbol = isSymbol$2;

  // `ToPropertyKey` abstract operation
  // https://tc39.es/ecma262/#sec-topropertykey
  var toPropertyKey$3 = function (argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol(key) ? key : key + '';
  };

  var DESCRIPTORS$7 = descriptors;
  var IE8_DOM_DEFINE$1 = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
  var anObject$6 = anObject$7;
  var toPropertyKey$2 = toPropertyKey$3;

  var $TypeError$4 = TypeError;
  // eslint-disable-next-line es-x/no-object-defineproperty -- safe
  var $defineProperty = Object.defineProperty;
  // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = 'enumerable';
  var CONFIGURABLE$1 = 'configurable';
  var WRITABLE = 'writable';

  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  objectDefineProperty.f = DESCRIPTORS$7 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
    anObject$6(O);
    P = toPropertyKey$2(P);
    anObject$6(Attributes);
    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor$1(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    } return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject$6(O);
    P = toPropertyKey$2(P);
    anObject$6(Attributes);
    if (IE8_DOM_DEFINE$1) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw $TypeError$4('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var createPropertyDescriptor$4 = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var DESCRIPTORS$6 = descriptors;
  var definePropertyModule$3 = objectDefineProperty;
  var createPropertyDescriptor$3 = createPropertyDescriptor$4;

  var createNonEnumerableProperty$5 = DESCRIPTORS$6 ? function (object, key, value) {
    return definePropertyModule$3.f(object, key, createPropertyDescriptor$3(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var shared$1 = shared$3.exports;
  var uid$1 = uid$3;

  var keys$2 = shared$1('keys');

  var sharedKey$3 = function (key) {
    return keys$2[key] || (keys$2[key] = uid$1(key));
  };

  var hiddenKeys$5 = {};

  var NATIVE_WEAK_MAP = nativeWeakMap;
  var global$3 = global$b;
  var uncurryThis$8 = functionUncurryThis;
  var isObject$4 = isObject$9;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$5;
  var hasOwn$7 = hasOwnProperty_1;
  var shared = sharedStore;
  var sharedKey$2 = sharedKey$3;
  var hiddenKeys$4 = hiddenKeys$5;

  var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  var TypeError$1 = global$3.TypeError;
  var WeakMap$1 = global$3.WeakMap;
  var set$1, get$1, has;

  var enforce = function (it) {
    return has(it) ? get$1(it) : set$1(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;
      if (!isObject$4(it) || (state = get$1(it)).type !== TYPE) {
        throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');
      } return state;
    };
  };

  if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap$1());
    var wmget = uncurryThis$8(store.get);
    var wmhas = uncurryThis$8(store.has);
    var wmset = uncurryThis$8(store.set);
    set$1 = function (it, metadata) {
      if (wmhas(store, it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      wmset(store, it, metadata);
      return metadata;
    };
    get$1 = function (it) {
      return wmget(store, it) || {};
    };
    has = function (it) {
      return wmhas(store, it);
    };
  } else {
    var STATE = sharedKey$2('state');
    hiddenKeys$4[STATE] = true;
    set$1 = function (it, metadata) {
      if (hasOwn$7(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$4(it, STATE, metadata);
      return metadata;
    };
    get$1 = function (it) {
      return hasOwn$7(it, STATE) ? it[STATE] : {};
    };
    has = function (it) {
      return hasOwn$7(it, STATE);
    };
  }

  var internalState = {
    set: set$1,
    get: get$1,
    has: has,
    enforce: enforce,
    getterFor: getterFor
  };

  var NATIVE_BIND$1 = functionBindNative;

  var FunctionPrototype$1 = Function.prototype;
  var apply$1 = FunctionPrototype$1.apply;
  var call$7 = FunctionPrototype$1.call;

  // eslint-disable-next-line es-x/no-reflect -- safe
  var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$7.bind(apply$1) : function () {
    return call$7.apply(apply$1, arguments);
  });

  var objectGetOwnPropertyDescriptor = {};

  var objectPropertyIsEnumerable = {};

  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
  var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

  // Nashorn ~ JDK8 bug
  var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

  // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$1(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;

  var DESCRIPTORS$5 = descriptors;
  var call$6 = functionCall;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var createPropertyDescriptor$2 = createPropertyDescriptor$4;
  var toIndexedObject$5 = toIndexedObject$6;
  var toPropertyKey$1 = toPropertyKey$3;
  var hasOwn$6 = hasOwnProperty_1;
  var IE8_DOM_DEFINE = ie8DomDefine;

  // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$5 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$5(O);
    P = toPropertyKey$1(P);
    if (IE8_DOM_DEFINE) try {
      return $getOwnPropertyDescriptor(O, P);
    } catch (error) { /* empty */ }
    if (hasOwn$6(O, P)) return createPropertyDescriptor$2(!call$6(propertyIsEnumerableModule.f, O, P), O[P]);
  };

  var fails$7 = fails$e;
  var isCallable$7 = isCallable$f;

  var replacement = /#|\.prototype\./;

  var isForced$1 = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true
      : value == NATIVE ? false
      : isCallable$7(detection) ? fails$7(detection)
      : !!detection;
  };

  var normalize = isForced$1.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced$1.data = {};
  var NATIVE = isForced$1.NATIVE = 'N';
  var POLYFILL = isForced$1.POLYFILL = 'P';

  var isForced_1 = isForced$1;

  var uncurryThis$7 = functionUncurryThis;
  var aCallable$1 = aCallable$3;
  var NATIVE_BIND = functionBindNative;

  var bind$4 = uncurryThis$7(uncurryThis$7.bind);

  // optional / simple context binding
  var functionBindContext = function (fn, that) {
    aCallable$1(fn);
    return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var global$2 = global$b;
  var apply = functionApply;
  var uncurryThis$6 = functionUncurryThis;
  var isCallable$6 = isCallable$f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var isForced = isForced_1;
  var path$2 = path$4;
  var bind$3 = functionBindContext;
  var createNonEnumerableProperty$3 = createNonEnumerableProperty$5;
  var hasOwn$5 = hasOwnProperty_1;

  var wrapConstructor = function (NativeConstructor) {
    var Wrapper = function (a, b, c) {
      if (this instanceof Wrapper) {
        switch (arguments.length) {
          case 0: return new NativeConstructor();
          case 1: return new NativeConstructor(a);
          case 2: return new NativeConstructor(a, b);
        } return new NativeConstructor(a, b, c);
      } return apply(NativeConstructor, this, arguments);
    };
    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
  };

  /*
    options.target         - name of the target object
    options.global         - target is the global object
    options.stat           - export as static methods of target
    options.proto          - export as prototype methods of target
    options.real           - real prototype method for the `pure` version
    options.forced         - export even if the native feature is available
    options.bind           - bind methods to the target, required for the `pure` version
    options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe         - use the simple assignment of property instead of delete + defineProperty
    options.sham           - add a flag to not completely full polyfills
    options.enumerable     - export as enumerable property
    options.dontCallGetSet - prevent calling a getter on target
    options.name           - the .name of the function if it does not match the key
  */
  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;

    var nativeSource = GLOBAL ? global$2 : STATIC ? global$2[TARGET] : (global$2[TARGET] || {}).prototype;

    var target = GLOBAL ? path$2 : path$2[TARGET] || createNonEnumerableProperty$3(path$2, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;

    var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

    for (key in source) {
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
      // contains in native
      USE_NATIVE = !FORCED && nativeSource && hasOwn$5(nativeSource, key);

      targetProperty = target[key];

      if (USE_NATIVE) if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else nativeProperty = nativeSource[key];

      // export native or implementation
      sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

      if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;

      // bind timers to global for call from export context
      if (options.bind && USE_NATIVE) resultProperty = bind$3(sourceProperty, global$2);
      // wrap global constructors for prevent changs in this version
      else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
      // make static versions for prototype methods
      else if (PROTO && isCallable$6(sourceProperty)) resultProperty = uncurryThis$6(sourceProperty);
      // default case
      else resultProperty = sourceProperty;

      // add a flag to not completely full polyfills
      if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty$3(resultProperty, 'sham', true);
      }

      createNonEnumerableProperty$3(target, key, resultProperty);

      if (PROTO) {
        VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
        if (!hasOwn$5(path$2, VIRTUAL_PROTOTYPE)) {
          createNonEnumerableProperty$3(path$2, VIRTUAL_PROTOTYPE, {});
        }
        // export virtual prototype methods
        createNonEnumerableProperty$3(path$2[VIRTUAL_PROTOTYPE], key, sourceProperty);
        // export real prototype methods
        if (options.real && targetPrototype && !targetPrototype[key]) {
          createNonEnumerableProperty$3(targetPrototype, key, sourceProperty);
        }
      }
    }
  };

  var DESCRIPTORS$4 = descriptors;
  var hasOwn$4 = hasOwnProperty_1;

  var FunctionPrototype = Function.prototype;
  // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
  var getDescriptor = DESCRIPTORS$4 && Object.getOwnPropertyDescriptor;

  var EXISTS = hasOwn$4(FunctionPrototype, 'name');
  // additional protection from minified / mangled / dropped function names
  var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$4 || (DESCRIPTORS$4 && getDescriptor(FunctionPrototype, 'name').configurable));

  var functionName = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
  };

  var objectDefineProperties = {};

  var ceil = Math.ceil;
  var floor = Math.floor;

  // `Math.trunc` method
  // https://tc39.es/ecma262/#sec-math.trunc
  // eslint-disable-next-line es-x/no-math-trunc -- safe
  var mathTrunc = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
  };

  var trunc = mathTrunc;

  // `ToIntegerOrInfinity` abstract operation
  // https://tc39.es/ecma262/#sec-tointegerorinfinity
  var toIntegerOrInfinity$3 = function (argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- NaN check
    return number !== number || number === 0 ? 0 : trunc(number);
  };

  var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;

  var max$2 = Math.max;
  var min$2 = Math.min;

  // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
  var toAbsoluteIndex$2 = function (index, length) {
    var integer = toIntegerOrInfinity$2(index);
    return integer < 0 ? max$2(integer + length, 0) : min$2(integer, length);
  };

  var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;

  var min$1 = Math.min;

  // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength
  var toLength$1 = function (argument) {
    return argument > 0 ? min$1(toIntegerOrInfinity$1(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var toLength = toLength$1;

  // `LengthOfArrayLike` abstract operation
  // https://tc39.es/ecma262/#sec-lengthofarraylike
  var lengthOfArrayLike$4 = function (obj) {
    return toLength(obj.length);
  };

  var toIndexedObject$4 = toIndexedObject$6;
  var toAbsoluteIndex$1 = toAbsoluteIndex$2;
  var lengthOfArrayLike$3 = lengthOfArrayLike$4;

  // `Array.prototype.{ indexOf, includes }` methods implementation
  var createMethod$2 = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject$4($this);
      var length = lengthOfArrayLike$3(O);
      var index = toAbsoluteIndex$1(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare -- NaN check
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod$2(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$2(false)
  };

  var uncurryThis$5 = functionUncurryThis;
  var hasOwn$3 = hasOwnProperty_1;
  var toIndexedObject$3 = toIndexedObject$6;
  var indexOf$2 = arrayIncludes.indexOf;
  var hiddenKeys$3 = hiddenKeys$5;

  var push$2 = uncurryThis$5([].push);

  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject$3(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwn$3(hiddenKeys$3, key) && hasOwn$3(O, key) && push$2(result, key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (hasOwn$3(O, key = names[i++])) {
      ~indexOf$2(result, key) || push$2(result, key);
    }
    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys$3 = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
  ];

  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3;

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  // eslint-disable-next-line es-x/no-object-keys -- safe
  var objectKeys$2 = Object.keys || function keys(O) {
    return internalObjectKeys$1(O, enumBugKeys$2);
  };

  var DESCRIPTORS$3 = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var definePropertyModule$2 = objectDefineProperty;
  var anObject$5 = anObject$7;
  var toIndexedObject$2 = toIndexedObject$6;
  var objectKeys$1 = objectKeys$2;

  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es-x/no-object-defineproperties -- safe
  objectDefineProperties.f = DESCRIPTORS$3 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$5(O);
    var props = toIndexedObject$2(Properties);
    var keys = objectKeys$1(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);
    return O;
  };

  var getBuiltIn$2 = getBuiltIn$5;

  var html$1 = getBuiltIn$2('document', 'documentElement');

  /* global ActiveXObject -- old IE, WSH */

  var anObject$4 = anObject$7;
  var definePropertiesModule = objectDefineProperties;
  var enumBugKeys$1 = enumBugKeys$3;
  var hiddenKeys$2 = hiddenKeys$5;
  var html = html$1;
  var documentCreateElement = documentCreateElement$1;
  var sharedKey$1 = sharedKey$3;

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO$1 = sharedKey$1('IE_PROTO');

  var EmptyConstructor = function () { /* empty */ };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  };

  // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
  };

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  };

  // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug
  var activeXDocument;
  var NullProtoObject = function () {
    try {
      activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) { /* ignore */ }
    NullProtoObject = typeof document != 'undefined'
      ? document.domain && activeXDocument
        ? NullProtoObjectViaActiveX(activeXDocument) // old IE
        : NullProtoObjectViaIFrame()
      : NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys$1.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];
    return NullProtoObject();
  };

  hiddenKeys$2[IE_PROTO$1] = true;

  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  // eslint-disable-next-line es-x/no-object-create -- safe
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject$4(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO$1] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
  };

  var fails$6 = fails$e;

  var correctPrototypeGetter = !fails$6(function () {
    function F() { /* empty */ }
    F.prototype.constructor = null;
    // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var hasOwn$2 = hasOwnProperty_1;
  var isCallable$5 = isCallable$f;
  var toObject$1 = toObject$3;
  var sharedKey = sharedKey$3;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

  var IE_PROTO = sharedKey('IE_PROTO');
  var $Object$1 = Object;
  var ObjectPrototype = $Object$1.prototype;

  // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof
  // eslint-disable-next-line es-x/no-object-getprototypeof -- safe
  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function (O) {
    var object = toObject$1(O);
    if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable$5(constructor) && object instanceof constructor) {
      return constructor.prototype;
    } return object instanceof $Object$1 ? ObjectPrototype : null;
  };

  var createNonEnumerableProperty$2 = createNonEnumerableProperty$5;

  var defineBuiltIn$3 = function (target, key, value, options) {
    if (options && options.enumerable) target[key] = value;
    else createNonEnumerableProperty$2(target, key, value);
    return target;
  };

  var fails$5 = fails$e;
  var isCallable$4 = isCallable$f;
  var create$2 = objectCreate;
  var getPrototypeOf$1 = objectGetPrototypeOf;
  var defineBuiltIn$2 = defineBuiltIn$3;
  var wellKnownSymbol$8 = wellKnownSymbol$a;

  var ITERATOR$3 = wellKnownSymbol$8('iterator');
  var BUGGY_SAFARI_ITERATORS$1 = false;

  // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
  var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;

  /* eslint-disable es-x/no-array-prototype-keys -- safe */
  if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$5(function () {
    var test = {};
    // FF44- legacy iterators case
    return IteratorPrototype$1[ITERATOR$3].call(test) !== test;
  });

  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};
  else IteratorPrototype$1 = create$2(IteratorPrototype$1);

  // `%IteratorPrototype%[@@iterator]()` method
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
  if (!isCallable$4(IteratorPrototype$1[ITERATOR$3])) {
    defineBuiltIn$2(IteratorPrototype$1, ITERATOR$3, function () {
      return this;
    });
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$1,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };

  var wellKnownSymbol$7 = wellKnownSymbol$a;

  var TO_STRING_TAG$2 = wellKnownSymbol$7('toStringTag');
  var test = {};

  test[TO_STRING_TAG$2] = 'z';

  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
  var isCallable$3 = isCallable$f;
  var classofRaw = classofRaw$1;
  var wellKnownSymbol$6 = wellKnownSymbol$a;

  var TO_STRING_TAG$1 = wellKnownSymbol$6('toStringTag');
  var $Object = Object;

  // ES3 wrong here
  var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) { /* empty */ }
  };

  // getting tag from ES6+ `Object.prototype.toString`
  var classof$7 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG$1)) == 'string' ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && isCallable$3(O.callee) ? 'Arguments' : result;
  };

  var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
  var classof$6 = classof$7;

  // `Object.prototype.toString` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
    return '[object ' + classof$6(this) + ']';
  };

  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var defineProperty$3 = objectDefineProperty.f;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$5;
  var hasOwn$1 = hasOwnProperty_1;
  var toString$3 = objectToString;
  var wellKnownSymbol$5 = wellKnownSymbol$a;

  var TO_STRING_TAG = wellKnownSymbol$5('toStringTag');

  var setToStringTag$3 = function (it, TAG, STATIC, SET_METHOD) {
    if (it) {
      var target = STATIC ? it : it.prototype;
      if (!hasOwn$1(target, TO_STRING_TAG)) {
        defineProperty$3(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
      if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
        createNonEnumerableProperty$1(target, 'toString', toString$3);
      }
    }
  };

  var IteratorPrototype = iteratorsCore.IteratorPrototype;
  var create$1 = objectCreate;
  var createPropertyDescriptor$1 = createPropertyDescriptor$4;
  var setToStringTag$2 = setToStringTag$3;
  var Iterators$4 = iterators;

  var returnThis$1 = function () { return this; };

  var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create$1(IteratorPrototype, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });
    setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators$4[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var isCallable$2 = isCallable$f;

  var $String$1 = String;
  var $TypeError$3 = TypeError;

  var aPossiblePrototype$1 = function (argument) {
    if (typeof argument == 'object' || isCallable$2(argument)) return argument;
    throw $TypeError$3("Can't set " + $String$1(argument) + ' as a prototype');
  };

  /* eslint-disable no-proto -- safe */

  var uncurryThis$4 = functionUncurryThis;
  var anObject$3 = anObject$7;
  var aPossiblePrototype = aPossiblePrototype$1;

  // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  // eslint-disable-next-line es-x/no-object-setprototypeof -- safe
  Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
      setter = uncurryThis$4(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) { /* empty */ }
    return function setPrototypeOf(O, proto) {
      anObject$3(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  var $$2 = _export;
  var call$5 = functionCall;
  var FunctionName = functionName;
  var createIteratorConstructor = createIteratorConstructor$1;
  var getPrototypeOf = objectGetPrototypeOf;
  var setToStringTag$1 = setToStringTag$3;
  var defineBuiltIn$1 = defineBuiltIn$3;
  var wellKnownSymbol$4 = wellKnownSymbol$a;
  var Iterators$3 = iterators;
  var IteratorsCore = iteratorsCore;

  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$2 = wellKnownSymbol$4('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis = function () { return this; };

  var defineIterator$3 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function (KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
        case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
        case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
      } return function () { return new IteratorConstructor(this); };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$2]
      || IterablePrototype['@@iterator']
      || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;

    // fix native
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        Iterators$3[TO_STRING_TAG] = returnThis;
      }
    }

    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() { return call$5(nativeIterator, this); };
      }
    }

    // export additional methods
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn$1(IterablePrototype, KEY, methods[KEY]);
        }
      } else $$2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }

    // define iterator
    if ((FORCED) && IterablePrototype[ITERATOR$2] !== defaultIterator) {
      defineBuiltIn$1(IterablePrototype, ITERATOR$2, defaultIterator, { name: DEFAULT });
    }
    Iterators$3[NAME] = defaultIterator;

    return methods;
  };

  var toIndexedObject$1 = toIndexedObject$6;
  var Iterators$2 = iterators;
  var InternalStateModule$3 = internalState;
  objectDefineProperty.f;
  var defineIterator$2 = defineIterator$3;

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$3 = InternalStateModule$3.set;
  var getInternalState$1 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);

  // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator
  defineIterator$2(Array, 'Array', function (iterated, kind) {
    setInternalState$3(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject$1(iterated), // target
      index: 0,                          // next index
      kind: kind                         // kind
    });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = undefined;
      return { value: undefined, done: true };
    }
    if (kind == 'keys') return { value: index, done: false };
    if (kind == 'values') return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject
  Iterators$2.Arguments = Iterators$2.Array;

  var internalMetadata = {exports: {}};

  var objectGetOwnPropertyNames = {};

  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys = enumBugKeys$3;

  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  // eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNamesExternal = {};

  var toPropertyKey = toPropertyKey$3;
  var definePropertyModule$1 = objectDefineProperty;
  var createPropertyDescriptor = createPropertyDescriptor$4;

  var createProperty$1 = function (object, key, value) {
    var propertyKey = toPropertyKey(key);
    if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
  };

  var toAbsoluteIndex = toAbsoluteIndex$2;
  var lengthOfArrayLike$2 = lengthOfArrayLike$4;
  var createProperty = createProperty$1;

  var $Array$1 = Array;
  var max$1 = Math.max;

  var arraySliceSimple = function (O, start, end) {
    var length = lengthOfArrayLike$2(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = $Array$1(max$1(fin - k, 0));
    for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  };

  /* eslint-disable es-x/no-object-getownpropertynames -- safe */

  var classof$5 = classofRaw$1;
  var toIndexedObject = toIndexedObject$6;
  var $getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var arraySlice = arraySliceSimple;

  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return $getOwnPropertyNames(it);
    } catch (error) {
      return arraySlice(windowNames);
    }
  };

  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
    return windowNames && classof$5(it) == 'Window'
      ? getWindowNames(it)
      : $getOwnPropertyNames(toIndexedObject(it));
  };

  // FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
  var fails$4 = fails$e;

  var arrayBufferNonExtensible = fails$4(function () {
    if (typeof ArrayBuffer == 'function') {
      var buffer = new ArrayBuffer(8);
      // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-defineproperty -- safe
      if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
    }
  });

  var fails$3 = fails$e;
  var isObject$3 = isObject$9;
  var classof$4 = classofRaw$1;
  var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;

  // eslint-disable-next-line es-x/no-object-isextensible -- safe
  var $isExtensible = Object.isExtensible;
  var FAILS_ON_PRIMITIVES = fails$3(function () { $isExtensible(1); });

  // `Object.isExtensible` method
  // https://tc39.es/ecma262/#sec-object.isextensible
  var objectIsExtensible = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
    if (!isObject$3(it)) return false;
    if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$4(it) == 'ArrayBuffer') return false;
    return $isExtensible ? $isExtensible(it) : true;
  } : $isExtensible;

  var fails$2 = fails$e;

  var freezing = !fails$2(function () {
    // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-preventextensions -- required for testing
    return Object.isExtensible(Object.preventExtensions({}));
  });

  var $$1 = _export;
  var uncurryThis$3 = functionUncurryThis;
  var hiddenKeys = hiddenKeys$5;
  var isObject$2 = isObject$9;
  var hasOwn = hasOwnProperty_1;
  var defineProperty$2 = objectDefineProperty.f;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
  var isExtensible = objectIsExtensible;
  var uid = uid$3;
  var FREEZING = freezing;

  var REQUIRED = false;
  var METADATA = uid('meta');
  var id = 0;

  var setMetadata = function (it) {
    defineProperty$2(it, METADATA, { value: {
      objectID: 'O' + id++, // object ID
      weakData: {}          // weak collections IDs
    } });
  };

  var fastKey$1 = function (it, create) {
    // return a primitive with prefix
    if (!isObject$2(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!hasOwn(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMetadata(it);
    // return object ID
    } return it[METADATA].objectID;
  };

  var getWeakData = function (it, create) {
    if (!hasOwn(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMetadata(it);
    // return the store of weak collections IDs
    } return it[METADATA].weakData;
  };

  // add metadata on freeze-family methods calling
  var onFreeze = function (it) {
    if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
    return it;
  };

  var enable = function () {
    meta.enable = function () { /* empty */ };
    REQUIRED = true;
    var getOwnPropertyNames = getOwnPropertyNamesModule.f;
    var splice = uncurryThis$3([].splice);
    var test = {};
    test[METADATA] = 1;

    // prevent exposing of metadata key
    if (getOwnPropertyNames(test).length) {
      getOwnPropertyNamesModule.f = function (it) {
        var result = getOwnPropertyNames(it);
        for (var i = 0, length = result.length; i < length; i++) {
          if (result[i] === METADATA) {
            splice(result, i, 1);
            break;
          }
        } return result;
      };

      $$1({ target: 'Object', stat: true, forced: true }, {
        getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
      });
    }
  };

  var meta = internalMetadata.exports = {
    enable: enable,
    fastKey: fastKey$1,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };

  hiddenKeys[METADATA] = true;

  var wellKnownSymbol$3 = wellKnownSymbol$a;
  var Iterators$1 = iterators;

  var ITERATOR$1 = wellKnownSymbol$3('iterator');
  var ArrayPrototype = Array.prototype;

  // check on default Array iterator
  var isArrayIteratorMethod$1 = function (it) {
    return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$1] === it);
  };

  var classof$3 = classof$7;
  var getMethod$1 = getMethod$3;
  var Iterators = iterators;
  var wellKnownSymbol$2 = wellKnownSymbol$a;

  var ITERATOR = wellKnownSymbol$2('iterator');

  var getIteratorMethod$2 = function (it) {
    if (it != undefined) return getMethod$1(it, ITERATOR)
      || getMethod$1(it, '@@iterator')
      || Iterators[classof$3(it)];
  };

  var call$4 = functionCall;
  var aCallable = aCallable$3;
  var anObject$2 = anObject$7;
  var tryToString$1 = tryToString$3;
  var getIteratorMethod$1 = getIteratorMethod$2;

  var $TypeError$2 = TypeError;

  var getIterator$1 = function (argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
    if (aCallable(iteratorMethod)) return anObject$2(call$4(iteratorMethod, argument));
    throw $TypeError$2(tryToString$1(argument) + ' is not iterable');
  };

  var call$3 = functionCall;
  var anObject$1 = anObject$7;
  var getMethod = getMethod$3;

  var iteratorClose$1 = function (iterator, kind, value) {
    var innerResult, innerError;
    anObject$1(iterator);
    try {
      innerResult = getMethod(iterator, 'return');
      if (!innerResult) {
        if (kind === 'throw') throw value;
        return value;
      }
      innerResult = call$3(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject$1(innerResult);
    return value;
  };

  var bind$2 = functionBindContext;
  var call$2 = functionCall;
  var anObject = anObject$7;
  var tryToString = tryToString$3;
  var isArrayIteratorMethod = isArrayIteratorMethod$1;
  var lengthOfArrayLike$1 = lengthOfArrayLike$4;
  var isPrototypeOf$1 = objectIsPrototypeOf;
  var getIterator = getIterator$1;
  var getIteratorMethod = getIteratorMethod$2;
  var iteratorClose = iteratorClose$1;

  var $TypeError$1 = TypeError;

  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var ResultPrototype = Result.prototype;

  var iterate$2 = function (iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind$2(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function (condition) {
      if (iterator) iteratorClose(iterator, 'normal', condition);
      return new Result(true, condition);
    };

    var callFn = function (value) {
      if (AS_ENTRIES) {
        anObject(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      } return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_RECORD) {
      iterator = iterable.iterator;
    } else if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn) throw $TypeError$1(tryToString(iterable) + ' is not iterable');
      // optimisation for array iterators
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike$1(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && isPrototypeOf$1(ResultPrototype, result)) return result;
        } return new Result(false);
      }
      iterator = getIterator(iterable, iterFn);
    }

    next = IS_RECORD ? iterable.next : iterator.next;
    while (!(step = call$2(next, iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }
      if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;
    } return new Result(false);
  };

  var isPrototypeOf = objectIsPrototypeOf;

  var $TypeError = TypeError;

  var anInstance$2 = function (it, Prototype) {
    if (isPrototypeOf(Prototype, it)) return it;
    throw $TypeError('Incorrect invocation');
  };

  var classof$2 = classofRaw$1;

  // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  // eslint-disable-next-line es-x/no-array-isarray -- safe
  var isArray$1 = Array.isArray || function isArray(argument) {
    return classof$2(argument) == 'Array';
  };

  var uncurryThis$2 = functionUncurryThis;
  var fails$1 = fails$e;
  var isCallable$1 = isCallable$f;
  var classof$1 = classof$7;
  var getBuiltIn$1 = getBuiltIn$5;
  var inspectSource = inspectSource$2;

  var noop$4 = function () { /* empty */ };
  var empty = [];
  var construct = getBuiltIn$1('Reflect', 'construct');
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = uncurryThis$2(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$4);

  var isConstructorModern = function isConstructor(argument) {
    if (!isCallable$1(argument)) return false;
    try {
      construct(noop$4, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };

  var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable$1(argument)) return false;
    switch (classof$1(argument)) {
      case 'AsyncFunction':
      case 'GeneratorFunction':
      case 'AsyncGeneratorFunction': return false;
    }
    try {
      // we can't check .prototype since constructors produced by .bind haven't it
      // `Function#toString` throws on some built-it function in some legacy engines
      // (for example, `DOMQuad` and similar in FF41-)
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
    } catch (error) {
      return true;
    }
  };

  isConstructorLegacy.sham = true;

  // `IsConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-isconstructor
  var isConstructor$1 = !construct || fails$1(function () {
    var called;
    return isConstructorModern(isConstructorModern.call)
      || !isConstructorModern(Object)
      || !isConstructorModern(function () { called = true; })
      || called;
  }) ? isConstructorLegacy : isConstructorModern;

  var isArray = isArray$1;
  var isConstructor = isConstructor$1;
  var isObject$1 = isObject$9;
  var wellKnownSymbol$1 = wellKnownSymbol$a;

  var SPECIES$1 = wellKnownSymbol$1('species');
  var $Array = Array;

  // a part of `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate
  var arraySpeciesConstructor$1 = function (originalArray) {
    var C;
    if (isArray(originalArray)) {
      C = originalArray.constructor;
      // cross-realm fallback
      if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
      else if (isObject$1(C)) {
        C = C[SPECIES$1];
        if (C === null) C = undefined;
      }
    } return C === undefined ? $Array : C;
  };

  var arraySpeciesConstructor = arraySpeciesConstructor$1;

  // `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate
  var arraySpeciesCreate$1 = function (originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
  };

  var bind$1 = functionBindContext;
  var uncurryThis$1 = functionUncurryThis;
  var IndexedObject = indexedObject;
  var toObject = toObject$3;
  var lengthOfArrayLike = lengthOfArrayLike$4;
  var arraySpeciesCreate = arraySpeciesCreate$1;

  var push$1 = uncurryThis$1([].push);

  // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
  var createMethod$1 = function (TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject($this);
      var self = IndexedObject(O);
      var boundFunction = bind$1(callbackfn, that);
      var length = lengthOfArrayLike(self);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
      var value, result;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
            case 3: return true;              // some
            case 5: return value;             // find
            case 6: return index;             // findIndex
            case 2: push$1(target, value);      // filter
          } else switch (TYPE) {
            case 4: return false;             // every
            case 7: push$1(target, value);      // filterReject
          }
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$1(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod$1(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod$1(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod$1(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod$1(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod$1(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$1(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod$1(7)
  };

  var $ = _export;
  var global$1 = global$b;
  var InternalMetadataModule = internalMetadata.exports;
  var fails = fails$e;
  var createNonEnumerableProperty = createNonEnumerableProperty$5;
  var iterate$1 = iterate$2;
  var anInstance$1 = anInstance$2;
  var isCallable = isCallable$f;
  var isObject = isObject$9;
  var setToStringTag = setToStringTag$3;
  var defineProperty$1 = objectDefineProperty.f;
  var forEach$1 = arrayIteration.forEach;
  var DESCRIPTORS$2 = descriptors;
  var InternalStateModule$2 = internalState;

  var setInternalState$2 = InternalStateModule$2.set;
  var internalStateGetterFor$1 = InternalStateModule$2.getterFor;

  var collection$1 = function (CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global$1[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var exported = {};
    var Constructor;

    if (!DESCRIPTORS$2 || !isCallable(NativeConstructor)
      || !(IS_WEAK || NativePrototype.forEach && !fails(function () { new NativeConstructor().entries().next(); }))
    ) {
      // create collection constructor
      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
      InternalMetadataModule.enable();
    } else {
      Constructor = wrapper(function (target, iterable) {
        setInternalState$2(anInstance$1(target, Prototype), {
          type: CONSTRUCTOR_NAME,
          collection: new NativeConstructor()
        });
        if (iterable != undefined) iterate$1(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });
      });

      var Prototype = Constructor.prototype;

      var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

      forEach$1(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
          createNonEnumerableProperty(Prototype, KEY, function (a, b) {
            var collection = getInternalState(this).collection;
            if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
            var result = collection[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
        }
      });

      IS_WEAK || defineProperty$1(Prototype, 'size', {
        configurable: true,
        get: function () {
          return getInternalState(this).collection.size;
        }
      });
    }

    setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);

    exported[CONSTRUCTOR_NAME] = Constructor;
    $({ global: true, forced: true }, exported);

    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

    return Constructor;
  };

  var defineBuiltIn = defineBuiltIn$3;

  var defineBuiltIns$1 = function (target, src, options) {
    for (var key in src) {
      if (options && options.unsafe && target[key]) target[key] = src[key];
      else defineBuiltIn(target, key, src[key], options);
    } return target;
  };

  var getBuiltIn = getBuiltIn$5;
  var definePropertyModule = objectDefineProperty;
  var wellKnownSymbol = wellKnownSymbol$a;
  var DESCRIPTORS$1 = descriptors;

  var SPECIES = wellKnownSymbol('species');

  var setSpecies$1 = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule.f;

    if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
      defineProperty(Constructor, SPECIES, {
        configurable: true,
        get: function () { return this; }
      });
    }
  };

  var defineProperty = objectDefineProperty.f;
  var create = objectCreate;
  var defineBuiltIns = defineBuiltIns$1;
  var bind = functionBindContext;
  var anInstance = anInstance$2;
  var iterate = iterate$2;
  var defineIterator$1 = defineIterator$3;
  var setSpecies = setSpecies$1;
  var DESCRIPTORS = descriptors;
  var fastKey = internalMetadata.exports.fastKey;
  var InternalStateModule$1 = internalState;

  var setInternalState$1 = InternalStateModule$1.set;
  var internalStateGetterFor = InternalStateModule$1.getterFor;

  var collectionStrong$1 = {
    getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var Constructor = wrapper(function (that, iterable) {
        anInstance(that, Prototype);
        setInternalState$1(that, {
          type: CONSTRUCTOR_NAME,
          index: create(null),
          first: undefined,
          last: undefined,
          size: 0
        });
        if (!DESCRIPTORS) that.size = 0;
        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
      });

      var Prototype = Constructor.prototype;

      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

      var define = function (that, key, value) {
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        var previous, index;
        // change existing entry
        if (entry) {
          entry.value = value;
        // create new entry
        } else {
          state.last = entry = {
            index: index = fastKey(key, true),
            key: key,
            value: value,
            previous: previous = state.last,
            next: undefined,
            removed: false
          };
          if (!state.first) state.first = entry;
          if (previous) previous.next = entry;
          if (DESCRIPTORS) state.size++;
          else that.size++;
          // add to index
          if (index !== 'F') state.index[index] = entry;
        } return that;
      };

      var getEntry = function (that, key) {
        var state = getInternalState(that);
        // fast case
        var index = fastKey(key);
        var entry;
        if (index !== 'F') return state.index[index];
        // frozen object case
        for (entry = state.first; entry; entry = entry.next) {
          if (entry.key == key) return entry;
        }
      };

      defineBuiltIns(Prototype, {
        // `{ Map, Set }.prototype.clear()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.clear
        // https://tc39.es/ecma262/#sec-set.prototype.clear
        clear: function clear() {
          var that = this;
          var state = getInternalState(that);
          var data = state.index;
          var entry = state.first;
          while (entry) {
            entry.removed = true;
            if (entry.previous) entry.previous = entry.previous.next = undefined;
            delete data[entry.index];
            entry = entry.next;
          }
          state.first = state.last = undefined;
          if (DESCRIPTORS) state.size = 0;
          else that.size = 0;
        },
        // `{ Map, Set }.prototype.delete(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.delete
        // https://tc39.es/ecma262/#sec-set.prototype.delete
        'delete': function (key) {
          var that = this;
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.next;
            var prev = entry.previous;
            delete state.index[entry.index];
            entry.removed = true;
            if (prev) prev.next = next;
            if (next) next.previous = prev;
            if (state.first == entry) state.first = next;
            if (state.last == entry) state.last = prev;
            if (DESCRIPTORS) state.size--;
            else that.size--;
          } return !!entry;
        },
        // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.foreach
        // https://tc39.es/ecma262/#sec-set.prototype.foreach
        forEach: function forEach(callbackfn /* , that = undefined */) {
          var state = getInternalState(this);
          var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          var entry;
          while (entry = entry ? entry.next : state.first) {
            boundFunction(entry.value, entry.key, this);
            // revert to the last existing entry
            while (entry && entry.removed) entry = entry.previous;
          }
        },
        // `{ Map, Set}.prototype.has(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.has
        // https://tc39.es/ecma262/#sec-set.prototype.has
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });

      defineBuiltIns(Prototype, IS_MAP ? {
        // `Map.prototype.get(key)` method
        // https://tc39.es/ecma262/#sec-map.prototype.get
        get: function get(key) {
          var entry = getEntry(this, key);
          return entry && entry.value;
        },
        // `Map.prototype.set(key, value)` method
        // https://tc39.es/ecma262/#sec-map.prototype.set
        set: function set(key, value) {
          return define(this, key === 0 ? 0 : key, value);
        }
      } : {
        // `Set.prototype.add(value)` method
        // https://tc39.es/ecma262/#sec-set.prototype.add
        add: function add(value) {
          return define(this, value = value === 0 ? 0 : value, value);
        }
      });
      if (DESCRIPTORS) defineProperty(Prototype, 'size', {
        get: function () {
          return getInternalState(this).size;
        }
      });
      return Constructor;
    },
    setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
      var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
      var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
      // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.entries
      // https://tc39.es/ecma262/#sec-map.prototype.keys
      // https://tc39.es/ecma262/#sec-map.prototype.values
      // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
      // https://tc39.es/ecma262/#sec-set.prototype.entries
      // https://tc39.es/ecma262/#sec-set.prototype.keys
      // https://tc39.es/ecma262/#sec-set.prototype.values
      // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
      defineIterator$1(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
        setInternalState$1(this, {
          type: ITERATOR_NAME,
          target: iterated,
          state: getInternalCollectionState(iterated),
          kind: kind,
          last: undefined
        });
      }, function () {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var entry = state.last;
        // revert to the last existing entry
        while (entry && entry.removed) entry = entry.previous;
        // get next entry
        if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
          // or finish the iteration
          state.target = undefined;
          return { value: undefined, done: true };
        }
        // return step by kind
        if (kind == 'keys') return { value: entry.key, done: false };
        if (kind == 'values') return { value: entry.value, done: false };
        return { value: [entry.key, entry.value], done: false };
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

      // `{ Map, Set }.prototype[@@species]` accessors
      // https://tc39.es/ecma262/#sec-get-map-@@species
      // https://tc39.es/ecma262/#sec-get-set-@@species
      setSpecies(CONSTRUCTOR_NAME);
    }
  };

  var collection = collection$1;
  var collectionStrong = collectionStrong$1;

  // `Set` constructor
  // https://tc39.es/ecma262/#sec-set-objects
  collection('Set', function (init) {
    return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
  }, collectionStrong);

  var classof = classof$7;

  var $String = String;

  var toString$2 = function (argument) {
    if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return $String(argument);
  };

  var uncurryThis = functionUncurryThis;
  var toIntegerOrInfinity = toIntegerOrInfinity$3;
  var toString$1 = toString$2;
  var requireObjectCoercible = requireObjectCoercible$3;

  var charAt$1 = uncurryThis(''.charAt);
  var charCodeAt = uncurryThis(''.charCodeAt);
  var stringSlice = uncurryThis(''.slice);

  var createMethod = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = toString$1(requireObjectCoercible($this));
      var position = toIntegerOrInfinity(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = charCodeAt(S, position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size
        || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
          ? CONVERT_TO_STRING
            ? charAt$1(S, position)
            : first
          : CONVERT_TO_STRING
            ? stringSlice(S, position, position + 2)
            : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };

  var charAt = stringMultibyte.charAt;
  var toString = toString$2;
  var InternalStateModule = internalState;
  var defineIterator = defineIterator$3;

  var STRING_ITERATOR = 'String Iterator';
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

  // `String.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
  defineIterator(String, 'String', function (iterated) {
    setInternalState(this, {
      type: STRING_ITERATOR,
      string: toString(iterated),
      index: 0
    });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return { value: undefined, done: true };
    point = charAt(string, index);
    state.index += point.length;
    return { value: point, done: false };
  });

  var path$1 = path$4;

  var set = path$1.Set;

  Object.defineProperty(vmState, "__esModule", { value: true });
  vmState.VmState = void 0;
  const common_1$b = dist$8;
  const precompiles_1 = precompiles$1;
  const util_1$q = dist$a;
  const debug_1$3 = src$1.exports;
  const Set$1 = set;
  class VmState {
      constructor({ common, stateManager }) {
          this.DEBUG = false;
          this._checkpointCount = 0;
          this._stateManager = stateManager;
          this._common = common ?? new common_1$b.Common({ chain: common_1$b.Chain.Mainnet, hardfork: common_1$b.Hardfork.Petersburg });
          this._touched = new Set$1();
          this._touchedStack = [];
          this._originalStorageCache = new Map();
          this._accessedStorage = [new Map()];
          this._accessedStorageReverted = [new Map()];
          // Safeguard if "process" is not available (browser)
          if (browser$1$1 !== undefined && typeof browser$1$1.env.DEBUG !== 'undefined') {
              this.DEBUG = true;
          }
          this._debug = (0, debug_1$3.debug)('vm:state');
      }
      /**
       * Checkpoints the current state of the StateManager instance.
       * State changes that follow can then be committed by calling
       * `commit` or `reverted` by calling rollback.
       *
       * Partial implementation, called from the subclass.
       */
      async checkpoint() {
          this._touchedStack.push(new Set$1(Array.from(this._touched)));
          this._accessedStorage.push(new Map());
          await this._stateManager.checkpoint();
          this._checkpointCount++;
          if (this.DEBUG) {
              this._debug('-'.repeat(100));
              this._debug(`message checkpoint`);
          }
      }
      async commit() {
          // setup cache checkpointing
          this._touchedStack.pop();
          // Copy the contents of the map of the current level to a map higher.
          const storageMap = this._accessedStorage.pop();
          if (storageMap) {
              this._accessedStorageMerge(this._accessedStorage, storageMap);
          }
          await this._stateManager.commit();
          this._checkpointCount--;
          if (this._checkpointCount === 0) {
              await this._stateManager.flush();
              this._clearOriginalStorageCache();
          }
          if (this.DEBUG) {
              this._debug(`message checkpoint committed`);
          }
      }
      /**
       * Reverts the current change-set to the instance since the
       * last call to checkpoint.
       *
       * Partial implementation , called from the subclass.
       */
      async revert() {
          // setup cache checkpointing
          const lastItem = this._accessedStorage.pop();
          if (lastItem) {
              this._accessedStorageReverted.push(lastItem);
          }
          const touched = this._touchedStack.pop();
          if (!touched) {
              throw new Error('Reverting to invalid state checkpoint failed');
          }
          // Exceptional case due to consensus issue in Geth and Parity.
          // See [EIP issue #716](https://github.com/ethereum/EIPs/issues/716) for context.
          // The RIPEMD precompile has to remain *touched* even when the call reverts,
          // and be considered for deletion.
          if (this._touched.has(precompiles_1.ripemdPrecompileAddress)) {
              touched.add(precompiles_1.ripemdPrecompileAddress);
          }
          this._touched = touched;
          await this._stateManager.revert();
          this._checkpointCount--;
          if (this._checkpointCount === 0) {
              await this._stateManager.flush();
              this._clearOriginalStorageCache();
          }
          if (this.DEBUG) {
              this._debug(`message checkpoint reverted`);
          }
      }
      async getAccount(address) {
          return await this._stateManager.getAccount(address);
      }
      async putAccount(address, account) {
          await this._stateManager.putAccount(address, account);
          this.touchAccount(address);
      }
      async modifyAccountFields(address, accountFields) {
          return this._stateManager.modifyAccountFields(address, accountFields);
      }
      /**
       * Deletes an account from state under the provided `address`. The account will also be removed from the state trie.
       * @param address - Address of the account which should be deleted
       */
      async deleteAccount(address) {
          await this._stateManager.deleteAccount(address);
          this.touchAccount(address);
      }
      async getContractCode(address) {
          return await this._stateManager.getContractCode(address);
      }
      async putContractCode(address, value) {
          return await this._stateManager.putContractCode(address, value);
      }
      async getContractStorage(address, key) {
          return await this._stateManager.getContractStorage(address, key);
      }
      async putContractStorage(address, key, value) {
          await this._stateManager.putContractStorage(address, key, value);
          this.touchAccount(address);
      }
      async clearContractStorage(address) {
          await this._stateManager.clearContractStorage(address);
          this.touchAccount(address);
      }
      async accountExists(address) {
          return await this._stateManager.accountExists(address);
      }
      async setStateRoot(stateRoot) {
          if (this._checkpointCount !== 0) {
              throw new Error('Cannot set state root with uncommitted checkpoints');
          }
          return await this._stateManager.setStateRoot(stateRoot);
      }
      async getStateRoot() {
          return await this._stateManager.getStateRoot();
      }
      async hasStateRoot(root) {
          return await this._stateManager.hasStateRoot(root);
      }
      /**
       * Marks an account as touched, according to the definition
       * in [EIP-158](https://eips.ethereum.org/EIPS/eip-158).
       * This happens when the account is triggered for a state-changing
       * event. Touched accounts that are empty will be cleared
       * at the end of the tx.
       */
      touchAccount(address) {
          this._touched.add(address.buf.toString('hex'));
      }
      /**
       * Merges a storage map into the last item of the accessed storage stack
       */
      _accessedStorageMerge(storageList, storageMap) {
          const mapTarget = storageList[storageList.length - 1];
          if ((0, util_1$q.isTruthy)(mapTarget)) {
              // Note: storageMap is always defined here per definition (TypeScript cannot infer this)
              storageMap.forEach((slotSet, addressString) => {
                  const addressExists = mapTarget.get(addressString);
                  if (!addressExists) {
                      mapTarget.set(addressString, new Set$1());
                  }
                  const storageSet = mapTarget.get(addressString);
                  slotSet.forEach((value) => {
                      storageSet.add(value);
                  });
              });
          }
      }
      /**
       * Initializes the provided genesis state into the state trie.
       * Will error if there are uncommitted checkpoints on the instance.
       * @param initState address -> balance | [balance, code, storage]
       */
      async generateCanonicalGenesis(initState) {
          if (this._checkpointCount !== 0) {
              throw new Error('Cannot create genesis state with uncommitted checkpoints');
          }
          if (this.DEBUG) {
              this._debug(`Save genesis state into the state trie`);
          }
          const addresses = Object.keys(initState);
          for (const address of addresses) {
              const addr = util_1$q.Address.fromString(address);
              const state = initState[address];
              if (!Array.isArray(state)) {
                  // Prior format: address -> balance
                  const account = util_1$q.Account.fromAccountData({ balance: state });
                  await this.putAccount(addr, account);
              }
              else {
                  // New format: address -> [balance, code, storage]
                  const [balance, code, storage] = state;
                  const account = util_1$q.Account.fromAccountData({ balance });
                  await this.putAccount(addr, account);
                  if ((0, util_1$q.isTruthy)(code)) {
                      await this.putContractCode(addr, (0, util_1$q.toBuffer)(code));
                  }
                  if ((0, util_1$q.isTruthy)(storage)) {
                      for (const [key, value] of storage) {
                          await this.putContractStorage(addr, (0, util_1$q.toBuffer)(key), (0, util_1$q.toBuffer)(value));
                      }
                  }
              }
          }
          await this._stateManager.flush();
      }
      /**
       * Removes accounts form the state trie that have been touched,
       * as defined in EIP-161 (https://eips.ethereum.org/EIPS/eip-161).
       */
      async cleanupTouchedAccounts() {
          if (this._common.gteHardfork(common_1$b.Hardfork.SpuriousDragon) === true) {
              const touchedArray = Array.from(this._touched);
              for (const addressHex of touchedArray) {
                  const address = new util_1$q.Address(Buffer$8.from(addressHex, 'hex'));
                  const empty = await this.accountIsEmpty(address);
                  if (empty) {
                      await this._stateManager.deleteAccount(address);
                      if (this.DEBUG) {
                          this._debug(`Cleanup touched account address=${address} (>= SpuriousDragon)`);
                      }
                  }
              }
          }
          this._touched.clear();
      }
      /**
       * Caches the storage value associated with the provided `address` and `key`
       * on first invocation, and returns the cached (original) value from then
       * onwards. This is used to get the original value of a storage slot for
       * computing gas costs according to EIP-1283.
       * @param address - Address of the account to get the storage for
       * @param key - Key in the account's storage to get the value for. Must be 32 bytes long.
       */
      async getOriginalContractStorage(address, key) {
          if (key.length !== 32) {
              throw new Error('Storage key must be 32 bytes long');
          }
          const addressHex = address.buf.toString('hex');
          const keyHex = key.toString('hex');
          let map;
          if (!this._originalStorageCache.has(addressHex)) {
              map = new Map();
              this._originalStorageCache.set(addressHex, map);
          }
          else {
              map = this._originalStorageCache.get(addressHex);
          }
          if (map.has(keyHex)) {
              return map.get(keyHex);
          }
          else {
              const current = await this.getContractStorage(address, key);
              map.set(keyHex, current);
              return current;
          }
      }
      /**
       * Clears the original storage cache. Refer to {@link StateManager.getOriginalContractStorage}
       * for more explanation.
       */
      _clearOriginalStorageCache() {
          this._originalStorageCache = new Map();
      }
      /**
       * Clears the original storage cache. Refer to {@link StateManager.getOriginalContractStorage}
       * for more explanation. Alias of the internal {@link StateManager._clearOriginalStorageCache}
       */
      clearOriginalStorageCache() {
          this._clearOriginalStorageCache();
      }
      /** EIP-2929 logic
       * This should only be called from within the EVM
       */
      /**
       * Returns true if the address is warm in the current context
       * @param address - The address (as a Buffer) to check
       */
      isWarmedAddress(address) {
          for (let i = this._accessedStorage.length - 1; i >= 0; i--) {
              const currentMap = this._accessedStorage[i];
              if (currentMap.has(address.toString('hex'))) {
                  return true;
              }
          }
          return false;
      }
      /**
       * Add a warm address in the current context
       * @param address - The address (as a Buffer) to check
       */
      addWarmedAddress(address) {
          const key = address.toString('hex');
          const storageSet = this._accessedStorage[this._accessedStorage.length - 1].get(key);
          if (!storageSet) {
              const emptyStorage = new Set$1();
              this._accessedStorage[this._accessedStorage.length - 1].set(key, emptyStorage);
          }
      }
      /**
       * Returns true if the slot of the address is warm
       * @param address - The address (as a Buffer) to check
       * @param slot - The slot (as a Buffer) to check
       */
      isWarmedStorage(address, slot) {
          const addressKey = address.toString('hex');
          const storageKey = slot.toString('hex');
          for (let i = this._accessedStorage.length - 1; i >= 0; i--) {
              const currentMap = this._accessedStorage[i];
              if (currentMap.has(addressKey) && currentMap.get(addressKey).has(storageKey)) {
                  return true;
              }
          }
          return false;
      }
      /**
       * Mark the storage slot in the address as warm in the current context
       * @param address - The address (as a Buffer) to check
       * @param slot - The slot (as a Buffer) to check
       */
      addWarmedStorage(address, slot) {
          const addressKey = address.toString('hex');
          let storageSet = this._accessedStorage[this._accessedStorage.length - 1].get(addressKey);
          if (!storageSet) {
              storageSet = new Set$1();
              this._accessedStorage[this._accessedStorage.length - 1].set(addressKey, storageSet);
          }
          storageSet.add(slot.toString('hex'));
      }
      /**
       * Clear the warm accounts and storage. To be called after a transaction finished.
       */
      clearWarmedAccounts() {
          this._accessedStorage = [new Map()];
          this._accessedStorageReverted = [new Map()];
      }
      /**
       * Generates an EIP-2930 access list
       *
       * Note: this method is not yet part of the {@link StateManager} interface.
       * If not implemented, {@link VM.runTx} is not allowed to be used with the
       * `reportAccessList` option and will instead throw.
       *
       * Note: there is an edge case on accessList generation where an
       * internal call might revert without an accessList but pass if the
       * accessList is used for a tx run (so the subsequent behavior might change).
       * This edge case is not covered by this implementation.
       *
       * @param addressesRemoved - List of addresses to be removed from the final list
       * @param addressesOnlyStorage - List of addresses only to be added in case of present storage slots
       *
       * @returns - an [@ethereumjs/tx](https://github.com/ethereumjs/ethereumjs-monorepo/packages/tx) `AccessList`
       */
      generateAccessList(addressesRemoved = [], addressesOnlyStorage = []) {
          // Merge with the reverted storage list
          const mergedStorage = [...this._accessedStorage, ...this._accessedStorageReverted];
          // Fold merged storage array into one Map
          while (mergedStorage.length >= 2) {
              const storageMap = mergedStorage.pop();
              if (storageMap) {
                  this._accessedStorageMerge(mergedStorage, storageMap);
              }
          }
          const folded = new Map([...mergedStorage[0].entries()].sort());
          // Transfer folded map to final structure
          const accessList = [];
          folded.forEach((slots, addressStr) => {
              const address = util_1$q.Address.fromString(`0x${addressStr}`);
              const check1 = addressesRemoved.find((a) => a.equals(address));
              const check2 = addressesOnlyStorage.find((a) => a.equals(address)) !== undefined && slots.size === 0;
              if (!check1 && !check2) {
                  const storageSlots = Array.from(slots)
                      .map((s) => `0x${s}`)
                      .sort();
                  const accessListItem = {
                      address: `0x${addressStr}`,
                      storageKeys: storageSlots,
                  };
                  accessList.push(accessListItem);
              }
          });
          return accessList;
      }
      /**
       * Checks if the `account` corresponding to `address`
       * is empty or non-existent as defined in
       * EIP-161 (https://eips.ethereum.org/EIPS/eip-161).
       * @param address - Address to check
       */
      async accountIsEmpty(address) {
          return this._stateManager.accountIsEmpty(address);
      }
  }
  vmState.VmState = VmState;

  Object.defineProperty(eei, "__esModule", { value: true });
  eei.EEI = void 0;
  const util_1$p = dist$a;
  const vmState_1 = vmState;
  /**
   * External interface made available to EVM bytecode. Modeled after
   * the ewasm EEI [spec](https://github.com/ewasm/design/blob/master/eth_interface.md).
   * It includes methods for accessing/modifying state, calling or creating contracts, access
   * to environment data among other things.
   * The EEI instance also keeps artifacts produced by the bytecode such as logs
   * and to-be-selfdestructed addresses.
   */
  class EEI extends vmState_1.VmState {
      constructor(stateManager, common, blockchain) {
          super({ common, stateManager });
          this._common = common;
          this._blockchain = blockchain;
      }
      /**
       * Returns balance of the given account.
       * @param address - Address of account
       */
      async getExternalBalance(address) {
          const account = await this.getAccount(address);
          return account.balance;
      }
      /**
       * Get size of an account’s code.
       * @param address - Address of account
       */
      async getExternalCodeSize(address) {
          const code = await this.getContractCode(address);
          return BigInt(code.length);
      }
      /**
       * Returns code of an account.
       * @param address - Address of account
       */
      async getExternalCode(address) {
          return this.getContractCode(address);
      }
      /**
       * Returns Gets the hash of one of the 256 most recent complete blocks.
       * @param num - Number of block
       */
      async getBlockHash(num) {
          const block = await this._blockchain.getBlock(Number(num));
          return (0, util_1$p.bufferToBigInt)(block.hash());
      }
      /**
       * Storage 256-bit value into storage of an address
       * @param address Address to store into
       * @param key Storage key
       * @param value Storage value
       */
      async storageStore(address, key, value) {
          await this.putContractStorage(address, key, value);
      }
      /**
       * Loads a 256-bit value to memory from persistent storage.
       * @param address Address to get storage key value from
       * @param key Storage key
       * @param original If true, return the original storage value (default: false)
       */
      async storageLoad(address, key, original = false) {
          if (original) {
              return this.getOriginalContractStorage(address, key);
          }
          else {
              return this.getContractStorage(address, key);
          }
      }
      copy() {
          return new EEI(this._stateManager.copy(), this._common.copy(), this._blockchain.copy());
      }
  }
  eei.EEI = EEI;

  var types$3 = {};

  Object.defineProperty(types$3, "__esModule", { value: true });

  var vm = {};

  var dist$7 = {};

  var blockchain = {};

  var dist$6 = {};

  var block = {};

  var dist$5 = {};

  var db = {};

  var checkpoint$1 = {};

  Object.defineProperty(checkpoint$1, "__esModule", { value: true });
  checkpoint$1.CheckpointDB = void 0;
  /**
   * DB is a thin wrapper around the underlying levelup db,
   * which validates inputs and sets encoding type.
   */
  class CheckpointDB {
      /**
       * Initialize a DB instance.
       */
      constructor(db) {
          this.db = db;
          // Roots of trie at the moment of checkpoint
          this.checkpoints = [];
      }
      /**
       * Is the DB during a checkpoint phase?
       */
      get isCheckpoint() {
          return this.checkpoints.length > 0;
      }
      /**
       * Adds a new checkpoint to the stack
       * @param root
       */
      checkpoint(root) {
          this.checkpoints.push({ keyValueMap: new Map(), root });
      }
      /**
       * Commits the latest checkpoint
       */
      async commit() {
          const { keyValueMap } = this.checkpoints.pop();
          if (!this.isCheckpoint) {
              // This was the final checkpoint, we should now commit and flush everything to disk
              const batchOp = [];
              keyValueMap.forEach(function (value, key) {
                  if (value === null) {
                      batchOp.push({
                          type: 'del',
                          key: Buffer$8.from(key, 'binary'),
                      });
                  }
                  else {
                      batchOp.push({
                          type: 'put',
                          key: Buffer$8.from(key, 'binary'),
                          value,
                      });
                  }
              });
              await this.batch(batchOp);
          }
          else {
              // dump everything into the current (higher level) cache
              const currentKeyValueMap = this.checkpoints[this.checkpoints.length - 1].keyValueMap;
              keyValueMap.forEach((value, key) => currentKeyValueMap.set(key, value));
          }
      }
      /**
       * Reverts the latest checkpoint
       */
      async revert() {
          const { root } = this.checkpoints.pop();
          return root;
      }
      /**
       * @inheritDoc
       */
      async get(key) {
          // Lookup the value in our cache. We return the latest checkpointed value (which should be the value on disk)
          for (let index = this.checkpoints.length - 1; index >= 0; index--) {
              const value = this.checkpoints[index].keyValueMap.get(key.toString('binary'));
              if (value !== undefined) {
                  return value;
              }
          }
          // Nothing has been found in cache, look up from disk
          const value = await this.db.get(key);
          if (this.isCheckpoint) {
              // Since we are a checkpoint, put this value in cache, so future `get` calls will not look the key up again from disk.
              this.checkpoints[this.checkpoints.length - 1].keyValueMap.set(key.toString('binary'), value);
          }
          return value;
      }
      /**
       * @inheritDoc
       */
      async put(key, val) {
          if (this.isCheckpoint) {
              // put value in cache
              this.checkpoints[this.checkpoints.length - 1].keyValueMap.set(key.toString('binary'), val);
          }
          else {
              await this.db.put(key, val);
          }
      }
      /**
       * @inheritDoc
       */
      async del(key) {
          if (this.isCheckpoint) {
              // delete the value in the current cache
              this.checkpoints[this.checkpoints.length - 1].keyValueMap.set(key.toString('binary'), null);
          }
          else {
              // delete the value on disk
              await this.db.del(key);
          }
      }
      /**
       * @inheritDoc
       */
      async batch(opStack) {
          if (this.isCheckpoint) {
              for (const op of opStack) {
                  if (op.type === 'put') {
                      await this.put(op.key, op.value);
                  }
                  else if (op.type === 'del') {
                      await this.del(op.key);
                  }
              }
          }
          else {
              await this.db.batch(opStack);
          }
      }
      /**
       * @inheritDoc
       */
      copy() {
          return new CheckpointDB(this.db);
      }
  }
  checkpoint$1.CheckpointDB = CheckpointDB;

  var level = {};

  var memoryLevel = {};

  var abstractLevel$1 = {};

  var abstractLevel = {};

  var levelSupports = {};

  levelSupports.supports = function supports (...manifests) {
    const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});

    return Object.assign(manifest, {
      snapshots: manifest.snapshots || false,
      permanence: manifest.permanence || false,
      seek: manifest.seek || false,
      clear: manifest.clear || false,
      getMany: manifest.getMany || false,
      keyIterator: manifest.keyIterator || false,
      valueIterator: manifest.valueIterator || false,
      iteratorNextv: manifest.iteratorNextv || false,
      iteratorAll: manifest.iteratorAll || false,
      status: manifest.status || false,
      createIfMissing: manifest.createIfMissing || false,
      errorIfExists: manifest.errorIfExists || false,
      deferredOpen: manifest.deferredOpen || false,
      promises: manifest.promises || false,
      streams: manifest.streams || false,
      encodings: Object.assign({}, manifest.encodings),
      events: Object.assign({}, manifest.events),
      additionalMethods: Object.assign({}, manifest.additionalMethods)
    })
  };

  var levelTranscoder = {};

  var moduleError = class ModuleError extends Error {
    /**
     * @param {string} message Error message
     * @param {{ code?: string, cause?: Error, expected?: boolean, transient?: boolean }} [options]
     */
    constructor (message, options) {
      super(message || '');

      if (typeof options === 'object' && options !== null) {
        if (options.code) this.code = String(options.code);
        if (options.expected) this.expected = true;
        if (options.transient) this.transient = true;
        if (options.cause) this.cause = options.cause;
      }

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
  };

  var encodings$1 = {};

  /** @type {{ textEncoder: TextEncoder, textDecoder: TextDecoder }|null} */
  let lazy = null;

  /**
   * Get semi-global instances of TextEncoder and TextDecoder.
   * @returns {{ textEncoder: TextEncoder, textDecoder: TextDecoder }}
   */
  var textEndec$1 = function () {
    if (lazy === null) {
      lazy = {
        textEncoder: new TextEncoder(),
        textDecoder: new TextDecoder()
      };
    }

    return lazy
  };

  var formats$2 = {};

  var encoding = {};

  const ModuleError$9 = moduleError;
  const formats$1 = new Set(['buffer', 'view', 'utf8']);

  /**
   * @template TIn, TFormat, TOut
   * @abstract
   */
  class Encoding$2 {
    /**
     * @param {IEncoding<TIn,TFormat,TOut>} options
     */
    constructor (options) {
      /** @type {(data: TIn) => TFormat} */
      this.encode = options.encode || this.encode;

      /** @type {(data: TFormat) => TOut} */
      this.decode = options.decode || this.decode;

      /** @type {string} */
      this.name = options.name || this.name;

      /** @type {string} */
      this.format = options.format || this.format;

      if (typeof this.encode !== 'function') {
        throw new TypeError("The 'encode' property must be a function")
      }

      if (typeof this.decode !== 'function') {
        throw new TypeError("The 'decode' property must be a function")
      }

      this.encode = this.encode.bind(this);
      this.decode = this.decode.bind(this);

      if (typeof this.name !== 'string' || this.name === '') {
        throw new TypeError("The 'name' property must be a string")
      }

      if (typeof this.format !== 'string' || !formats$1.has(this.format)) {
        throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'")
      }

      if (options.createViewTranscoder) {
        this.createViewTranscoder = options.createViewTranscoder;
      }

      if (options.createBufferTranscoder) {
        this.createBufferTranscoder = options.createBufferTranscoder;
      }

      if (options.createUTF8Transcoder) {
        this.createUTF8Transcoder = options.createUTF8Transcoder;
      }
    }

    get commonName () {
      return /** @type {string} */ (this.name.split('+')[0])
    }

    /** @return {BufferFormat<TIn,TOut>} */
    createBufferTranscoder () {
      throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
      })
    }

    /** @return {ViewFormat<TIn,TOut>} */
    createViewTranscoder () {
      throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
      })
    }

    /** @return {UTF8Format<TIn,TOut>} */
    createUTF8Transcoder () {
      throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
        code: 'LEVEL_ENCODING_NOT_SUPPORTED'
      })
    }
  }

  encoding.Encoding = Encoding$2;

  const { Buffer: Buffer$7 } = buffer || {};
  const { Encoding: Encoding$1 } = encoding;
  const textEndec = textEndec$1;

  /**
   * @template TIn, TOut
   * @extends {Encoding<TIn,Buffer,TOut>}
   */
  class BufferFormat$2 extends Encoding$1 {
    /**
     * @param {Omit<IEncoding<TIn, Buffer, TOut>, 'format'>} options
     */
    constructor (options) {
      super({ ...options, format: 'buffer' });
    }

    /** @override */
    createViewTranscoder () {
      return new ViewFormat$2({
        encode: this.encode, // Buffer is a view (UInt8Array)
        decode: (data) => this.decode(
          Buffer$7.from(data.buffer, data.byteOffset, data.byteLength)
        ),
        name: `${this.name}+view`
      })
    }

    /** @override */
    createBufferTranscoder () {
      return this
    }
  }

  /**
   * @extends {Encoding<TIn,Uint8Array,TOut>}
   * @template TIn, TOut
   */
  class ViewFormat$2 extends Encoding$1 {
    /**
     * @param {Omit<IEncoding<TIn, Uint8Array, TOut>, 'format'>} options
     */
    constructor (options) {
      super({ ...options, format: 'view' });
    }

    /** @override */
    createBufferTranscoder () {
      return new BufferFormat$2({
        encode: (data) => {
          const view = this.encode(data);
          return Buffer$7.from(view.buffer, view.byteOffset, view.byteLength)
        },
        decode: this.decode, // Buffer is a view (UInt8Array)
        name: `${this.name}+buffer`
      })
    }

    /** @override */
    createViewTranscoder () {
      return this
    }
  }

  /**
   * @extends {Encoding<TIn,string,TOut>}
   * @template TIn, TOut
   */
  class UTF8Format$2 extends Encoding$1 {
    /**
     * @param {Omit<IEncoding<TIn, string, TOut>, 'format'>} options
     */
    constructor (options) {
      super({ ...options, format: 'utf8' });
    }

    /** @override */
    createBufferTranscoder () {
      return new BufferFormat$2({
        encode: (data) => Buffer$7.from(this.encode(data), 'utf8'),
        decode: (data) => this.decode(data.toString('utf8')),
        name: `${this.name}+buffer`
      })
    }

    /** @override */
    createViewTranscoder () {
      const { textEncoder, textDecoder } = textEndec();

      return new ViewFormat$2({
        encode: (data) => textEncoder.encode(this.encode(data)),
        decode: (data) => this.decode(textDecoder.decode(data)),
        name: `${this.name}+view`
      })
    }

    /** @override */
    createUTF8Transcoder () {
      return this
    }
  }

  formats$2.BufferFormat = BufferFormat$2;
  formats$2.ViewFormat = ViewFormat$2;
  formats$2.UTF8Format = UTF8Format$2;

  const { Buffer: Buffer$6 } = buffer || { Buffer: { isBuffer: () => false } };
  const { textEncoder: textEncoder$1, textDecoder } = textEndec$1();
  const { BufferFormat: BufferFormat$1, ViewFormat: ViewFormat$1, UTF8Format: UTF8Format$1 } = formats$2;

  /** @type {<T>(v: T) => v} */
  const identity = (v) => v;

  /**
   * @type {typeof import('./encodings').utf8}
   */
  encodings$1.utf8 = new UTF8Format$1({
    encode: function (data) {
      // On node 16.9.1 buffer.toString() is 5x faster than TextDecoder
      return Buffer$6.isBuffer(data)
        ? data.toString('utf8')
        : ArrayBuffer.isView(data)
          ? textDecoder.decode(data)
          : String(data)
    },
    decode: identity,
    name: 'utf8',
    createViewTranscoder () {
      return new ViewFormat$1({
        encode: function (data) {
          return ArrayBuffer.isView(data) ? data : textEncoder$1.encode(data)
        },
        decode: function (data) {
          return textDecoder.decode(data)
        },
        name: `${this.name}+view`
      })
    },
    createBufferTranscoder () {
      return new BufferFormat$1({
        encode: function (data) {
          return Buffer$6.isBuffer(data)
            ? data
            : ArrayBuffer.isView(data)
              ? Buffer$6.from(data.buffer, data.byteOffset, data.byteLength)
              : Buffer$6.from(String(data), 'utf8')
        },
        decode: function (data) {
          return data.toString('utf8')
        },
        name: `${this.name}+buffer`
      })
    }
  });

  /**
   * @type {typeof import('./encodings').json}
   */
  encodings$1.json = new UTF8Format$1({
    encode: JSON.stringify,
    decode: JSON.parse,
    name: 'json'
  });

  /**
   * @type {typeof import('./encodings').buffer}
   */
  encodings$1.buffer = new BufferFormat$1({
    encode: function (data) {
      return Buffer$6.isBuffer(data)
        ? data
        : ArrayBuffer.isView(data)
          ? Buffer$6.from(data.buffer, data.byteOffset, data.byteLength)
          : Buffer$6.from(String(data), 'utf8')
    },
    decode: identity,
    name: 'buffer',
    createViewTranscoder () {
      return new ViewFormat$1({
        encode: function (data) {
          return ArrayBuffer.isView(data) ? data : Buffer$6.from(String(data), 'utf8')
        },
        decode: function (data) {
          return Buffer$6.from(data.buffer, data.byteOffset, data.byteLength)
        },
        name: `${this.name}+view`
      })
    }
  });

  /**
   * @type {typeof import('./encodings').view}
   */
  encodings$1.view = new ViewFormat$1({
    encode: function (data) {
      return ArrayBuffer.isView(data) ? data : textEncoder$1.encode(data)
    },
    decode: identity,
    name: 'view',
    createBufferTranscoder () {
      return new BufferFormat$1({
        encode: function (data) {
          return Buffer$6.isBuffer(data)
            ? data
            : ArrayBuffer.isView(data)
              ? Buffer$6.from(data.buffer, data.byteOffset, data.byteLength)
              : Buffer$6.from(String(data), 'utf8')
        },
        decode: identity,
        name: `${this.name}+buffer`
      })
    }
  });

  /**
   * @type {typeof import('./encodings').hex}
   */
  encodings$1.hex = new BufferFormat$1({
    encode: function (data) {
      return Buffer$6.isBuffer(data) ? data : Buffer$6.from(String(data), 'hex')
    },
    decode: function (buffer) {
      return buffer.toString('hex')
    },
    name: 'hex'
  });

  /**
   * @type {typeof import('./encodings').base64}
   */
  encodings$1.base64 = new BufferFormat$1({
    encode: function (data) {
      return Buffer$6.isBuffer(data) ? data : Buffer$6.from(String(data), 'base64')
    },
    decode: function (buffer) {
      return buffer.toString('base64')
    },
    name: 'base64'
  });

  const ModuleError$8 = moduleError;
  const encodings = encodings$1;
  const { Encoding } = encoding;
  const { BufferFormat, ViewFormat, UTF8Format } = formats$2;

  const kFormats = Symbol('formats');
  const kEncodings = Symbol('encodings');
  const validFormats = new Set(['buffer', 'view', 'utf8']);

  /** @template T */
  class Transcoder$1 {
    /**
     * @param {Array<'buffer'|'view'|'utf8'>} formats
     */
    constructor (formats) {
      if (!Array.isArray(formats)) {
        throw new TypeError("The first argument 'formats' must be an array")
      } else if (!formats.every(f => validFormats.has(f))) {
        // Note: we only only support aliases in key- and valueEncoding options (where we already did)
        throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'")
      }

      /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */
      this[kEncodings] = new Map();
      this[kFormats] = new Set(formats);

      // Register encodings (done early in order to populate encodings())
      for (const k in encodings) {
        try {
          this.encoding(k);
        } catch (err) {
          /* istanbul ignore if: assertion */
          if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err
        }
      }
    }

    /**
     * @returns {Array<Encoding<any,T,any>>}
     */
    encodings () {
      return Array.from(new Set(this[kEncodings].values()))
    }

    /**
     * @param {string|MixedEncoding<any, any, any>} encoding
     * @returns {Encoding<any, T, any>}
     */
    encoding (encoding) {
      let resolved = this[kEncodings].get(encoding);

      if (resolved === undefined) {
        if (typeof encoding === 'string' && encoding !== '') {
          resolved = lookup[encoding];

          if (!resolved) {
            throw new ModuleError$8(`Encoding '${encoding}' is not found`, {
              code: 'LEVEL_ENCODING_NOT_FOUND'
            })
          }
        } else if (typeof encoding !== 'object' || encoding === null) {
          throw new TypeError("First argument 'encoding' must be a string or object")
        } else {
          resolved = from$2(encoding);
        }

        const { name, format } = resolved;

        if (!this[kFormats].has(format)) {
          if (this[kFormats].has('view')) {
            resolved = resolved.createViewTranscoder();
          } else if (this[kFormats].has('buffer')) {
            resolved = resolved.createBufferTranscoder();
          } else if (this[kFormats].has('utf8')) {
            resolved = resolved.createUTF8Transcoder();
          } else {
            throw new ModuleError$8(`Encoding '${name}' cannot be transcoded`, {
              code: 'LEVEL_ENCODING_NOT_SUPPORTED'
            })
          }
        }

        for (const k of [encoding, name, resolved.name, resolved.commonName]) {
          this[kEncodings].set(k, resolved);
        }
      }

      return resolved
    }
  }

  levelTranscoder.Transcoder = Transcoder$1;

  /**
   * @param {MixedEncoding<any, any, any>} options
   * @returns {Encoding<any, any, any>}
   */
  function from$2 (options) {
    if (options instanceof Encoding) {
      return options
    }

    // Loosely typed for ecosystem compatibility
    const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined;
    const name = options.name || maybeType || `anonymous-${anonymousCount++}`;

    switch (detectFormat(options)) {
      case 'view': return new ViewFormat({ ...options, name })
      case 'utf8': return new UTF8Format({ ...options, name })
      case 'buffer': return new BufferFormat({ ...options, name })
      default: {
        throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'")
      }
    }
  }

  /**
   * If format is not provided, fallback to detecting `level-codec`
   * or `multiformats` encodings, else assume a format of buffer.
   * @param {MixedEncoding<any, any, any>} options
   * @returns {string}
   */
  function detectFormat (options) {
    if ('format' in options && options.format !== undefined) {
      return options.format
    } else if ('buffer' in options && typeof options.buffer === 'boolean') {
      return options.buffer ? 'buffer' : 'utf8' // level-codec
    } else if ('code' in options && Number.isInteger(options.code)) {
      return 'view' // multiformats
    } else {
      return 'buffer'
    }
  }

  /**
   * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding
   * @template TIn, TFormat, TOut
   */

  /**
   * @type {Object.<string, Encoding<any, any, any>>}
   */
  const aliases = {
    binary: encodings.buffer,
    'utf-8': encodings.utf8
  };

  /**
   * @type {Object.<string, Encoding<any, any, any>>}
   */
  const lookup = {
    ...encodings,
    ...aliases
  };

  let anonymousCount = 0;

  var catering = {};

  var nextTick$2 = browser$1$1.nextTick.bind(browser$1$1);

  var nextTick$1 = nextTick$2;

  catering.fromCallback = function (callback, symbol) {
    if (callback === undefined) {
      var promise = new Promise(function (resolve, reject) {
        callback = function (err, res) {
          if (err) reject(err);
          else resolve(res);
        };
      });

      callback[symbol !== undefined ? symbol : 'promise'] = promise;
    } else if (typeof callback !== 'function') {
      throw new TypeError('Callback must be a function')
    }

    return callback
  };

  catering.fromPromise = function (promise, callback) {
    if (callback === undefined) return promise

    promise
      .then(function (res) { nextTick$1(() => callback(null, res)); })
      .catch(function (err) { nextTick$1(() => callback(err)); });
  };

  var abstractIterator = {};

  var common = {};

  common.getCallback = function (options, callback) {
    return typeof options === 'function' ? options : callback
  };

  common.getOptions = function (options, def) {
    if (typeof options === 'object' && options !== null) {
      return options
    }

    if (def !== undefined) {
      return def
    }

    return {}
  };

  const { fromCallback: fromCallback$2 } = catering;
  const ModuleError$7 = moduleError;
  const { getOptions: getOptions$2, getCallback: getCallback$2 } = common;

  const kPromise$2 = Symbol('promise');
  const kCallback$2 = Symbol('callback');
  const kWorking = Symbol('working');
  const kHandleOne$2 = Symbol('handleOne');
  const kHandleMany$2 = Symbol('handleMany');
  const kAutoClose = Symbol('autoClose');
  const kFinishWork = Symbol('finishWork');
  const kReturnMany = Symbol('returnMany');
  const kClosing = Symbol('closing');
  const kHandleClose = Symbol('handleClose');
  const kClosed = Symbol('closed');
  const kCloseCallbacks$1 = Symbol('closeCallbacks');
  const kKeyEncoding$1 = Symbol('keyEncoding');
  const kValueEncoding$1 = Symbol('valueEncoding');
  const kAbortOnClose = Symbol('abortOnClose');
  const kLegacy = Symbol('legacy');
  const kKeys = Symbol('keys');
  const kValues = Symbol('values');
  const kLimit = Symbol('limit');
  const kCount = Symbol('count');

  const emptyOptions = Object.freeze({});
  const noop$3 = () => {};
  let warnedEnd = false;

  // This class is an internal utility for common functionality between AbstractIterator,
  // AbstractKeyIterator and AbstractValueIterator. It's not exported.
  class CommonIterator {
    constructor (db, options, legacy) {
      if (typeof db !== 'object' || db === null) {
        const hint = db === null ? 'null' : typeof db;
        throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`)
      }

      if (typeof options !== 'object' || options === null) {
        throw new TypeError('The second argument must be an options object')
      }

      this[kClosed] = false;
      this[kCloseCallbacks$1] = [];
      this[kWorking] = false;
      this[kClosing] = false;
      this[kAutoClose] = false;
      this[kCallback$2] = null;
      this[kHandleOne$2] = this[kHandleOne$2].bind(this);
      this[kHandleMany$2] = this[kHandleMany$2].bind(this);
      this[kHandleClose] = this[kHandleClose].bind(this);
      this[kKeyEncoding$1] = options[kKeyEncoding$1];
      this[kValueEncoding$1] = options[kValueEncoding$1];
      this[kLegacy] = legacy;
      this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
      this[kCount] = 0;

      // Undocumented option to abort pending work on close(). Used by the
      // many-level module as a temporary solution to a blocked close().
      // TODO (next major): consider making this the default behavior. Native
      // implementations should have their own logic to safely close iterators.
      this[kAbortOnClose] = !!options.abortOnClose;

      this.db = db;
      this.db.attachResource(this);
      this.nextTick = db.nextTick;
    }

    get count () {
      return this[kCount]
    }

    get limit () {
      return this[kLimit]
    }

    next (callback) {
      let promise;

      if (callback === undefined) {
        promise = new Promise((resolve, reject) => {
          callback = (err, key, value) => {
            if (err) reject(err);
            else if (!this[kLegacy]) resolve(key);
            else if (key === undefined && value === undefined) resolve();
            else resolve([key, value]);
          };
        });
      } else if (typeof callback !== 'function') {
        throw new TypeError('Callback must be a function')
      }

      if (this[kClosing]) {
        this.nextTick(callback, new ModuleError$7('Iterator is not open: cannot call next() after close()', {
          code: 'LEVEL_ITERATOR_NOT_OPEN'
        }));
      } else if (this[kWorking]) {
        this.nextTick(callback, new ModuleError$7('Iterator is busy: cannot call next() until previous call has completed', {
          code: 'LEVEL_ITERATOR_BUSY'
        }));
      } else {
        this[kWorking] = true;
        this[kCallback$2] = callback;

        if (this[kCount] >= this[kLimit]) this.nextTick(this[kHandleOne$2], null);
        else this._next(this[kHandleOne$2]);
      }

      return promise
    }

    _next (callback) {
      this.nextTick(callback);
    }

    nextv (size, options, callback) {
      callback = getCallback$2(options, callback);
      callback = fromCallback$2(callback, kPromise$2);
      options = getOptions$2(options, emptyOptions);

      if (!Number.isInteger(size)) {
        this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
        return callback[kPromise$2]
      }

      if (this[kClosing]) {
        this.nextTick(callback, new ModuleError$7('Iterator is not open: cannot call nextv() after close()', {
          code: 'LEVEL_ITERATOR_NOT_OPEN'
        }));
      } else if (this[kWorking]) {
        this.nextTick(callback, new ModuleError$7('Iterator is busy: cannot call nextv() until previous call has completed', {
          code: 'LEVEL_ITERATOR_BUSY'
        }));
      } else {
        if (size < 1) size = 1;
        if (this[kLimit] < Infinity) size = Math.min(size, this[kLimit] - this[kCount]);

        this[kWorking] = true;
        this[kCallback$2] = callback;

        if (size <= 0) this.nextTick(this[kHandleMany$2], null, []);
        else this._nextv(size, options, this[kHandleMany$2]);
      }

      return callback[kPromise$2]
    }

    _nextv (size, options, callback) {
      const acc = [];
      const onnext = (err, key, value) => {
        if (err) {
          return callback(err)
        } else if (this[kLegacy] ? key === undefined && value === undefined : key === undefined) {
          return callback(null, acc)
        }

        acc.push(this[kLegacy] ? [key, value] : key);

        if (acc.length === size) {
          callback(null, acc);
        } else {
          this._next(onnext);
        }
      };

      this._next(onnext);
    }

    all (options, callback) {
      callback = getCallback$2(options, callback);
      callback = fromCallback$2(callback, kPromise$2);
      options = getOptions$2(options, emptyOptions);

      if (this[kClosing]) {
        this.nextTick(callback, new ModuleError$7('Iterator is not open: cannot call all() after close()', {
          code: 'LEVEL_ITERATOR_NOT_OPEN'
        }));
      } else if (this[kWorking]) {
        this.nextTick(callback, new ModuleError$7('Iterator is busy: cannot call all() until previous call has completed', {
          code: 'LEVEL_ITERATOR_BUSY'
        }));
      } else {
        this[kWorking] = true;
        this[kCallback$2] = callback;
        this[kAutoClose] = true;

        if (this[kCount] >= this[kLimit]) this.nextTick(this[kHandleMany$2], null, []);
        else this._all(options, this[kHandleMany$2]);
      }

      return callback[kPromise$2]
    }

    _all (options, callback) {
      // Must count here because we're directly calling _nextv()
      let count = this[kCount];
      const acc = [];

      const nextv = () => {
        // Not configurable, because implementations should optimize _all().
        const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;

        if (size <= 0) {
          this.nextTick(callback, null, acc);
        } else {
          this._nextv(size, emptyOptions, onnextv);
        }
      };

      const onnextv = (err, items) => {
        if (err) {
          callback(err);
        } else if (items.length === 0) {
          callback(null, acc);
        } else {
          acc.push.apply(acc, items);
          count += items.length;
          nextv();
        }
      };

      nextv();
    }

    [kFinishWork] () {
      const cb = this[kCallback$2];

      // Callback will be null if work was aborted on close
      if (this[kAbortOnClose] && cb === null) return noop$3

      this[kWorking] = false;
      this[kCallback$2] = null;

      if (this[kClosing]) this._close(this[kHandleClose]);

      return cb
    }

    [kReturnMany] (cb, err, items) {
      if (this[kAutoClose]) {
        this.close(cb.bind(null, err, items));
      } else {
        cb(err, items);
      }
    }

    seek (target, options) {
      options = getOptions$2(options, emptyOptions);

      if (this[kClosing]) ; else if (this[kWorking]) {
        throw new ModuleError$7('Iterator is busy: cannot call seek() until next() has completed', {
          code: 'LEVEL_ITERATOR_BUSY'
        })
      } else {
        const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding$1]);
        const keyFormat = keyEncoding.format;

        if (options.keyEncoding !== keyFormat) {
          options = { ...options, keyEncoding: keyFormat };
        }

        const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
        this._seek(mapped, options);
      }
    }

    _seek (target, options) {
      throw new ModuleError$7('Iterator does not support seek()', {
        code: 'LEVEL_NOT_SUPPORTED'
      })
    }

    close (callback) {
      callback = fromCallback$2(callback, kPromise$2);

      if (this[kClosed]) {
        this.nextTick(callback);
      } else if (this[kClosing]) {
        this[kCloseCallbacks$1].push(callback);
      } else {
        this[kClosing] = true;
        this[kCloseCallbacks$1].push(callback);

        if (!this[kWorking]) {
          this._close(this[kHandleClose]);
        } else if (this[kAbortOnClose]) {
          // Don't wait for work to finish. Subsequently ignore the result.
          const cb = this[kFinishWork]();

          cb(new ModuleError$7('Aborted on iterator close()', {
            code: 'LEVEL_ITERATOR_NOT_OPEN'
          }));
        }
      }

      return callback[kPromise$2]
    }

    _close (callback) {
      this.nextTick(callback);
    }

    [kHandleClose] () {
      this[kClosed] = true;
      this.db.detachResource(this);

      const callbacks = this[kCloseCallbacks$1];
      this[kCloseCallbacks$1] = [];

      for (const cb of callbacks) {
        cb();
      }
    }

    async * [Symbol.asyncIterator] () {
      try {
        let item;

        while ((item = (await this.next())) !== undefined) {
          yield item;
        }
      } finally {
        if (!this[kClosed]) await this.close();
      }
    }
  }

  // For backwards compatibility this class is not (yet) called AbstractEntryIterator.
  class AbstractIterator$4 extends CommonIterator {
    constructor (db, options) {
      super(db, options, true);
      this[kKeys] = options.keys !== false;
      this[kValues] = options.values !== false;
    }

    [kHandleOne$2] (err, key, value) {
      const cb = this[kFinishWork]();
      if (err) return cb(err)

      try {
        key = this[kKeys] && key !== undefined ? this[kKeyEncoding$1].decode(key) : undefined;
        value = this[kValues] && value !== undefined ? this[kValueEncoding$1].decode(value) : undefined;
      } catch (err) {
        return cb(new IteratorDecodeError('entry', err))
      }

      if (!(key === undefined && value === undefined)) {
        this[kCount]++;
      }

      cb(null, key, value);
    }

    [kHandleMany$2] (err, entries) {
      const cb = this[kFinishWork]();
      if (err) return this[kReturnMany](cb, err)

      try {
        for (const entry of entries) {
          const key = entry[0];
          const value = entry[1];

          entry[0] = this[kKeys] && key !== undefined ? this[kKeyEncoding$1].decode(key) : undefined;
          entry[1] = this[kValues] && value !== undefined ? this[kValueEncoding$1].decode(value) : undefined;
        }
      } catch (err) {
        return this[kReturnMany](cb, new IteratorDecodeError('entries', err))
      }

      this[kCount] += entries.length;
      this[kReturnMany](cb, null, entries);
    }

    end (callback) {
      if (!warnedEnd && typeof console !== 'undefined') {
        warnedEnd = true;
        console.warn(new ModuleError$7(
          'The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version',
          { code: 'LEVEL_LEGACY' }
        ));
      }

      return this.close(callback)
    }
  }

  class AbstractKeyIterator$4 extends CommonIterator {
    constructor (db, options) {
      super(db, options, false);
    }

    [kHandleOne$2] (err, key) {
      const cb = this[kFinishWork]();
      if (err) return cb(err)

      try {
        key = key !== undefined ? this[kKeyEncoding$1].decode(key) : undefined;
      } catch (err) {
        return cb(new IteratorDecodeError('key', err))
      }

      if (key !== undefined) this[kCount]++;
      cb(null, key);
    }

    [kHandleMany$2] (err, keys) {
      const cb = this[kFinishWork]();
      if (err) return this[kReturnMany](cb, err)

      try {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          keys[i] = key !== undefined ? this[kKeyEncoding$1].decode(key) : undefined;
        }
      } catch (err) {
        return this[kReturnMany](cb, new IteratorDecodeError('keys', err))
      }

      this[kCount] += keys.length;
      this[kReturnMany](cb, null, keys);
    }
  }

  class AbstractValueIterator$4 extends CommonIterator {
    constructor (db, options) {
      super(db, options, false);
    }

    [kHandleOne$2] (err, value) {
      const cb = this[kFinishWork]();
      if (err) return cb(err)

      try {
        value = value !== undefined ? this[kValueEncoding$1].decode(value) : undefined;
      } catch (err) {
        return cb(new IteratorDecodeError('value', err))
      }

      if (value !== undefined) this[kCount]++;
      cb(null, value);
    }

    [kHandleMany$2] (err, values) {
      const cb = this[kFinishWork]();
      if (err) return this[kReturnMany](cb, err)

      try {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          values[i] = value !== undefined ? this[kValueEncoding$1].decode(value) : undefined;
        }
      } catch (err) {
        return this[kReturnMany](cb, new IteratorDecodeError('values', err))
      }

      this[kCount] += values.length;
      this[kReturnMany](cb, null, values);
    }
  }

  // Internal utility, not typed or exported
  class IteratorDecodeError extends ModuleError$7 {
    constructor (subject, cause) {
      super(`Iterator could not decode ${subject}`, {
        code: 'LEVEL_DECODE_ERROR',
        cause
      });
    }
  }

  // To help migrating to abstract-level
  for (const k of ['_ended property', '_nexting property', '_end method']) {
    Object.defineProperty(AbstractIterator$4.prototype, k.split(' ')[0], {
      get () { throw new ModuleError$7(`The ${k} has been removed`, { code: 'LEVEL_LEGACY' }) },
      set () { throw new ModuleError$7(`The ${k} has been removed`, { code: 'LEVEL_LEGACY' }) }
    });
  }

  // Exposed so that AbstractLevel can set these options
  AbstractIterator$4.keyEncoding = kKeyEncoding$1;
  AbstractIterator$4.valueEncoding = kValueEncoding$1;

  abstractIterator.AbstractIterator = AbstractIterator$4;
  abstractIterator.AbstractKeyIterator = AbstractKeyIterator$4;
  abstractIterator.AbstractValueIterator = AbstractValueIterator$4;

  var defaultKvIterator = {};

  const { AbstractKeyIterator: AbstractKeyIterator$3, AbstractValueIterator: AbstractValueIterator$3 } = abstractIterator;

  const kIterator$2 = Symbol('iterator');
  const kCallback$1 = Symbol('callback');
  const kHandleOne$1 = Symbol('handleOne');
  const kHandleMany$1 = Symbol('handleMany');

  class DefaultKeyIterator$1 extends AbstractKeyIterator$3 {
    constructor (db, options) {
      super(db, options);

      this[kIterator$2] = db.iterator({ ...options, keys: true, values: false });
      this[kHandleOne$1] = this[kHandleOne$1].bind(this);
      this[kHandleMany$1] = this[kHandleMany$1].bind(this);
    }
  }

  class DefaultValueIterator$1 extends AbstractValueIterator$3 {
    constructor (db, options) {
      super(db, options);

      this[kIterator$2] = db.iterator({ ...options, keys: false, values: true });
      this[kHandleOne$1] = this[kHandleOne$1].bind(this);
      this[kHandleMany$1] = this[kHandleMany$1].bind(this);
    }
  }

  for (const Iterator of [DefaultKeyIterator$1, DefaultValueIterator$1]) {
    const keys = Iterator === DefaultKeyIterator$1;
    const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];

    Iterator.prototype._next = function (callback) {
      this[kCallback$1] = callback;
      this[kIterator$2].next(this[kHandleOne$1]);
    };

    Iterator.prototype[kHandleOne$1] = function (err, key, value) {
      const callback = this[kCallback$1];
      if (err) callback(err);
      else callback(null, keys ? key : value);
    };

    Iterator.prototype._nextv = function (size, options, callback) {
      this[kCallback$1] = callback;
      this[kIterator$2].nextv(size, options, this[kHandleMany$1]);
    };

    Iterator.prototype._all = function (options, callback) {
      this[kCallback$1] = callback;
      this[kIterator$2].all(options, this[kHandleMany$1]);
    };

    Iterator.prototype[kHandleMany$1] = function (err, entries) {
      const callback = this[kCallback$1];
      if (err) callback(err);
      else callback(null, entries.map(mapEntry));
    };

    Iterator.prototype._seek = function (target, options) {
      this[kIterator$2].seek(target, options);
    };

    Iterator.prototype._close = function (callback) {
      this[kIterator$2].close(callback);
    };
  }

  // Internal utilities, should be typed as AbstractKeyIterator and AbstractValueIterator
  defaultKvIterator.DefaultKeyIterator = DefaultKeyIterator$1;
  defaultKvIterator.DefaultValueIterator = DefaultValueIterator$1;

  var deferredIterator = {};

  const { AbstractIterator: AbstractIterator$3, AbstractKeyIterator: AbstractKeyIterator$2, AbstractValueIterator: AbstractValueIterator$2 } = abstractIterator;
  const ModuleError$6 = moduleError;

  const kNut = Symbol('nut');
  const kUndefer$1 = Symbol('undefer');
  const kFactory = Symbol('factory');

  class DeferredIterator$1 extends AbstractIterator$3 {
    constructor (db, options) {
      super(db, options);

      this[kNut] = null;
      this[kFactory] = () => db.iterator(options);

      this.db.defer(() => this[kUndefer$1]());
    }
  }

  class DeferredKeyIterator$1 extends AbstractKeyIterator$2 {
    constructor (db, options) {
      super(db, options);

      this[kNut] = null;
      this[kFactory] = () => db.keys(options);

      this.db.defer(() => this[kUndefer$1]());
    }
  }

  class DeferredValueIterator$1 extends AbstractValueIterator$2 {
    constructor (db, options) {
      super(db, options);

      this[kNut] = null;
      this[kFactory] = () => db.values(options);

      this.db.defer(() => this[kUndefer$1]());
    }
  }

  for (const Iterator of [DeferredIterator$1, DeferredKeyIterator$1, DeferredValueIterator$1]) {
    Iterator.prototype[kUndefer$1] = function () {
      if (this.db.status === 'open') {
        this[kNut] = this[kFactory]();
      }
    };

    Iterator.prototype._next = function (callback) {
      if (this[kNut] !== null) {
        this[kNut].next(callback);
      } else if (this.db.status === 'opening') {
        this.db.defer(() => this._next(callback));
      } else {
        this.nextTick(callback, new ModuleError$6('Iterator is not open: cannot call next() after close()', {
          code: 'LEVEL_ITERATOR_NOT_OPEN'
        }));
      }
    };

    Iterator.prototype._nextv = function (size, options, callback) {
      if (this[kNut] !== null) {
        this[kNut].nextv(size, options, callback);
      } else if (this.db.status === 'opening') {
        this.db.defer(() => this._nextv(size, options, callback));
      } else {
        this.nextTick(callback, new ModuleError$6('Iterator is not open: cannot call nextv() after close()', {
          code: 'LEVEL_ITERATOR_NOT_OPEN'
        }));
      }
    };

    Iterator.prototype._all = function (options, callback) {
      if (this[kNut] !== null) {
        this[kNut].all(callback);
      } else if (this.db.status === 'opening') {
        this.db.defer(() => this._all(options, callback));
      } else {
        this.nextTick(callback, new ModuleError$6('Iterator is not open: cannot call all() after close()', {
          code: 'LEVEL_ITERATOR_NOT_OPEN'
        }));
      }
    };

    Iterator.prototype._seek = function (target, options) {
      if (this[kNut] !== null) {
        // TODO: explain why we need _seek() rather than seek() here
        this[kNut]._seek(target, options);
      } else if (this.db.status === 'opening') {
        this.db.defer(() => this._seek(target, options));
      }
    };

    Iterator.prototype._close = function (callback) {
      if (this[kNut] !== null) {
        this[kNut].close(callback);
      } else if (this.db.status === 'opening') {
        this.db.defer(() => this._close(callback));
      } else {
        this.nextTick(callback);
      }
    };
  }

  deferredIterator.DeferredIterator = DeferredIterator$1;
  deferredIterator.DeferredKeyIterator = DeferredKeyIterator$1;
  deferredIterator.DeferredValueIterator = DeferredValueIterator$1;

  var defaultChainedBatch = {};

  var abstractChainedBatch = {};

  const { fromCallback: fromCallback$1 } = catering;
  const ModuleError$5 = moduleError;
  const { getCallback: getCallback$1, getOptions: getOptions$1 } = common;

  const kPromise$1 = Symbol('promise');
  const kStatus$1 = Symbol('status');
  const kOperations$1 = Symbol('operations');
  const kFinishClose = Symbol('finishClose');
  const kCloseCallbacks = Symbol('closeCallbacks');

  class AbstractChainedBatch$1 {
    constructor (db) {
      if (typeof db !== 'object' || db === null) {
        const hint = db === null ? 'null' : typeof db;
        throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`)
      }

      this[kOperations$1] = [];
      this[kCloseCallbacks] = [];
      this[kStatus$1] = 'open';
      this[kFinishClose] = this[kFinishClose].bind(this);

      this.db = db;
      this.db.attachResource(this);
      this.nextTick = db.nextTick;
    }

    get length () {
      return this[kOperations$1].length
    }

    put (key, value, options) {
      if (this[kStatus$1] !== 'open') {
        throw new ModuleError$5('Batch is not open: cannot call put() after write() or close()', {
          code: 'LEVEL_BATCH_NOT_OPEN'
        })
      }

      const err = this.db._checkKey(key) || this.db._checkValue(value);
      if (err) throw err

      const db = options && options.sublevel != null ? options.sublevel : this.db;
      const original = options;
      const keyEncoding = db.keyEncoding(options && options.keyEncoding);
      const valueEncoding = db.valueEncoding(options && options.valueEncoding);
      const keyFormat = keyEncoding.format;

      // Forward encoding options
      options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };

      // Prevent double prefixing
      if (db !== this.db) {
        options.sublevel = null;
      }

      const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
      const mappedValue = valueEncoding.encode(value);

      this._put(mappedKey, mappedValue, options);
      this[kOperations$1].push({ ...original, type: 'put', key, value });

      return this
    }

    _put (key, value, options) {}

    del (key, options) {
      if (this[kStatus$1] !== 'open') {
        throw new ModuleError$5('Batch is not open: cannot call del() after write() or close()', {
          code: 'LEVEL_BATCH_NOT_OPEN'
        })
      }

      const err = this.db._checkKey(key);
      if (err) throw err

      const db = options && options.sublevel != null ? options.sublevel : this.db;
      const original = options;
      const keyEncoding = db.keyEncoding(options && options.keyEncoding);
      const keyFormat = keyEncoding.format;

      // Forward encoding options
      options = { ...options, keyEncoding: keyFormat };

      // Prevent double prefixing
      if (db !== this.db) {
        options.sublevel = null;
      }

      this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
      this[kOperations$1].push({ ...original, type: 'del', key });

      return this
    }

    _del (key, options) {}

    clear () {
      if (this[kStatus$1] !== 'open') {
        throw new ModuleError$5('Batch is not open: cannot call clear() after write() or close()', {
          code: 'LEVEL_BATCH_NOT_OPEN'
        })
      }

      this._clear();
      this[kOperations$1] = [];

      return this
    }

    _clear () {}

    write (options, callback) {
      callback = getCallback$1(options, callback);
      callback = fromCallback$1(callback, kPromise$1);
      options = getOptions$1(options);

      if (this[kStatus$1] !== 'open') {
        this.nextTick(callback, new ModuleError$5('Batch is not open: cannot call write() after write() or close()', {
          code: 'LEVEL_BATCH_NOT_OPEN'
        }));
      } else if (this.length === 0) {
        this.close(callback);
      } else {
        this[kStatus$1] = 'writing';
        this._write(options, (err) => {
          this[kStatus$1] = 'closing';
          this[kCloseCallbacks].push(() => callback(err));

          // Emit after setting 'closing' status, because event may trigger a
          // db close which in turn triggers (idempotently) closing this batch.
          if (!err) this.db.emit('batch', this[kOperations$1]);

          this._close(this[kFinishClose]);
        });
      }

      return callback[kPromise$1]
    }

    _write (options, callback) {}

    close (callback) {
      callback = fromCallback$1(callback, kPromise$1);

      if (this[kStatus$1] === 'closing') {
        this[kCloseCallbacks].push(callback);
      } else if (this[kStatus$1] === 'closed') {
        this.nextTick(callback);
      } else {
        this[kCloseCallbacks].push(callback);

        if (this[kStatus$1] !== 'writing') {
          this[kStatus$1] = 'closing';
          this._close(this[kFinishClose]);
        }
      }

      return callback[kPromise$1]
    }

    _close (callback) {
      this.nextTick(callback);
    }

    [kFinishClose] () {
      this[kStatus$1] = 'closed';
      this.db.detachResource(this);

      const callbacks = this[kCloseCallbacks];
      this[kCloseCallbacks] = [];

      for (const cb of callbacks) {
        cb();
      }
    }
  }

  abstractChainedBatch.AbstractChainedBatch = AbstractChainedBatch$1;

  const { AbstractChainedBatch } = abstractChainedBatch;
  const ModuleError$4 = moduleError;
  const kEncoded = Symbol('encoded');

  // Functional default for chained batch, with support of deferred open
  class DefaultChainedBatch$1 extends AbstractChainedBatch {
    constructor (db) {
      super(db);
      this[kEncoded] = [];
    }

    _put (key, value, options) {
      this[kEncoded].push({ ...options, type: 'put', key, value });
    }

    _del (key, options) {
      this[kEncoded].push({ ...options, type: 'del', key });
    }

    _clear () {
      this[kEncoded] = [];
    }

    // Assumes this[kEncoded] cannot change after write()
    _write (options, callback) {
      if (this.db.status === 'opening') {
        this.db.defer(() => this._write(options, callback));
      } else if (this.db.status === 'open') {
        if (this[kEncoded].length === 0) this.nextTick(callback);
        else this.db._batch(this[kEncoded], options, callback);
      } else {
        this.nextTick(callback, new ModuleError$4('Batch is not open: cannot call write() after write() or close()', {
          code: 'LEVEL_BATCH_NOT_OPEN'
        }));
      }
    }
  }

  defaultChainedBatch.DefaultChainedBatch = DefaultChainedBatch$1;

  const ModuleError$3 = moduleError;
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const rangeOptions$2 = new Set(['lt', 'lte', 'gt', 'gte']);

  var rangeOptions_1 = function (options, keyEncoding) {
    const result = {};

    for (const k in options) {
      if (!hasOwnProperty.call(options, k)) continue
      if (k === 'keyEncoding' || k === 'valueEncoding') continue

      if (k === 'start' || k === 'end') {
        throw new ModuleError$3(`The legacy range option '${k}' has been removed`, {
          code: 'LEVEL_LEGACY'
        })
      } else if (k === 'encoding') {
        // To help migrating to abstract-level
        throw new ModuleError$3("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
          code: 'LEVEL_LEGACY'
        })
      }

      if (rangeOptions$2.has(k)) {
        // Note that we don't reject nullish and empty options here. While
        // those types are invalid as keys, they are valid as range options.
        result[k] = keyEncoding.encode(options[k]);
      } else {
        result[k] = options[k];
      }
    }

    result.reverse = !!result.reverse;
    result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;

    return result
  };

  var nextTick = browser$1$1.nextTick;

  var abstractSublevelIterator = {};

  const { AbstractIterator: AbstractIterator$2, AbstractKeyIterator: AbstractKeyIterator$1, AbstractValueIterator: AbstractValueIterator$1 } = abstractIterator;

  const kUnfix$1 = Symbol('unfix');
  const kIterator$1 = Symbol('iterator');
  const kHandleOne = Symbol('handleOne');
  const kHandleMany = Symbol('handleMany');
  const kCallback = Symbol('callback');

  // TODO: unfix natively if db supports it
  class AbstractSublevelIterator$1 extends AbstractIterator$2 {
    constructor (db, options, iterator, unfix) {
      super(db, options);

      this[kIterator$1] = iterator;
      this[kUnfix$1] = unfix;
      this[kHandleOne] = this[kHandleOne].bind(this);
      this[kHandleMany] = this[kHandleMany].bind(this);
      this[kCallback] = null;
    }

    [kHandleOne] (err, key, value) {
      const callback = this[kCallback];
      if (err) return callback(err)
      if (key !== undefined) key = this[kUnfix$1](key);
      callback(err, key, value);
    }

    [kHandleMany] (err, entries) {
      const callback = this[kCallback];
      if (err) return callback(err)

      for (const entry of entries) {
        const key = entry[0];
        if (key !== undefined) entry[0] = this[kUnfix$1](key);
      }

      callback(err, entries);
    }
  }

  class AbstractSublevelKeyIterator$1 extends AbstractKeyIterator$1 {
    constructor (db, options, iterator, unfix) {
      super(db, options);

      this[kIterator$1] = iterator;
      this[kUnfix$1] = unfix;
      this[kHandleOne] = this[kHandleOne].bind(this);
      this[kHandleMany] = this[kHandleMany].bind(this);
      this[kCallback] = null;
    }

    [kHandleOne] (err, key) {
      const callback = this[kCallback];
      if (err) return callback(err)
      if (key !== undefined) key = this[kUnfix$1](key);
      callback(err, key);
    }

    [kHandleMany] (err, keys) {
      const callback = this[kCallback];
      if (err) return callback(err)

      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== undefined) keys[i] = this[kUnfix$1](key);
      }

      callback(err, keys);
    }
  }

  class AbstractSublevelValueIterator$1 extends AbstractValueIterator$1 {
    constructor (db, options, iterator) {
      super(db, options);
      this[kIterator$1] = iterator;
    }
  }

  for (const Iterator of [AbstractSublevelIterator$1, AbstractSublevelKeyIterator$1]) {
    Iterator.prototype._next = function (callback) {
      this[kCallback] = callback;
      this[kIterator$1].next(this[kHandleOne]);
    };

    Iterator.prototype._nextv = function (size, options, callback) {
      this[kCallback] = callback;
      this[kIterator$1].nextv(size, options, this[kHandleMany]);
    };

    Iterator.prototype._all = function (options, callback) {
      this[kCallback] = callback;
      this[kIterator$1].all(options, this[kHandleMany]);
    };
  }

  for (const Iterator of [AbstractSublevelValueIterator$1]) {
    Iterator.prototype._next = function (callback) {
      this[kIterator$1].next(callback);
    };

    Iterator.prototype._nextv = function (size, options, callback) {
      this[kIterator$1].nextv(size, options, callback);
    };

    Iterator.prototype._all = function (options, callback) {
      this[kIterator$1].all(options, callback);
    };
  }

  for (const Iterator of [AbstractSublevelIterator$1, AbstractSublevelKeyIterator$1, AbstractSublevelValueIterator$1]) {
    Iterator.prototype._seek = function (target, options) {
      this[kIterator$1].seek(target, options);
    };

    Iterator.prototype._close = function (callback) {
      this[kIterator$1].close(callback);
    };
  }

  abstractSublevelIterator.AbstractSublevelIterator = AbstractSublevelIterator$1;
  abstractSublevelIterator.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator$1;
  abstractSublevelIterator.AbstractSublevelValueIterator = AbstractSublevelValueIterator$1;

  const ModuleError$2 = moduleError;
  const { Buffer: Buffer$5 } = buffer || {};
  const {
    AbstractSublevelIterator,
    AbstractSublevelKeyIterator,
    AbstractSublevelValueIterator
  } = abstractSublevelIterator;

  const kPrefix = Symbol('prefix');
  const kUpperBound$1 = Symbol('upperBound');
  const kPrefixRange = Symbol('prefixRange');
  const kParent = Symbol('parent');
  const kUnfix = Symbol('unfix');

  const textEncoder = new TextEncoder();
  const defaults = { separator: '!' };

  // Wrapped to avoid circular dependency
  var abstractSublevel = function ({ AbstractLevel }) {
    class AbstractSublevel extends AbstractLevel {
      static defaults (options) {
        // To help migrating from subleveldown to abstract-level
        if (typeof options === 'string') {
          throw new ModuleError$2('The subleveldown string shorthand for { separator } has been removed', {
            code: 'LEVEL_LEGACY'
          })
        } else if (options && options.open) {
          throw new ModuleError$2('The subleveldown open option has been removed', {
            code: 'LEVEL_LEGACY'
          })
        }

        if (options == null) {
          return defaults
        } else if (!options.separator) {
          return { ...options, separator: '!' }
        } else {
          return options
        }
      }

      // TODO: add autoClose option, which if true, does parent.attachResource(this)
      constructor (db, name, options) {
        // Don't forward AbstractSublevel options to AbstractLevel
        const { separator, manifest, ...forward } = AbstractSublevel.defaults(options);
        name = trim$1(name, separator);

        // Reserve one character between separator and name to give us an upper bound
        const reserved = separator.charCodeAt(0) + 1;
        const parent = db[kParent] || db;

        // Keys should sort like ['!a!', '!a!!a!', '!a"', '!aa!', '!b!'].
        // Use ASCII for consistent length between string, Buffer and Uint8Array
        if (!textEncoder.encode(name).every(x => x > reserved && x < 127)) {
          throw new ModuleError$2(`Prefix must use bytes > ${reserved} < ${127}`, {
            code: 'LEVEL_INVALID_PREFIX'
          })
        }

        super(mergeManifests(parent, manifest), forward);

        const prefix = (db.prefix || '') + separator + name + separator;
        const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);

        this[kParent] = parent;
        this[kPrefix] = new MultiFormat(prefix);
        this[kUpperBound$1] = new MultiFormat(upperBound);
        this[kUnfix] = new Unfixer();

        this.nextTick = parent.nextTick;
      }

      prefixKey (key, keyFormat) {
        if (keyFormat === 'utf8') {
          return this[kPrefix].utf8 + key
        } else if (key.byteLength === 0) {
          // Fast path for empty key (no copy)
          return this[kPrefix][keyFormat]
        } else if (keyFormat === 'view') {
          const view = this[kPrefix].view;
          const result = new Uint8Array(view.byteLength + key.byteLength);

          result.set(view, 0);
          result.set(key, view.byteLength);

          return result
        } else {
          const buffer = this[kPrefix].buffer;
          return Buffer$5.concat([buffer, key], buffer.byteLength + key.byteLength)
        }
      }

      // Not exposed for now.
      [kPrefixRange] (range, keyFormat) {
        if (range.gte !== undefined) {
          range.gte = this.prefixKey(range.gte, keyFormat);
        } else if (range.gt !== undefined) {
          range.gt = this.prefixKey(range.gt, keyFormat);
        } else {
          range.gte = this[kPrefix][keyFormat];
        }

        if (range.lte !== undefined) {
          range.lte = this.prefixKey(range.lte, keyFormat);
        } else if (range.lt !== undefined) {
          range.lt = this.prefixKey(range.lt, keyFormat);
        } else {
          range.lte = this[kUpperBound$1][keyFormat];
        }
      }

      get prefix () {
        return this[kPrefix].utf8
      }

      get db () {
        return this[kParent]
      }

      _open (options, callback) {
        // The parent db must open itself or be (re)opened by the user because
        // a sublevel should not initiate state changes on the rest of the db.
        this[kParent].open({ passive: true }, callback);
      }

      _put (key, value, options, callback) {
        this[kParent].put(key, value, options, callback);
      }

      _get (key, options, callback) {
        this[kParent].get(key, options, callback);
      }

      _getMany (keys, options, callback) {
        this[kParent].getMany(keys, options, callback);
      }

      _del (key, options, callback) {
        this[kParent].del(key, options, callback);
      }

      _batch (operations, options, callback) {
        this[kParent].batch(operations, options, callback);
      }

      _clear (options, callback) {
        // TODO (refactor): move to AbstractLevel
        this[kPrefixRange](options, options.keyEncoding);
        this[kParent].clear(options, callback);
      }

      _iterator (options) {
        // TODO (refactor): move to AbstractLevel
        this[kPrefixRange](options, options.keyEncoding);
        const iterator = this[kParent].iterator(options);
        const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
        return new AbstractSublevelIterator(this, options, iterator, unfix)
      }

      _keys (options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator = this[kParent].keys(options);
        const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
        return new AbstractSublevelKeyIterator(this, options, iterator, unfix)
      }

      _values (options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator = this[kParent].values(options);
        return new AbstractSublevelValueIterator(this, options, iterator)
      }
    }

    return { AbstractSublevel }
  };

  const mergeManifests = function (parent, manifest) {
    return {
      // Inherit manifest of parent db
      ...parent.supports,

      // Disable unsupported features
      createIfMissing: false,
      errorIfExists: false,

      // Unset additional events because we're not forwarding them
      events: {},

      // Unset additional methods (like approximateSize) which we can't support here unless
      // the AbstractSublevel class is overridden by an implementation of `abstract-level`.
      additionalMethods: {},

      // Inherit manifest of custom AbstractSublevel subclass. Such a class is not
      // allowed to override encodings.
      ...manifest,

      encodings: {
        utf8: supportsEncoding(parent, 'utf8'),
        buffer: supportsEncoding(parent, 'buffer'),
        view: supportsEncoding(parent, 'view')
      }
    }
  };

  const supportsEncoding = function (parent, encoding) {
    // Prefer a non-transcoded encoding for optimal performance
    return parent.supports.encodings[encoding]
      ? parent.keyEncoding(encoding).name === encoding
      : false
  };

  class MultiFormat {
    constructor (key) {
      this.utf8 = key;
      this.view = textEncoder.encode(key);
      this.buffer = Buffer$5 ? Buffer$5.from(this.view.buffer, 0, this.view.byteLength) : {};
    }
  }

  class Unfixer {
    constructor () {
      this.cache = new Map();
    }

    get (prefixLength, keyFormat) {
      let unfix = this.cache.get(keyFormat);

      if (unfix === undefined) {
        if (keyFormat === 'view') {
          unfix = function (prefixLength, key) {
            // Avoid Uint8Array#slice() because it copies
            return key.subarray(prefixLength)
          }.bind(null, prefixLength);
        } else {
          unfix = function (prefixLength, key) {
            // Avoid Buffer#subarray() because it's slow
            return key.slice(prefixLength)
          }.bind(null, prefixLength);
        }

        this.cache.set(keyFormat, unfix);
      }

      return unfix
    }
  }

  const trim$1 = function (str, char) {
    let start = 0;
    let end = str.length;

    while (start < end && str[start] === char) start++;
    while (end > start && str[end - 1] === char) end--;

    return str.slice(start, end)
  };

  const { supports } = levelSupports;
  const { Transcoder } = levelTranscoder;
  const { EventEmitter } = events.exports;
  const { fromCallback } = catering;
  const ModuleError$1 = moduleError;
  const { AbstractIterator: AbstractIterator$1 } = abstractIterator;
  const { DefaultKeyIterator, DefaultValueIterator } = defaultKvIterator;
  const { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = deferredIterator;
  const { DefaultChainedBatch } = defaultChainedBatch;
  const { getCallback, getOptions } = common;
  const rangeOptions$1 = rangeOptions_1;

  const kPromise = Symbol('promise');
  const kLanded = Symbol('landed');
  const kResources = Symbol('resources');
  const kCloseResources = Symbol('closeResources');
  const kOperations = Symbol('operations');
  const kUndefer = Symbol('undefer');
  const kDeferOpen = Symbol('deferOpen');
  const kOptions$1 = Symbol('options');
  const kStatus = Symbol('status');
  const kDefaultOptions = Symbol('defaultOptions');
  const kTranscoder = Symbol('transcoder');
  const kKeyEncoding = Symbol('keyEncoding');
  const kValueEncoding = Symbol('valueEncoding');
  const noop$2 = () => {};

  class AbstractLevel$1 extends EventEmitter {
    constructor (manifest, options) {
      super();

      if (typeof manifest !== 'object' || manifest === null) {
        throw new TypeError("The first argument 'manifest' must be an object")
      }

      options = getOptions(options);
      const { keyEncoding, valueEncoding, passive, ...forward } = options;

      this[kResources] = new Set();
      this[kOperations] = [];
      this[kDeferOpen] = true;
      this[kOptions$1] = forward;
      this[kStatus] = 'opening';

      this.supports = supports(manifest, {
        status: true,
        promises: true,
        clear: true,
        getMany: true,
        deferredOpen: true,

        // TODO (next major): add seek
        snapshots: manifest.snapshots !== false,
        permanence: manifest.permanence !== false,

        // TODO: remove from level-supports because it's always supported
        keyIterator: true,
        valueIterator: true,
        iteratorNextv: true,
        iteratorAll: true,

        encodings: manifest.encodings || {},
        events: Object.assign({}, manifest.events, {
          opening: true,
          open: true,
          closing: true,
          closed: true,
          put: true,
          del: true,
          batch: true,
          clear: true
        })
      });

      this[kTranscoder] = new Transcoder(formats(this));
      this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8');
      this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8');

      // Add custom and transcoder encodings to manifest
      for (const encoding of this[kTranscoder].encodings()) {
        if (!this.supports.encodings[encoding.commonName]) {
          this.supports.encodings[encoding.commonName] = true;
        }
      }

      this[kDefaultOptions] = {
        empty: Object.freeze({}),
        entry: Object.freeze({
          keyEncoding: this[kKeyEncoding].commonName,
          valueEncoding: this[kValueEncoding].commonName
        }),
        key: Object.freeze({
          keyEncoding: this[kKeyEncoding].commonName
        })
      };

      // Let subclass finish its constructor
      this.nextTick(() => {
        if (this[kDeferOpen]) {
          this.open({ passive: false }, noop$2);
        }
      });
    }

    get status () {
      return this[kStatus]
    }

    keyEncoding (encoding) {
      return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding])
    }

    valueEncoding (encoding) {
      return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding])
    }

    open (options, callback) {
      callback = getCallback(options, callback);
      callback = fromCallback(callback, kPromise);

      options = { ...this[kOptions$1], ...getOptions(options) };

      options.createIfMissing = options.createIfMissing !== false;
      options.errorIfExists = !!options.errorIfExists;

      const maybeOpened = (err) => {
        if (this[kStatus] === 'closing' || this[kStatus] === 'opening') {
          // Wait until pending state changes are done
          this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened);
        } else if (this[kStatus] !== 'open') {
          callback(new ModuleError$1('Database is not open', {
            code: 'LEVEL_DATABASE_NOT_OPEN',
            cause: err
          }));
        } else {
          callback();
        }
      };

      if (options.passive) {
        if (this[kStatus] === 'opening') {
          this.once(kLanded, maybeOpened);
        } else {
          this.nextTick(maybeOpened);
        }
      } else if (this[kStatus] === 'closed' || this[kDeferOpen]) {
        this[kDeferOpen] = false;
        this[kStatus] = 'opening';
        this.emit('opening');

        this._open(options, (err) => {
          if (err) {
            this[kStatus] = 'closed';

            // Resources must be safe to close in any db state
            this[kCloseResources](() => {
              this.emit(kLanded);
              maybeOpened(err);
            });

            this[kUndefer]();
            return
          }

          this[kStatus] = 'open';
          this[kUndefer]();
          this.emit(kLanded);

          // Only emit public event if pending state changes are done
          if (this[kStatus] === 'open') this.emit('open');

          // TODO (next major): remove this alias
          if (this[kStatus] === 'open') this.emit('ready');

          maybeOpened();
        });
      } else if (this[kStatus] === 'open') {
        this.nextTick(maybeOpened);
      } else {
        this.once(kLanded, () => this.open(options, callback));
      }

      return callback[kPromise]
    }

    _open (options, callback) {
      this.nextTick(callback);
    }

    close (callback) {
      callback = fromCallback(callback, kPromise);

      const maybeClosed = (err) => {
        if (this[kStatus] === 'opening' || this[kStatus] === 'closing') {
          // Wait until pending state changes are done
          this.once(kLanded, err ? maybeClosed(err) : maybeClosed);
        } else if (this[kStatus] !== 'closed') {
          callback(new ModuleError$1('Database is not closed', {
            code: 'LEVEL_DATABASE_NOT_CLOSED',
            cause: err
          }));
        } else {
          callback();
        }
      };

      if (this[kStatus] === 'open') {
        this[kStatus] = 'closing';
        this.emit('closing');

        const cancel = (err) => {
          this[kStatus] = 'open';
          this[kUndefer]();
          this.emit(kLanded);
          maybeClosed(err);
        };

        this[kCloseResources](() => {
          this._close((err) => {
            if (err) return cancel(err)

            this[kStatus] = 'closed';
            this[kUndefer]();
            this.emit(kLanded);

            // Only emit public event if pending state changes are done
            if (this[kStatus] === 'closed') this.emit('closed');

            maybeClosed();
          });
        });
      } else if (this[kStatus] === 'closed') {
        this.nextTick(maybeClosed);
      } else {
        this.once(kLanded, () => this.close(callback));
      }

      return callback[kPromise]
    }

    [kCloseResources] (callback) {
      if (this[kResources].size === 0) {
        return this.nextTick(callback)
      }

      let pending = this[kResources].size;
      let sync = true;

      const next = () => {
        if (--pending === 0) {
          // We don't have tests for generic resources, so dezalgo
          if (sync) this.nextTick(callback);
          else callback();
        }
      };

      // In parallel so that all resources know they are closed
      for (const resource of this[kResources]) {
        resource.close(next);
      }

      sync = false;
      this[kResources].clear();
    }

    _close (callback) {
      this.nextTick(callback);
    }

    get (key, options, callback) {
      callback = getCallback(options, callback);
      callback = fromCallback(callback, kPromise);
      options = getOptions(options, this[kDefaultOptions].entry);

      if (this[kStatus] === 'opening') {
        this.defer(() => this.get(key, options, callback));
        return callback[kPromise]
      }

      if (maybeError(this, callback)) {
        return callback[kPromise]
      }

      const err = this._checkKey(key);

      if (err) {
        this.nextTick(callback, err);
        return callback[kPromise]
      }

      const keyEncoding = this.keyEncoding(options.keyEncoding);
      const valueEncoding = this.valueEncoding(options.valueEncoding);
      const keyFormat = keyEncoding.format;
      const valueFormat = valueEncoding.format;

      // Forward encoding options to the underlying store
      if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
        // Avoid spread operator because of https://bugs.chromium.org/p/chromium/issues/detail?id=1204540
        options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
      }

      this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err, value) => {
        if (err) {
          // Normalize not found error for backwards compatibility with abstract-leveldown and level(up)
          if (err.code === 'LEVEL_NOT_FOUND' || err.notFound || /NotFound/i.test(err)) {
            if (!err.code) err.code = 'LEVEL_NOT_FOUND'; // Preferred way going forward
            if (!err.notFound) err.notFound = true; // Same as level-errors
            if (!err.status) err.status = 404; // Same as level-errors
          }

          return callback(err)
        }

        try {
          value = valueEncoding.decode(value);
        } catch (err) {
          return callback(new ModuleError$1('Could not decode value', {
            code: 'LEVEL_DECODE_ERROR',
            cause: err
          }))
        }

        callback(null, value);
      });

      return callback[kPromise]
    }

    _get (key, options, callback) {
      this.nextTick(callback, new Error('NotFound'));
    }

    getMany (keys, options, callback) {
      callback = getCallback(options, callback);
      callback = fromCallback(callback, kPromise);
      options = getOptions(options, this[kDefaultOptions].entry);

      if (this[kStatus] === 'opening') {
        this.defer(() => this.getMany(keys, options, callback));
        return callback[kPromise]
      }

      if (maybeError(this, callback)) {
        return callback[kPromise]
      }

      if (!Array.isArray(keys)) {
        this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
        return callback[kPromise]
      }

      if (keys.length === 0) {
        this.nextTick(callback, null, []);
        return callback[kPromise]
      }

      const keyEncoding = this.keyEncoding(options.keyEncoding);
      const valueEncoding = this.valueEncoding(options.valueEncoding);
      const keyFormat = keyEncoding.format;
      const valueFormat = valueEncoding.format;

      // Forward encoding options
      if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
        options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
      }

      const mappedKeys = new Array(keys.length);

      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const err = this._checkKey(key);

        if (err) {
          this.nextTick(callback, err);
          return callback[kPromise]
        }

        mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat);
      }

      this._getMany(mappedKeys, options, (err, values) => {
        if (err) return callback(err)

        try {
          for (let i = 0; i < values.length; i++) {
            if (values[i] !== undefined) {
              values[i] = valueEncoding.decode(values[i]);
            }
          }
        } catch (err) {
          return callback(new ModuleError$1(`Could not decode one or more of ${values.length} value(s)`, {
            code: 'LEVEL_DECODE_ERROR',
            cause: err
          }))
        }

        callback(null, values);
      });

      return callback[kPromise]
    }

    _getMany (keys, options, callback) {
      this.nextTick(callback, null, new Array(keys.length).fill(undefined));
    }

    put (key, value, options, callback) {
      callback = getCallback(options, callback);
      callback = fromCallback(callback, kPromise);
      options = getOptions(options, this[kDefaultOptions].entry);

      if (this[kStatus] === 'opening') {
        this.defer(() => this.put(key, value, options, callback));
        return callback[kPromise]
      }

      if (maybeError(this, callback)) {
        return callback[kPromise]
      }

      const err = this._checkKey(key) || this._checkValue(value);

      if (err) {
        this.nextTick(callback, err);
        return callback[kPromise]
      }

      const keyEncoding = this.keyEncoding(options.keyEncoding);
      const valueEncoding = this.valueEncoding(options.valueEncoding);
      const keyFormat = keyEncoding.format;
      const valueFormat = valueEncoding.format;

      // Forward encoding options
      if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
        options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
      }

      const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
      const mappedValue = valueEncoding.encode(value);

      this._put(mappedKey, mappedValue, options, (err) => {
        if (err) return callback(err)
        this.emit('put', key, value);
        callback();
      });

      return callback[kPromise]
    }

    _put (key, value, options, callback) {
      this.nextTick(callback);
    }

    del (key, options, callback) {
      callback = getCallback(options, callback);
      callback = fromCallback(callback, kPromise);
      options = getOptions(options, this[kDefaultOptions].key);

      if (this[kStatus] === 'opening') {
        this.defer(() => this.del(key, options, callback));
        return callback[kPromise]
      }

      if (maybeError(this, callback)) {
        return callback[kPromise]
      }

      const err = this._checkKey(key);

      if (err) {
        this.nextTick(callback, err);
        return callback[kPromise]
      }

      const keyEncoding = this.keyEncoding(options.keyEncoding);
      const keyFormat = keyEncoding.format;

      // Forward encoding options
      if (options.keyEncoding !== keyFormat) {
        options = Object.assign({}, options, { keyEncoding: keyFormat });
      }

      this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err) => {
        if (err) return callback(err)
        this.emit('del', key);
        callback();
      });

      return callback[kPromise]
    }

    _del (key, options, callback) {
      this.nextTick(callback);
    }

    batch (operations, options, callback) {
      if (!arguments.length) {
        if (this[kStatus] === 'opening') return new DefaultChainedBatch(this)
        if (this[kStatus] !== 'open') {
          throw new ModuleError$1('Database is not open', {
            code: 'LEVEL_DATABASE_NOT_OPEN'
          })
        }
        return this._chainedBatch()
      }

      if (typeof operations === 'function') callback = operations;
      else callback = getCallback(options, callback);

      callback = fromCallback(callback, kPromise);
      options = getOptions(options, this[kDefaultOptions].empty);

      if (this[kStatus] === 'opening') {
        this.defer(() => this.batch(operations, options, callback));
        return callback[kPromise]
      }

      if (maybeError(this, callback)) {
        return callback[kPromise]
      }

      if (!Array.isArray(operations)) {
        this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
        return callback[kPromise]
      }

      if (operations.length === 0) {
        this.nextTick(callback);
        return callback[kPromise]
      }

      const mapped = new Array(operations.length);
      const { keyEncoding: ke, valueEncoding: ve, ...forward } = options;

      for (let i = 0; i < operations.length; i++) {
        if (typeof operations[i] !== 'object' || operations[i] === null) {
          this.nextTick(callback, new TypeError('A batch operation must be an object'));
          return callback[kPromise]
        }

        const op = Object.assign({}, operations[i]);

        if (op.type !== 'put' && op.type !== 'del') {
          this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
          return callback[kPromise]
        }

        const err = this._checkKey(op.key);

        if (err) {
          this.nextTick(callback, err);
          return callback[kPromise]
        }

        const db = op.sublevel != null ? op.sublevel : this;
        const keyEncoding = db.keyEncoding(op.keyEncoding || ke);
        const keyFormat = keyEncoding.format;

        op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
        op.keyEncoding = keyFormat;

        if (op.type === 'put') {
          const valueErr = this._checkValue(op.value);

          if (valueErr) {
            this.nextTick(callback, valueErr);
            return callback[kPromise]
          }

          const valueEncoding = db.valueEncoding(op.valueEncoding || ve);

          op.value = valueEncoding.encode(op.value);
          op.valueEncoding = valueEncoding.format;
        }

        // Prevent double prefixing
        if (db !== this) {
          op.sublevel = null;
        }

        mapped[i] = op;
      }

      this._batch(mapped, forward, (err) => {
        if (err) return callback(err)
        this.emit('batch', operations);
        callback();
      });

      return callback[kPromise]
    }

    _batch (operations, options, callback) {
      this.nextTick(callback);
    }

    sublevel (name, options) {
      return this._sublevel(name, AbstractSublevel.defaults(options))
    }

    _sublevel (name, options) {
      return new AbstractSublevel(this, name, options)
    }

    prefixKey (key, keyFormat) {
      return key
    }

    clear (options, callback) {
      callback = getCallback(options, callback);
      callback = fromCallback(callback, kPromise);
      options = getOptions(options, this[kDefaultOptions].empty);

      if (this[kStatus] === 'opening') {
        this.defer(() => this.clear(options, callback));
        return callback[kPromise]
      }

      if (maybeError(this, callback)) {
        return callback[kPromise]
      }

      const original = options;
      const keyEncoding = this.keyEncoding(options.keyEncoding);

      options = rangeOptions$1(options, keyEncoding);
      options.keyEncoding = keyEncoding.format;

      if (options.limit === 0) {
        this.nextTick(callback);
      } else {
        this._clear(options, (err) => {
          if (err) return callback(err)
          this.emit('clear', original);
          callback();
        });
      }

      return callback[kPromise]
    }

    _clear (options, callback) {
      this.nextTick(callback);
    }

    iterator (options) {
      const keyEncoding = this.keyEncoding(options && options.keyEncoding);
      const valueEncoding = this.valueEncoding(options && options.valueEncoding);

      options = rangeOptions$1(options, keyEncoding);
      options.keys = options.keys !== false;
      options.values = options.values !== false;

      // We need the original encoding options in AbstractIterator in order to decode data
      options[AbstractIterator$1.keyEncoding] = keyEncoding;
      options[AbstractIterator$1.valueEncoding] = valueEncoding;

      // Forward encoding options to private API
      options.keyEncoding = keyEncoding.format;
      options.valueEncoding = valueEncoding.format;

      if (this[kStatus] === 'opening') {
        return new DeferredIterator(this, options)
      } else if (this[kStatus] !== 'open') {
        throw new ModuleError$1('Database is not open', {
          code: 'LEVEL_DATABASE_NOT_OPEN'
        })
      }

      return this._iterator(options)
    }

    _iterator (options) {
      return new AbstractIterator$1(this, options)
    }

    keys (options) {
      // Also include valueEncoding (though unused) because we may fallback to _iterator()
      const keyEncoding = this.keyEncoding(options && options.keyEncoding);
      const valueEncoding = this.valueEncoding(options && options.valueEncoding);

      options = rangeOptions$1(options, keyEncoding);

      // We need the original encoding options in AbstractKeyIterator in order to decode data
      options[AbstractIterator$1.keyEncoding] = keyEncoding;
      options[AbstractIterator$1.valueEncoding] = valueEncoding;

      // Forward encoding options to private API
      options.keyEncoding = keyEncoding.format;
      options.valueEncoding = valueEncoding.format;

      if (this[kStatus] === 'opening') {
        return new DeferredKeyIterator(this, options)
      } else if (this[kStatus] !== 'open') {
        throw new ModuleError$1('Database is not open', {
          code: 'LEVEL_DATABASE_NOT_OPEN'
        })
      }

      return this._keys(options)
    }

    _keys (options) {
      return new DefaultKeyIterator(this, options)
    }

    values (options) {
      const keyEncoding = this.keyEncoding(options && options.keyEncoding);
      const valueEncoding = this.valueEncoding(options && options.valueEncoding);

      options = rangeOptions$1(options, keyEncoding);

      // We need the original encoding options in AbstractValueIterator in order to decode data
      options[AbstractIterator$1.keyEncoding] = keyEncoding;
      options[AbstractIterator$1.valueEncoding] = valueEncoding;

      // Forward encoding options to private API
      options.keyEncoding = keyEncoding.format;
      options.valueEncoding = valueEncoding.format;

      if (this[kStatus] === 'opening') {
        return new DeferredValueIterator(this, options)
      } else if (this[kStatus] !== 'open') {
        throw new ModuleError$1('Database is not open', {
          code: 'LEVEL_DATABASE_NOT_OPEN'
        })
      }

      return this._values(options)
    }

    _values (options) {
      return new DefaultValueIterator(this, options)
    }

    defer (fn) {
      if (typeof fn !== 'function') {
        throw new TypeError('The first argument must be a function')
      }

      this[kOperations].push(fn);
    }

    [kUndefer] () {
      if (this[kOperations].length === 0) {
        return
      }

      const operations = this[kOperations];
      this[kOperations] = [];

      for (const op of operations) {
        op();
      }
    }

    // TODO: docs and types
    attachResource (resource) {
      if (typeof resource !== 'object' || resource === null ||
        typeof resource.close !== 'function') {
        throw new TypeError('The first argument must be a resource object')
      }

      this[kResources].add(resource);
    }

    // TODO: docs and types
    detachResource (resource) {
      this[kResources].delete(resource);
    }

    _chainedBatch () {
      return new DefaultChainedBatch(this)
    }

    _checkKey (key) {
      if (key === null || key === undefined) {
        return new ModuleError$1('Key cannot be null or undefined', {
          code: 'LEVEL_INVALID_KEY'
        })
      }
    }

    _checkValue (value) {
      if (value === null || value === undefined) {
        return new ModuleError$1('Value cannot be null or undefined', {
          code: 'LEVEL_INVALID_VALUE'
        })
      }
    }
  }

  // Expose browser-compatible nextTick for dependents
  // TODO: after we drop node 10, also use queueMicrotask in node
  AbstractLevel$1.prototype.nextTick = nextTick;

  const { AbstractSublevel } = abstractSublevel({ AbstractLevel: AbstractLevel$1 });

  abstractLevel.AbstractLevel = AbstractLevel$1;
  abstractLevel.AbstractSublevel = AbstractSublevel;

  const maybeError = function (db, callback) {
    if (db[kStatus] !== 'open') {
      db.nextTick(callback, new ModuleError$1('Database is not open', {
        code: 'LEVEL_DATABASE_NOT_OPEN'
      }));
      return true
    }

    return false
  };

  const formats = function (db) {
    return Object.keys(db.supports.encodings)
      .filter(k => !!db.supports.encodings[k])
  };

  abstractLevel$1.AbstractLevel = abstractLevel.AbstractLevel;
  abstractLevel$1.AbstractSublevel = abstractLevel.AbstractSublevel;
  abstractLevel$1.AbstractIterator = abstractIterator.AbstractIterator;
  abstractLevel$1.AbstractKeyIterator = abstractIterator.AbstractKeyIterator;
  abstractLevel$1.AbstractValueIterator = abstractIterator.AbstractValueIterator;
  abstractLevel$1.AbstractChainedBatch = abstractChainedBatch.AbstractChainedBatch;

  var rbtree = createRBTree;

  var RED   = 0;
  var BLACK = 1;

  function RBNode(color, key, value, left, right, count) {
    this._color = color;
    this.key = key;
    this.value = value;
    this.left = left;
    this.right = right;
    this._count = count;
  }

  function cloneNode(node) {
    return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
  }

  function repaint(color, node) {
    return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
  }

  function recount(node) {
    node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
  }

  function RedBlackTree(compare, root) {
    this._compare = compare;
    this.root = root;
  }

  var proto = RedBlackTree.prototype;

  Object.defineProperty(proto, "keys", {
    get: function() {
      var result = [];
      this.forEach(function(k,v) {
        result.push(k);
      });
      return result
    }
  });

  Object.defineProperty(proto, "values", {
    get: function() {
      var result = [];
      this.forEach(function(k,v) {
        result.push(v);
      });
      return result
    }
  });

  //Returns the number of nodes in the tree
  Object.defineProperty(proto, "length", {
    get: function() {
      if(this.root) {
        return this.root._count
      }
      return 0
    }
  });

  //Insert a new item into the tree
  proto.insert = function(key, value) {
    var cmp = this._compare;
    //Find point to insert new node at
    var n = this.root;
    var n_stack = [];
    var d_stack = [];
    while(n) {
      var d = cmp(key, n.key);
      n_stack.push(n);
      d_stack.push(d);
      if(d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    //Rebuild path to leaf node
    n_stack.push(new RBNode(RED, key, value, null, null, 1));
    for(var s=n_stack.length-2; s>=0; --s) {
      var n = n_stack[s];
      if(d_stack[s] <= 0) {
        n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1);
      } else {
        n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1);
      }
    }
    //Rebalance tree using rotations
    //console.log("start insert", key, d_stack)
    for(var s=n_stack.length-1; s>1; --s) {
      var p = n_stack[s-1];
      var n = n_stack[s];
      if(p._color === BLACK || n._color === BLACK) {
        break
      }
      var pp = n_stack[s-2];
      if(pp.left === p) {
        if(p.left === n) {
          var y = pp.right;
          if(y && y._color === RED) {
            //console.log("LLr")
            p._color = BLACK;
            pp.right = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            //console.log("LLb")
            pp._color = RED;
            pp.left = p.right;
            p._color = BLACK;
            p.right = pp;
            n_stack[s-2] = p;
            n_stack[s-1] = n;
            recount(pp);
            recount(p);
            if(s >= 3) {
              var ppp = n_stack[s-3];
              if(ppp.left === pp) {
                ppp.left = p;
              } else {
                ppp.right = p;
              }
            }
            break
          }
        } else {
          var y = pp.right;
          if(y && y._color === RED) {
            //console.log("LRr")
            p._color = BLACK;
            pp.right = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            //console.log("LRb")
            p.right = n.left;
            pp._color = RED;
            pp.left = n.right;
            n._color = BLACK;
            n.left = p;
            n.right = pp;
            n_stack[s-2] = n;
            n_stack[s-1] = p;
            recount(pp);
            recount(p);
            recount(n);
            if(s >= 3) {
              var ppp = n_stack[s-3];
              if(ppp.left === pp) {
                ppp.left = n;
              } else {
                ppp.right = n;
              }
            }
            break
          }
        }
      } else {
        if(p.right === n) {
          var y = pp.left;
          if(y && y._color === RED) {
            //console.log("RRr", y.key)
            p._color = BLACK;
            pp.left = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            //console.log("RRb")
            pp._color = RED;
            pp.right = p.left;
            p._color = BLACK;
            p.left = pp;
            n_stack[s-2] = p;
            n_stack[s-1] = n;
            recount(pp);
            recount(p);
            if(s >= 3) {
              var ppp = n_stack[s-3];
              if(ppp.right === pp) {
                ppp.right = p;
              } else {
                ppp.left = p;
              }
            }
            break
          }
        } else {
          var y = pp.left;
          if(y && y._color === RED) {
            //console.log("RLr")
            p._color = BLACK;
            pp.left = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            //console.log("RLb")
            p.left = n.right;
            pp._color = RED;
            pp.right = n.left;
            n._color = BLACK;
            n.right = p;
            n.left = pp;
            n_stack[s-2] = n;
            n_stack[s-1] = p;
            recount(pp);
            recount(p);
            recount(n);
            if(s >= 3) {
              var ppp = n_stack[s-3];
              if(ppp.right === pp) {
                ppp.right = n;
              } else {
                ppp.left = n;
              }
            }
            break
          }
        }
      }
    }
    //Return new tree
    n_stack[0]._color = BLACK;
    return new RedBlackTree(cmp, n_stack[0])
  };


  //Visit all nodes inorder
  function doVisitFull(visit, node) {
    if(node.left) {
      var v = doVisitFull(visit, node.left);
      if(v) { return v }
    }
    var v = visit(node.key, node.value);
    if(v) { return v }
    if(node.right) {
      return doVisitFull(visit, node.right)
    }
  }

  //Visit half nodes in order
  function doVisitHalf(lo, compare, visit, node) {
    var l = compare(lo, node.key);
    if(l <= 0) {
      if(node.left) {
        var v = doVisitHalf(lo, compare, visit, node.left);
        if(v) { return v }
      }
      var v = visit(node.key, node.value);
      if(v) { return v }
    }
    if(node.right) {
      return doVisitHalf(lo, compare, visit, node.right)
    }
  }

  //Visit all nodes within a range
  function doVisit(lo, hi, compare, visit, node) {
    var l = compare(lo, node.key);
    var h = compare(hi, node.key);
    var v;
    if(l <= 0) {
      if(node.left) {
        v = doVisit(lo, hi, compare, visit, node.left);
        if(v) { return v }
      }
      if(h > 0) {
        v = visit(node.key, node.value);
        if(v) { return v }
      }
    }
    if(h > 0 && node.right) {
      return doVisit(lo, hi, compare, visit, node.right)
    }
  }


  proto.forEach = function rbTreeForEach(visit, lo, hi) {
    if(!this.root) {
      return
    }
    switch(arguments.length) {
      case 1:
        return doVisitFull(visit, this.root)

      case 2:
        return doVisitHalf(lo, this._compare, visit, this.root)

      case 3:
        if(this._compare(lo, hi) >= 0) {
          return
        }
        return doVisit(lo, hi, this._compare, visit, this.root)
    }
  };

  //First item in list
  Object.defineProperty(proto, "begin", {
    get: function() {
      var stack = [];
      var n = this.root;
      while(n) {
        stack.push(n);
        n = n.left;
      }
      return new RedBlackTreeIterator(this, stack)
    }
  });

  //Last item in list
  Object.defineProperty(proto, "end", {
    get: function() {
      var stack = [];
      var n = this.root;
      while(n) {
        stack.push(n);
        n = n.right;
      }
      return new RedBlackTreeIterator(this, stack)
    }
  });

  //Find the ith item in the tree
  proto.at = function(idx) {
    if(idx < 0) {
      return new RedBlackTreeIterator(this, [])
    }
    var n = this.root;
    var stack = [];
    while(true) {
      stack.push(n);
      if(n.left) {
        if(idx < n.left._count) {
          n = n.left;
          continue
        }
        idx -= n.left._count;
      }
      if(!idx) {
        return new RedBlackTreeIterator(this, stack)
      }
      idx -= 1;
      if(n.right) {
        if(idx >= n.right._count) {
          break
        }
        n = n.right;
      } else {
        break
      }
    }
    return new RedBlackTreeIterator(this, [])
  };

  proto.ge = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while(n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if(d <= 0) {
        last_ptr = stack.length;
      }
      if(d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack)
  };

  proto.gt = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while(n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if(d < 0) {
        last_ptr = stack.length;
      }
      if(d < 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack)
  };

  proto.lt = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while(n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if(d > 0) {
        last_ptr = stack.length;
      }
      if(d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack)
  };

  proto.le = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while(n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if(d >= 0) {
        last_ptr = stack.length;
      }
      if(d < 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack)
  };

  //Finds the item with key if it exists
  proto.find = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    while(n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if(d === 0) {
        return new RedBlackTreeIterator(this, stack)
      }
      if(d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    return new RedBlackTreeIterator(this, [])
  };

  //Removes item with key from tree
  proto.remove = function(key) {
    var iter = this.find(key);
    if(iter) {
      return iter.remove()
    }
    return this
  };

  //Returns the item at `key`
  proto.get = function(key) {
    var cmp = this._compare;
    var n = this.root;
    while(n) {
      var d = cmp(key, n.key);
      if(d === 0) {
        return n.value
      }
      if(d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    return
  };

  //Iterator for red black tree
  function RedBlackTreeIterator(tree, stack) {
    this.tree = tree;
    this._stack = stack;
  }

  var iproto = RedBlackTreeIterator.prototype;

  //Test if iterator is valid
  Object.defineProperty(iproto, "valid", {
    get: function() {
      return this._stack.length > 0
    }
  });

  //Node of the iterator
  Object.defineProperty(iproto, "node", {
    get: function() {
      if(this._stack.length > 0) {
        return this._stack[this._stack.length-1]
      }
      return null
    },
    enumerable: true
  });

  //Makes a copy of an iterator
  iproto.clone = function() {
    return new RedBlackTreeIterator(this.tree, this._stack.slice())
  };

  //Swaps two nodes
  function swapNode(n, v) {
    n.key = v.key;
    n.value = v.value;
    n.left = v.left;
    n.right = v.right;
    n._color = v._color;
    n._count = v._count;
  }

  //Fix up a double black node in a tree
  function fixDoubleBlack(stack) {
    var n, p, s, z;
    for(var i=stack.length-1; i>=0; --i) {
      n = stack[i];
      if(i === 0) {
        n._color = BLACK;
        return
      }
      //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
      p = stack[i-1];
      if(p.left === n) {
        //console.log("left child")
        s = p.right;
        if(s.right && s.right._color === RED) {
          //console.log("case 1: right sibling child red")
          s = p.right = cloneNode(s);
          z = s.right = cloneNode(s.right);
          p.right = s.left;
          s.left = p;
          s.right = z;
          s._color = p._color;
          n._color = BLACK;
          p._color = BLACK;
          z._color = BLACK;
          recount(p);
          recount(s);
          if(i > 1) {
            var pp = stack[i-2];
            if(pp.left === p) {
              pp.left = s;
            } else {
              pp.right = s;
            }
          }
          stack[i-1] = s;
          return
        } else if(s.left && s.left._color === RED) {
          //console.log("case 1: left sibling child red")
          s = p.right = cloneNode(s);
          z = s.left = cloneNode(s.left);
          p.right = z.left;
          s.left = z.right;
          z.left = p;
          z.right = s;
          z._color = p._color;
          p._color = BLACK;
          s._color = BLACK;
          n._color = BLACK;
          recount(p);
          recount(s);
          recount(z);
          if(i > 1) {
            var pp = stack[i-2];
            if(pp.left === p) {
              pp.left = z;
            } else {
              pp.right = z;
            }
          }
          stack[i-1] = z;
          return
        }
        if(s._color === BLACK) {
          if(p._color === RED) {
            //console.log("case 2: black sibling, red parent", p.right.value)
            p._color = BLACK;
            p.right = repaint(RED, s);
            return
          } else {
            //console.log("case 2: black sibling, black parent", p.right.value)
            p.right = repaint(RED, s);
            continue  
          }
        } else {
          //console.log("case 3: red sibling")
          s = cloneNode(s);
          p.right = s.left;
          s.left = p;
          s._color = p._color;
          p._color = RED;
          recount(p);
          recount(s);
          if(i > 1) {
            var pp = stack[i-2];
            if(pp.left === p) {
              pp.left = s;
            } else {
              pp.right = s;
            }
          }
          stack[i-1] = s;
          stack[i] = p;
          if(i+1 < stack.length) {
            stack[i+1] = n;
          } else {
            stack.push(n);
          }
          i = i+2;
        }
      } else {
        //console.log("right child")
        s = p.left;
        if(s.left && s.left._color === RED) {
          //console.log("case 1: left sibling child red", p.value, p._color)
          s = p.left = cloneNode(s);
          z = s.left = cloneNode(s.left);
          p.left = s.right;
          s.right = p;
          s.left = z;
          s._color = p._color;
          n._color = BLACK;
          p._color = BLACK;
          z._color = BLACK;
          recount(p);
          recount(s);
          if(i > 1) {
            var pp = stack[i-2];
            if(pp.right === p) {
              pp.right = s;
            } else {
              pp.left = s;
            }
          }
          stack[i-1] = s;
          return
        } else if(s.right && s.right._color === RED) {
          //console.log("case 1: right sibling child red")
          s = p.left = cloneNode(s);
          z = s.right = cloneNode(s.right);
          p.left = z.right;
          s.right = z.left;
          z.right = p;
          z.left = s;
          z._color = p._color;
          p._color = BLACK;
          s._color = BLACK;
          n._color = BLACK;
          recount(p);
          recount(s);
          recount(z);
          if(i > 1) {
            var pp = stack[i-2];
            if(pp.right === p) {
              pp.right = z;
            } else {
              pp.left = z;
            }
          }
          stack[i-1] = z;
          return
        }
        if(s._color === BLACK) {
          if(p._color === RED) {
            //console.log("case 2: black sibling, red parent")
            p._color = BLACK;
            p.left = repaint(RED, s);
            return
          } else {
            //console.log("case 2: black sibling, black parent")
            p.left = repaint(RED, s);
            continue  
          }
        } else {
          //console.log("case 3: red sibling")
          s = cloneNode(s);
          p.left = s.right;
          s.right = p;
          s._color = p._color;
          p._color = RED;
          recount(p);
          recount(s);
          if(i > 1) {
            var pp = stack[i-2];
            if(pp.right === p) {
              pp.right = s;
            } else {
              pp.left = s;
            }
          }
          stack[i-1] = s;
          stack[i] = p;
          if(i+1 < stack.length) {
            stack[i+1] = n;
          } else {
            stack.push(n);
          }
          i = i+2;
        }
      }
    }
  }

  //Removes item at iterator from tree
  iproto.remove = function() {
    var stack = this._stack;
    if(stack.length === 0) {
      return this.tree
    }
    //First copy path to node
    var cstack = new Array(stack.length);
    var n = stack[stack.length-1];
    cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
    for(var i=stack.length-2; i>=0; --i) {
      var n = stack[i];
      if(n.left === stack[i+1]) {
        cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count);
      } else {
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count);
      }
    }

    //Get node
    n = cstack[cstack.length-1];
    //console.log("start remove: ", n.value)

    //If not leaf, then swap with previous node
    if(n.left && n.right) {
      //console.log("moving to leaf")

      //First walk to previous leaf
      var split = cstack.length;
      n = n.left;
      while(n.right) {
        cstack.push(n);
        n = n.right;
      }
      //Copy path to leaf
      var v = cstack[split-1];
      cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
      cstack[split-1].key = n.key;
      cstack[split-1].value = n.value;

      //Fix up stack
      for(var i=cstack.length-2; i>=split; --i) {
        n = cstack[i];
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count);
      }
      cstack[split-1].left = cstack[split];
    }
    //console.log("stack=", cstack.map(function(v) { return v.value }))

    //Remove leaf node
    n = cstack[cstack.length-1];
    if(n._color === RED) {
      //Easy case: removing red leaf
      //console.log("RED leaf")
      var p = cstack[cstack.length-2];
      if(p.left === n) {
        p.left = null;
      } else if(p.right === n) {
        p.right = null;
      }
      cstack.pop();
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--;
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else {
      if(n.left || n.right) {
        //Second easy case:  Single child black parent
        //console.log("BLACK single child")
        if(n.left) {
          swapNode(n, n.left);
        } else if(n.right) {
          swapNode(n, n.right);
        }
        //Child must be red, so repaint it black to balance color
        n._color = BLACK;
        for(var i=0; i<cstack.length-1; ++i) {
          cstack[i]._count--;
        }
        return new RedBlackTree(this.tree._compare, cstack[0])
      } else if(cstack.length === 1) {
        //Third easy case: root
        //console.log("ROOT")
        return new RedBlackTree(this.tree._compare, null)
      } else {
        //Hard case: Repaint n, and then do some nasty stuff
        //console.log("BLACK leaf no children")
        for(var i=0; i<cstack.length; ++i) {
          cstack[i]._count--;
        }
        var parent = cstack[cstack.length-2];
        fixDoubleBlack(cstack);
        //Fix up links
        if(parent.left === n) {
          parent.left = null;
        } else {
          parent.right = null;
        }
      }
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  };

  //Returns key
  Object.defineProperty(iproto, "key", {
    get: function() {
      if(this._stack.length > 0) {
        return this._stack[this._stack.length-1].key
      }
      return
    },
    enumerable: true
  });

  //Returns value
  Object.defineProperty(iproto, "value", {
    get: function() {
      if(this._stack.length > 0) {
        return this._stack[this._stack.length-1].value
      }
      return
    },
    enumerable: true
  });


  //Returns the position of this iterator in the sorted list
  Object.defineProperty(iproto, "index", {
    get: function() {
      var idx = 0;
      var stack = this._stack;
      if(stack.length === 0) {
        var r = this.tree.root;
        if(r) {
          return r._count
        }
        return 0
      } else if(stack[stack.length-1].left) {
        idx = stack[stack.length-1].left._count;
      }
      for(var s=stack.length-2; s>=0; --s) {
        if(stack[s+1] === stack[s].right) {
          ++idx;
          if(stack[s].left) {
            idx += stack[s].left._count;
          }
        }
      }
      return idx
    },
    enumerable: true
  });

  //Advances iterator to next element in list
  iproto.next = function() {
    var stack = this._stack;
    if(stack.length === 0) {
      return
    }
    var n = stack[stack.length-1];
    if(n.right) {
      n = n.right;
      while(n) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while(stack.length > 0 && stack[stack.length-1].right === n) {
        n = stack[stack.length-1];
        stack.pop();
      }
    }
  };

  //Checks if iterator is at end of tree
  Object.defineProperty(iproto, "hasNext", {
    get: function() {
      var stack = this._stack;
      if(stack.length === 0) {
        return false
      }
      if(stack[stack.length-1].right) {
        return true
      }
      for(var s=stack.length-1; s>0; --s) {
        if(stack[s-1].left === stack[s]) {
          return true
        }
      }
      return false
    }
  });

  //Update value
  iproto.update = function(value) {
    var stack = this._stack;
    if(stack.length === 0) {
      throw new Error("Can't update empty node!")
    }
    var cstack = new Array(stack.length);
    var n = stack[stack.length-1];
    cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
    for(var i=stack.length-2; i>=0; --i) {
      n = stack[i];
      if(n.left === stack[i+1]) {
        cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count);
      } else {
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count);
      }
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  };

  //Moves iterator backward one element
  iproto.prev = function() {
    var stack = this._stack;
    if(stack.length === 0) {
      return
    }
    var n = stack[stack.length-1];
    if(n.left) {
      n = n.left;
      while(n) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while(stack.length > 0 && stack[stack.length-1].left === n) {
        n = stack[stack.length-1];
        stack.pop();
      }
    }
  };

  //Checks if iterator is at start of tree
  Object.defineProperty(iproto, "hasPrev", {
    get: function() {
      var stack = this._stack;
      if(stack.length === 0) {
        return false
      }
      if(stack[stack.length-1].left) {
        return true
      }
      for(var s=stack.length-1; s>0; --s) {
        if(stack[s-1].right === stack[s]) {
          return true
        }
      }
      return false
    }
  });

  //Default comparison function
  function defaultCompare(a, b) {
    if(a < b) {
      return -1
    }
    if(a > b) {
      return 1
    }
    return 0
  }

  //Build a tree
  function createRBTree(compare) {
    return new RedBlackTree(compare || defaultCompare, null)
  }

  const {
    AbstractLevel,
    AbstractIterator,
    AbstractKeyIterator,
    AbstractValueIterator
  } = abstractLevel$1;

  const ModuleError = moduleError;
  const createRBT = rbtree;

  const rangeOptions = new Set(['gt', 'gte', 'lt', 'lte']);
  const kNone = Symbol('none');
  const kTree = Symbol('tree');
  const kIterator = Symbol('iterator');
  const kLowerBound = Symbol('lowerBound');
  const kUpperBound = Symbol('upperBound');
  const kOutOfRange = Symbol('outOfRange');
  const kReverse = Symbol('reverse');
  const kOptions = Symbol('options');
  const kTest = Symbol('test');
  const kAdvance = Symbol('advance');
  const kInit = Symbol('init');

  function compare (a, b) {
    // Only relevant when storeEncoding is 'utf8',
    // which guarantees that b is also a string.
    if (typeof a === 'string') {
      return a < b ? -1 : a > b ? 1 : 0
    }

    const length = Math.min(a.byteLength, b.byteLength);

    for (let i = 0; i < length; i++) {
      const cmp = a[i] - b[i];
      if (cmp !== 0) return cmp
    }

    return a.byteLength - b.byteLength
  }

  function gt (value) {
    return compare(value, this[kUpperBound]) > 0
  }

  function gte (value) {
    return compare(value, this[kUpperBound]) >= 0
  }

  function lt (value) {
    return compare(value, this[kUpperBound]) < 0
  }

  function lte (value) {
    return compare(value, this[kUpperBound]) <= 0
  }

  class MemoryIterator extends AbstractIterator {
    constructor (db, options) {
      super(db, options);
      this[kInit](db[kTree], options);
    }

    _next (callback) {
      if (!this[kIterator].valid) return this.nextTick(callback)

      const key = this[kIterator].key;
      const value = this[kIterator].value;

      if (!this[kTest](key)) return this.nextTick(callback)

      this[kIterator][this[kAdvance]]();
      this.nextTick(callback, null, key, value);
    }

    _nextv (size, options, callback) {
      const it = this[kIterator];
      const entries = [];

      while (it.valid && entries.length < size && this[kTest](it.key)) {
        entries.push([it.key, it.value]);
        it[this[kAdvance]]();
      }

      this.nextTick(callback, null, entries);
    }

    _all (options, callback) {
      const size = this.limit - this.count;
      const it = this[kIterator];
      const entries = [];

      while (it.valid && entries.length < size && this[kTest](it.key)) {
        entries.push([it.key, it.value]);
        it[this[kAdvance]]();
      }

      this.nextTick(callback, null, entries);
    }
  }

  class MemoryKeyIterator extends AbstractKeyIterator {
    constructor (db, options) {
      super(db, options);
      this[kInit](db[kTree], options);
    }

    _next (callback) {
      if (!this[kIterator].valid) return this.nextTick(callback)

      const key = this[kIterator].key;
      if (!this[kTest](key)) return this.nextTick(callback)

      this[kIterator][this[kAdvance]]();
      this.nextTick(callback, null, key);
    }

    _nextv (size, options, callback) {
      const it = this[kIterator];
      const keys = [];

      while (it.valid && keys.length < size && this[kTest](it.key)) {
        keys.push(it.key);
        it[this[kAdvance]]();
      }

      this.nextTick(callback, null, keys);
    }

    _all (options, callback) {
      const size = this.limit - this.count;
      const it = this[kIterator];
      const keys = [];

      while (it.valid && keys.length < size && this[kTest](it.key)) {
        keys.push(it.key);
        it[this[kAdvance]]();
      }

      this.nextTick(callback, null, keys);
    }
  }

  class MemoryValueIterator extends AbstractValueIterator {
    constructor (db, options) {
      super(db, options);
      this[kInit](db[kTree], options);
    }

    _next (callback) {
      if (!this[kIterator].valid) return this.nextTick(callback)

      const key = this[kIterator].key;
      const value = this[kIterator].value;

      if (!this[kTest](key)) return this.nextTick(callback)

      this[kIterator][this[kAdvance]]();
      this.nextTick(callback, null, value);
    }

    _nextv (size, options, callback) {
      const it = this[kIterator];
      const values = [];

      while (it.valid && values.length < size && this[kTest](it.key)) {
        values.push(it.value);
        it[this[kAdvance]]();
      }

      this.nextTick(callback, null, values);
    }

    _all (options, callback) {
      const size = this.limit - this.count;
      const it = this[kIterator];
      const values = [];

      while (it.valid && values.length < size && this[kTest](it.key)) {
        values.push(it.value);
        it[this[kAdvance]]();
      }

      this.nextTick(callback, null, values);
    }
  }

  for (const Ctor of [MemoryIterator, MemoryKeyIterator, MemoryValueIterator]) {
    Ctor.prototype[kInit] = function (tree, options) {
      this[kReverse] = options.reverse;
      this[kOptions] = options;

      if (!this[kReverse]) {
        this[kAdvance] = 'next';
        this[kLowerBound] = 'gte' in options ? options.gte : 'gt' in options ? options.gt : kNone;
        this[kUpperBound] = 'lte' in options ? options.lte : 'lt' in options ? options.lt : kNone;

        if (this[kLowerBound] === kNone) {
          this[kIterator] = tree.begin;
        } else if ('gte' in options) {
          this[kIterator] = tree.ge(this[kLowerBound]);
        } else {
          this[kIterator] = tree.gt(this[kLowerBound]);
        }

        if (this[kUpperBound] !== kNone) {
          this[kTest] = 'lte' in options ? lte : lt;
        }
      } else {
        this[kAdvance] = 'prev';
        this[kLowerBound] = 'lte' in options ? options.lte : 'lt' in options ? options.lt : kNone;
        this[kUpperBound] = 'gte' in options ? options.gte : 'gt' in options ? options.gt : kNone;

        if (this[kLowerBound] === kNone) {
          this[kIterator] = tree.end;
        } else if ('lte' in options) {
          this[kIterator] = tree.le(this[kLowerBound]);
        } else {
          this[kIterator] = tree.lt(this[kLowerBound]);
        }

        if (this[kUpperBound] !== kNone) {
          this[kTest] = 'gte' in options ? gte : gt;
        }
      }
    };

    Ctor.prototype[kTest] = function () {
      return true
    };

    Ctor.prototype[kOutOfRange] = function (target) {
      if (!this[kTest](target)) {
        return true
      } else if (this[kLowerBound] === kNone) {
        return false
      } else if (!this[kReverse]) {
        if ('gte' in this[kOptions]) {
          return compare(target, this[kLowerBound]) < 0
        } else {
          return compare(target, this[kLowerBound]) <= 0
        }
      } else {
        if ('lte' in this[kOptions]) {
          return compare(target, this[kLowerBound]) > 0
        } else {
          return compare(target, this[kLowerBound]) >= 0
        }
      }
    };

    Ctor.prototype._seek = function (target, options) {
      if (this[kOutOfRange](target)) {
        this[kIterator] = this[kIterator].tree.end;
        this[kIterator].next();
      } else if (this[kReverse]) {
        this[kIterator] = this[kIterator].tree.le(target);
      } else {
        this[kIterator] = this[kIterator].tree.ge(target);
      }
    };
  }

  class MemoryLevel extends AbstractLevel {
    constructor (location, options, _) {
      // Take a dummy location argument to align with other implementations
      if (typeof location === 'object' && location !== null) {
        options = location;
      }

      // To help migrating from level-mem to abstract-level
      if (typeof location === 'function' || typeof options === 'function' || typeof _ === 'function') {
        throw new ModuleError('The levelup-style callback argument has been removed', {
          code: 'LEVEL_LEGACY'
        })
      }

      let { storeEncoding, ...forward } = options || {};
      storeEncoding = storeEncoding || 'buffer';

      // Our compare() function supports Buffer, Uint8Array and strings
      if (!['buffer', 'view', 'utf8'].includes(storeEncoding)) {
        throw new ModuleError("The storeEncoding option must be 'buffer', 'view' or 'utf8'", {
          code: 'LEVEL_ENCODING_NOT_SUPPORTED'
        })
      }

      super({
        seek: true,
        permanence: false,
        createIfMissing: false,
        errorIfExists: false,
        encodings: { [storeEncoding]: true }
      }, forward);

      this[kTree] = createRBT(compare);
    }

    _put (key, value, options, callback) {
      const it = this[kTree].find(key);

      if (it.valid) {
        this[kTree] = it.update(value);
      } else {
        this[kTree] = this[kTree].insert(key, value);
      }

      this.nextTick(callback);
    }

    _get (key, options, callback) {
      const value = this[kTree].get(key);

      if (typeof value === 'undefined') {
        // TODO: use error code (not urgent, abstract-level normalizes this)
        return this.nextTick(callback, new Error('NotFound'))
      }

      this.nextTick(callback, null, value);
    }

    _getMany (keys, options, callback) {
      this.nextTick(callback, null, keys.map(key => this[kTree].get(key)));
    }

    _del (key, options, callback) {
      this[kTree] = this[kTree].remove(key);
      this.nextTick(callback);
    }

    _batch (operations, options, callback) {
      let tree = this[kTree];

      for (const op of operations) {
        const key = op.key;
        const it = tree.find(key);

        if (op.type === 'put') {
          tree = it.valid ? it.update(op.value) : tree.insert(key, op.value);
        } else {
          tree = it.remove();
        }
      }

      this[kTree] = tree;
      this.nextTick(callback);
    }

    _clear (options, callback) {
      if (options.limit === -1 && !Object.keys(options).some(isRangeOption)) {
        // Delete everything by creating a new empty tree.
        this[kTree] = createRBT(compare);
        return this.nextTick(callback)
      }

      const iterator = this._keys({ ...options });
      const limit = iterator.limit;

      let count = 0;

      const loop = () => {
        // TODO: add option to control "batch size"
        for (let i = 0; i < 500; i++) {
          if (++count > limit) return callback()
          if (!iterator[kIterator].valid) return callback()
          if (!iterator[kTest](iterator[kIterator].key)) return callback()

          // Must also include changes made in parallel to clear()
          this[kTree] = this[kTree].remove(iterator[kIterator].key);
          iterator[kIterator][iterator[kAdvance]]();
        }

        // Some time to breathe
        this.nextTick(loop);
      };

      this.nextTick(loop);
    }

    _iterator (options) {
      return new MemoryIterator(this, options)
    }

    _keys (options) {
      return new MemoryKeyIterator(this, options)
    }

    _values (options) {
      return new MemoryValueIterator(this, options)
    }
  }

  memoryLevel.MemoryLevel = MemoryLevel;

  // Use setImmediate() in Node.js to allow IO in between our callbacks
  if (typeof browser$1$1 !== 'undefined' && !browser$1$1.browser && typeof commonjsGlobal !== 'undefined' && typeof commonjsGlobal.setImmediate === 'function') {
    const setImmediate = commonjsGlobal.setImmediate;

    // Automatically applies to iterators, sublevels and chained batches as well
    MemoryLevel.prototype.nextTick = function (fn, ...args) {
      if (args.length === 0) {
        setImmediate(fn);
      } else {
        setImmediate(() => fn(...args));
      }
    };
  }

  function isRangeOption (k) {
    return rangeOptions.has(k)
  }

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LevelDB = exports.ENCODING_OPTS = void 0;
  // eslint-disable-next-line implicit-dependencies/no-implicit
  const util_1 = dist$a;
  const memory_level_1 = memoryLevel;
  exports.ENCODING_OPTS = { keyEncoding: 'buffer', valueEncoding: 'buffer' };
  /**
   * LevelDB is a thin wrapper around the underlying levelup db,
   * which validates inputs and sets encoding type.
   */
  class LevelDB {
      /**
       * Initialize a DB instance. If `leveldb` is not provided, DB
       * defaults to an [in-memory store](https://github.com/Level/memdown).
       * @param leveldb - An abstract-leveldown compliant store
       */
      constructor(leveldb) {
          this._leveldb = leveldb ?? new memory_level_1.MemoryLevel(exports.ENCODING_OPTS);
      }
      /**
       * @inheritDoc
       */
      async get(key) {
          let value = null;
          try {
              value = await this._leveldb.get(key, exports.ENCODING_OPTS);
          }
          catch (error) {
              if ((0, util_1.isTruthy)(error.notFound)) ;
              else {
                  throw error;
              }
          }
          return value;
      }
      /**
       * @inheritDoc
       */
      async put(key, val) {
          await this._leveldb.put(key, val, exports.ENCODING_OPTS);
      }
      /**
       * @inheritDoc
       */
      async del(key) {
          await this._leveldb.del(key, exports.ENCODING_OPTS);
      }
      /**
       * @inheritDoc
       */
      async batch(opStack) {
          await this._leveldb.batch(opStack, exports.ENCODING_OPTS);
      }
      /**
       * @inheritDoc
       */
      copy() {
          return new LevelDB(this._leveldb);
      }
  }
  exports.LevelDB = LevelDB;

  }(level));

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(checkpoint$1, exports);
  __exportStar(level, exports);

  }(db));

  var proof = {};

  var range = {};

  var trie$1 = {};

  var checkpoint = {};

  var trie = {};

  var dist$4 = {};

  var Semaphore = {};

  (function (exports) {
  var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
      return { next: verb(0), "throw": verb(1), "return": verb(2) };
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [0, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  };
  exports.__esModule = true;
  /** Class representing a semaphore
   * Semaphores are initialized with a number of permits that get aquired and released
   * over the lifecycle of the Semaphore. These permits limit the number of simultaneous
   * executions of the code that the Semaphore synchronizes. Functions can wait and stop
   * executing until a permit becomes available.
   *
   * Locks that only allow one execution of a critical section are a special case of
   * Semaphores. To construct a lock, initialize a Semaphore with a permit count of 1.
   *
   * This Semaphore class is implemented with the help of promises that get returned
   * by functions that wait for permits to become available. This makes it possible
   * to use async/await to synchronize your code.
   */
  var Semaphore = (function () {
      /**
       * Creates a semaphore.
       * @param permits  The number of permits, i.e. things being allowed to run in parallel.
       * To create a lock that only lets one thing run at a time, set this to 1.
       * This number can also be negative.
       */
      function Semaphore(permits) {
          this.promiseResolverQueue = [];
          this.permits = permits;
      }
      /**
       * Returns the number of available permits.
       * @returns  The number of available permits.
       */
      Semaphore.prototype.getPermits = function () {
          return this.permits;
      };
      /**
       * Returns a promise used to wait for a permit to become available. This method should be awaited on.
       * @returns  A promise that gets resolved when execution is allowed to proceed.
       */
      Semaphore.prototype.wait = function () {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              return __generator(this, function (_a) {
                  if (this.permits > 0) {
                      this.permits -= 1;
                      return [2 /*return*/, Promise.resolve(true)];
                  }
                  // If there is no permit available, we return a promise that resolves once the semaphore gets
                  // signaled enough times that permits is equal to one.
                  return [2 /*return*/, new Promise(function (resolver) { return _this.promiseResolverQueue.push(resolver); })];
              });
          });
      };
      /**
       * Alias for {@linkcode Semaphore.wait}.
       * @returns  A promise that gets resolved when execution is allowed to proceed.
       */
      Semaphore.prototype.acquire = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, this.wait()];
              });
          });
      };
      /**
       * Same as {@linkcode Semaphore.wait} except the promise returned gets resolved with false if no
       * permit becomes available in time.
       * @param milliseconds  The time spent waiting before the wait is aborted. This is a lower bound,
       * don't rely on it being precise.
       * @returns  A promise that gets resolved with true when execution is allowed to proceed or
       * false if the time given elapses before a permit becomes available.
       */
      Semaphore.prototype.waitFor = function (milliseconds) {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              var resolver, promise;
              return __generator(this, function (_a) {
                  if (this.permits > 0) {
                      this.permits -= 1;
                      return [2 /*return*/, Promise.resolve(true)];
                  }
                  resolver = function (b) { return void (0); };
                  promise = new Promise(function (r) {
                      resolver = r;
                  });
                  // The saved resolver gets added to our list of promise resolvers so that it gets a chance
                  // to be resolved as a result of a call to signal().
                  this.promiseResolverQueue.push(resolver);
                  setTimeout(function () {
                      // We have to remove the promise resolver from our list. Resolving it twice would not be
                      // an issue but signal() always takes the next resolver from the queue and resolves it which
                      // would swallow a permit if we didn't remove it.
                      var index = _this.promiseResolverQueue.indexOf(resolver);
                      if (index !== -1) {
                          _this.promiseResolverQueue.splice(index, 1);
                      }
                      // false because the wait was unsuccessful.
                      resolver(false);
                  }, milliseconds);
                  return [2 /*return*/, promise];
              });
          });
      };
      /**
       * Synchronous function that tries to acquire a permit and returns true if successful, false otherwise.
       * @returns  Whether a permit could be acquired.
       */
      Semaphore.prototype.tryAcquire = function () {
          if (this.permits > 0) {
              this.permits -= 1;
              return true;
          }
          return false;
      };
      /**
       * Acquires all permits that are currently available and returns the number of acquired permits.
       * @returns  Number of acquired permits.
       */
      Semaphore.prototype.drainPermits = function () {
          if (this.permits > 0) {
              var permitCount = this.permits;
              this.permits = 0;
              return permitCount;
          }
          return 0;
      };
      /**
       * Increases the number of permits by one. If there are other functions waiting, one of them will
       * continue to execute in a future iteration of the event loop.
       */
      Semaphore.prototype.signal = function () {
          this.permits += 1;
          if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
              throw new Error('this.permits should never be > 0 when there is someone waiting.');
          }
          else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
              // If there is someone else waiting, immediately consume the permit that was released
              // at the beginning of this function and let the waiting function resume.
              this.permits -= 1;
              var nextResolver = this.promiseResolverQueue.shift();
              if (nextResolver) {
                  nextResolver(true);
              }
          }
      };
      /**
       * Alias for {@linkcode Semaphore.signal}.
       */
      Semaphore.prototype.release = function () {
          this.signal();
      };
      /**
       * Schedules func to be called once a permit becomes available.
       * Returns a promise that resolves to the return value of func.
       * @typeparam T  The return type of func.
       * @param func  The function to be executed.
       * @return  A promise that gets resolved with the return value of the function.
       */
      Semaphore.prototype.execute = function (func) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.wait()];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2:
                          _a.trys.push([2, , 4, 5]);
                          return [4 /*yield*/, func()];
                      case 3: return [2 /*return*/, _a.sent()];
                      case 4:
                          this.signal();
                          return [7 /*endfinally*/];
                      case 5: return [2 /*return*/];
                  }
              });
          });
      };
      return Semaphore;
  }());
  exports["default"] = Semaphore;
  }(Semaphore));

  var Lock$1 = {};

  var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
      var extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Lock$1.__esModule = true;
  var Semaphore_1 = Semaphore;
  /**
   * A lock that can be used to synchronize critical sections in your code.
   * For more details on how to use this class, please view the documentation
   * of the Semaphore class from which Lock inherits.
   */
  var Lock = (function (_super) {
      __extends(Lock, _super);
      /**
       * Creates a lock.
       */
      function Lock() {
          return _super.call(this, 1) || this;
      }
      return Lock;
  }(Semaphore_1["default"]));
  Lock$1.Lock = Lock;

  (function (exports) {
  function __export(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
  exports.__esModule = true;
  var Semaphore_1 = Semaphore;
  exports["default"] = Semaphore_1["default"];
  __export(Lock$1);
  }(dist$4));

  var types$2 = {};

  Object.defineProperty(types$2, "__esModule", { value: true });
  types$2.ROOT_DB_KEY = void 0;
  types$2.ROOT_DB_KEY = Buffer$8.from('__root__');

  var nibbles = {};

  Object.defineProperty(nibbles, "__esModule", { value: true });
  nibbles.doKeysMatch = nibbles.matchingNibbleLength = nibbles.nibblesCompare = nibbles.nibblesToBuffer = nibbles.bufferToNibbles = void 0;
  /**
   * Converts a buffer to a nibble array.
   * @private
   * @param key
   */
  function bufferToNibbles(key) {
      const bkey = Buffer$8.from(key);
      const nibbles = [];
      for (let i = 0; i < bkey.length; i++) {
          let q = i * 2;
          nibbles[q] = bkey[i] >> 4;
          ++q;
          nibbles[q] = bkey[i] % 16;
      }
      return nibbles;
  }
  nibbles.bufferToNibbles = bufferToNibbles;
  /**
   * Converts a nibble array into a buffer.
   * @private
   * @param arr - Nibble array
   */
  function nibblesToBuffer(arr) {
      const buf = Buffer$8.alloc(arr.length / 2);
      for (let i = 0; i < buf.length; i++) {
          let q = i * 2;
          buf[i] = (arr[q] << 4) + arr[++q];
      }
      return buf;
  }
  nibbles.nibblesToBuffer = nibblesToBuffer;
  /**
   * Compare two nibble array.
   * * `0` is returned if `n2` == `n1`.
   * * `1` is returned if `n2` > `n1`.
   * * `-1` is returned if `n2` < `n1`.
   * @param n1 - Nibble array
   * @param n2 - Nibble array
   */
  function nibblesCompare(n1, n2) {
      const cmpLength = Math.min(n1.length, n2.length);
      let res = 0;
      for (let i = 0; i < cmpLength; i++) {
          if (n1[i] < n2[i]) {
              res = -1;
              break;
          }
          else if (n1[i] > n2[i]) {
              res = 1;
              break;
          }
      }
      if (res === 0) {
          if (n1.length < n2.length) {
              res = -1;
          }
          else if (n1.length > n2.length) {
              res = 1;
          }
      }
      return res;
  }
  nibbles.nibblesCompare = nibblesCompare;
  /**
   * Returns the number of in order matching nibbles of two give nibble arrays.
   * @private
   * @param nib1
   * @param nib2
   */
  function matchingNibbleLength(nib1, nib2) {
      let i = 0;
      while (nib1[i] === nib2[i] && nib1.length > i) {
          i++;
      }
      return i;
  }
  nibbles.matchingNibbleLength = matchingNibbleLength;
  /**
   * Compare two nibble array keys.
   * @param keyA
   * @param keyB
   */
  function doKeysMatch(keyA, keyB) {
      const length = matchingNibbleLength(keyA, keyB);
      return length === keyA.length && length === keyB.length;
  }
  nibbles.doKeysMatch = doKeysMatch;

  var readStream = {};

  var readable = {exports: {}};

  // for now just expose the builtin process global from node.js
  var process = commonjsGlobal.process;

  function BufferList$1() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList$1.prototype.push = function (v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList$1.prototype.unshift = function (v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList$1.prototype.shift = function () {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList$1.prototype.clear = function () {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList$1.prototype.join = function (s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList$1.prototype.concat = function (n) {
    if (this.length === 0) return buffer.Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = buffer.Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      p.data.copy(ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  var string_decoder = {};

  var safeBuffer = {exports: {}};

  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

  (function (module, exports) {
  /* eslint-disable node/no-deprecated-api */
  var buffer$1 = buffer;
  var Buffer = buffer$1.Buffer;

  // alternative to using Object.keys for old browsers
  function copyProps (src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer$1;
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer$1, exports);
    exports.Buffer = SafeBuffer;
  }

  function SafeBuffer (arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length)
  }

  SafeBuffer.prototype = Object.create(Buffer.prototype);

  // Copy static methods from Buffer
  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number')
    }
    return Buffer(arg, encodingOrOffset, length)
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return Buffer(size)
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return buffer$1.SlowBuffer(size)
  };
  }(safeBuffer, safeBuffer.exports));

  /*<replacement>*/

  var Buffer$4 = safeBuffer.exports.Buffer;
  /*</replacement>*/

  var isEncoding = Buffer$4.isEncoding || function (encoding) {
    encoding = '' + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
        return true;
      default:
        return false;
    }
  };

  function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while (true) {
      switch (enc) {
        case 'utf8':
        case 'utf-8':
          return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 'utf16le';
        case 'latin1':
        case 'binary':
          return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
          return enc;
        default:
          if (retried) return; // undefined
          enc = ('' + enc).toLowerCase();
          retried = true;
      }
    }
  }
  // Do not cache `Buffer.isEncoding` when checking encoding names as some
  // modules monkey-patch it to support additional encodings
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer$4.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
  }

  // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters.
  var StringDecoder_1 = string_decoder.StringDecoder = StringDecoder$1;
  function StringDecoder$1(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case 'utf16le':
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case 'utf8':
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case 'base64':
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer$4.allocUnsafe(nb);
  }

  StringDecoder$1.prototype.write = function (buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined) return '';
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
  };

  StringDecoder$1.prototype.end = utf8End;

  // Returns only complete characters in a Buffer
  StringDecoder$1.prototype.text = utf8Text;

  // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
  StringDecoder$1.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };

  // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
  // continuation byte. If an invalid byte is detected, -2 is returned.
  function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
  }

  // Checks at most 3 bytes at the end of a Buffer in order to detect an
  // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
  // needed to complete the UTF-8 character (if applicable) are returned.
  function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }

  // Validates as many continuation bytes for a multi-byte UTF-8 character as
  // needed or are available. If we see a non-continuation byte where we expect
  // one, we "replace" the validated continuation bytes we've seen so far with
  // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
  // behavior. The continuation byte check is included three times in the case
  // where all of the continuation bytes for a character exist in the same buffer.
  // It is also done this way as a slight performance increase instead of using a
  // loop.
  function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
      self.lastNeed = 0;
      return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 0xC0) !== 0x80) {
        self.lastNeed = 1;
        return '\ufffd';
      }
      if (self.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 0xC0) !== 0x80) {
          self.lastNeed = 2;
          return '\ufffd';
        }
      }
    }
  }

  // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }

  // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
  // partial character, the character's bytes are buffered until the required
  // number of bytes are available.
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
  }

  // For UTF-8, a replacement character is added when ending on a partial
  // character.
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
  }

  // UTF-16LE typically needs two bytes per character, but even if we have an even
  // number of bytes available, we need to check if we end on a leading/high
  // surrogate. In that case, we need to wait for the next two bytes in order to
  // decode the last character properly.
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString('utf16le', i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 0xD800 && c <= 0xDBFF) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
  }

  // For UTF-16LE we do not explicitly append special replacement characters if we
  // end on a partial character, we simply let v8 handle that.
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
  }

  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
  }

  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
  }

  // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }

  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
  }

  Readable$2.ReadableState = ReadableState$1;

  var debug$3 = util$6.debuglog('stream');
  util$6.inherits(Readable$2, EE);

  function prependListener$1(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') {
      return emitter.prependListener(event, fn);
    } else {
      // This is a hack to make sure that our error handler is attached before any
      // userland ones.  NEVER DO THIS. This is here only because this code needs
      // to continue to work with older versions of Node.js that do not include
      // the prependListener() method. The goal is to eventually remove this hack.
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount (emitter, type) {
    return emitter.listeners(type).length;
  }
  function ReadableState$1(options, stream) {

    options = options || {};

    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex$4) this.objectMode = this.objectMode || !!options.readableObjectMode;

    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList$1();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // when piping, we only care about 'readable' events that happen
    // after read()ing all the bytes and not getting any pushback.
    this.ranOut = false;

    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;

    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;

    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder_1(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable$2(options) {

    if (!(this instanceof Readable$2)) return new Readable$2(options);

    this._readableState = new ReadableState$1(options, this);

    // legacy
    this.readable = true;

    if (options && typeof options.read === 'function') this._read = options.read;

    EE.call(this);
  }

  // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.
  Readable$2.prototype.push = function (chunk, encoding) {
    var state = this._readableState;

    if (!state.objectMode && typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer$8.from(chunk, encoding);
        encoding = '';
      }
    }

    return readableAddChunk$1(this, state, chunk, encoding, false);
  };

  // Unshift should *always* be something directly out of read()
  Readable$2.prototype.unshift = function (chunk) {
    var state = this._readableState;
    return readableAddChunk$1(this, state, chunk, '', true);
  };

  Readable$2.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  };

  function readableAddChunk$1(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid$1(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk$1(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error('stream.push() after EOF');
        stream.emit('error', e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error('stream.unshift() after end event');
        stream.emit('error', _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }

        if (!addToFront) state.reading = false;

        // Don't add to the buffer if we've decoded to an empty string chunk and
        // we're not in object mode
        if (!skipAdd) {
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

            if (state.needReadable) emitReadable$1(stream);
          }
        }

        maybeReadMore$1(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }

    return needMoreData(state);
  }

  // if it's past the high water mark, we can push in some more.
  // Also, if we have no data yet, we can stand some
  // more bytes.  This is to work around cases where hwm=0,
  // such as the repl.  Also, if the push() triggered a
  // readable event, and the user called read(largeNumber) such that
  // needReadable was set, then we ought to push more, so that another
  // 'readable' event will be triggered.
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }

  // backwards compatibility.
  Readable$2.prototype.setEncoding = function (enc) {
    this._readableState.decoder = new StringDecoder_1(enc);
    this._readableState.encoding = enc;
    return this;
  };

  // Don't raise the hwm > 8MB
  var MAX_HWM$1 = 0x800000;
  function computeNewHighWaterMark$1(n) {
    if (n >= MAX_HWM$1) {
      n = MAX_HWM$1;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }

  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function howMuchToRead$1(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark$1(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }

  // you can override either this method, or the async _read(n) below.
  Readable$2.prototype.read = function (n) {
    debug$3('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;

    if (n !== 0) state.emittedReadable = false;

    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug$3('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable$1(this);else emitReadable$1(this);
      return null;
    }

    n = howMuchToRead$1(n, state);

    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable$1(this);
      return null;
    }

    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.

    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug$3('need readable', doRead);

    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug$3('length less than watermark', doRead);
    }

    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
      doRead = false;
      debug$3('reading or ended', doRead);
    } else if (doRead) {
      debug$3('do read');
      state.reading = true;
      state.sync = true;
      // if the length is currently zero, then we *need* a readable event.
      if (state.length === 0) state.needReadable = true;
      // call internal read method
      this._read(state.highWaterMark);
      state.sync = false;
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (!state.reading) n = howMuchToRead$1(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList$1(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true;

      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended) endReadable$1(this);
    }

    if (ret !== null) this.emit('data', ret);

    return ret;
  };

  function chunkInvalid$1(state, chunk) {
    var er = null;
    if (!Buffer$8.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    return er;
  }

  function onEofChunk$1(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;

    // emit 'readable' now to make sure it gets picked up.
    emitReadable$1(stream);
  }

  // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.
  function emitReadable$1(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug$3('emitReadable', state.flowing);
      state.emittedReadable = true;
      if (state.sync) process.nextTick(emitReadable_$1, stream);else emitReadable_$1(stream);
    }
  }

  function emitReadable_$1(stream) {
    debug$3('emit readable');
    stream.emit('readable');
    flow$1(stream);
  }

  // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.
  function maybeReadMore$1(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_$1, stream, state);
    }
  }

  function maybeReadMore_$1(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug$3('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length)
        // didn't get any data, stop spinning.
        break;else len = state.length;
    }
    state.readingMore = false;
  }

  // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.
  Readable$2.prototype._read = function (n) {
    this.emit('error', new Error('not implemented'));
  };

  Readable$2.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug$3('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

    var doEnd = (!pipeOpts || pipeOpts.end !== false);

    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);

    dest.on('unpipe', onunpipe);
    function onunpipe(readable) {
      debug$3('onunpipe');
      if (readable === src) {
        cleanup();
      }
    }

    function onend() {
      debug$3('onend');
      dest.end();
    }

    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain$1(src);
    dest.on('drain', ondrain);

    var cleanedUp = false;
    function cleanup() {
      debug$3('cleanup');
      // cleanup event handlers once the pipe is broken
      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', cleanup);
      src.removeListener('data', ondata);

      cleanedUp = true;

      // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on('data', ondata);
    function ondata(chunk) {
      debug$3('ondata');
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf$1(state.pipes, dest) !== -1) && !cleanedUp) {
          debug$3('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }

    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
      debug$3('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
    }

    // Make sure our error handler is attached before userland ones.
    prependListener$1(dest, 'error', onerror);

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
      debug$3('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }
    dest.once('finish', onfinish);

    function unpipe() {
      debug$3('unpipe');
      src.unpipe(dest);
    }

    // tell the dest that it's being piped to
    dest.emit('pipe', src);

    // start the flow if it hasn't been started already.
    if (!state.flowing) {
      debug$3('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain$1(src) {
    return function () {
      var state = src._readableState;
      debug$3('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners('data').length) {
        state.flowing = true;
        flow$1(src);
      }
    };
  }

  Readable$2.prototype.unpipe = function (dest) {
    var state = this._readableState;

    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;

    // just one destination.  most common case.
    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;

      if (!dest) dest = state.pipes;

      // got a match.
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this);
      return this;
    }

    // slow case. multiple pipe destinations.

    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var _i = 0; _i < len; _i++) {
        dests[_i].emit('unpipe', this);
      }return this;
    }

    // try to find the right one.
    var i = indexOf$1(state.pipes, dest);
    if (i === -1) return this;

    state.pipes.splice(i, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];

    dest.emit('unpipe', this);

    return this;
  };

  // set up data events if they are asked for
  // Ensure readable listeners eventually get something
  Readable$2.prototype.on = function (ev, fn) {
    var res = EE.prototype.on.call(this, ev, fn);

    if (ev === 'data') {
      // Start flowing on next tick if stream isn't explicitly paused
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          process.nextTick(nReadingNextTick$1, this);
        } else if (state.length) {
          emitReadable$1(this);
        }
      }
    }

    return res;
  };
  Readable$2.prototype.addListener = Readable$2.prototype.on;

  function nReadingNextTick$1(self) {
    debug$3('readable nexttick read 0');
    self.read(0);
  }

  // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.
  Readable$2.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
      debug$3('resume');
      state.flowing = true;
      resume$1(this, state);
    }
    return this;
  };

  function resume$1(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_$1, stream, state);
    }
  }

  function resume_$1(stream, state) {
    if (!state.reading) {
      debug$3('resume read 0');
      stream.read(0);
    }

    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit('resume');
    flow$1(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable$2.prototype.pause = function () {
    debug$3('call pause flowing=%j', this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug$3('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }
    return this;
  };

  function flow$1(stream) {
    var state = stream._readableState;
    debug$3('flow', state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }

  // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.
  Readable$2.prototype.wrap = function (stream) {
    var state = this._readableState;
    var paused = false;

    var self = this;
    stream.on('end', function () {
      debug$3('wrapped end');
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) self.push(chunk);
      }

      self.push(null);
    });

    stream.on('data', function (chunk) {
      debug$3('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk);

      // don't skip over falsy values in objectMode
      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = self.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });

    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function (method) {
          return function () {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }

    // proxy certain important events.
    var events = ['error', 'close', 'destroy', 'pause', 'resume'];
    forEach(events, function (ev) {
      stream.on(ev, self.emit.bind(self, ev));
    });

    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    self._read = function (n) {
      debug$3('wrapped _read', n);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return self;
  };

  // exposed for testing purposes only.
  Readable$2._fromList = fromList$1;

  // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromList$1(n, state) {
    // nothing buffered
    if (state.length === 0) return null;

    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = fromListPartial(n, state.buffer, state.decoder);
    }

    return ret;
  }

  // Extracts only enough buffered data to satisfy the amount requested.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      // slice is the same for buffers and strings
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      // first chunk is a perfect match
      ret = list.shift();
    } else {
      // result spans more than one buffer
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }

  // Copies a specified amount of characters from the list of buffered data
  // chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  // Copies a specified amount of bytes from the list of buffered data chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBuffer(n, list) {
    var ret = Buffer$8.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  function endReadable$1(stream) {
    var state = stream._readableState;

    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT$1, state, stream);
    }
  }

  function endReadableNT$1(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');
    }
  }

  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }

  function indexOf$1(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }

  // A bit simpler than readable streams.
  Writable$2.WritableState = WritableState$1;
  util$6.inherits(Writable$2, events.exports.EventEmitter);

  function nop$1() {}

  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }

  function WritableState$1(options, stream) {
    Object.defineProperty(this, 'buffer', {
      get: util$6.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
    options = options || {};

    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex$4) this.objectMode = this.objectMode || !!options.writableObjectMode;

    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;

    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;

    // a flag to see when we're in the middle of a write.
    this.writing = false;

    // when true all writes will be buffered until .uncork() call
    this.corked = 0;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;

    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function (er) {
      onwrite$1(stream, er);
    };

    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;

    // the amount that is being written when _write is called.
    this.writelen = 0;

    this.bufferedRequest = null;
    this.lastBufferedRequest = null;

    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;

    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;

    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;

    // count buffered requests
    this.bufferedRequestCount = 0;

    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest$1(this);
  }

  WritableState$1.prototype.getBuffer = function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  function Writable$2(options) {

    // Writable ctor is applied to Duplexes, though they're not
    // instanceof Writable, they're instanceof Readable.
    if (!(this instanceof Writable$2) && !(this instanceof Duplex$4)) return new Writable$2(options);

    this._writableState = new WritableState$1(options, this);

    // legacy.
    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;

      if (typeof options.writev === 'function') this._writev = options.writev;
    }

    events.exports.EventEmitter.call(this);
  }

  // Otherwise people can pipe Writable streams, which is just wrong.
  Writable$2.prototype.pipe = function () {
    this.emit('error', new Error('Cannot pipe, not readable'));
  };

  function writeAfterEnd$1(stream, cb) {
    var er = new Error('write after end');
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit('error', er);
    process.nextTick(cb, er);
  }

  // If we get something that is not a buffer, string, null, or undefined,
  // and we're not in objectMode, then that's an error.
  // Otherwise stream chunks are all considered to be of length=1, and the
  // watermarks determine how many objects to keep in the buffer, rather than
  // how many bytes or characters.
  function validChunk$1(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    // Always throw error if a null is written
    // if we are not in object mode then throw
    // if it is not a buffer, string, or undefined.
    if (chunk === null) {
      er = new TypeError('May not write null values to stream');
    } else if (!buffer.Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    if (er) {
      stream.emit('error', er);
      process.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }

  Writable$2.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (buffer.Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

    if (typeof cb !== 'function') cb = nop$1;

    if (state.ended) writeAfterEnd$1(this, cb);else if (validChunk$1(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer$1(this, state, chunk, encoding, cb);
    }

    return ret;
  };

  Writable$2.prototype.cork = function () {
    var state = this._writableState;

    state.corked++;
  };

  Writable$2.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;

      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer$1(this, state);
    }
  };

  Writable$2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  function decodeChunk$1(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = buffer.Buffer.from(chunk, encoding);
    }
    return chunk;
  }

  // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.
  function writeOrBuffer$1(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk$1(state, chunk, encoding);

    if (buffer.Buffer.isBuffer(chunk)) encoding = 'buffer';
    var len = state.objectMode ? 1 : chunk.length;

    state.length += len;

    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite$1(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite$1(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError$1(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) process.nextTick(cb, er);else cb(er);

    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  }

  function onwriteStateUpdate$1(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite$1(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;

    onwriteStateUpdate$1(state);

    if (er) onwriteError$1(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish$1(state);

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer$1(stream, state);
      }

      if (sync) {
        /*<replacement>*/
          process.nextTick(afterWrite$1, stream, state, finished, cb);
        /*</replacement>*/
      } else {
          afterWrite$1(stream, state, finished, cb);
        }
    }
  }

  function afterWrite$1(stream, state, finished, cb) {
    if (!finished) onwriteDrain$1(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe$1(stream, state);
  }

  // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.
  function onwriteDrain$1(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  }

  // if there's something in the buffer waiting, then process it
  function clearBuffer$1(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;

      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }

      doWrite$1(stream, state, true, state.length, buffer, '', holder.finish);

      // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest$1(state);
      }
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;

        doWrite$1(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable$2.prototype._write = function (chunk, encoding, cb) {
    cb(new Error('not implemented'));
  };

  Writable$2.prototype._writev = null;

  Writable$2.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

    // .end() fully uncorks
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }

    // ignore unnecessary end() calls.
    if (!state.ending && !state.finished) endWritable$1(this, state, cb);
  };

  function needFinish$1(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function prefinish$2(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }

  function finishMaybe$1(stream, state) {
    var need = needFinish$1(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish$2(stream, state);
        state.finished = true;
        stream.emit('finish');
      } else {
        prefinish$2(stream, state);
      }
    }
    return need;
  }

  function endWritable$1(stream, state, cb) {
    state.ending = true;
    finishMaybe$1(stream, state);
    if (cb) {
      if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
  }

  // It seems a linked list but it is not
  // there will be only 2 of these for each stream
  function CorkedRequest$1(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function (err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }

  util$6.inherits(Duplex$4, Readable$2);

  var keys$1 = Object.keys(Writable$2.prototype);
  for (var v$1 = 0; v$1 < keys$1.length; v$1++) {
    var method$1 = keys$1[v$1];
    if (!Duplex$4.prototype[method$1]) Duplex$4.prototype[method$1] = Writable$2.prototype[method$1];
  }
  function Duplex$4(options) {
    if (!(this instanceof Duplex$4)) return new Duplex$4(options);

    Readable$2.call(this, options);
    Writable$2.call(this, options);

    if (options && options.readable === false) this.readable = false;

    if (options && options.writable === false) this.writable = false;

    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

    this.once('end', onend$1);
  }

  // the no-half-open enforcer
  function onend$1() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;

    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT$1, this);
  }

  function onEndNT$1(self) {
    self.end();
  }

  // a transform stream is a readable/writable stream where you do
  util$6.inherits(Transform$2, Duplex$4);

  function TransformState(stream) {
    this.afterTransform = function (er, data) {
      return afterTransform$1(stream, er, data);
    };

    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }

  function afterTransform$1(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;

    var cb = ts.writecb;

    if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

    ts.writechunk = null;
    ts.writecb = null;

    if (data !== null && data !== undefined) stream.push(data);

    cb(er);

    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform$2(options) {
    if (!(this instanceof Transform$2)) return new Transform$2(options);

    Duplex$4.call(this, options);

    this._transformState = new TransformState(this);

    // when the writable side finishes, then flush out anything remaining.
    var stream = this;

    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;

    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;

      if (typeof options.flush === 'function') this._flush = options.flush;
    }

    this.once('prefinish', function () {
      if (typeof this._flush === 'function') this._flush(function (er) {
        done$1(stream, er);
      });else done$1(stream);
    });
  }

  Transform$2.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex$4.prototype.push.call(this, chunk, encoding);
  };

  // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.
  Transform$2.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('Not implemented');
  };

  Transform$2.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };

  // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.
  Transform$2.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  function done$1(stream, er) {
    if (er) return stream.emit('error', er);

    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    var ws = stream._writableState;
    var ts = stream._transformState;

    if (ws.length) throw new Error('Calling transform done when ws.length != 0');

    if (ts.transforming) throw new Error('Calling transform done when still transforming');

    return stream.push(null);
  }

  util$6.inherits(PassThrough$1, Transform$2);
  function PassThrough$1(options) {
    if (!(this instanceof PassThrough$1)) return new PassThrough$1(options);

    Transform$2.call(this, options);
  }

  PassThrough$1.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  util$6.inherits(Stream$2, EE);
  Stream$2.Readable = Readable$2;
  Stream$2.Writable = Writable$2;
  Stream$2.Duplex = Duplex$4;
  Stream$2.Transform = Transform$2;
  Stream$2.PassThrough = PassThrough$1;

  // Backwards-compat with node 0.4.x
  Stream$2.Stream = Stream$2;

  // old-style streams.  Note that the pipe method (the only relevant
  // part of this class) is overridden in the Readable class.

  function Stream$2() {
    EE.call(this);
  }

  Stream$2.prototype.pipe = function(dest, options) {
    var source = this;

    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }

    source.on('data', ondata);

    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }

    dest.on('drain', ondrain);

    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }

    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;

      dest.end();
    }


    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;

      if (typeof dest.destroy === 'function') dest.destroy();
    }

    // don't leave dangling pipes when there are errors.
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er; // Unhandled stream error in pipe.
      }
    }

    source.on('error', onerror);
    dest.on('error', onerror);

    // remove all the event listeners that were added.
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);

      source.removeListener('end', onend);
      source.removeListener('close', onclose);

      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);

      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);

      dest.removeListener('close', cleanup);
    }

    source.on('end', cleanup);
    source.on('close', cleanup);

    dest.on('close', cleanup);

    dest.emit('pipe', source);

    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
  };

  var _polyfillNode_stream = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': Stream$2,
    Readable: Readable$2,
    Writable: Writable$2,
    Duplex: Duplex$4,
    Transform: Transform$2,
    PassThrough: PassThrough$1,
    Stream: Stream$2
  });

  var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);

  var stream = require$$0$1;

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _require$2 = buffer,
      Buffer$3 = _require$2.Buffer;

  var _require2 = util$6,
      inspect = _require2.inspect;

  var custom = inspect && inspect.custom || 'inspect';

  function copyBuffer(src, target, offset) {
    Buffer$3.prototype.copy.call(src, target, offset);
  }

  var buffer_list =
  /*#__PURE__*/
  function () {
    function BufferList() {
      _classCallCheck(this, BufferList);

      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return '';
        var p = this.head;
        var ret = '' + p.data;

        while (p = p.next) {
          ret += s + p.data;
        }

        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer$3.alloc(0);
        var ret = Buffer$3.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;

        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }

        return ret;
      } // Consumes a specified amount of bytes or characters from the buffered data.

    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;

        if (n < this.head.data.length) {
          // `slice` is the same for buffers and strings.
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          // First chunk is a perfect match.
          ret = this.shift();
        } else {
          // Result spans more than one buffer.
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }

        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      } // Consumes a specified amount of characters from the buffered data.

    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;

        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;else ret += str.slice(0, n);
          n -= nb;

          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Consumes a specified amount of bytes from the buffered data.

    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer$3.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;

        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;

          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Make sure the linked list only shows the minimal necessary information.

    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread$1({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);

    return BufferList;
  }();

  function destroy(err, cb) {
    var _this = this;

    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;

    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          browser$1$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          browser$1$1.nextTick(emitErrorNT, this, err);
        }
      }

      return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks


    if (this._readableState) {
      this._readableState.destroyed = true;
    } // if this is a duplex stream mark the writable part as destroyed as well


    if (this._writableState) {
      this._writableState.destroyed = true;
    }

    this._destroy(err || null, function (err) {
      if (!cb && err) {
        if (!_this._writableState) {
          browser$1$1.nextTick(emitErrorAndCloseNT, _this, err);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          browser$1$1.nextTick(emitErrorAndCloseNT, _this, err);
        } else {
          browser$1$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        browser$1$1.nextTick(emitCloseNT, _this);
        cb(err);
      } else {
        browser$1$1.nextTick(emitCloseNT, _this);
      }
    });

    return this;
  }

  function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
  }

  function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit('close');
  }

  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }

    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }

  function emitErrorNT(self, err) {
    self.emit('error', err);
  }

  function errorOrDestroy$2(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
  }

  var destroy_1 = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy$2
  };

  var errors = {};

  const codes = {};

  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    function getMessage (arg1, arg2, arg3) {
      if (typeof message === 'string') {
        return message
      } else {
        return message(arg1, arg2, arg3)
      }
    }

    class NodeError extends Base {
      constructor (arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }

    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;

    codes[code] = NodeError;
  }

  // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
               expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
  function startsWith(str, search, pos) {
  	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
  function endsWith(str, search, this_len) {
  	if (this_len === undefined || this_len > str.length) {
  		this_len = str.length;
  	}
  	return str.substring(this_len - search.length, this_len) === search;
  }

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
  function includes(str, search, start) {
    if (typeof start !== 'number') {
      start = 0;
    }

    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }

  createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"'
  }, TypeError);
  createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;
    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
      determiner = 'must not be';
      expected = expected.replace(/^not /, '');
    } else {
      determiner = 'must be';
    }

    let msg;
    if (endsWith(name, ' argument')) {
      // For cases like 'first argument'
      msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
    } else {
      const type = includes(name, '.') ? 'property' : 'argument';
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
    }

    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
  createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
    return 'The ' + name + ' method is not implemented'
  });
  createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
  createErrorType('ERR_STREAM_DESTROYED', function (name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
  });
  createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
  createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
  createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
  createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
  createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
    return 'Unknown encoding: ' + arg
  }, TypeError);
  createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

  errors.codes = codes;

  var ERR_INVALID_OPT_VALUE = errors.codes.ERR_INVALID_OPT_VALUE;

  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }

  function getHighWaterMark$2(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : 'highWaterMark';
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }

      return Math.floor(hwm);
    } // Default value


    return state.objectMode ? 16 : 16 * 1024;
  }

  var state = {
    getHighWaterMark: getHighWaterMark$2
  };

  /**
   * For Node.js, simply re-export the core `util.deprecate` function.
   */

  var node$1 = util$6.deprecate;

  var _stream_writable = Writable$1;
  // there will be only 2 of these for each stream


  function CorkedRequest(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function () {
      onCorkedFinish(_this, state);
    };
  }
  /* </replacement> */

  /*<replacement>*/


  var Duplex$3;
  /*</replacement>*/

  Writable$1.WritableState = WritableState;
  /*<replacement>*/

  var internalUtil = {
    deprecate: node$1
  };
  /*</replacement>*/

  /*<replacement>*/

  var Stream$1 = stream;
  /*</replacement>*/


  var Buffer$2 = buffer.Buffer;

  var OurUint8Array$1 = commonjsGlobal.Uint8Array || function () {};

  function _uint8ArrayToBuffer$1(chunk) {
    return Buffer$2.from(chunk);
  }

  function _isUint8Array$1(obj) {
    return Buffer$2.isBuffer(obj) || obj instanceof OurUint8Array$1;
  }

  var destroyImpl$1 = destroy_1;

  var _require$1 = state,
      getHighWaterMark$1 = _require$1.getHighWaterMark;

  var _require$codes$3 = errors.codes,
      ERR_INVALID_ARG_TYPE$2 = _require$codes$3.ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE = _require$codes$3.ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED,
      ERR_STREAM_NULL_VALUES = _require$codes$3.ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END = _require$codes$3.ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING = _require$codes$3.ERR_UNKNOWN_ENCODING;

  var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;

  inherits$1.exports(Writable$1, Stream$1);

  function nop() {}

  function WritableState(options, stream, isDuplex) {
    Duplex$3 = Duplex$3 || _stream_duplex;
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$3; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()

    this.highWaterMark = getHighWaterMark$1(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

    this.finalCalled = false; // drain event flag.

    this.needDrain = false; // at the start of calling end()

    this.ending = false; // when end() has been called, and returned

    this.ended = false; // when 'finish' is emitted

    this.finished = false; // has it been destroyed

    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.

    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.

    this.length = 0; // a flag to see when we're in the middle of a write.

    this.writing = false; // when true all writes will be buffered until .uncork() call

    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.

    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.

    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

    this.onwrite = function (er) {
      onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)


    this.writecb = null; // the amount that is being written when _write is called.

    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted

    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams

    this.prefinished = false; // True if the error was already emitted and should not be thrown again

    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

    this.autoDestroy = !!options.autoDestroy; // count buffered requests

    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two

    this.corkedRequestsFree = new CorkedRequest(this);
  }

  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];

    while (current) {
      out.push(current);
      current = current.next;
    }

    return out;
  };

  (function () {
    try {
      Object.defineProperty(WritableState.prototype, 'buffer', {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
      });
    } catch (_) {}
  })(); // Test _writableState for inheritance to account for Duplex streams,
  // whose prototype chain only points to Readable.


  var realHasInstance;

  if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable$1, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable$1) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }

  function Writable$1(options) {
    Duplex$3 = Duplex$3 || _stream_duplex; // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex$3;
    if (!isDuplex && !realHasInstance.call(Writable$1, this)) return new Writable$1(options);
    this._writableState = new WritableState(options, this, isDuplex); // legacy.

    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;
      if (typeof options.writev === 'function') this._writev = options.writev;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
      if (typeof options.final === 'function') this._final = options.final;
    }

    Stream$1.call(this);
  } // Otherwise people can pipe Writable streams, which is just wrong.


  Writable$1.prototype.pipe = function () {
    errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
  };

  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

    errorOrDestroy$1(stream, er);
    browser$1$1.nextTick(cb, er);
  } // Checks that a user-supplied chunk is valid, especially for the particular
  // mode the stream is in. Currently this means that `null` is never accepted
  // and undefined/non-string values are only allowed in object mode.


  function validChunk(stream, state, chunk, cb) {
    var er;

    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== 'string' && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE$2('chunk', ['string', 'Buffer'], chunk);
    }

    if (er) {
      errorOrDestroy$1(stream, er);
      browser$1$1.nextTick(cb, er);
      return false;
    }

    return true;
  }

  Writable$1.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    var isBuf = !state.objectMode && _isUint8Array$1(chunk);

    if (isBuf && !Buffer$2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer$1(chunk);
    }

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop;
    if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };

  Writable$1.prototype.cork = function () {
    this._writableState.corked++;
  };

  Writable$1.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };

  Writable$1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  Object.defineProperty(Writable$1.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });

  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer$2.from(chunk, encoding);
    }

    return chunk;
  }

  Object.defineProperty(Writable$1.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  }); // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.

  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);

      if (chunk !== newChunk) {
        isBuf = true;
        encoding = 'buffer';
        chunk = newChunk;
      }
    }

    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk: chunk,
        encoding: encoding,
        isBuf: isBuf,
        callback: cb,
        next: null
      };

      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }

      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED$1('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;

    if (sync) {
      // defer the callback if we are being called synchronously
      // to avoid piling up things on the stack
      browser$1$1.nextTick(cb, er); // this can emit finish, and it will always happen
      // after error

      browser$1$1.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy$1(stream, er);
    } else {
      // the caller expect this to happen before if
      // it is async
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy$1(stream, er); // this can emit finish, but finish must
      // always follow error

      finishMaybe(stream, state);
    }
  }

  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK$1();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state) || stream.destroyed;

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }

      if (sync) {
        browser$1$1.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }

  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  } // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.


  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  } // if there's something in the buffer waiting, then process it


  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;

      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }

      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite

      state.pendingcb++;
      state.lastBufferedRequest = null;

      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }

      state.bufferedRequestCount = 0;
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.

        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable$1.prototype._write = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED$2('_write()'));
  };

  Writable$1.prototype._writev = null;

  Writable$1.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

    if (state.corked) {
      state.corked = 1;
      this.uncork();
    } // ignore unnecessary end() calls.


    if (!state.ending) endWritable(this, state, cb);
    return this;
  };

  Object.defineProperty(Writable$1.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });

  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function callFinal(stream, state) {
    stream._final(function (err) {
      state.pendingcb--;

      if (err) {
        errorOrDestroy$1(stream, err);
      }

      state.prefinished = true;
      stream.emit('prefinish');
      finishMaybe(stream, state);
    });
  }

  function prefinish$1(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === 'function' && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        browser$1$1.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
  }

  function finishMaybe(stream, state) {
    var need = needFinish(state);

    if (need) {
      prefinish$1(stream, state);

      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit('finish');

        if (state.autoDestroy) {
          // In case of duplex streams we need a way to detect
          // if the readable side is ready for autoDestroy as well
          var rState = stream._readableState;

          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }

    return need;
  }

  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);

    if (cb) {
      if (state.finished) browser$1$1.nextTick(cb);else stream.once('finish', cb);
    }

    state.ended = true;
    stream.writable = false;
  }

  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;

    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    } // reuse the free corkReq.


    state.corkedRequestsFree.next = corkReq;
  }

  Object.defineProperty(Writable$1.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }

      return this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._writableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._writableState.destroyed = value;
    }
  });
  Writable$1.prototype.destroy = destroyImpl$1.destroy;
  Writable$1.prototype._undestroy = destroyImpl$1.undestroy;

  Writable$1.prototype._destroy = function (err, cb) {
    cb(err);
  };

  /*<replacement>*/

  var objectKeys = Object.keys || function (obj) {
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    }

    return keys;
  };
  /*</replacement>*/


  var _stream_duplex = Duplex$2;

  var Readable$1 = _stream_readable;

  var Writable = _stream_writable;

  inherits$1.exports(Duplex$2, Readable$1);

  {
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable.prototype);

    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex$2.prototype[method]) Duplex$2.prototype[method] = Writable.prototype[method];
    }
  }

  function Duplex$2(options) {
    if (!(this instanceof Duplex$2)) return new Duplex$2(options);
    Readable$1.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;

    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;

      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once('end', onend);
      }
    }
  }

  Object.defineProperty(Duplex$2.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex$2.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex$2.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  }); // the no-half-open enforcer

  function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.

    browser$1$1.nextTick(onEndNT, this);
  }

  function onEndNT(self) {
    self.end();
  }

  Object.defineProperty(Duplex$2.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }

      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });

  var ERR_STREAM_PREMATURE_CLOSE = errors.codes.ERR_STREAM_PREMATURE_CLOSE;

  function once$1(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      callback.apply(this, args);
    };
  }

  function noop$1() {}

  function isRequest$1(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
  }

  function eos$1(stream, opts, callback) {
    if (typeof opts === 'function') return eos$1(stream, null, opts);
    if (!opts) opts = {};
    callback = once$1(callback || noop$1);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;

    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable) onfinish();
    };

    var writableEnded = stream._writableState && stream._writableState.finished;

    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };

    var readableEnded = stream._readableState && stream._readableState.endEmitted;

    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };

    var onerror = function onerror(err) {
      callback.call(stream, err);
    };

    var onclose = function onclose() {
      var err;

      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }

      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };

    var onrequest = function onrequest() {
      stream.req.on('finish', onfinish);
    };

    if (isRequest$1(stream)) {
      stream.on('complete', onfinish);
      stream.on('abort', onclose);
      if (stream.req) onrequest();else stream.on('request', onrequest);
    } else if (writable && !stream._writableState) {
      // legacy streams
      stream.on('end', onlegacyfinish);
      stream.on('close', onlegacyfinish);
    }

    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function () {
      stream.removeListener('complete', onfinish);
      stream.removeListener('abort', onclose);
      stream.removeListener('request', onrequest);
      if (stream.req) stream.req.removeListener('finish', onfinish);
      stream.removeListener('end', onlegacyfinish);
      stream.removeListener('close', onlegacyfinish);
      stream.removeListener('finish', onfinish);
      stream.removeListener('end', onend);
      stream.removeListener('error', onerror);
      stream.removeListener('close', onclose);
    };
  }

  var endOfStream = eos$1;

  var _Object$setPrototypeO;

  function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var finished = endOfStream;

  var kLastResolve = Symbol('lastResolve');
  var kLastReject = Symbol('lastReject');
  var kError = Symbol('error');
  var kEnded = Symbol('ended');
  var kLastPromise = Symbol('lastPromise');
  var kHandlePromise = Symbol('handlePromise');
  var kStream = Symbol('stream');

  function createIterResult(value, done) {
    return {
      value: value,
      done: done
    };
  }

  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];

    if (resolve !== null) {
      var data = iter[kStream].read(); // we defer if data is null
      // we can be expecting either 'end' or
      // 'error'

      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }

  function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    browser$1$1.nextTick(readAndResolve, iter);
  }

  function wrapForNext(lastPromise, iter) {
    return function (resolve, reject) {
      lastPromise.then(function () {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }

        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }

  var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },

    next: function next() {
      var _this = this;

      // if we have detected an error in the meanwhile
      // reject straight away
      var error = this[kError];

      if (error !== null) {
        return Promise.reject(error);
      }

      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }

      if (this[kStream].destroyed) {
        // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function (resolve, reject) {
          browser$1$1.nextTick(function () {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      } // if we have multiple next() calls
      // we will wait for the previous Promise to finish
      // this logic is optimized to support for await loops,
      // where next() is only called once at a time


      var lastPromise = this[kLastPromise];
      var promise;

      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        // fast path needed to support multiple this.push()
        // without triggering the next() queue
        var data = this[kStream].read();

        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }

        promise = new Promise(this[kHandlePromise]);
      }

      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty$1(_Object$setPrototypeO, Symbol.asyncIterator, function () {
    return this;
  }), _defineProperty$1(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;

    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function (resolve, reject) {
      _this2[kStream].destroy(null, function (err) {
        if (err) {
          reject(err);
          return;
        }

        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);

  var createReadableStreamAsyncIterator$1 = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;

    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$1(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty$1(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty$1(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();

        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function (err) {
      if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
        var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
        // returned by next() and store the error

        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }

        iterator[kError] = err;
        return;
      }

      var resolve = iterator[kLastResolve];

      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }

      iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
  };

  var async_iterator = createReadableStreamAsyncIterator$1;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

  function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var ERR_INVALID_ARG_TYPE$1 = errors.codes.ERR_INVALID_ARG_TYPE;

  function from$1(Readable, iterable, opts) {
    var iterator;

    if (iterable && typeof iterable.next === 'function') {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE$1('iterable', ['Iterable'], iterable);

    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts)); // Reading boolean to protect against _read
    // being called before last iteration completion.

    var reading = false;

    readable._read = function () {
      if (!reading) {
        reading = true;
        next();
      }
    };

    function next() {
      return _next2.apply(this, arguments);
    }

    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _ref = yield iterator.next(),
              value = _ref.value,
              done = _ref.done;

          if (done) {
            readable.push(null);
          } else if (readable.push((yield value))) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }

    return readable;
  }

  var from_1 = from$1;

  var _stream_readable = Readable;
  /*<replacement>*/

  var Duplex$1;
  /*</replacement>*/

  Readable.ReadableState = ReadableState;
  /*<replacement>*/

  events.exports.EventEmitter;

  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  /*</replacement>*/

  /*<replacement>*/


  var Stream = stream;
  /*</replacement>*/


  var Buffer$1 = buffer.Buffer;

  var OurUint8Array = commonjsGlobal.Uint8Array || function () {};

  function _uint8ArrayToBuffer(chunk) {
    return Buffer$1.from(chunk);
  }

  function _isUint8Array(obj) {
    return Buffer$1.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  /*<replacement>*/


  var debugUtil = util$6;

  var debug$2;

  if (debugUtil && debugUtil.debuglog) {
    debug$2 = debugUtil.debuglog('stream');
  } else {
    debug$2 = function debug() {};
  }
  /*</replacement>*/


  var BufferList = buffer_list;

  var destroyImpl = destroy_1;

  var _require = state,
      getHighWaterMark = _require.getHighWaterMark;

  var _require$codes$2 = errors.codes,
      ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE,
      ERR_STREAM_PUSH_AFTER_EOF = _require$codes$2.ERR_STREAM_PUSH_AFTER_EOF,
      ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;

  inherits$1.exports(Readable, Stream);

  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.

    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }

  function ReadableState(options, stream, isDuplex) {
    Duplex$1 = Duplex$1 || _stream_duplex;
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.

    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$1; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"

    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()

    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.

    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.

    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

    this.autoDestroy = !!options.autoDestroy; // has it been destroyed

    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;

    if (options.encoding) {
      if (!StringDecoder) StringDecoder = string_decoder.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }

  function Readable(options) {
    Duplex$1 = Duplex$1 || _stream_duplex;
    if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex$1;
    this._readableState = new ReadableState(options, this, isDuplex); // legacy

    this.readable = true;

    if (options) {
      if (typeof options.read === 'function') this._read = options.read;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }

    Stream.call(this);
  }

  Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }

      return this._readableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._readableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;

  Readable.prototype._destroy = function (err, cb) {
    cb(err);
  }; // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.


  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;

    if (!state.objectMode) {
      if (typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;

        if (encoding !== state.encoding) {
          chunk = Buffer$1.from(chunk, encoding);
          encoding = '';
        }

        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }

    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  }; // Unshift should *always* be something directly out of read()


  Readable.prototype.unshift = function (chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };

  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug$2('readableAddChunk', chunk);
    var state = stream._readableState;

    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);

      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer$1.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }

        if (addToFront) {
          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;

          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.


    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }

  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit('data', chunk);
    } else {
      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
      if (state.needReadable) emitReadable(stream);
    }

    maybeReadMore(stream, state);
  }

  function chunkInvalid(state, chunk) {
    var er;

    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    }

    return er;
  }

  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  }; // backwards compatibility.


  Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder) StringDecoder = string_decoder.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

    var p = this._readableState.buffer.head;
    var content = '';

    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }

    this._readableState.buffer.clear();

    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  }; // Don't raise the hwm > 1GB


  var MAX_HWM = 0x40000000;

  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }

    return n;
  } // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;

    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.


    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n; // Don't have enough

    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }

    return state.length;
  } // you can override either this method, or the async _read(n) below.


  Readable.prototype.read = function (n) {
    debug$2('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.

    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug$2('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }

    n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.


    var doRead = state.needReadable;
    debug$2('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug$2('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.


    if (state.ended || state.reading) {
      doRead = false;
      debug$2('reading or ended', doRead);
    } else if (doRead) {
      debug$2('do read');
      state.reading = true;
      state.sync = true; // if the length is currently zero, then we *need* a readable event.

      if (state.length === 0) state.needReadable = true; // call internal read method

      this._read(state.highWaterMark);

      state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.

      if (!state.reading) n = howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

      if (nOrig !== n && state.ended) endReadable(this);
    }

    if (ret !== null) this.emit('data', ret);
    return ret;
  };

  function onEofChunk(stream, state) {
    debug$2('onEofChunk');
    if (state.ended) return;

    if (state.decoder) {
      var chunk = state.decoder.end();

      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }

    state.ended = true;

    if (state.sync) {
      // if we are sync, wait until next tick to emit the data.
      // Otherwise we risk emitting data in the flow()
      // the readable code triggers during a read() call
      emitReadable(stream);
    } else {
      // emit 'readable' now to make sure it gets picked up.
      state.needReadable = false;

      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  } // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.


  function emitReadable(stream) {
    var state = stream._readableState;
    debug$2('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;

    if (!state.emittedReadable) {
      debug$2('emitReadable', state.flowing);
      state.emittedReadable = true;
      browser$1$1.nextTick(emitReadable_, stream);
    }
  }

  function emitReadable_(stream) {
    var state = stream._readableState;
    debug$2('emitReadable_', state.destroyed, state.length, state.ended);

    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit('readable');
      state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.


    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  } // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.


  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      browser$1$1.nextTick(maybeReadMore_, stream, state);
    }
  }

  function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug$2('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length) // didn't get any data, stop spinning.
        break;
    }

    state.readingMore = false;
  } // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.


  Readable.prototype._read = function (n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED$1('_read()'));
  };

  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;

      case 1:
        state.pipes = [state.pipes, dest];
        break;

      default:
        state.pipes.push(dest);
        break;
    }

    state.pipesCount += 1;
    debug$2('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) browser$1$1.nextTick(endFn);else src.once('end', endFn);
    dest.on('unpipe', onunpipe);

    function onunpipe(readable, unpipeInfo) {
      debug$2('onunpipe');

      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }

    function onend() {
      debug$2('onend');
      dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.


    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;

    function cleanup() {
      debug$2('cleanup'); // cleanup event handlers once the pipe is broken

      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', unpipe);
      src.removeListener('data', ondata);
      cleanedUp = true; // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.

      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    src.on('data', ondata);

    function ondata(chunk) {
      debug$2('ondata');
      var ret = dest.write(chunk);
      debug$2('dest.write', ret);

      if (ret === false) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug$2('false write response, pause', state.awaitDrain);
          state.awaitDrain++;
        }

        src.pause();
      }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.


    function onerror(er) {
      debug$2('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.


    prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }

    dest.once('close', onclose);

    function onfinish() {
      debug$2('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }

    dest.once('finish', onfinish);

    function unpipe() {
      debug$2('unpipe');
      src.unpipe(dest);
    } // tell the dest that it's being piped to


    dest.emit('pipe', src); // start the flow if it hasn't been started already.

    if (!state.flowing) {
      debug$2('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug$2('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;

      if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
        state.flowing = true;
        flow(src);
      }
    };
  }

  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.

    if (state.pipesCount === 0) return this; // just one destination.  most common case.

    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes; // got a match.

      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this, unpipeInfo);
      return this;
    } // slow case. multiple pipe destinations.


    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var i = 0; i < len; i++) {
        dests[i].emit('unpipe', this, {
          hasUnpiped: false
        });
      }

      return this;
    } // try to find the right one.


    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
  }; // set up data events if they are asked for
  // Ensure readable listeners eventually get something


  Readable.prototype.on = function (ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;

    if (ev === 'data') {
      // update readableListening so that resume() may be a no-op
      // a few lines down. This is needed to support once('readable').
      state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

      if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug$2('on readable', state.length, state.reading);

        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          browser$1$1.nextTick(nReadingNextTick, this);
        }
      }
    }

    return res;
  };

  Readable.prototype.addListener = Readable.prototype.on;

  Readable.prototype.removeListener = function (ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);

    if (ev === 'readable') {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      browser$1$1.nextTick(updateReadableListening, this);
    }

    return res;
  };

  Readable.prototype.removeAllListeners = function (ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);

    if (ev === 'readable' || ev === undefined) {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      browser$1$1.nextTick(updateReadableListening, this);
    }

    return res;
  };

  function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;

    if (state.resumeScheduled && !state.paused) {
      // flowing needs to be set to true now, otherwise
      // the upcoming resume will not flow.
      state.flowing = true; // crude way to check if we should resume
    } else if (self.listenerCount('data') > 0) {
      self.resume();
    }
  }

  function nReadingNextTick(self) {
    debug$2('readable nexttick read 0');
    self.read(0);
  } // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.


  Readable.prototype.resume = function () {
    var state = this._readableState;

    if (!state.flowing) {
      debug$2('resume'); // we flow only if there is no one listening
      // for readable, but we still have to call
      // resume()

      state.flowing = !state.readableListening;
      resume(this, state);
    }

    state.paused = false;
    return this;
  };

  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      browser$1$1.nextTick(resume_, stream, state);
    }
  }

  function resume_(stream, state) {
    debug$2('resume', state.reading);

    if (!state.reading) {
      stream.read(0);
    }

    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable.prototype.pause = function () {
    debug$2('call pause flowing=%j', this._readableState.flowing);

    if (this._readableState.flowing !== false) {
      debug$2('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }

    this._readableState.paused = true;
    return this;
  };

  function flow(stream) {
    var state = stream._readableState;
    debug$2('flow', state.flowing);

    while (state.flowing && stream.read() !== null) {
    }
  } // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.


  Readable.prototype.wrap = function (stream) {
    var _this = this;

    var state = this._readableState;
    var paused = false;
    stream.on('end', function () {
      debug$2('wrapped end');

      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }

      _this.push(null);
    });
    stream.on('data', function (chunk) {
      debug$2('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = _this.push(chunk);

      if (!ret) {
        paused = true;
        stream.pause();
      }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.

    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    } // proxy certain important events.


    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    } // when we try to consume some more bytes, simply unpause the
    // underlying stream.


    this._read = function (n) {
      debug$2('wrapped _read', n);

      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return this;
  };

  if (typeof Symbol === 'function') {
    Readable.prototype[Symbol.asyncIterator] = function () {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = async_iterator;
      }

      return createReadableStreamAsyncIterator(this);
    };
  }

  Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  }); // exposed for testing purposes only.

  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  }); // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.

  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }

  function endReadable(stream) {
    var state = stream._readableState;
    debug$2('endReadable', state.endEmitted);

    if (!state.endEmitted) {
      state.ended = true;
      browser$1$1.nextTick(endReadableNT, state, stream);
    }
  }

  function endReadableNT(state, stream) {
    debug$2('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the writable side is ready for autoDestroy as well
        var wState = stream._writableState;

        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }

  if (typeof Symbol === 'function') {
    Readable.from = function (iterable, opts) {
      if (from === undefined) {
        from = from_1;
      }

      return from(Readable, iterable, opts);
    };
  }

  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }

    return -1;
  }

  var _stream_transform = Transform$1;

  var _require$codes$1 = errors.codes,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK,
      ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;

  var Duplex = _stream_duplex;

  inherits$1.exports(Transform$1, Duplex);

  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;

    if (cb === null) {
      return this.emit('error', new ERR_MULTIPLE_CALLBACK());
    }

    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;

    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }

  function Transform$1(options) {
    if (!(this instanceof Transform$1)) return new Transform$1(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }; // start out asking for a readable event once data is transformed.

    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.

    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;
      if (typeof options.flush === 'function') this._flush = options.flush;
    } // When the writable side finishes, then flush out anything remaining.


    this.on('prefinish', prefinish);
  }

  function prefinish() {
    var _this = this;

    if (typeof this._flush === 'function' && !this._readableState.destroyed) {
      this._flush(function (er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }

  Transform$1.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  }; // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.


  Transform$1.prototype._transform = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
  };

  Transform$1.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;

    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  }; // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.


  Transform$1.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;

      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  Transform$1.prototype._destroy = function (err, cb) {
    Duplex.prototype._destroy.call(this, err, function (err2) {
      cb(err2);
    });
  };

  function done(stream, er, data) {
    if (er) return stream.emit('error', er);
    if (data != null) // single equals check for both `null` and `undefined`
      stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided

    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }

  var _stream_passthrough = PassThrough;

  var Transform = _stream_transform;

  inherits$1.exports(PassThrough, Transform);

  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  var eos;

  function once(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }

  var _require$codes = errors.codes,
      ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

  function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
  }

  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
  }

  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function () {
      closed = true;
    });
    if (eos === undefined) eos = endOfStream;
    eos(stream, {
      readable: reading,
      writable: writing
    }, function (err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function (err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true; // request.destroy just do .end - .abort is what we want

      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === 'function') return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED('pipe'));
    };
  }

  function call$1(fn) {
    fn();
  }

  function pipe(from, to) {
    return from.pipe(to);
  }

  function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== 'function') return noop;
    return streams.pop();
  }

  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }

    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];

    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS('streams');
    }

    var error;
    var destroys = streams.map(function (stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function (err) {
        if (!error) error = err;
        if (err) destroys.forEach(call$1);
        if (reading) return;
        destroys.forEach(call$1);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }

  var pipeline_1 = pipeline;

  (function (module, exports) {
  var Stream = require$$0$1;
  if (browser$1$1.env.READABLE_STREAM === 'disable' && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = _stream_readable;
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = _stream_writable;
    exports.Duplex = _stream_duplex;
    exports.Transform = _stream_transform;
    exports.PassThrough = _stream_passthrough;
    exports.finished = endOfStream;
    exports.pipeline = pipeline_1;
  }
  }(readable, readable.exports));

  Object.defineProperty(readStream, "__esModule", { value: true });
  readStream.TrieReadStream = void 0;
  const readable_stream_1 = readable.exports;
  const nibbles_1$5 = nibbles;
  class TrieReadStream extends readable_stream_1.Readable {
      constructor(trie) {
          super({ objectMode: true });
          this.trie = trie;
          this._started = false;
      }
      async _read() {
          if (this._started) {
              return;
          }
          this._started = true;
          try {
              await this.trie._findValueNodes(async (nodeRef, node, key, walkController) => {
                  if (node !== null) {
                      this.push({
                          key: (0, nibbles_1$5.nibblesToBuffer)(key),
                          value: node.value,
                      });
                      walkController.allChildren(node, key);
                  }
              });
          }
          catch (error) {
              if (error.message == 'Missing node in DB') ;
              else {
                  throw error;
              }
          }
          this.push(null);
      }
  }
  readStream.TrieReadStream = TrieReadStream;

  var walkController = {};

  var node = {};

  var branch = {};

  Object.defineProperty(branch, "__esModule", { value: true });
  branch.BranchNode = void 0;
  const rlp_1$e = dist$9;
  const util_1$o = dist$a;
  class BranchNode {
      constructor() {
          this._branches = new Array(16).fill(null);
          this._value = null;
      }
      static fromArray(arr) {
          const node = new BranchNode();
          node._branches = arr.slice(0, 16);
          node._value = arr[16];
          return node;
      }
      get value() {
          return this._value && this._value.length > 0 ? this._value : null;
      }
      set value(v) {
          this._value = v;
      }
      setBranch(i, v) {
          this._branches[i] = v;
      }
      raw() {
          return [...this._branches, this._value];
      }
      serialize() {
          return Buffer$8.from(rlp_1$e.RLP.encode((0, util_1$o.bufArrToArr)(this.raw())));
      }
      getBranch(i) {
          const b = this._branches[i];
          if (b !== null && b.length > 0) {
              return b;
          }
          else {
              return null;
          }
      }
      getChildren() {
          const children = [];
          for (let i = 0; i < 16; i++) {
              const b = this._branches[i];
              if (b !== null && b.length > 0) {
                  children.push([i, b]);
              }
          }
          return children;
      }
  }
  branch.BranchNode = BranchNode;

  var extension = {};

  var hex = {};

  Object.defineProperty(hex, "__esModule", { value: true });
  hex.isTerminator = hex.removeHexPrefix = hex.addHexPrefix = void 0;
  /**
   * Prepends hex prefix to an array of nibbles.
   * @param key - Array of nibbles
   * @returns returns buffer of encoded data
   **/
  function addHexPrefix(key, terminator) {
      // odd
      if (key.length % 2) {
          key.unshift(1);
      }
      else {
          // even
          key.unshift(0);
          key.unshift(0);
      }
      if (terminator) {
          key[0] += 2;
      }
      return key;
  }
  hex.addHexPrefix = addHexPrefix;
  /**
   * Removes hex prefix of an array of nibbles.
   * @param val - Array of nibbles
   * @private
   */
  function removeHexPrefix(val) {
      if (val[0] % 2) {
          val = val.slice(1);
      }
      else {
          val = val.slice(2);
      }
      return val;
  }
  hex.removeHexPrefix = removeHexPrefix;
  /**
   * Returns true if hex-prefixed path is for a terminating (leaf) node.
   * @param key - a hex-prefixed array of nibbles
   * @private
   */
  function isTerminator(key) {
      return key[0] > 1;
  }
  hex.isTerminator = isTerminator;

  Object.defineProperty(extension, "__esModule", { value: true });
  extension.ExtensionNode = void 0;
  const rlp_1$d = dist$9;
  const util_1$n = dist$a;
  const hex_1$2 = hex;
  const nibbles_1$4 = nibbles;
  class ExtensionNode {
      constructor(nibbles, value) {
          this._nibbles = nibbles;
          this._value = value;
      }
      static encodeKey(key) {
          return (0, hex_1$2.addHexPrefix)(key, false);
      }
      static decodeKey(key) {
          return (0, hex_1$2.removeHexPrefix)(key);
      }
      get key() {
          return this._nibbles.slice(0);
      }
      set key(k) {
          this._nibbles = k;
      }
      get keyLength() {
          return this._nibbles.length;
      }
      get value() {
          return this._value;
      }
      set value(v) {
          this._value = v;
      }
      encodedKey() {
          return ExtensionNode.encodeKey(this._nibbles.slice(0));
      }
      raw() {
          return [(0, nibbles_1$4.nibblesToBuffer)(this.encodedKey()), this._value];
      }
      serialize() {
          return Buffer$8.from(rlp_1$d.RLP.encode((0, util_1$n.bufArrToArr)(this.raw())));
      }
  }
  extension.ExtensionNode = ExtensionNode;

  var leaf = {};

  Object.defineProperty(leaf, "__esModule", { value: true });
  leaf.LeafNode = void 0;
  const rlp_1$c = dist$9;
  const util_1$m = dist$a;
  const hex_1$1 = hex;
  const nibbles_1$3 = nibbles;
  class LeafNode {
      constructor(nibbles, value) {
          this._nibbles = nibbles;
          this._value = value;
      }
      static encodeKey(key) {
          return (0, hex_1$1.addHexPrefix)(key, true);
      }
      static decodeKey(encodedKey) {
          return (0, hex_1$1.removeHexPrefix)(encodedKey);
      }
      get key() {
          return this._nibbles.slice(0);
      }
      set key(k) {
          this._nibbles = k;
      }
      get keyLength() {
          return this._nibbles.length;
      }
      get value() {
          return this._value;
      }
      set value(v) {
          this._value = v;
      }
      encodedKey() {
          return LeafNode.encodeKey(this._nibbles.slice(0));
      }
      raw() {
          return [(0, nibbles_1$3.nibblesToBuffer)(this.encodedKey()), this._value];
      }
      serialize() {
          return Buffer$8.from(rlp_1$c.RLP.encode((0, util_1$m.bufArrToArr)(this.raw())));
      }
  }
  leaf.LeafNode = LeafNode;

  var util$3 = {};

  Object.defineProperty(util$3, "__esModule", { value: true });
  util$3.isRawNode = util$3.decodeNode = util$3.decodeRawNode = void 0;
  const rlp_1$b = dist$9;
  const util_1$l = dist$a;
  const hex_1 = hex;
  const nibbles_1$2 = nibbles;
  const branch_1 = branch;
  const extension_1 = extension;
  const leaf_1 = leaf;
  function decodeRawNode(raw) {
      if (raw.length === 17) {
          return branch_1.BranchNode.fromArray(raw);
      }
      else if (raw.length === 2) {
          const nibbles = (0, nibbles_1$2.bufferToNibbles)(raw[0]);
          if ((0, hex_1.isTerminator)(nibbles)) {
              return new leaf_1.LeafNode(leaf_1.LeafNode.decodeKey(nibbles), raw[1]);
          }
          return new extension_1.ExtensionNode(extension_1.ExtensionNode.decodeKey(nibbles), raw[1]);
      }
      else {
          throw new Error('Invalid node');
      }
  }
  util$3.decodeRawNode = decodeRawNode;
  function decodeNode(raw) {
      const des = (0, util_1$l.arrToBufArr)(rlp_1$b.RLP.decode(Uint8Array.from(raw)));
      if (!Array.isArray(des)) {
          throw new Error('Invalid node');
      }
      return decodeRawNode(des);
  }
  util$3.decodeNode = decodeNode;
  function isRawNode(n) {
      return Array.isArray(n) && !Buffer$8.isBuffer(n);
  }
  util$3.isRawNode = isRawNode;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(branch, exports);
  __exportStar(extension, exports);
  __exportStar(leaf, exports);
  __exportStar(util$3, exports);

  }(node));

  var tasks = {};

  Object.defineProperty(tasks, "__esModule", { value: true });
  tasks.PrioritizedTaskExecutor = void 0;
  class PrioritizedTaskExecutor {
      /**
       * Executes tasks up to maxPoolSize at a time, other items are put in a priority queue.
       * @class PrioritizedTaskExecutor
       * @private
       * @param maxPoolSize The maximum size of the pool
       */
      constructor(maxPoolSize) {
          this.maxPoolSize = maxPoolSize;
          this.currentPoolSize = 0;
          this.queue = [];
      }
      /**
       * Executes the task or queues it if no spots are available.
       * When a task is added, check if there are spots left in the pool.
       * If a spot is available, claim that spot and give back the spot once the asynchronous task has been resolved.
       * When no spots are available, add the task to the task queue. The task will be executed at some point when another task has been resolved.
       * @private
       * @param priority The priority of the task
       * @param fn The function that accepts the callback, which must be called upon the task completion.
       */
      executeOrQueue(priority, fn) {
          if (this.currentPoolSize < this.maxPoolSize) {
              this.currentPoolSize++;
              fn(() => {
                  this.currentPoolSize--;
                  if (this.queue.length > 0) {
                      this.queue.sort((a, b) => b.priority - a.priority);
                      const item = this.queue.shift();
                      this.executeOrQueue(item.priority, item.fn);
                  }
              });
          }
          else {
              this.queue.push({ priority, fn });
          }
      }
      /**
       * Checks if the taskExecutor is finished.
       * @private
       * @returns Returns `true` if the taskExecutor is finished, otherwise returns `false`.
       */
      finished() {
          return this.currentPoolSize === 0;
      }
  }
  tasks.PrioritizedTaskExecutor = PrioritizedTaskExecutor;

  Object.defineProperty(walkController, "__esModule", { value: true });
  walkController.WalkController = void 0;
  const node_1$1 = node;
  const tasks_1 = tasks;
  /**
   * WalkController is an interface to control how the trie is being traversed.
   */
  class WalkController {
      /**
       * Creates a new WalkController
       * @param onNode - The `FoundNodeFunction` to call if a node is found.
       * @param trie - The `Trie` to walk on.
       * @param poolSize - The size of the task queue.
       */
      constructor(onNode, trie, poolSize) {
          this.onNode = onNode;
          this.taskExecutor = new tasks_1.PrioritizedTaskExecutor(poolSize);
          this.trie = trie;
          this.resolve = () => { };
          this.reject = () => { };
      }
      /**
       * Async function to create and start a new walk over a trie.
       * @param onNode - The `FoundNodeFunction to call if a node is found.
       * @param trie - The trie to walk on.
       * @param root - The root key to walk on.
       * @param poolSize - Task execution pool size to prevent OOM errors. Defaults to 500.
       */
      static async newWalk(onNode, trie, root, poolSize) {
          const strategy = new WalkController(onNode, trie, poolSize ?? 500);
          await strategy.startWalk(root);
      }
      async startWalk(root) {
          // eslint-disable-next-line no-async-promise-executor
          return await new Promise(async (resolve, reject) => {
              this.resolve = resolve;
              this.reject = reject;
              let node;
              try {
                  node = await this.trie.lookupNode(root);
              }
              catch (error) {
                  return this.reject(error);
              }
              this.processNode(root, node, []);
          });
      }
      /**
       * Run all children of a node. Priority of these nodes are the key length of the children.
       * @param node - Node to get all children of and call onNode on.
       * @param key - The current `key` which would yield the `node` when trying to get this node with a `get` operation.
       */
      allChildren(node, key = []) {
          if (node instanceof node_1$1.LeafNode) {
              return;
          }
          let children;
          if (node instanceof node_1$1.ExtensionNode) {
              children = [[node.key, node.value]];
          }
          else if (node instanceof node_1$1.BranchNode) {
              children = node.getChildren().map((b) => [[b[0]], b[1]]);
          }
          if (!children) {
              return;
          }
          for (const child of children) {
              const keyExtension = child[0];
              const childRef = child[1];
              const childKey = key.concat(keyExtension);
              const priority = childKey.length;
              this.pushNodeToQueue(childRef, childKey, priority);
          }
      }
      /**
       * Push a node to the queue. If the queue has places left for tasks, the node is executed immediately, otherwise it is queued.
       * @param nodeRef - Push a node reference to the event queue. This reference is a 32-byte keccak hash of the value corresponding to the `key`.
       * @param key - The current key.
       * @param priority - Optional priority, defaults to key length
       */
      pushNodeToQueue(nodeRef, key = [], priority) {
          this.taskExecutor.executeOrQueue(priority ?? key.length, async (taskFinishedCallback) => {
              let childNode;
              try {
                  childNode = await this.trie.lookupNode(nodeRef);
              }
              catch (error) {
                  return this.reject(error);
              }
              taskFinishedCallback(); // this marks the current task as finished. If there are any tasks left in the queue, this will immediately execute the first task.
              this.processNode(nodeRef, childNode, key);
          });
      }
      /**
       * Push a branch of a certain BranchNode to the event queue.
       * @param node - The node to select a branch on. Should be a BranchNode.
       * @param key - The current key which leads to the corresponding node.
       * @param childIndex - The child index to add to the event queue.
       * @param priority - Optional priority of the event, defaults to the total key length.
       */
      onlyBranchIndex(node, key = [], childIndex, priority) {
          if (!(node instanceof node_1$1.BranchNode)) {
              throw new Error('Expected branch node');
          }
          const childRef = node.getBranch(childIndex);
          if (!childRef) {
              throw new Error('Could not get branch of childIndex');
          }
          const childKey = key.slice(); // This copies the key to a new array.
          childKey.push(childIndex);
          const prio = priority ?? childKey.length;
          this.pushNodeToQueue(childRef, childKey, prio);
      }
      processNode(nodeRef, node, key = []) {
          this.onNode(nodeRef, node, key, this);
          if (this.taskExecutor.finished()) {
              // onNode should schedule new tasks. If no tasks was added and the queue is empty, then we have finished our walk.
              this.resolve();
          }
      }
  }
  walkController.WalkController = WalkController;

  Object.defineProperty(trie, "__esModule", { value: true });
  trie.Trie = void 0;
  const util_1$k = dist$a;
  const keccak_1$8 = keccak;
  const semaphore_async_await_1$1 = dist$4;
  const db_1$1 = db;
  const range_1 = range;
  const types_1$4 = types$2;
  const nibbles_1$1 = nibbles;
  const readStream_1 = readStream;
  const walkController_1 = walkController;
  const node_1 = node;
  /**
   * The basic trie interface, use with `import { Trie } from '@ethereumjs/trie'`.
   * In Ethereum applications stick with the {@link SecureTrie} overlay.
   * The API for the base and the secure interface are about the same.
   */
  class Trie {
      /**
       * Create a new trie
       * @param opts Options for instantiating the trie
       */
      constructor(opts) {
          this.lock = new semaphore_async_await_1$1.default(1);
          this.db = opts?.db ?? new db_1$1.LevelDB();
          this._hash = opts?.hash ?? keccak_1$8.keccak256;
          this.EMPTY_TRIE_ROOT = this.hash(util_1$k.RLP_EMPTY_STRING);
          this._hashLen = this.EMPTY_TRIE_ROOT.length;
          this._root = this.EMPTY_TRIE_ROOT;
          this._deleteFromDB = opts?.deleteFromDB ?? false;
          this._persistRoot = opts?.persistRoot ?? false;
          if (opts?.root) {
              this.root = opts.root;
          }
      }
      static async create(opts) {
          if (opts?.db !== undefined && opts?.persistRoot === true) {
              if (opts?.root === undefined) {
                  opts.root = (await opts?.db.get(types_1$4.ROOT_DB_KEY)) ?? undefined;
              }
              else {
                  await opts?.db.put(types_1$4.ROOT_DB_KEY, opts.root);
              }
          }
          return new Trie(opts);
      }
      /**
       * Sets the current root of the `trie`
       */
      set root(value) {
          if ((0, util_1$k.isFalsy)(value)) {
              value = this.EMPTY_TRIE_ROOT;
          }
          if (value.length !== this._hashLen)
              throw new Error(`Invalid root length. Roots are ${this._hashLen} bytes`);
          this._root = value;
      }
      /**
       * Gets the current root of the `trie`
       */
      get root() {
          return this._root;
      }
      /**
       * Checks if a given root exists.
       */
      async checkRoot(root) {
          try {
              const value = await this.lookupNode(root);
              return value !== null;
          }
          catch (error) {
              if (error.message == 'Missing node in DB') {
                  return false;
              }
              else {
                  throw error;
              }
          }
      }
      /**
       * Trie has no checkpointing so return false
       */
      get isCheckpoint() {
          return false;
      }
      /**
       * Gets a value given a `key`
       * @param key - the key to search for
       * @param throwIfMissing - if true, throws if any nodes are missing. Used for verifying proofs. (default: false)
       * @returns A Promise that resolves to `Buffer` if a value was found or `null` if no value was found.
       */
      async get(key, throwIfMissing = false) {
          const { node, remaining } = await this.findPath(key, throwIfMissing);
          let value = null;
          if (node && remaining.length === 0) {
              value = node.value;
          }
          return value;
      }
      /**
       * Stores a given `value` at the given `key` or do a delete if `value` is empty
       * (delete operations are only executed on DB with `deleteFromDB` set to `true`)
       * @param key
       * @param value
       * @returns A Promise that resolves once value is stored.
       */
      async put(key, value) {
          if (this._persistRoot && key.equals(types_1$4.ROOT_DB_KEY)) {
              throw new Error(`Attempted to set '${types_1$4.ROOT_DB_KEY.toString()}' key but it is not allowed.`);
          }
          // If value is empty, delete
          if ((0, util_1$k.isFalsy)(value) || value.toString() === '') {
              return await this.del(key);
          }
          await this.lock.wait();
          if (this.root.equals(this.EMPTY_TRIE_ROOT)) {
              // If no root, initialize this trie
              await this._createInitialNode(key, value);
          }
          else {
              // First try to find the given key or its nearest node
              const { remaining, stack } = await this.findPath(key);
              // then update
              await this._updateNode(key, value, remaining, stack);
          }
          await this.persistRoot();
          this.lock.signal();
      }
      /**
       * Deletes a value given a `key` from the trie
       * (delete operations are only executed on DB with `deleteFromDB` set to `true`)
       * @param key
       * @returns A Promise that resolves once value is deleted.
       */
      async del(key) {
          await this.lock.wait();
          const { node, stack } = await this.findPath(key);
          if (node) {
              await this._deleteNode(key, stack);
          }
          await this.persistRoot();
          this.lock.signal();
      }
      /**
       * Tries to find a path to the node for the given key.
       * It returns a `stack` of nodes to the closest node.
       * @param key - the search key
       * @param throwIfMissing - if true, throws if any nodes are missing. Used for verifying proofs. (default: false)
       */
      async findPath(key, throwIfMissing = false) {
          // eslint-disable-next-line no-async-promise-executor
          return new Promise(async (resolve, reject) => {
              const stack = [];
              const targetKey = (0, nibbles_1$1.bufferToNibbles)(key);
              const onFound = async (nodeRef, node, keyProgress, walkController) => {
                  if (node === null) {
                      return reject(new Error('Path not found'));
                  }
                  const keyRemainder = targetKey.slice((0, nibbles_1$1.matchingNibbleLength)(keyProgress, targetKey));
                  stack.push(node);
                  if (node instanceof node_1.BranchNode) {
                      if (keyRemainder.length === 0) {
                          // we exhausted the key without finding a node
                          resolve({ node, remaining: [], stack });
                      }
                      else {
                          const branchIndex = keyRemainder[0];
                          const branchNode = node.getBranch(branchIndex);
                          if (!branchNode) {
                              // there are no more nodes to find and we didn't find the key
                              resolve({ node: null, remaining: keyRemainder, stack });
                          }
                          else {
                              // node found, continuing search
                              // this can be optimized as this calls getBranch again.
                              walkController.onlyBranchIndex(node, keyProgress, branchIndex);
                          }
                      }
                  }
                  else if (node instanceof node_1.LeafNode) {
                      if ((0, nibbles_1$1.doKeysMatch)(keyRemainder, node.key)) {
                          // keys match, return node with empty key
                          resolve({ node, remaining: [], stack });
                      }
                      else {
                          // reached leaf but keys dont match
                          resolve({ node: null, remaining: keyRemainder, stack });
                      }
                  }
                  else if (node instanceof node_1.ExtensionNode) {
                      const matchingLen = (0, nibbles_1$1.matchingNibbleLength)(keyRemainder, node.key);
                      if (matchingLen !== node.key.length) {
                          // keys don't match, fail
                          resolve({ node: null, remaining: keyRemainder, stack });
                      }
                      else {
                          // keys match, continue search
                          walkController.allChildren(node, keyProgress);
                      }
                  }
              };
              // walk trie and process nodes
              try {
                  await this.walkTrie(this.root, onFound);
              }
              catch (error) {
                  if (error.message == 'Missing node in DB' && !throwIfMissing) ;
                  else {
                      reject(error);
                  }
              }
              // Resolve if walkTrie finishes without finding any nodes
              resolve({ node: null, remaining: [], stack });
          });
      }
      /**
       * Walks a trie until finished.
       * @param root
       * @param onFound - callback to call when a node is found. This schedules new tasks. If no tasks are available, the Promise resolves.
       * @returns Resolves when finished walking trie.
       */
      async walkTrie(root, onFound) {
          await walkController_1.WalkController.newWalk(onFound, this, root);
      }
      /**
       * Creates the initial node from an empty tree.
       * @private
       */
      async _createInitialNode(key, value) {
          const newNode = new node_1.LeafNode((0, nibbles_1$1.bufferToNibbles)(key), value);
          const encoded = newNode.serialize();
          this.root = this.hash(encoded);
          await this.db.put(this.root, encoded);
          await this.persistRoot();
      }
      /**
       * Retrieves a node from db by hash.
       */
      async lookupNode(node) {
          if ((0, node_1.isRawNode)(node)) {
              return (0, node_1.decodeRawNode)(node);
          }
          let value = null;
          let foundNode = null;
          value = await this.db.get(node);
          if (value) {
              foundNode = (0, node_1.decodeNode)(value);
          }
          else {
              // Dev note: this error message text is used for error checking in `checkRoot`, `verifyProof`, and `findPath`
              throw new Error('Missing node in DB');
          }
          return foundNode;
      }
      /**
       * Updates a node.
       * @private
       * @param key
       * @param value
       * @param keyRemainder
       * @param stack
       */
      async _updateNode(k, value, keyRemainder, stack) {
          const toSave = [];
          const lastNode = stack.pop();
          if (!lastNode) {
              throw new Error('Stack underflow');
          }
          // add the new nodes
          const key = (0, nibbles_1$1.bufferToNibbles)(k);
          // Check if the last node is a leaf and the key matches to this
          let matchLeaf = false;
          if (lastNode instanceof node_1.LeafNode) {
              let l = 0;
              for (let i = 0; i < stack.length; i++) {
                  const n = stack[i];
                  if (n instanceof node_1.BranchNode) {
                      l++;
                  }
                  else {
                      l += n.key.length;
                  }
              }
              if ((0, nibbles_1$1.matchingNibbleLength)(lastNode.key, key.slice(l)) === lastNode.key.length &&
                  keyRemainder.length === 0) {
                  matchLeaf = true;
              }
          }
          if (matchLeaf) {
              // just updating a found value
              lastNode.value = value;
              stack.push(lastNode);
          }
          else if (lastNode instanceof node_1.BranchNode) {
              stack.push(lastNode);
              if (keyRemainder.length !== 0) {
                  // add an extension to a branch node
                  keyRemainder.shift();
                  // create a new leaf
                  const newLeaf = new node_1.LeafNode(keyRemainder, value);
                  stack.push(newLeaf);
              }
              else {
                  lastNode.value = value;
              }
          }
          else {
              // create a branch node
              const lastKey = lastNode.key;
              const matchingLength = (0, nibbles_1$1.matchingNibbleLength)(lastKey, keyRemainder);
              const newBranchNode = new node_1.BranchNode();
              // create a new extension node
              if (matchingLength !== 0) {
                  const newKey = lastNode.key.slice(0, matchingLength);
                  const newExtNode = new node_1.ExtensionNode(newKey, value);
                  stack.push(newExtNode);
                  lastKey.splice(0, matchingLength);
                  keyRemainder.splice(0, matchingLength);
              }
              stack.push(newBranchNode);
              if (lastKey.length !== 0) {
                  const branchKey = lastKey.shift();
                  if (lastKey.length !== 0 || lastNode instanceof node_1.LeafNode) {
                      // shrinking extension or leaf
                      lastNode.key = lastKey;
                      const formattedNode = this._formatNode(lastNode, false, toSave);
                      newBranchNode.setBranch(branchKey, formattedNode);
                  }
                  else {
                      // remove extension or attaching
                      this._formatNode(lastNode, false, toSave, true);
                      newBranchNode.setBranch(branchKey, lastNode.value);
                  }
              }
              else {
                  newBranchNode.value = lastNode.value;
              }
              if (keyRemainder.length !== 0) {
                  keyRemainder.shift();
                  // add a leaf node to the new branch node
                  const newLeafNode = new node_1.LeafNode(keyRemainder, value);
                  stack.push(newLeafNode);
              }
              else {
                  newBranchNode.value = value;
              }
          }
          await this._saveStack(key, stack, toSave);
      }
      /**
       * Deletes a node from the trie.
       * @private
       */
      async _deleteNode(k, stack) {
          const processBranchNode = (key, branchKey, branchNode, parentNode, stack) => {
              // branchNode is the node ON the branch node not THE branch node
              if ((0, util_1$k.isFalsy)(parentNode) || parentNode instanceof node_1.BranchNode) {
                  // branch->?
                  if ((0, util_1$k.isTruthy)(parentNode)) {
                      stack.push(parentNode);
                  }
                  if (branchNode instanceof node_1.BranchNode) {
                      // create an extension node
                      // branch->extension->branch
                      // @ts-ignore
                      const extensionNode = new node_1.ExtensionNode([branchKey], null);
                      stack.push(extensionNode);
                      key.push(branchKey);
                  }
                  else {
                      const branchNodeKey = branchNode.key;
                      // branch key is an extension or a leaf
                      // branch->(leaf or extension)
                      branchNodeKey.unshift(branchKey);
                      branchNode.key = branchNodeKey.slice(0);
                      key = key.concat(branchNodeKey);
                  }
                  stack.push(branchNode);
              }
              else {
                  // parent is an extension
                  let parentKey = parentNode.key;
                  if (branchNode instanceof node_1.BranchNode) {
                      // ext->branch
                      parentKey.push(branchKey);
                      key.push(branchKey);
                      parentNode.key = parentKey;
                      stack.push(parentNode);
                  }
                  else {
                      const branchNodeKey = branchNode.key;
                      // branch node is an leaf or extension and parent node is an exstention
                      // add two keys together
                      // dont push the parent node
                      branchNodeKey.unshift(branchKey);
                      key = key.concat(branchNodeKey);
                      parentKey = parentKey.concat(branchNodeKey);
                      branchNode.key = parentKey;
                  }
                  stack.push(branchNode);
              }
              return key;
          };
          let lastNode = stack.pop();
          if ((0, util_1$k.isFalsy)(lastNode))
              throw new Error('missing last node');
          let parentNode = stack.pop();
          const opStack = [];
          let key = (0, nibbles_1$1.bufferToNibbles)(k);
          if (!parentNode) {
              // the root here has to be a leaf.
              this.root = this.EMPTY_TRIE_ROOT;
              return;
          }
          if (lastNode instanceof node_1.BranchNode) {
              lastNode.value = null;
          }
          else {
              // the lastNode has to be a leaf if it's not a branch.
              // And a leaf's parent, if it has one, must be a branch.
              if (!(parentNode instanceof node_1.BranchNode)) {
                  throw new Error('Expected branch node');
              }
              const lastNodeKey = lastNode.key;
              key.splice(key.length - lastNodeKey.length);
              // delete the value
              this._formatNode(lastNode, false, opStack, true);
              parentNode.setBranch(key.pop(), null);
              lastNode = parentNode;
              parentNode = stack.pop();
          }
          // nodes on the branch
          // count the number of nodes on the branch
          const branchNodes = lastNode.getChildren();
          // if there is only one branch node left, collapse the branch node
          if (branchNodes.length === 1) {
              // add the one remaing branch node to node above it
              const branchNode = branchNodes[0][1];
              const branchNodeKey = branchNodes[0][0];
              // look up node
              const foundNode = await this.lookupNode(branchNode);
              if (foundNode) {
                  key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack);
                  await this._saveStack(key, stack, opStack);
              }
          }
          else {
              // simple removing a leaf and recaluclation the stack
              if (parentNode) {
                  stack.push(parentNode);
              }
              stack.push(lastNode);
              await this._saveStack(key, stack, opStack);
          }
      }
      /**
       * Saves a stack of nodes to the database.
       * @private
       * @param key - the key. Should follow the stack
       * @param stack - a stack of nodes to the value given by the key
       * @param opStack - a stack of levelup operations to commit at the end of this funciton
       */
      async _saveStack(key, stack, opStack) {
          let lastRoot;
          // update nodes
          while (stack.length) {
              const node = stack.pop();
              if (node instanceof node_1.LeafNode) {
                  key.splice(key.length - node.key.length);
              }
              else if (node instanceof node_1.ExtensionNode) {
                  key.splice(key.length - node.key.length);
                  if (lastRoot) {
                      node.value = lastRoot;
                  }
              }
              else if (node instanceof node_1.BranchNode) {
                  if (lastRoot) {
                      const branchKey = key.pop();
                      node.setBranch(branchKey, lastRoot);
                  }
              }
              lastRoot = this._formatNode(node, stack.length === 0, opStack);
          }
          if (lastRoot) {
              this.root = lastRoot;
          }
          await this.db.batch(opStack);
          await this.persistRoot();
      }
      /**
       * Formats node to be saved by `levelup.batch`.
       * @private
       * @param node - the node to format.
       * @param topLevel - if the node is at the top level.
       * @param opStack - the opStack to push the node's data.
       * @param remove - whether to remove the node (only used for CheckpointTrie).
       * @returns The node's hash used as the key or the rawNode.
       */
      _formatNode(node, topLevel, opStack, remove = false) {
          const encoded = node.serialize();
          if (encoded.length >= 32 || topLevel) {
              const hashRoot = Buffer$8.from(this.hash(encoded));
              if (remove) {
                  if (this._deleteFromDB) {
                      opStack.push({
                          type: 'del',
                          key: hashRoot,
                      });
                  }
              }
              else {
                  opStack.push({
                      type: 'put',
                      key: hashRoot,
                      value: encoded,
                  });
              }
              return hashRoot;
          }
          return node.raw();
      }
      /**
       * The given hash of operations (key additions or deletions) are executed on the trie
       * (delete operations are only executed on DB with `deleteFromDB` set to `true`)
       * @example
       * const ops = [
       *    { type: 'del', key: Buffer.from('father') }
       *  , { type: 'put', key: Buffer.from('name'), value: Buffer.from('Yuri Irsenovich Kim') }
       *  , { type: 'put', key: Buffer.from('dob'), value: Buffer.from('16 February 1941') }
       *  , { type: 'put', key: Buffer.from('spouse'), value: Buffer.from('Kim Young-sook') }
       *  , { type: 'put', key: Buffer.from('occupation'), value: Buffer.from('Clown') }
       * ]
       * await trie.batch(ops)
       * @param ops
       */
      async batch(ops) {
          for (const op of ops) {
              if (op.type === 'put') {
                  if ((0, util_1$k.isFalsy)(op.value)) {
                      throw new Error('Invalid batch db operation');
                  }
                  await this.put(op.key, op.value);
              }
              else if (op.type === 'del') {
                  await this.del(op.key);
              }
          }
          await this.persistRoot();
      }
      /**
       * Saves the nodes from a proof into the trie.
       * @param proof
       */
      async fromProof(proof) {
          const opStack = proof.map((nodeValue) => {
              return {
                  type: 'put',
                  key: Buffer$8.from(this.hash(nodeValue)),
                  value: nodeValue,
              };
          });
          if (this.root === this.EMPTY_TRIE_ROOT && (0, util_1$k.isTruthy)(opStack[0])) {
              this.root = opStack[0].key;
          }
          await this.db.batch(opStack);
          await this.persistRoot();
          return;
      }
      /**
       * prove has been renamed to {@link Trie.createProof}.
       * @deprecated
       * @param key
       */
      async prove(key) {
          return this.createProof(key);
      }
      /**
       * Creates a proof from a trie and key that can be verified using {@link Trie.verifyProof}.
       * @param key
       */
      async createProof(key) {
          const { stack } = await this.findPath(key);
          const p = stack.map((stackElem) => {
              return stackElem.serialize();
          });
          return p;
      }
      /**
       * Verifies a proof.
       * @param rootHash
       * @param key
       * @param proof
       * @throws If proof is found to be invalid.
       * @returns The value from the key, or null if valid proof of non-existence.
       */
      async verifyProof(rootHash, key, proof) {
          const proofTrie = new Trie({ root: rootHash, hash: this._hash });
          try {
              await proofTrie.fromProof(proof);
          }
          catch (e) {
              throw new Error('Invalid proof nodes given');
          }
          try {
              const value = await proofTrie.get(key, true);
              return value;
          }
          catch (err) {
              if (err.message == 'Missing node in DB') {
                  throw new Error('Invalid proof provided');
              }
              else {
                  throw err;
              }
          }
      }
      /**
       * {@link verifyRangeProof}
       */
      verifyRangeProof(rootHash, firstKey, lastKey, keys, values, proof) {
          return (0, range_1.verifyRangeProof)(rootHash, firstKey && (0, nibbles_1$1.bufferToNibbles)(firstKey), lastKey && (0, nibbles_1$1.bufferToNibbles)(lastKey), keys.map(nibbles_1$1.bufferToNibbles), values, proof, this._hash);
      }
      /**
       * The `data` event is given an `Object` that has two properties; the `key` and the `value`. Both should be Buffers.
       * @return Returns a [stream](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`
       */
      createReadStream() {
          return new readStream_1.TrieReadStream(this);
      }
      /**
       * Creates a new trie backed by the same db.
       */
      copy() {
          return new Trie({
              db: this.db.copy(),
              root: this.root,
              deleteFromDB: this._deleteFromDB,
              persistRoot: this._persistRoot,
              hash: this._hash,
          });
      }
      /**
       * Persists the root hash in the underlying database
       */
      async persistRoot() {
          if (this._persistRoot === true) {
              await this.db.put(types_1$4.ROOT_DB_KEY, this.root);
          }
      }
      /**
       * Finds all nodes that are stored directly in the db
       * (some nodes are stored raw inside other nodes)
       * called by {@link ScratchReadStream}
       * @private
       */
      async _findDbNodes(onFound) {
          const outerOnFound = async (nodeRef, node, key, walkController) => {
              if ((0, node_1.isRawNode)(nodeRef)) {
                  if (node !== null) {
                      walkController.allChildren(node, key);
                  }
              }
              else {
                  onFound(nodeRef, node, key, walkController);
              }
          };
          await this.walkTrie(this.root, outerOnFound);
      }
      /**
       * Finds all nodes that store k,v values
       * called by {@link TrieReadStream}
       * @private
       */
      async _findValueNodes(onFound) {
          const outerOnFound = async (nodeRef, node, key, walkController) => {
              let fullKey = key;
              if (node instanceof node_1.LeafNode) {
                  fullKey = key.concat(node.key);
                  // found leaf node!
                  onFound(nodeRef, node, fullKey, walkController);
              }
              else if (node instanceof node_1.BranchNode && node.value) {
                  // found branch with value
                  onFound(nodeRef, node, fullKey, walkController);
              }
              else {
                  // keep looking for value nodes
                  if (node !== null) {
                      walkController.allChildren(node, key);
                  }
              }
          };
          await this.walkTrie(this.root, outerOnFound);
      }
      hash(msg) {
          return Buffer$8.from(this._hash(msg));
      }
  }
  trie.Trie = Trie;

  Object.defineProperty(checkpoint, "__esModule", { value: true });
  checkpoint.CheckpointTrie = void 0;
  const db_1 = db;
  const trie_1$6 = trie;
  /**
   * Adds checkpointing to the {@link Trie}
   */
  class CheckpointTrie extends trie_1$6.Trie {
      constructor(opts) {
          super(opts);
          this.dbStorage = opts?.db ?? new db_1.LevelDB();
          this.db = new db_1.CheckpointDB(this.dbStorage);
      }
      /**
       * Is the trie during a checkpoint phase?
       */
      get isCheckpoint() {
          return this.db.isCheckpoint;
      }
      /**
       * Creates a checkpoint that can later be reverted to or committed.
       * After this is called, all changes can be reverted until `commit` is called.
       */
      checkpoint() {
          this.db.checkpoint(this.root);
      }
      /**
       * Commits a checkpoint to disk, if current checkpoint is not nested.
       * If nested, only sets the parent checkpoint as current checkpoint.
       * @throws If not during a checkpoint phase
       */
      async commit() {
          if (!this.isCheckpoint) {
              throw new Error('trying to commit when not checkpointed');
          }
          await this.lock.wait();
          await this.db.commit();
          await this.persistRoot();
          this.lock.signal();
      }
      /**
       * Reverts the trie to the state it was at when `checkpoint` was first called.
       * If during a nested checkpoint, sets root to most recent checkpoint, and sets
       * parent checkpoint as current.
       */
      async revert() {
          if (!this.isCheckpoint) {
              throw new Error('trying to revert when not checkpointed');
          }
          await this.lock.wait();
          this.root = await this.db.revert();
          await this.persistRoot();
          this.lock.signal();
      }
      /**
       * Returns a copy of the underlying trie with the interface of CheckpointTrie.
       * @param includeCheckpoints - If true and during a checkpoint, the copy will contain the checkpointing metadata and will use the same scratch as underlying db.
       */
      copy(includeCheckpoints = true) {
          const trie = new CheckpointTrie({
              db: this.dbStorage.copy(),
              root: this.root,
              deleteFromDB: this._deleteFromDB,
              persistRoot: this._persistRoot,
              hash: this._hash,
          });
          if (includeCheckpoints && this.isCheckpoint) {
              trie.db.checkpoints = [...this.db.checkpoints];
          }
          return trie;
      }
  }
  checkpoint.CheckpointTrie = CheckpointTrie;

  var secure = {};

  Object.defineProperty(secure, "__esModule", { value: true });
  secure.SecureTrie = void 0;
  const util_1$j = dist$a;
  const types_1$3 = types$2;
  const checkpoint_1 = checkpoint;
  /**
   * You can create a secure Trie where the keys are automatically hashed
   * using **keccak256** by using `import { SecureTrie as Trie } from '@ethereumjs/trie'`.
   * It has the same methods and constructor as `Trie`.
   * @class SecureTrie
   * @extends Trie
   * @public
   */
  class SecureTrie extends checkpoint_1.CheckpointTrie {
      /**
       * Gets a value given a `key`
       * @param key - the key to search for
       * @returns A Promise that resolves to `Buffer` if a value was found or `null` if no value was found.
       */
      async get(key) {
          return super.get(this.hash(key));
      }
      /**
       * Stores a given `value` at the given `key`.
       * For a falsey value, use the original key to avoid double hashing the key.
       * @param key
       * @param value
       */
      async put(key, val) {
          if (this._persistRoot && key.equals(types_1$3.ROOT_DB_KEY)) {
              throw new Error(`Attempted to set '${types_1$3.ROOT_DB_KEY.toString()}' key but it is not allowed.`);
          }
          if ((0, util_1$j.isFalsy)(val) || val.toString() === '') {
              await this.del(key);
          }
          else {
              await super.put(this.hash(key), val);
          }
      }
      /**
       * Deletes a value given a `key`.
       * @param key
       */
      async del(key) {
          await super.del(this.hash(key));
      }
      /**
       * prove has been renamed to {@link SecureTrie.createProof}.
       * @deprecated
       * @param key
       */
      async prove(key) {
          return this.createProof(key);
      }
      /**
       * Creates a proof that can be verified using {@link SecureTrie.verifyProof}.
       * @param key
       */
      async createProof(key) {
          return super.createProof(this.hash(key));
      }
      /**
       * Verifies a proof.
       * @param rootHash
       * @param key
       * @param proof
       * @throws If proof is found to be invalid.
       * @returns The value from the key.
       */
      async verifyProof(rootHash, key, proof) {
          return super.verifyProof(rootHash, this.hash(key), proof);
      }
      /**
       * Verifies a range proof.
       */
      verifyRangeProof(rootHash, firstKey, lastKey, keys, values, proof) {
          return super.verifyRangeProof(rootHash, firstKey && this.hash(firstKey), lastKey && this.hash(lastKey), keys.map((k) => this.hash(k)), values, proof);
      }
      /**
       * Returns a copy of the underlying trie with the interface of SecureTrie.
       * @param includeCheckpoints - If true and during a checkpoint, the copy will contain the checkpointing metadata and will use the same scratch as underlying db.
       */
      copy(includeCheckpoints = true) {
          const secureTrie = new SecureTrie({
              db: this.dbStorage.copy(),
              root: this.root,
              deleteFromDB: this._deleteFromDB,
              persistRoot: this._persistRoot,
              hash: this._hash,
          });
          if (includeCheckpoints && this.isCheckpoint) {
              secureTrie.db.checkpoints = [...this.db.checkpoints];
          }
          return secureTrie;
      }
      /**
       * Persists the root hash in the underlying database
       */
      async persistRoot() {
          if (this._persistRoot !== undefined) {
              await this.db.put(this.hash(types_1$3.ROOT_DB_KEY), this.root);
          }
      }
  }
  secure.SecureTrie = SecureTrie;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(checkpoint, exports);
  __exportStar(node, exports);
  __exportStar(secure, exports);
  __exportStar(trie, exports);

  }(trie$1));

  Object.defineProperty(range, "__esModule", { value: true });
  range.verifyRangeProof = void 0;
  const trie_1$5 = trie$1;
  const nibbles_1 = nibbles;
  // reference: https://github.com/ethereum/go-ethereum/blob/20356e57b119b4e70ce47665a71964434e15200d/trie/proof.go
  /**
   * unset will remove all nodes to the left or right of the target key(decided by `removeLeft`).
   * @param trie - trie object.
   * @param parent - parent node, it can be `null`.
   * @param child - child node.
   * @param key - target nibbles.
   * @param pos - key position.
   * @param removeLeft - remove all nodes to the left or right of the target key.
   * @param stack - a stack of modified nodes.
   * @returns The end position of key.
   */
  async function unset(trie, parent, child, key, pos, removeLeft, stack) {
      if (child instanceof trie_1$5.BranchNode) {
          /**
           * This node is a branch node,
           * remove all branches on the left or right
           */
          if (removeLeft) {
              for (let i = 0; i < key[pos]; i++) {
                  child.setBranch(i, null);
              }
          }
          else {
              for (let i = key[pos] + 1; i < 16; i++) {
                  child.setBranch(i, null);
              }
          }
          // record this node on the stack
          stack.push(child);
          // continue to the next node
          const next = child.getBranch(key[pos]);
          const _child = next && (await trie.lookupNode(next));
          return await unset(trie, child, _child, key, pos + 1, removeLeft, stack);
      }
      else if (child instanceof trie_1$5.ExtensionNode || child instanceof trie_1$5.LeafNode) {
          /**
           * This node is an extension node or lead node,
           * if node._nibbles is less or greater than the target key,
           * remove self from parent
           */
          if (key.length - pos < child.keyLength ||
              (0, nibbles_1.nibblesCompare)(child._nibbles, key.slice(pos, pos + child.keyLength)) !== 0) {
              if (removeLeft) {
                  if ((0, nibbles_1.nibblesCompare)(child._nibbles, key.slice(pos)) < 0) {
                      parent.setBranch(key[pos - 1], null);
                  }
              }
              else {
                  if ((0, nibbles_1.nibblesCompare)(child._nibbles, key.slice(pos)) > 0) {
                      parent.setBranch(key[pos - 1], null);
                  }
              }
              return pos - 1;
          }
          if (child instanceof trie_1$5.LeafNode) {
              parent.setBranch(key[pos - 1], null);
              return pos - 1;
          }
          else {
              const _child = await trie.lookupNode(child.value);
              if (_child && _child instanceof trie_1$5.LeafNode) {
                  parent.setBranch(key[pos - 1], null);
                  return pos - 1;
              }
              // record this node on the stack
              stack.push(child);
              // continue to the next node
              return await unset(trie, child, _child, key, pos + child.keyLength, removeLeft, stack);
          }
      }
      else if (child === null) {
          return pos - 1;
      }
      else {
          throw new Error('invalid node');
      }
  }
  /**
   * unsetInternal will remove all nodes between `left` and `right` (including `left` and `right`)
   * @param trie - trie object.
   * @param left - left nibbles.
   * @param right - right nibbles.
   * @returns Is it an empty trie.
   */
  async function unsetInternal(trie, left, right) {
      // Key position
      let pos = 0;
      // Parent node
      let parent = null;
      // Current node
      let node = await trie.lookupNode(trie.root);
      let shortForkLeft;
      let shortForkRight;
      // A stack of modified nodes.
      const stack = [];
      // 1. Find the fork point of `left` and `right`
      // eslint-disable-next-line no-constant-condition
      while (true) {
          if (node instanceof trie_1$5.ExtensionNode || node instanceof trie_1$5.LeafNode) {
              // record this node on the stack
              stack.push(node);
              if (left.length - pos < node.keyLength) {
                  shortForkLeft = (0, nibbles_1.nibblesCompare)(left.slice(pos), node._nibbles);
              }
              else {
                  shortForkLeft = (0, nibbles_1.nibblesCompare)(left.slice(pos, pos + node.keyLength), node._nibbles);
              }
              if (right.length - pos < node.keyLength) {
                  shortForkRight = (0, nibbles_1.nibblesCompare)(right.slice(pos), node._nibbles);
              }
              else {
                  shortForkRight = (0, nibbles_1.nibblesCompare)(right.slice(pos, pos + node.keyLength), node._nibbles);
              }
              // If one of `left` and `right` is not equal to node._nibbles, it means we found the fork point
              if (shortForkLeft !== 0 || shortForkRight !== 0) {
                  break;
              }
              if (node instanceof trie_1$5.LeafNode) {
                  // it shouldn't happen
                  throw new Error('invalid node');
              }
              // continue to the next node
              parent = node;
              pos += node.keyLength;
              node = await trie.lookupNode(node.value);
          }
          else if (node instanceof trie_1$5.BranchNode) {
              // record this node on the stack
              stack.push(node);
              const leftNode = node.getBranch(left[pos]);
              const rightNode = node.getBranch(right[pos]);
              // One of `left` and `right` is `null`, stop searching
              if (leftNode === null || rightNode === null) {
                  break;
              }
              // Stop searching if `left` and `right` are not equal
              if (!(leftNode instanceof Buffer$8)) {
                  if (rightNode instanceof Buffer$8) {
                      break;
                  }
                  if (leftNode.length !== rightNode.length) {
                      break;
                  }
                  let abort = false;
                  for (let i = 0; i < leftNode.length; i++) {
                      if (leftNode[i].compare(rightNode[i]) !== 0) {
                          abort = true;
                          break;
                      }
                  }
                  if (abort) {
                      break;
                  }
              }
              else {
                  if (!(rightNode instanceof Buffer$8)) {
                      break;
                  }
                  if (leftNode.compare(rightNode) !== 0) {
                      break;
                  }
              }
              // continue to the next node
              parent = node;
              node = await trie.lookupNode(leftNode);
              pos += 1;
          }
          else {
              throw new Error('invalid node');
          }
      }
      // 2. Starting from the fork point, delete all nodes between `left` and `right`
      const saveStack = (key, stack) => {
          return trie._saveStack(key, stack, []);
      };
      if (node instanceof trie_1$5.ExtensionNode || node instanceof trie_1$5.LeafNode) {
          /**
           * There can have these five scenarios:
           * - both proofs are less than the trie path => no valid range
           * - both proofs are greater than the trie path => no valid range
           * - left proof is less and right proof is greater => valid range, unset the entire trie
           * - left proof points to the trie node, but right proof is greater => valid range, unset left node
           * - right proof points to the trie node, but left proof is less  => valid range, unset right node
           */
          const removeSelfFromParentAndSaveStack = async (key) => {
              if (parent === null) {
                  return true;
              }
              stack.pop();
              parent.setBranch(key[pos - 1], null);
              await saveStack(key.slice(0, pos - 1), stack);
              return false;
          };
          if (shortForkLeft === -1 && shortForkRight === -1) {
              throw new Error('invalid range');
          }
          if (shortForkLeft === 1 && shortForkRight === 1) {
              throw new Error('invalid range');
          }
          if (shortForkLeft !== 0 && shortForkRight !== 0) {
              // Unset the entire trie
              return await removeSelfFromParentAndSaveStack(left);
          }
          // Unset left node
          if (shortForkRight !== 0) {
              if (node instanceof trie_1$5.LeafNode) {
                  return await removeSelfFromParentAndSaveStack(left);
              }
              const child = await trie.lookupNode(node._value);
              if (child && child instanceof trie_1$5.LeafNode) {
                  return await removeSelfFromParentAndSaveStack(left);
              }
              const endPos = await unset(trie, node, child, left.slice(pos), node.keyLength, false, stack);
              await saveStack(left.slice(0, pos + endPos), stack);
              return false;
          }
          // Unset right node
          if (shortForkLeft !== 0) {
              if (node instanceof trie_1$5.LeafNode) {
                  return await removeSelfFromParentAndSaveStack(right);
              }
              const child = await trie.lookupNode(node._value);
              if (child && child instanceof trie_1$5.LeafNode) {
                  return await removeSelfFromParentAndSaveStack(right);
              }
              const endPos = await unset(trie, node, child, right.slice(pos), node.keyLength, true, stack);
              await saveStack(right.slice(0, pos + endPos), stack);
              return false;
          }
          return false;
      }
      else if (node instanceof trie_1$5.BranchNode) {
          // Unset all internal nodes in the forkpoint
          for (let i = left[pos] + 1; i < right[pos]; i++) {
              node.setBranch(i, null);
          }
          {
              /**
               * `stack` records the path from root to fork point.
               * Since we need to unset both left and right nodes once,
               * we need to make a copy here.
               */
              const _stack = [...stack];
              const next = node.getBranch(left[pos]);
              const child = next && (await trie.lookupNode(next));
              const endPos = await unset(trie, node, child, left.slice(pos), 1, false, _stack);
              await saveStack(left.slice(0, pos + endPos), _stack);
          }
          {
              const _stack = [...stack];
              const next = node.getBranch(right[pos]);
              const child = next && (await trie.lookupNode(next));
              const endPos = await unset(trie, node, child, right.slice(pos), 1, true, _stack);
              await saveStack(right.slice(0, pos + endPos), _stack);
          }
          return false;
      }
      else {
          throw new Error('invalid node');
      }
  }
  /**
   * Verifies a proof and return the verified trie.
   * @param rootHash - root hash.
   * @param key - target key.
   * @param proof - proof node list.
   * @throws If proof is found to be invalid.
   * @returns The value from the key, or null if valid proof of non-existence.
   */
  async function verifyProof(rootHash, key, proof, hash) {
      const proofTrie = new trie_1$5.Trie({ root: rootHash, hash });
      try {
          await proofTrie.fromProof(proof);
      }
      catch (e) {
          throw new Error('Invalid proof nodes given');
      }
      try {
          const value = await proofTrie.get(key, true);
          return {
              trie: proofTrie,
              value,
          };
      }
      catch (err) {
          if (err.message == 'Missing node in DB') {
              throw new Error('Invalid proof provided');
          }
          else {
              throw err;
          }
      }
  }
  /**
   * hasRightElement returns the indicator whether there exists more elements
   * on the right side of the given path
   * @param trie - trie object.
   * @param key - given path.
   */
  async function hasRightElement(trie, key) {
      let pos = 0;
      let node = await trie.lookupNode(trie.root);
      while (node !== null) {
          if (node instanceof trie_1$5.BranchNode) {
              for (let i = key[pos] + 1; i < 16; i++) {
                  if (node.getBranch(i) !== null) {
                      return true;
                  }
              }
              const next = node.getBranch(key[pos]);
              node = next && (await trie.lookupNode(next));
              pos += 1;
          }
          else if (node instanceof trie_1$5.ExtensionNode) {
              if (key.length - pos < node.keyLength ||
                  (0, nibbles_1.nibblesCompare)(node._nibbles, key.slice(pos, pos + node.keyLength)) !== 0) {
                  return (0, nibbles_1.nibblesCompare)(node._nibbles, key.slice(pos)) > 0;
              }
              pos += node.keyLength;
              node = await trie.lookupNode(node._value);
          }
          else if (node instanceof trie_1$5.LeafNode) {
              return false;
          }
          else {
              throw new Error('invalid node');
          }
      }
      return false;
  }
  /**
   * verifyRangeProof checks whether the given leaf nodes and edge proof
   * can prove the given trie leaves range is matched with the specific root.
   *
   * There are four situations:
   *
   * - All elements proof. In this case the proof can be null, but the range should
   *   be all the leaves in the trie.
   *
   * - One element proof. In this case no matter the edge proof is a non-existent
   *   proof or not, we can always verify the correctness of the proof.
   *
   * - Zero element proof. In this case a single non-existent proof is enough to prove.
   *   Besides, if there are still some other leaves available on the right side, then
   *   an error will be returned.
   *
   * - Two edge elements proof. In this case two existent or non-existent proof(fisrt and last) should be provided.
   *
   * NOTE: Currently only supports verification when the length of firstKey and lastKey are the same.
   *
   * @param rootHash - root hash.
   * @param firstKey - first key.
   * @param lastKey - last key.
   * @param keys - key list.
   * @param values - value list, one-to-one correspondence with keys.
   * @param proof - proof node list, if proof is null, both `firstKey` and `lastKey` must be null
   * @returns a flag to indicate whether there exists more trie node in the trie
   */
  async function verifyRangeProof(rootHash, firstKey, lastKey, keys, values, proof, hash) {
      if (keys.length !== values.length) {
          throw new Error('invalid keys length or values length');
      }
      // Make sure the keys are in order
      for (let i = 0; i < keys.length - 1; i++) {
          if ((0, nibbles_1.nibblesCompare)(keys[i], keys[i + 1]) >= 0) {
              throw new Error('invalid keys order');
          }
      }
      // Make sure all values are present
      for (const value of values) {
          if (value.length === 0) {
              throw new Error('invalid values');
          }
      }
      // All elements proof
      if (proof === null && firstKey === null && lastKey === null) {
          const trie = new trie_1$5.Trie({ hash });
          for (let i = 0; i < keys.length; i++) {
              await trie.put((0, nibbles_1.nibblesToBuffer)(keys[i]), values[i]);
          }
          if (rootHash.compare(trie.root) !== 0) {
              throw new Error('invalid all elements proof: root mismatch');
          }
          return false;
      }
      if (proof === null || firstKey === null || lastKey === null) {
          throw new Error('invalid all elements proof: proof, firstKey, lastKey must be null at the same time');
      }
      // Zero element proof
      if (keys.length === 0) {
          const { trie, value } = await verifyProof(rootHash, (0, nibbles_1.nibblesToBuffer)(firstKey), proof, hash);
          if (value !== null || (await hasRightElement(trie, firstKey))) {
              throw new Error('invalid zero element proof: value mismatch');
          }
          return false;
      }
      // One element proof
      if (keys.length === 1 && (0, nibbles_1.nibblesCompare)(firstKey, lastKey) === 0) {
          const { trie, value } = await verifyProof(rootHash, (0, nibbles_1.nibblesToBuffer)(firstKey), proof, hash);
          if ((0, nibbles_1.nibblesCompare)(firstKey, keys[0]) !== 0) {
              throw new Error('invalid one element proof: firstKey should be equal to keys[0]');
          }
          if (value === null || value.compare(values[0]) !== 0) {
              throw new Error('invalid one element proof: value mismatch');
          }
          return hasRightElement(trie, firstKey);
      }
      // Two edge elements proof
      if ((0, nibbles_1.nibblesCompare)(firstKey, lastKey) >= 0) {
          throw new Error('invalid two edge elements proof: firstKey should be less than lastKey');
      }
      if (firstKey.length !== lastKey.length) {
          throw new Error('invalid two edge elements proof: the length of firstKey should be equal to the length of lastKey');
      }
      const trie = new trie_1$5.Trie({ root: rootHash, hash });
      await trie.fromProof(proof);
      // Remove all nodes between two edge proofs
      const empty = await unsetInternal(trie, firstKey, lastKey);
      if (empty) {
          trie.root = trie.EMPTY_TRIE_ROOT;
      }
      // Put all elements to the trie
      for (let i = 0; i < keys.length; i++) {
          await trie.put((0, nibbles_1.nibblesToBuffer)(keys[i]), values[i]);
      }
      // Compare rootHash
      if (trie.root.compare(rootHash) !== 0) {
          throw new Error('invalid two edge elements proof: root mismatch');
      }
      return hasRightElement(trie, keys[keys.length - 1]);
  }
  range.verifyRangeProof = verifyRangeProof;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(range, exports);

  }(proof));

  var util$2 = {};

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(readStream, exports);
  __exportStar(tasks, exports);
  __exportStar(walkController, exports);

  }(util$2));

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(db, exports);
  __exportStar(proof, exports);
  __exportStar(trie$1, exports);
  __exportStar(types$2, exports);
  __exportStar(util$2, exports);

  }(dist$5));

  var dist$3 = {};

  var eip1559Transaction = {};

  var baseTransaction = {};

  var types$1 = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAccessList = exports.isAccessListBuffer = exports.Capability = void 0;
  (function (Capability) {
      /**
       * Tx supports EIP-155 replay protection
       * See: [155](https://eips.ethereum.org/EIPS/eip-155) Replay Attack Protection EIP
       */
      Capability[Capability["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
      /**
       * Tx supports EIP-1559 gas fee market mechansim
       * See: [1559](https://eips.ethereum.org/EIPS/eip-1559) Fee Market EIP
       */
      Capability[Capability["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
      /**
       * Tx is a typed transaction as defined in EIP-2718
       * See: [2718](https://eips.ethereum.org/EIPS/eip-2718) Transaction Type EIP
       */
      Capability[Capability["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
      /**
       * Tx supports access list generation as defined in EIP-2930
       * See: [2930](https://eips.ethereum.org/EIPS/eip-2930) Access Lists EIP
       */
      Capability[Capability["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
  })(exports.Capability || (exports.Capability = {}));
  function isAccessListBuffer(input) {
      if (input.length === 0) {
          return true;
      }
      const firstItem = input[0];
      if (Array.isArray(firstItem)) {
          return true;
      }
      return false;
  }
  exports.isAccessListBuffer = isAccessListBuffer;
  function isAccessList(input) {
      return !isAccessListBuffer(input); // This is exactly the same method, except the output is negated.
  }
  exports.isAccessList = isAccessList;

  }(types$1));

  Object.defineProperty(baseTransaction, "__esModule", { value: true });
  baseTransaction.BaseTransaction = void 0;
  const common_1$a = dist$8;
  const util_1$i = dist$a;
  const types_1$2 = types$1;
  /**
   * This base class will likely be subject to further
   * refactoring along the introduction of additional tx types
   * on the Ethereum network.
   *
   * It is therefore not recommended to use directly.
   */
  class BaseTransaction {
      constructor(txData, opts) {
          this.cache = {
              hash: undefined,
              dataFee: undefined,
          };
          /**
           * List of tx type defining EIPs,
           * e.g. 1559 (fee market) and 2930 (access lists)
           * for FeeMarketEIP1559Transaction objects
           */
          this.activeCapabilities = [];
          /**
           * The default chain the tx falls back to if no Common
           * is provided and if the chain can't be derived from
           * a passed in chainId (only EIP-2718 typed txs) or
           * EIP-155 signature (legacy txs).
           *
           * @hidden
           */
          this.DEFAULT_CHAIN = common_1$a.Chain.Mainnet;
          /**
           * The default HF if the tx type is active on that HF
           * or the first greater HF where the tx is active.
           *
           * @hidden
           */
          this.DEFAULT_HARDFORK = common_1$a.Hardfork.Merge;
          const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
          this._type = Number((0, util_1$i.bufferToBigInt)((0, util_1$i.toBuffer)(type)));
          this.txOptions = opts;
          const toB = (0, util_1$i.toBuffer)(to === '' ? '0x' : to);
          const vB = (0, util_1$i.toBuffer)(v === '' ? '0x' : v);
          const rB = (0, util_1$i.toBuffer)(r === '' ? '0x' : r);
          const sB = (0, util_1$i.toBuffer)(s === '' ? '0x' : s);
          this.nonce = (0, util_1$i.bufferToBigInt)((0, util_1$i.toBuffer)(nonce === '' ? '0x' : nonce));
          this.gasLimit = (0, util_1$i.bufferToBigInt)((0, util_1$i.toBuffer)(gasLimit === '' ? '0x' : gasLimit));
          this.to = toB.length > 0 ? new util_1$i.Address(toB) : undefined;
          this.value = (0, util_1$i.bufferToBigInt)((0, util_1$i.toBuffer)(value === '' ? '0x' : value));
          this.data = (0, util_1$i.toBuffer)(data === '' ? '0x' : data);
          this.v = vB.length > 0 ? (0, util_1$i.bufferToBigInt)(vB) : undefined;
          this.r = rB.length > 0 ? (0, util_1$i.bufferToBigInt)(rB) : undefined;
          this.s = sB.length > 0 ? (0, util_1$i.bufferToBigInt)(sB) : undefined;
          this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
          // geth limits gasLimit to 2^64-1
          this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
          // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)
          this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
      }
      /**
       * Returns the transaction type.
       *
       * Note: legacy txs will return tx type `0`.
       */
      get type() {
          return this._type;
      }
      /**
       * Checks if a tx type defining capability is active
       * on a tx, for example the EIP-1559 fee market mechanism
       * or the EIP-2930 access list feature.
       *
       * Note that this is different from the tx type itself,
       * so EIP-2930 access lists can very well be active
       * on an EIP-1559 tx for example.
       *
       * This method can be useful for feature checks if the
       * tx type is unknown (e.g. when instantiated with
       * the tx factory).
       *
       * See `Capabilites` in the `types` module for a reference
       * on all supported capabilities.
       */
      supports(capability) {
          return this.activeCapabilities.includes(capability);
      }
      validate(stringError = false) {
          const errors = [];
          if (this.getBaseFee() > this.gasLimit) {
              errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
          }
          if (this.isSigned() && !this.verifySignature()) {
              errors.push('Invalid Signature');
          }
          return stringError ? errors : errors.length === 0;
      }
      _validateYParity() {
          const { v } = this;
          if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {
              const msg = this._errorMsg('The y-parity of the transaction should either be 0 or 1');
              throw new Error(msg);
          }
      }
      /**
       * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.
       * Reasoning: https://ethereum.stackexchange.com/a/55728
       */
      _validateHighS() {
          const { s } = this;
          if (this.common.gteHardfork('homestead') && s !== undefined && s > util_1$i.SECP256K1_ORDER_DIV_2) {
              const msg = this._errorMsg('Invalid Signature: s-values greater than secp256k1n/2 are considered invalid');
              throw new Error(msg);
          }
      }
      /**
       * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
       */
      getBaseFee() {
          const txFee = this.common.param('gasPrices', 'tx');
          let fee = this.getDataFee();
          if (txFee)
              fee += txFee;
          if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {
              const txCreationFee = this.common.param('gasPrices', 'txCreation');
              if (txCreationFee)
                  fee += txCreationFee;
          }
          return fee;
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
          const txDataZero = this.common.param('gasPrices', 'txDataZero');
          const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero');
          let cost = BigInt(0);
          for (let i = 0; i < this.data.length; i++) {
              this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero);
          }
          if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {
              const dataLength = BigInt(Math.ceil(this.data.length / 32));
              const initCodeCost = this.common.param('gasPrices', 'initCodeWordCost') * dataLength;
              cost += initCodeCost;
          }
          return cost;
      }
      /**
       * If the tx's `to` is to the creation address
       */
      toCreationAddress() {
          return this.to === undefined || this.to.buf.length === 0;
      }
      isSigned() {
          const { v, r, s } = this;
          if (v === undefined || r === undefined || s === undefined) {
              return false;
          }
          else {
              return true;
          }
      }
      /**
       * Determines if the signature is valid
       */
      verifySignature() {
          try {
              // Main signature verification is done in `getSenderPublicKey()`
              const publicKey = this.getSenderPublicKey();
              return (0, util_1$i.unpadBuffer)(publicKey).length !== 0;
          }
          catch (e) {
              return false;
          }
      }
      /**
       * Returns the sender's address
       */
      getSenderAddress() {
          return new util_1$i.Address((0, util_1$i.publicToAddress)(this.getSenderPublicKey()));
      }
      /**
       * Signs a transaction.
       *
       * Note that the signed tx is returned as a new object,
       * use as follows:
       * ```javascript
       * const signedTx = tx.sign(privateKey)
       * ```
       */
      sign(privateKey) {
          if (privateKey.length !== 32) {
              const msg = this._errorMsg('Private key must be 32 bytes in length.');
              throw new Error(msg);
          }
          // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature
          // and want to recreate a signature (where EIP155 should be applied)
          // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail
          // 2021-06-23
          let hackApplied = false;
          if (this.type === 0 &&
              this.common.gteHardfork('spuriousDragon') &&
              !this.supports(types_1$2.Capability.EIP155ReplayProtection)) {
              this.activeCapabilities.push(types_1$2.Capability.EIP155ReplayProtection);
              hackApplied = true;
          }
          const msgHash = this.getMessageToSign(true);
          const { v, r, s } = (0, util_1$i.ecsign)(msgHash, privateKey);
          const tx = this._processSignature(v, r, s);
          // Hack part 2
          if (hackApplied) {
              const index = this.activeCapabilities.indexOf(types_1$2.Capability.EIP155ReplayProtection);
              if (index > -1) {
                  this.activeCapabilities.splice(index, 1);
              }
          }
          return tx;
      }
      /**
       * Does chain ID checks on common and returns a common
       * to be used on instantiation
       * @hidden
       *
       * @param common - {@link Common} instance from tx options
       * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)
       */
      _getCommon(common, chainId) {
          // Chain ID provided
          if ((0, util_1$i.isTruthy)(chainId)) {
              const chainIdBigInt = (0, util_1$i.bufferToBigInt)((0, util_1$i.toBuffer)(chainId));
              if (common) {
                  if (common.chainId() !== chainIdBigInt) {
                      const msg = this._errorMsg('The chain ID does not match the chain ID of Common');
                      throw new Error(msg);
                  }
                  // Common provided, chain ID does match
                  // -> Return provided Common
                  return common.copy();
              }
              else {
                  if (common_1$a.Common.isSupportedChainId(chainIdBigInt)) {
                      // No Common, chain ID supported by Common
                      // -> Instantiate Common with chain ID
                      return new common_1$a.Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
                  }
                  else {
                      // No Common, chain ID not supported by Common
                      // -> Instantiate custom Common derived from DEFAULT_CHAIN
                      return common_1$a.Common.custom({
                          name: 'custom-chain',
                          networkId: chainIdBigInt,
                          chainId: chainIdBigInt,
                      }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
                  }
              }
          }
          else {
              // No chain ID provided
              // -> return Common provided or create new default Common
              return (common?.copy() ?? new common_1$a.Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK }));
          }
      }
      /**
       * Validates that an object with BigInt values cannot exceed the specified bit limit.
       * @param values Object containing string keys and BigInt values
       * @param bits Number of bits to check (64 or 256)
       * @param cannotEqual Pass true if the number also cannot equal one less the maximum value
       */
      _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
          for (const [key, value] of Object.entries(values)) {
              switch (bits) {
                  case 64:
                      if (cannotEqual) {
                          if (value !== undefined && value >= util_1$i.MAX_UINT64) {
                              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
                              throw new Error(msg);
                          }
                      }
                      else {
                          if (value !== undefined && value > util_1$i.MAX_UINT64) {
                              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
                              throw new Error(msg);
                          }
                      }
                      break;
                  case 256:
                      if (cannotEqual) {
                          if (value !== undefined && value >= util_1$i.MAX_INTEGER) {
                              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
                              throw new Error(msg);
                          }
                      }
                      else {
                          if (value !== undefined && value > util_1$i.MAX_INTEGER) {
                              const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
                              throw new Error(msg);
                          }
                      }
                      break;
                  default: {
                      const msg = this._errorMsg('unimplemented bits value');
                      throw new Error(msg);
                  }
              }
          }
      }
      /**
       * Returns the shared error postfix part for _error() method
       * tx type implementations.
       */
      _getSharedErrorPostfix() {
          let hash = '';
          try {
              hash = this.isSigned() ? (0, util_1$i.bufferToHex)(this.hash()) : 'not available (unsigned)';
          }
          catch (e) {
              hash = 'error';
          }
          let isSigned = '';
          try {
              isSigned = this.isSigned().toString();
          }
          catch (e) {
              hash = 'error';
          }
          let hf = '';
          try {
              hf = this.common.hardfork();
          }
          catch (e) {
              hf = 'error';
          }
          let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;
          postfix += `signed=${isSigned} hf=${hf}`;
          return postfix;
      }
  }
  baseTransaction.BaseTransaction = BaseTransaction;

  var util$1 = {};

  Object.defineProperty(util$1, "__esModule", { value: true });
  util$1.AccessLists = util$1.checkMaxInitCodeSize = void 0;
  const util_1$h = dist$a;
  const types_1$1 = types$1;
  function checkMaxInitCodeSize(common, length) {
      const maxInitCodeSize = common.param('vm', 'maxInitCodeSize');
      if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
          throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param('vm', 'maxInitCodeSize')}`);
      }
  }
  util$1.checkMaxInitCodeSize = checkMaxInitCodeSize;
  class AccessLists {
      static getAccessListData(accessList) {
          let AccessListJSON;
          let bufferAccessList;
          if ((0, types_1$1.isAccessList)(accessList)) {
              AccessListJSON = accessList;
              const newAccessList = [];
              for (let i = 0; i < accessList.length; i++) {
                  const item = accessList[i];
                  const addressBuffer = (0, util_1$h.toBuffer)(item.address);
                  const storageItems = [];
                  for (let index = 0; index < item.storageKeys.length; index++) {
                      storageItems.push((0, util_1$h.toBuffer)(item.storageKeys[index]));
                  }
                  newAccessList.push([addressBuffer, storageItems]);
              }
              bufferAccessList = newAccessList;
          }
          else {
              bufferAccessList = accessList ?? [];
              // build the JSON
              const json = [];
              for (let i = 0; i < bufferAccessList.length; i++) {
                  const data = bufferAccessList[i];
                  const address = (0, util_1$h.bufferToHex)(data[0]);
                  const storageKeys = [];
                  for (let item = 0; item < data[1].length; item++) {
                      storageKeys.push((0, util_1$h.bufferToHex)(data[1][item]));
                  }
                  const jsonItem = {
                      address,
                      storageKeys,
                  };
                  json.push(jsonItem);
              }
              AccessListJSON = json;
          }
          return {
              AccessListJSON,
              accessList: bufferAccessList,
          };
      }
      static verifyAccessList(accessList) {
          for (let key = 0; key < accessList.length; key++) {
              const accessListItem = accessList[key];
              const address = accessListItem[0];
              const storageSlots = accessListItem[1];
              if (accessListItem[2] !== undefined) {
                  throw new Error('Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.');
              }
              if (address.length != 20) {
                  throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes');
              }
              for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
                  if (storageSlots[storageSlot].length != 32) {
                      throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes');
                  }
              }
          }
      }
      static getAccessListJSON(accessList) {
          const accessListJSON = [];
          for (let index = 0; index < accessList.length; index++) {
              const item = accessList[index];
              const JSONItem = {
                  address: '0x' + (0, util_1$h.setLengthLeft)(item[0], 20).toString('hex'),
                  storageKeys: [],
              };
              const storageSlots = item[1];
              for (let slot = 0; slot < storageSlots.length; slot++) {
                  const storageSlot = storageSlots[slot];
                  JSONItem.storageKeys.push('0x' + (0, util_1$h.setLengthLeft)(storageSlot, 32).toString('hex'));
              }
              accessListJSON.push(JSONItem);
          }
          return accessListJSON;
      }
      static getDataFeeEIP2930(accessList, common) {
          const accessListStorageKeyCost = common.param('gasPrices', 'accessListStorageKeyCost');
          const accessListAddressCost = common.param('gasPrices', 'accessListAddressCost');
          let slots = 0;
          for (let index = 0; index < accessList.length; index++) {
              const item = accessList[index];
              const storageSlots = item[1];
              slots += storageSlots.length;
          }
          const addresses = accessList.length;
          return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
      }
  }
  util$1.AccessLists = AccessLists;

  Object.defineProperty(eip1559Transaction, "__esModule", { value: true });
  eip1559Transaction.FeeMarketEIP1559Transaction = void 0;
  const rlp_1$a = dist$9;
  const util_1$g = dist$a;
  const keccak_1$7 = keccak;
  const baseTransaction_1$2 = baseTransaction;
  const util_2$4 = util$1;
  const TRANSACTION_TYPE$2 = 2;
  const TRANSACTION_TYPE_BUFFER$1 = Buffer$8.from(TRANSACTION_TYPE$2.toString(16).padStart(2, '0'), 'hex');
  /**
   * Typed transaction with a new gas fee market mechanism
   *
   * - TransactionType: 2
   * - EIP: [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)
   */
  class FeeMarketEIP1559Transaction extends baseTransaction_1$2.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
          super({ ...txData, type: TRANSACTION_TYPE$2 }, opts);
          /**
           * The default HF if the tx type is active on that HF
           * or the first greater HF where the tx is active.
           *
           * @hidden
           */
          this.DEFAULT_HARDFORK = 'london';
          const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
          this.common = this._getCommon(opts.common, chainId);
          this.chainId = this.common.chainId();
          if (this.common.isActivatedEIP(1559) === false) {
              throw new Error('EIP-1559 not enabled on Common');
          }
          this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
          // Populate the access list fields
          const accessListData = util_2$4.AccessLists.getAccessListData(accessList ?? []);
          this.accessList = accessListData.accessList;
          this.AccessListJSON = accessListData.AccessListJSON;
          // Verify the access list format.
          util_2$4.AccessLists.verifyAccessList(this.accessList);
          this.maxFeePerGas = (0, util_1$g.bufferToBigInt)((0, util_1$g.toBuffer)(maxFeePerGas === '' ? '0x' : maxFeePerGas));
          this.maxPriorityFeePerGas = (0, util_1$g.bufferToBigInt)((0, util_1$g.toBuffer)(maxPriorityFeePerGas === '' ? '0x' : maxPriorityFeePerGas));
          this._validateCannotExceedMaxInteger({
              maxFeePerGas: this.maxFeePerGas,
              maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          });
          if (this.gasLimit * this.maxFeePerGas > util_1$g.MAX_INTEGER) {
              const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)');
              throw new Error(msg);
          }
          if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
              const msg = this._errorMsg('maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)');
              throw new Error(msg);
          }
          this._validateYParity();
          this._validateHighS();
          if (this.common.isActivatedEIP(3860)) {
              (0, util_2$4.checkMaxInitCodeSize)(this.common, this.data.length);
          }
          const freeze = opts?.freeze ?? true;
          if (freeze) {
              Object.freeze(this);
          }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, v, r, s }
       *
       * Notes:
       * - `chainId` will be set automatically if not provided
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
          return new FeeMarketEIP1559Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS])`
       */
      static fromSerializedTx(serialized, opts = {}) {
          if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER$1)) {
              throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE$2}, received: ${serialized
                .slice(0, 1)
                .toString('hex')}`);
          }
          const values = (0, util_1$g.arrToBufArr)(rlp_1$a.RLP.decode(serialized.slice(1)));
          if (!Array.isArray(values)) {
              throw new Error('Invalid serialized tx input: must be array');
          }
          return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS]`
       */
      static fromValuesArray(values, opts = {}) {
          if (values.length !== 9 && values.length !== 12) {
              throw new Error('Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).');
          }
          const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s,] = values;
          (0, util_1$g.validateNoLeadingZeroes)({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
          return new FeeMarketEIP1559Transaction({
              chainId: (0, util_1$g.bufferToBigInt)(chainId),
              nonce,
              maxPriorityFeePerGas,
              maxFeePerGas,
              gasLimit,
              to,
              value,
              data,
              accessList: accessList ?? [],
              v: v !== undefined ? (0, util_1$g.bufferToBigInt)(v) : undefined,
              r,
              s,
          }, opts);
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
          if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
              return this.cache.dataFee.value;
          }
          let cost = super.getDataFee();
          cost += BigInt(util_2$4.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
          if (Object.isFrozen(this)) {
              this.cache.dataFee = {
                  value: cost,
                  hardfork: this.common.hardfork(),
              };
          }
          return cost;
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       * @param baseFee The base fee of the block (will be set to 0 if not provided)
       */
      getUpfrontCost(baseFee = BigInt(0)) {
          const prio = this.maxPriorityFeePerGas;
          const maxBase = this.maxFeePerGas - baseFee;
          const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
          const gasPrice = inclusionFeePerGas + baseFee;
          return this.gasLimit * gasPrice + this.value;
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the EIP-1559 transaction, in order.
       *
       * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS]`
       *
       * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block
       * with {@link Block.fromValuesArray}.
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.
       */
      raw() {
          return [
              (0, util_1$g.bigIntToUnpaddedBuffer)(this.chainId),
              (0, util_1$g.bigIntToUnpaddedBuffer)(this.nonce),
              (0, util_1$g.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),
              (0, util_1$g.bigIntToUnpaddedBuffer)(this.maxFeePerGas),
              (0, util_1$g.bigIntToUnpaddedBuffer)(this.gasLimit),
              this.to !== undefined ? this.to.buf : Buffer$8.from([]),
              (0, util_1$g.bigIntToUnpaddedBuffer)(this.value),
              this.data,
              this.accessList,
              this.v !== undefined ? (0, util_1$g.bigIntToUnpaddedBuffer)(this.v) : Buffer$8.from([]),
              this.r !== undefined ? (0, util_1$g.bigIntToUnpaddedBuffer)(this.r) : Buffer$8.from([]),
              this.s !== undefined ? (0, util_1$g.bigIntToUnpaddedBuffer)(this.s) : Buffer$8.from([]),
          ];
      }
      /**
       * Returns the serialized encoding of the EIP-1559 transaction.
       *
       * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS])`
       *
       * Note that in contrast to the legacy tx serialization format this is not
       * valid RLP any more due to the raw tx type preceding and concatenated to
       * the RLP encoding of the values.
       */
      serialize() {
          const base = this.raw();
          return Buffer$8.concat([
              TRANSACTION_TYPE_BUFFER$1,
              Buffer$8.from(rlp_1$a.RLP.encode((0, util_1$g.bufArrToArr)(base))),
          ]);
      }
      /**
       * Returns the serialized unsigned tx (hashed or raw), which can be used
       * to sign the transaction (e.g. for sending to a hardware wallet).
       *
       * Note: in contrast to the legacy tx the raw message format is already
       * serialized and doesn't need to be RLP encoded any more.
       *
       * ```javascript
       * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
       * ```
       *
       * @param hashMessage - Return hashed message if set to true (default: true)
       */
      getMessageToSign(hashMessage = true) {
          const base = this.raw().slice(0, 9);
          const message = Buffer$8.concat([
              TRANSACTION_TYPE_BUFFER$1,
              Buffer$8.from(rlp_1$a.RLP.encode((0, util_1$g.bufArrToArr)(base))),
          ]);
          if (hashMessage) {
              return Buffer$8.from((0, keccak_1$7.keccak256)(message));
          }
          else {
              return message;
          }
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
          if (!this.isSigned()) {
              const msg = this._errorMsg('Cannot call hash method if transaction is not signed');
              throw new Error(msg);
          }
          if (Object.isFrozen(this)) {
              if (!this.cache.hash) {
                  this.cache.hash = Buffer$8.from((0, keccak_1$7.keccak256)(this.serialize()));
              }
              return this.cache.hash;
          }
          return Buffer$8.from((0, keccak_1$7.keccak256)(this.serialize()));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
          return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
          if (!this.isSigned()) {
              const msg = this._errorMsg('Cannot call this method if transaction is not signed');
              throw new Error(msg);
          }
          const msgHash = this.getMessageToVerifySignature();
          const { v, r, s } = this;
          this._validateHighS();
          try {
              return (0, util_1$g.ecrecover)(msgHash, v + BigInt(27), // Recover the 27 which was stripped from ecsign
              (0, util_1$g.bigIntToUnpaddedBuffer)(r), (0, util_1$g.bigIntToUnpaddedBuffer)(s));
          }
          catch (e) {
              const msg = this._errorMsg('Invalid Signature');
              throw new Error(msg);
          }
      }
      _processSignature(v, r, s) {
          const opts = { ...this.txOptions, common: this.common };
          return FeeMarketEIP1559Transaction.fromTxData({
              chainId: this.chainId,
              nonce: this.nonce,
              maxPriorityFeePerGas: this.maxPriorityFeePerGas,
              maxFeePerGas: this.maxFeePerGas,
              gasLimit: this.gasLimit,
              to: this.to,
              value: this.value,
              data: this.data,
              accessList: this.accessList,
              v: v - BigInt(27),
              r: (0, util_1$g.bufferToBigInt)(r),
              s: (0, util_1$g.bufferToBigInt)(s),
          }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction
       */
      toJSON() {
          const accessListJSON = util_2$4.AccessLists.getAccessListJSON(this.accessList);
          return {
              chainId: (0, util_1$g.bigIntToHex)(this.chainId),
              nonce: (0, util_1$g.bigIntToHex)(this.nonce),
              maxPriorityFeePerGas: (0, util_1$g.bigIntToHex)(this.maxPriorityFeePerGas),
              maxFeePerGas: (0, util_1$g.bigIntToHex)(this.maxFeePerGas),
              gasLimit: (0, util_1$g.bigIntToHex)(this.gasLimit),
              to: this.to !== undefined ? this.to.toString() : undefined,
              value: (0, util_1$g.bigIntToHex)(this.value),
              data: '0x' + this.data.toString('hex'),
              accessList: accessListJSON,
              v: this.v !== undefined ? (0, util_1$g.bigIntToHex)(this.v) : undefined,
              r: this.r !== undefined ? (0, util_1$g.bigIntToHex)(this.r) : undefined,
              s: this.s !== undefined ? (0, util_1$g.bigIntToHex)(this.s) : undefined,
          };
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
          let errorStr = this._getSharedErrorPostfix();
          errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
          return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
          return `${msg} (${this.errorStr()})`;
      }
  }
  eip1559Transaction.FeeMarketEIP1559Transaction = FeeMarketEIP1559Transaction;

  var eip2930Transaction = {};

  Object.defineProperty(eip2930Transaction, "__esModule", { value: true });
  eip2930Transaction.AccessListEIP2930Transaction = void 0;
  const rlp_1$9 = dist$9;
  const util_1$f = dist$a;
  const keccak_1$6 = keccak;
  const baseTransaction_1$1 = baseTransaction;
  const util_2$3 = util$1;
  const TRANSACTION_TYPE$1 = 1;
  const TRANSACTION_TYPE_BUFFER = Buffer$8.from(TRANSACTION_TYPE$1.toString(16).padStart(2, '0'), 'hex');
  /**
   * Typed transaction with optional access lists
   *
   * - TransactionType: 1
   * - EIP: [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)
   */
  class AccessListEIP2930Transaction extends baseTransaction_1$1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
          super({ ...txData, type: TRANSACTION_TYPE$1 }, opts);
          /**
           * The default HF if the tx type is active on that HF
           * or the first greater HF where the tx is active.
           *
           * @hidden
           */
          this.DEFAULT_HARDFORK = 'berlin';
          const { chainId, accessList, gasPrice } = txData;
          this.common = this._getCommon(opts.common, chainId);
          this.chainId = this.common.chainId();
          // EIP-2718 check is done in Common
          if (!this.common.isActivatedEIP(2930)) {
              throw new Error('EIP-2930 not enabled on Common');
          }
          this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
          // Populate the access list fields
          const accessListData = util_2$3.AccessLists.getAccessListData(accessList ?? []);
          this.accessList = accessListData.accessList;
          this.AccessListJSON = accessListData.AccessListJSON;
          // Verify the access list format.
          util_2$3.AccessLists.verifyAccessList(this.accessList);
          this.gasPrice = (0, util_1$f.bufferToBigInt)((0, util_1$f.toBuffer)(gasPrice === '' ? '0x' : gasPrice));
          this._validateCannotExceedMaxInteger({
              gasPrice: this.gasPrice,
          });
          if (this.gasPrice * this.gasLimit > util_1$f.MAX_INTEGER) {
              const msg = this._errorMsg('gasLimit * gasPrice cannot exceed MAX_INTEGER');
              throw new Error(msg);
          }
          this._validateYParity();
          this._validateHighS();
          if (this.common.isActivatedEIP(3860)) {
              (0, util_2$3.checkMaxInitCodeSize)(this.common, this.data.length);
          }
          const freeze = opts?.freeze ?? true;
          if (freeze) {
              Object.freeze(this);
          }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * v, r, s }
       *
       * Notes:
       * - `chainId` will be set automatically if not provided
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
          return new AccessListEIP2930Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)])`
       */
      static fromSerializedTx(serialized, opts = {}) {
          if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
              throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE$1}, received: ${serialized
                .slice(0, 1)
                .toString('hex')}`);
          }
          const values = (0, util_1$f.arrToBufArr)(rlp_1$9.RLP.decode(Uint8Array.from(serialized.slice(1))));
          if (!Array.isArray(values)) {
              throw new Error('Invalid serialized tx input: must be array');
          }
          return AccessListEIP2930Transaction.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)]`
       */
      static fromValuesArray(values, opts = {}) {
          if (values.length !== 8 && values.length !== 11) {
              throw new Error('Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).');
          }
          const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
          (0, util_1$f.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
          const emptyAccessList = [];
          return new AccessListEIP2930Transaction({
              chainId: (0, util_1$f.bufferToBigInt)(chainId),
              nonce,
              gasPrice,
              gasLimit,
              to,
              value,
              data,
              accessList: accessList ?? emptyAccessList,
              v: v !== undefined ? (0, util_1$f.bufferToBigInt)(v) : undefined,
              r,
              s,
          }, opts);
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
          if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
              return this.cache.dataFee.value;
          }
          let cost = super.getDataFee();
          cost += BigInt(util_2$3.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
          if (Object.isFrozen(this)) {
              this.cache.dataFee = {
                  value: cost,
                  hardfork: this.common.hardfork(),
              };
          }
          return cost;
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       */
      getUpfrontCost() {
          return this.gasLimit * this.gasPrice + this.value;
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.
       *
       * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)]`
       *
       * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block
       * with {@link Block.fromValuesArray}.
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.
       */
      raw() {
          return [
              (0, util_1$f.bigIntToUnpaddedBuffer)(this.chainId),
              (0, util_1$f.bigIntToUnpaddedBuffer)(this.nonce),
              (0, util_1$f.bigIntToUnpaddedBuffer)(this.gasPrice),
              (0, util_1$f.bigIntToUnpaddedBuffer)(this.gasLimit),
              this.to !== undefined ? this.to.buf : Buffer$8.from([]),
              (0, util_1$f.bigIntToUnpaddedBuffer)(this.value),
              this.data,
              this.accessList,
              this.v !== undefined ? (0, util_1$f.bigIntToUnpaddedBuffer)(this.v) : Buffer$8.from([]),
              this.r !== undefined ? (0, util_1$f.bigIntToUnpaddedBuffer)(this.r) : Buffer$8.from([]),
              this.s !== undefined ? (0, util_1$f.bigIntToUnpaddedBuffer)(this.s) : Buffer$8.from([]),
          ];
      }
      /**
       * Returns the serialized encoding of the EIP-2930 transaction.
       *
       * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)])`
       *
       * Note that in contrast to the legacy tx serialization format this is not
       * valid RLP any more due to the raw tx type preceding and concatenated to
       * the RLP encoding of the values.
       */
      serialize() {
          const base = this.raw();
          return Buffer$8.concat([
              TRANSACTION_TYPE_BUFFER,
              Buffer$8.from(rlp_1$9.RLP.encode((0, util_1$f.bufArrToArr)(base))),
          ]);
      }
      /**
       * Returns the serialized unsigned tx (hashed or raw), which can be used
       * to sign the transaction (e.g. for sending to a hardware wallet).
       *
       * Note: in contrast to the legacy tx the raw message format is already
       * serialized and doesn't need to be RLP encoded any more.
       *
       * ```javascript
       * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
       * ```
       *
       * @param hashMessage - Return hashed message if set to true (default: true)
       */
      getMessageToSign(hashMessage = true) {
          const base = this.raw().slice(0, 8);
          const message = Buffer$8.concat([
              TRANSACTION_TYPE_BUFFER,
              Buffer$8.from(rlp_1$9.RLP.encode((0, util_1$f.bufArrToArr)(base))),
          ]);
          if (hashMessage) {
              return Buffer$8.from((0, keccak_1$6.keccak256)(message));
          }
          else {
              return message;
          }
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
          if (!this.isSigned()) {
              const msg = this._errorMsg('Cannot call hash method if transaction is not signed');
              throw new Error(msg);
          }
          if (Object.isFrozen(this)) {
              if (!this.cache.hash) {
                  this.cache.hash = Buffer$8.from((0, keccak_1$6.keccak256)(this.serialize()));
              }
              return this.cache.hash;
          }
          return Buffer$8.from((0, keccak_1$6.keccak256)(this.serialize()));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
          return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
          if (!this.isSigned()) {
              const msg = this._errorMsg('Cannot call this method if transaction is not signed');
              throw new Error(msg);
          }
          const msgHash = this.getMessageToVerifySignature();
          const { v, r, s } = this;
          this._validateHighS();
          try {
              return (0, util_1$f.ecrecover)(msgHash, v + BigInt(27), // Recover the 27 which was stripped from ecsign
              (0, util_1$f.bigIntToUnpaddedBuffer)(r), (0, util_1$f.bigIntToUnpaddedBuffer)(s));
          }
          catch (e) {
              const msg = this._errorMsg('Invalid Signature');
              throw new Error(msg);
          }
      }
      _processSignature(v, r, s) {
          const opts = { ...this.txOptions, common: this.common };
          return AccessListEIP2930Transaction.fromTxData({
              chainId: this.chainId,
              nonce: this.nonce,
              gasPrice: this.gasPrice,
              gasLimit: this.gasLimit,
              to: this.to,
              value: this.value,
              data: this.data,
              accessList: this.accessList,
              v: v - BigInt(27),
              r: (0, util_1$f.bufferToBigInt)(r),
              s: (0, util_1$f.bufferToBigInt)(s),
          }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction
       */
      toJSON() {
          const accessListJSON = util_2$3.AccessLists.getAccessListJSON(this.accessList);
          return {
              chainId: (0, util_1$f.bigIntToHex)(this.chainId),
              nonce: (0, util_1$f.bigIntToHex)(this.nonce),
              gasPrice: (0, util_1$f.bigIntToHex)(this.gasPrice),
              gasLimit: (0, util_1$f.bigIntToHex)(this.gasLimit),
              to: this.to !== undefined ? this.to.toString() : undefined,
              value: (0, util_1$f.bigIntToHex)(this.value),
              data: '0x' + this.data.toString('hex'),
              accessList: accessListJSON,
              v: this.v !== undefined ? (0, util_1$f.bigIntToHex)(this.v) : undefined,
              r: this.r !== undefined ? (0, util_1$f.bigIntToHex)(this.r) : undefined,
              s: this.s !== undefined ? (0, util_1$f.bigIntToHex)(this.s) : undefined,
          };
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
          let errorStr = this._getSharedErrorPostfix();
          // Keep ? for this.accessList since this otherwise causes Hardhat E2E tests to fail
          errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`;
          return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
          return `${msg} (${this.errorStr()})`;
      }
  }
  eip2930Transaction.AccessListEIP2930Transaction = AccessListEIP2930Transaction;

  var legacyTransaction = {};

  Object.defineProperty(legacyTransaction, "__esModule", { value: true });
  legacyTransaction.Transaction = void 0;
  const rlp_1$8 = dist$9;
  const util_1$e = dist$a;
  const keccak_1$5 = keccak;
  const baseTransaction_1 = baseTransaction;
  const types_1 = types$1;
  const util_2$2 = util$1;
  const TRANSACTION_TYPE = 0;
  function meetsEIP155(_v, chainId) {
      const v = Number(_v);
      const chainIdDoubled = Number(chainId) * 2;
      return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
  }
  /**
   * An Ethereum non-typed (legacy) transaction
   */
  class Transaction extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
          super({ ...txData, type: TRANSACTION_TYPE }, opts);
          this.common = this._validateTxV(this.v, opts.common);
          this.gasPrice = (0, util_1$e.bufferToBigInt)((0, util_1$e.toBuffer)(txData.gasPrice === '' ? '0x' : txData.gasPrice));
          if (this.gasPrice * this.gasLimit > util_1$e.MAX_INTEGER) {
              const msg = this._errorMsg('gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)');
              throw new Error(msg);
          }
          this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
          if (this.common.gteHardfork('spuriousDragon')) {
              if (!this.isSigned()) {
                  this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
              }
              else {
                  // EIP155 spec:
                  // If block.number >= 2,675,000 and v = CHAIN_ID * 2 + 35 or v = CHAIN_ID * 2 + 36
                  // then when computing the hash of a transaction for purposes of signing or recovering
                  // instead of hashing only the first six elements (i.e. nonce, gasprice, startgas, to, value, data)
                  // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0.
                  // v and chain ID meet EIP-155 conditions
                  if (meetsEIP155(this.v, this.common.chainId())) {
                      this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
                  }
              }
          }
          if (this.common.isActivatedEIP(3860)) {
              (0, util_2$2.checkMaxInitCodeSize)(this.common, this.data.length);
          }
          const freeze = opts?.freeze ?? true;
          if (freeze) {
              Object.freeze(this);
          }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }
       *
       * Notes:
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
          return new Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
       */
      static fromSerializedTx(serialized, opts = {}) {
          const values = (0, util_1$e.arrToBufArr)(rlp_1$8.RLP.decode(Uint8Array.from(serialized)));
          if (!Array.isArray(values)) {
              throw new Error('Invalid serialized tx input. Must be array');
          }
          return this.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
       */
      static fromValuesArray(values, opts = {}) {
          // If length is not 6, it has length 9. If v/r/s are empty Buffers, it is still an unsigned transaction
          // This happens if you get the RLP data from `raw()`
          if (values.length !== 6 && values.length !== 9) {
              throw new Error('Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).');
          }
          const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
          (0, util_1$e.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
          return new Transaction({
              nonce,
              gasPrice,
              gasLimit,
              to,
              value,
              data,
              v,
              r,
              s,
          }, opts);
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the legacy transaction, in order.
       *
       * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
       *
       * For legacy txs this is also the correct format to add transactions
       * to a block with {@link Block.fromValuesArray} (use the `serialize()` method
       * for typed txs).
       *
       * For an unsigned tx this method returns the empty Buffer values
       * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant
       * representation have a look at {@link Transaction.getMessageToSign}.
       */
      raw() {
          return [
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.nonce),
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.gasPrice),
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.gasLimit),
              this.to !== undefined ? this.to.buf : Buffer$8.from([]),
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.value),
              this.data,
              this.v !== undefined ? (0, util_1$e.bigIntToUnpaddedBuffer)(this.v) : Buffer$8.from([]),
              this.r !== undefined ? (0, util_1$e.bigIntToUnpaddedBuffer)(this.r) : Buffer$8.from([]),
              this.s !== undefined ? (0, util_1$e.bigIntToUnpaddedBuffer)(this.s) : Buffer$8.from([]),
          ];
      }
      /**
       * Returns the serialized encoding of the legacy transaction.
       *
       * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link Transaction.getMessageToSign}.
       */
      serialize() {
          return Buffer$8.from(rlp_1$8.RLP.encode((0, util_1$e.bufArrToArr)(this.raw())));
      }
      _getMessageToSign() {
          const values = [
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.nonce),
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.gasPrice),
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.gasLimit),
              this.to !== undefined ? this.to.buf : Buffer$8.from([]),
              (0, util_1$e.bigIntToUnpaddedBuffer)(this.value),
              this.data,
          ];
          if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
              values.push((0, util_1$e.toBuffer)(this.common.chainId()));
              values.push((0, util_1$e.unpadBuffer)((0, util_1$e.toBuffer)(0)));
              values.push((0, util_1$e.unpadBuffer)((0, util_1$e.toBuffer)(0)));
          }
          return values;
      }
      getMessageToSign(hashMessage = true) {
          const message = this._getMessageToSign();
          if (hashMessage) {
              return Buffer$8.from((0, keccak_1$5.keccak256)(rlp_1$8.RLP.encode((0, util_1$e.bufArrToArr)(message))));
          }
          else {
              return message;
          }
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
          if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
              return this.cache.dataFee.value;
          }
          if (Object.isFrozen(this)) {
              this.cache.dataFee = {
                  value: super.getDataFee(),
                  hardfork: this.common.hardfork(),
              };
          }
          return super.getDataFee();
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       */
      getUpfrontCost() {
          return this.gasLimit * this.gasPrice + this.value;
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
          if (!this.isSigned()) {
              const msg = this._errorMsg('Cannot call hash method if transaction is not signed');
              throw new Error(msg);
          }
          if (Object.isFrozen(this)) {
              if (!this.cache.hash) {
                  this.cache.hash = Buffer$8.from((0, keccak_1$5.keccak256)(rlp_1$8.RLP.encode((0, util_1$e.bufArrToArr)(this.raw()))));
              }
              return this.cache.hash;
          }
          return Buffer$8.from((0, keccak_1$5.keccak256)(rlp_1$8.RLP.encode((0, util_1$e.bufArrToArr)(this.raw()))));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
          if (!this.isSigned()) {
              const msg = this._errorMsg('This transaction is not signed');
              throw new Error(msg);
          }
          const message = this._getMessageToSign();
          return Buffer$8.from((0, keccak_1$5.keccak256)(rlp_1$8.RLP.encode((0, util_1$e.bufArrToArr)(message))));
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
          const msgHash = this.getMessageToVerifySignature();
          const { v, r, s } = this;
          this._validateHighS();
          try {
              return (0, util_1$e.ecrecover)(msgHash, v, (0, util_1$e.bigIntToUnpaddedBuffer)(r), (0, util_1$e.bigIntToUnpaddedBuffer)(s), this.supports(types_1.Capability.EIP155ReplayProtection) ? this.common.chainId() : undefined);
          }
          catch (e) {
              const msg = this._errorMsg('Invalid Signature');
              throw new Error(msg);
          }
      }
      /**
       * Process the v, r, s values from the `sign` method of the base transaction.
       */
      _processSignature(v, r, s) {
          if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
              v += this.common.chainId() * BigInt(2) + BigInt(8);
          }
          const opts = { ...this.txOptions, common: this.common };
          return Transaction.fromTxData({
              nonce: this.nonce,
              gasPrice: this.gasPrice,
              gasLimit: this.gasLimit,
              to: this.to,
              value: this.value,
              data: this.data,
              v,
              r: (0, util_1$e.bufferToBigInt)(r),
              s: (0, util_1$e.bufferToBigInt)(s),
          }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction.
       */
      toJSON() {
          return {
              nonce: (0, util_1$e.bigIntToHex)(this.nonce),
              gasPrice: (0, util_1$e.bigIntToHex)(this.gasPrice),
              gasLimit: (0, util_1$e.bigIntToHex)(this.gasLimit),
              to: this.to !== undefined ? this.to.toString() : undefined,
              value: (0, util_1$e.bigIntToHex)(this.value),
              data: '0x' + this.data.toString('hex'),
              v: this.v !== undefined ? (0, util_1$e.bigIntToHex)(this.v) : undefined,
              r: this.r !== undefined ? (0, util_1$e.bigIntToHex)(this.r) : undefined,
              s: this.s !== undefined ? (0, util_1$e.bigIntToHex)(this.s) : undefined,
          };
      }
      /**
       * Validates tx's `v` value
       */
      _validateTxV(_v, common) {
          let chainIdBigInt;
          const v = _v !== undefined ? Number(_v) : undefined;
          // Check for valid v values in the scope of a signed legacy tx
          if (v !== undefined) {
              // v is 1. not matching the EIP-155 chainId included case and...
              // v is 2. not matching the classic v=27 or v=28 case
              if (v < 37 && v !== 27 && v !== 28) {
                  throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
              }
          }
          // No unsigned tx and EIP-155 activated and chain ID included
          if (v !== undefined &&
              v !== 0 &&
              (!common || common.gteHardfork('spuriousDragon')) &&
              v !== 27 &&
              v !== 28) {
              if (common) {
                  if (!meetsEIP155(BigInt(v), common.chainId())) {
                      throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
                  }
              }
              else {
                  // Derive the original chain ID
                  let numSub;
                  if ((v - 35) % 2 === 0) {
                      numSub = 35;
                  }
                  else {
                      numSub = 36;
                  }
                  // Use derived chain ID to create a proper Common
                  chainIdBigInt = BigInt(v - numSub) / BigInt(2);
              }
          }
          return this._getCommon(common, chainIdBigInt);
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
          let errorStr = this._getSharedErrorPostfix();
          errorStr += ` gasPrice=${this.gasPrice}`;
          return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
          return `${msg} (${this.errorStr()})`;
      }
  }
  legacyTransaction.Transaction = Transaction;

  var transactionFactory = {};

  Object.defineProperty(transactionFactory, "__esModule", { value: true });
  transactionFactory.TransactionFactory = void 0;
  const util_1$d = dist$a;
  const eip1559Transaction_1 = eip1559Transaction;
  const eip2930Transaction_1 = eip2930Transaction;
  const legacyTransaction_1 = legacyTransaction;
  class TransactionFactory {
      // It is not possible to instantiate a TransactionFactory object.
      constructor() { }
      /**
       * Create a transaction from a `txData` object
       *
       * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
       * @param txOptions - Options to pass on to the constructor of the transaction
       */
      static fromTxData(txData, txOptions = {}) {
          if (!('type' in txData) || txData.type === undefined) {
              // Assume legacy transaction
              return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
          }
          else {
              const txType = Number((0, util_1$d.bufferToBigInt)((0, util_1$d.toBuffer)(txData.type)));
              if (txType === 0) {
                  return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
              }
              else if (txType === 1) {
                  return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);
              }
              else if (txType === 2) {
                  return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
              }
              else {
                  throw new Error(`Tx instantiation with type ${txType} not supported`);
              }
          }
      }
      /**
       * This method tries to decode serialized data.
       *
       * @param data - The data Buffer
       * @param txOptions - The transaction options
       */
      static fromSerializedData(data, txOptions = {}) {
          if (data[0] <= 0x7f) {
              // Determine the type.
              let EIP;
              switch (data[0]) {
                  case 1:
                      EIP = 2930;
                      break;
                  case 2:
                      EIP = 1559;
                      break;
                  default:
                      throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
              }
              if (EIP === 1559) {
                  return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
              }
              else {
                  // EIP === 2930
                  return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
              }
          }
          else {
              return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);
          }
      }
      /**
       * When decoding a BlockBody, in the transactions field, a field is either:
       * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))
       * A Buffer[] (Legacy Transaction)
       * This method returns the right transaction.
       *
       * @param data - A Buffer or Buffer[]
       * @param txOptions - The transaction options
       */
      static fromBlockBodyData(data, txOptions = {}) {
          if (Buffer$8.isBuffer(data)) {
              return this.fromSerializedData(data, txOptions);
          }
          else if (Array.isArray(data)) {
              // It is a legacy transaction
              return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);
          }
          else {
              throw new Error('Cannot decode transaction: unknown type input');
          }
      }
  }
  transactionFactory.TransactionFactory = TransactionFactory;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransactionFactory = exports.Transaction = exports.AccessListEIP2930Transaction = exports.FeeMarketEIP1559Transaction = void 0;
  var eip1559Transaction_1 = eip1559Transaction;
  Object.defineProperty(exports, "FeeMarketEIP1559Transaction", { enumerable: true, get: function () { return eip1559Transaction_1.FeeMarketEIP1559Transaction; } });
  var eip2930Transaction_1 = eip2930Transaction;
  Object.defineProperty(exports, "AccessListEIP2930Transaction", { enumerable: true, get: function () { return eip2930Transaction_1.AccessListEIP2930Transaction; } });
  var legacyTransaction_1 = legacyTransaction;
  Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return legacyTransaction_1.Transaction; } });
  var transactionFactory_1 = transactionFactory;
  Object.defineProperty(exports, "TransactionFactory", { enumerable: true, get: function () { return transactionFactory_1.TransactionFactory; } });
  __exportStar(types$1, exports);

  }(dist$3));

  var header = {};

  var clique$1 = {};

  Object.defineProperty(clique$1, "__esModule", { value: true });
  clique$1.CLIQUE_EXTRA_SEAL = clique$1.CLIQUE_EXTRA_VANITY = void 0;
  // Fixed number of extra-data prefix bytes reserved for signer vanity
  clique$1.CLIQUE_EXTRA_VANITY = 32;
  // Fixed number of extra-data suffix bytes reserved for signer seal
  clique$1.CLIQUE_EXTRA_SEAL = 65;

  Object.defineProperty(header, "__esModule", { value: true });
  header.BlockHeader = void 0;
  const common_1$9 = dist$8;
  const rlp_1$7 = dist$9;
  const util_1$c = dist$a;
  const keccak_1$4 = keccak;
  const clique_1 = clique$1;
  const DEFAULT_GAS_LIMIT = BigInt('0xffffffffffffff');
  /**
   * An object that represents the block header.
   */
  class BlockHeader {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * @deprecated Use the public static factory methods to assist in creating a Header object from
       * varying data types. For a default empty header, use {@link BlockHeader.fromHeaderData}.
       *
       */
      constructor(headerData, options = {}) {
          this.cache = {
              hash: undefined,
          };
          if (options.common) {
              this._common = options.common.copy();
          }
          else {
              this._common = new common_1$9.Common({
                  chain: common_1$9.Chain.Mainnet, // default
              });
          }
          if (options.hardforkByBlockNumber !== undefined && options.hardforkByTTD !== undefined) {
              throw new Error(`The hardforkByBlockNumber and hardforkByTTD options can't be used in conjunction`);
          }
          const defaults = {
              parentHash: (0, util_1$c.zeros)(32),
              uncleHash: util_1$c.KECCAK256_RLP_ARRAY,
              coinbase: util_1$c.Address.zero(),
              stateRoot: (0, util_1$c.zeros)(32),
              transactionsTrie: util_1$c.KECCAK256_RLP,
              receiptTrie: util_1$c.KECCAK256_RLP,
              logsBloom: (0, util_1$c.zeros)(256),
              difficulty: BigInt(0),
              number: BigInt(0),
              gasLimit: DEFAULT_GAS_LIMIT,
              gasUsed: BigInt(0),
              timestamp: BigInt(0),
              extraData: Buffer$8.from([]),
              mixHash: (0, util_1$c.zeros)(32),
              nonce: (0, util_1$c.zeros)(8),
              baseFeePerGas: undefined,
          };
          const parentHash = (0, util_1$c.toType)(headerData.parentHash, util_1$c.TypeOutput.Buffer) ?? defaults.parentHash;
          const uncleHash = (0, util_1$c.toType)(headerData.uncleHash, util_1$c.TypeOutput.Buffer) ?? defaults.uncleHash;
          const coinbase = (0, util_1$c.isTruthy)(headerData.coinbase)
              ? new util_1$c.Address((0, util_1$c.toType)(headerData.coinbase, util_1$c.TypeOutput.Buffer))
              : defaults.coinbase;
          const stateRoot = (0, util_1$c.toType)(headerData.stateRoot, util_1$c.TypeOutput.Buffer) ?? defaults.stateRoot;
          const transactionsTrie = (0, util_1$c.toType)(headerData.transactionsTrie, util_1$c.TypeOutput.Buffer) ?? defaults.transactionsTrie;
          const receiptTrie = (0, util_1$c.toType)(headerData.receiptTrie, util_1$c.TypeOutput.Buffer) ?? defaults.receiptTrie;
          const logsBloom = (0, util_1$c.toType)(headerData.logsBloom, util_1$c.TypeOutput.Buffer) ?? defaults.logsBloom;
          const difficulty = (0, util_1$c.toType)(headerData.difficulty, util_1$c.TypeOutput.BigInt) ?? defaults.difficulty;
          const number = (0, util_1$c.toType)(headerData.number, util_1$c.TypeOutput.BigInt) ?? defaults.number;
          const gasLimit = (0, util_1$c.toType)(headerData.gasLimit, util_1$c.TypeOutput.BigInt) ?? defaults.gasLimit;
          const gasUsed = (0, util_1$c.toType)(headerData.gasUsed, util_1$c.TypeOutput.BigInt) ?? defaults.gasUsed;
          const timestamp = (0, util_1$c.toType)(headerData.timestamp, util_1$c.TypeOutput.BigInt) ?? defaults.timestamp;
          const extraData = (0, util_1$c.toType)(headerData.extraData, util_1$c.TypeOutput.Buffer) ?? defaults.extraData;
          const mixHash = (0, util_1$c.toType)(headerData.mixHash, util_1$c.TypeOutput.Buffer) ?? defaults.mixHash;
          const nonce = (0, util_1$c.toType)(headerData.nonce, util_1$c.TypeOutput.Buffer) ?? defaults.nonce;
          let baseFeePerGas = (0, util_1$c.toType)(headerData.baseFeePerGas, util_1$c.TypeOutput.BigInt) ?? defaults.baseFeePerGas;
          const hardforkByBlockNumber = options.hardforkByBlockNumber ?? false;
          if (hardforkByBlockNumber || options.hardforkByTTD !== undefined) {
              this._common.setHardforkByBlockNumber(number, options.hardforkByTTD);
          }
          if (this._common.isActivatedEIP(1559) === true) {
              if (baseFeePerGas === undefined) {
                  if (number === this._common.hardforkBlock(common_1$9.Hardfork.London)) {
                      baseFeePerGas = this._common.param('gasConfig', 'initialBaseFee');
                  }
                  else {
                      // Minimum possible value for baseFeePerGas is 7,
                      // so we use it as the default if the field is missing.
                      baseFeePerGas = BigInt(7);
                  }
              }
          }
          else {
              if (baseFeePerGas) {
                  throw new Error('A base fee for a block can only be set with EIP1559 being activated');
              }
          }
          this.parentHash = parentHash;
          this.uncleHash = uncleHash;
          this.coinbase = coinbase;
          this.stateRoot = stateRoot;
          this.transactionsTrie = transactionsTrie;
          this.receiptTrie = receiptTrie;
          this.logsBloom = logsBloom;
          this.difficulty = difficulty;
          this.number = number;
          this.gasLimit = gasLimit;
          this.gasUsed = gasUsed;
          this.timestamp = timestamp;
          this.extraData = extraData;
          this.mixHash = mixHash;
          this.nonce = nonce;
          this.baseFeePerGas = baseFeePerGas;
          this._genericFormatValidation();
          this._validateDAOExtraData();
          // Now we have set all the values of this Header, we possibly have set a dummy
          // `difficulty` value (defaults to 0). If we have a `calcDifficultyFromHeader`
          // block option parameter, we instead set difficulty to this value.
          if (options.calcDifficultyFromHeader &&
              this._common.consensusAlgorithm() === common_1$9.ConsensusAlgorithm.Ethash) {
              this.difficulty = this.ethashCanonicalDifficulty(options.calcDifficultyFromHeader);
          }
          // If cliqueSigner is provided, seal block with provided privateKey.
          if (options.cliqueSigner) {
              // Ensure extraData is at least length CLIQUE_EXTRA_VANITY + CLIQUE_EXTRA_SEAL
              const minExtraDataLength = clique_1.CLIQUE_EXTRA_VANITY + clique_1.CLIQUE_EXTRA_SEAL;
              if (this.extraData.length < minExtraDataLength) {
                  const remainingLength = minExtraDataLength - this.extraData.length;
                  this.extraData = Buffer$8.concat([this.extraData, Buffer$8.alloc(remainingLength)]);
              }
              this.extraData = this.cliqueSealBlock(options.cliqueSigner);
          }
          // Validate consensus format after block is sealed (if applicable) so extraData checks will pass
          this._consensusFormatValidation();
          const freeze = options?.freeze ?? true;
          if (freeze) {
              Object.freeze(this);
          }
      }
      /**
       * EIP-4399: After merge to PoS, `mixHash` supplanted as `prevRandao`
       */
      get prevRandao() {
          if (this._common.isActivatedEIP(4399) === false) {
              const msg = this._errorMsg('The prevRandao parameter can only be accessed when EIP-4399 is activated');
              throw new Error(msg);
          }
          return this.mixHash;
      }
      /**
       * Static constructor to create a block header from a header data dictionary
       *
       * @param headerData
       * @param opts
       */
      static fromHeaderData(headerData = {}, opts = {}) {
          return new BlockHeader(headerData, opts);
      }
      /**
       * Static constructor to create a block header from a RLP-serialized header
       *
       * @param serializedHeaderData
       * @param opts
       */
      static fromRLPSerializedHeader(serializedHeaderData, opts = {}) {
          const values = (0, util_1$c.arrToBufArr)(rlp_1$7.RLP.decode(Uint8Array.from(serializedHeaderData)));
          if (!Array.isArray(values)) {
              throw new Error('Invalid serialized header input. Must be array');
          }
          // If an RLP serialized block header is provided and no `hardforkByBlockNumber` opt is provided, default true to
          // avoid scenarios where no `opts.common` or `opts.hardforkByBlockNumber` is provided and a serialized blockheader
          // is provided that predates London result in a default base fee being added to the block
          // (resulting in an erroneous block hash since the default `common` hardfork is London and the blockheader constructor
          // adds a default basefee if EIP-1559 is active and no basefee is provided in the `headerData`)
          if (opts.hardforkByTTD === undefined) {
              opts.hardforkByBlockNumber = opts.hardforkByBlockNumber ?? true;
          }
          return BlockHeader.fromValuesArray(values, opts);
      }
      /**
       * Static constructor to create a block header from an array of Buffer values
       *
       * @param values
       * @param opts
       */
      static fromValuesArray(values, opts = {}) {
          const [parentHash, uncleHash, coinbase, stateRoot, transactionsTrie, receiptTrie, logsBloom, difficulty, number, gasLimit, gasUsed, timestamp, extraData, mixHash, nonce, baseFeePerGas,] = values;
          if (values.length > 16) {
              throw new Error('invalid header. More values than expected were received');
          }
          if (values.length < 15) {
              throw new Error('invalid header. Less values than expected were received');
          }
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          if (opts.common?.isActivatedEIP(1559) && baseFeePerGas === undefined) {
              const eip1559ActivationBlock = (0, util_1$c.bigIntToBuffer)(opts.common?.eipBlock(1559));
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              if (eip1559ActivationBlock && eip1559ActivationBlock.equals(number)) {
                  throw new Error('invalid header. baseFeePerGas should be provided');
              }
          }
          return new BlockHeader({
              parentHash,
              uncleHash,
              coinbase,
              stateRoot,
              transactionsTrie,
              receiptTrie,
              logsBloom,
              difficulty,
              number,
              gasLimit,
              gasUsed,
              timestamp,
              extraData,
              mixHash,
              nonce,
              baseFeePerGas,
          }, opts);
      }
      /**
       * Validates correct buffer lengths, throws if invalid.
       */
      _genericFormatValidation() {
          const { parentHash, stateRoot, transactionsTrie, receiptTrie, mixHash, nonce } = this;
          if (parentHash.length !== 32) {
              const msg = this._errorMsg(`parentHash must be 32 bytes, received ${parentHash.length} bytes`);
              throw new Error(msg);
          }
          if (stateRoot.length !== 32) {
              const msg = this._errorMsg(`stateRoot must be 32 bytes, received ${stateRoot.length} bytes`);
              throw new Error(msg);
          }
          if (transactionsTrie.length !== 32) {
              const msg = this._errorMsg(`transactionsTrie must be 32 bytes, received ${transactionsTrie.length} bytes`);
              throw new Error(msg);
          }
          if (receiptTrie.length !== 32) {
              const msg = this._errorMsg(`receiptTrie must be 32 bytes, received ${receiptTrie.length} bytes`);
              throw new Error(msg);
          }
          if (mixHash.length !== 32) {
              const msg = this._errorMsg(`mixHash must be 32 bytes, received ${mixHash.length} bytes`);
              throw new Error(msg);
          }
          if (nonce.length !== 8) {
              // Hack to check for Kovan due to non-standard nonce length (65 bytes)
              if (this._common.networkId() === BigInt(common_1$9.Chain.Kovan)) {
                  if (nonce.length !== 65) {
                      const msg = this._errorMsg(`nonce must be 65 bytes on kovan, received ${nonce.length} bytes`);
                      throw new Error(msg);
                  }
              }
              else {
                  const msg = this._errorMsg(`nonce must be 8 bytes, received ${nonce.length} bytes`);
                  throw new Error(msg);
              }
          }
          // check if the block used too much gas
          if (this.gasUsed > this.gasLimit) {
              const msg = this._errorMsg('Invalid block: too much gas used');
              throw new Error(msg);
          }
          // Validation for EIP-1559 blocks
          if (this._common.isActivatedEIP(1559) === true) {
              if (typeof this.baseFeePerGas !== 'bigint') {
                  const msg = this._errorMsg('EIP1559 block has no base fee field');
                  throw new Error(msg);
              }
              const londonHfBlock = this._common.hardforkBlock(common_1$9.Hardfork.London);
              if ((0, util_1$c.isTruthy)(londonHfBlock) && this.number === londonHfBlock) {
                  const initialBaseFee = this._common.param('gasConfig', 'initialBaseFee');
                  if (this.baseFeePerGas !== initialBaseFee) {
                      const msg = this._errorMsg('Initial EIP1559 block does not have initial base fee');
                      throw new Error(msg);
                  }
              }
          }
      }
      /**
       * Checks static parameters related to consensus algorithm
       * @throws if any check fails
       */
      _consensusFormatValidation() {
          const { nonce, uncleHash, difficulty, extraData } = this;
          const hardfork = this._common.hardfork();
          // Consensus type dependent checks
          if (this._common.consensusAlgorithm() === common_1$9.ConsensusAlgorithm.Ethash) {
              // PoW/Ethash
              if (this.extraData.length > this._common.paramByHardfork('vm', 'maxExtraDataSize', hardfork)) {
                  const msg = this._errorMsg('invalid amount of extra data');
                  throw new Error(msg);
              }
          }
          if (this._common.consensusAlgorithm() === common_1$9.ConsensusAlgorithm.Clique) {
              // PoA/Clique
              const minLength = clique_1.CLIQUE_EXTRA_VANITY + clique_1.CLIQUE_EXTRA_SEAL;
              if (!this.cliqueIsEpochTransition()) {
                  // ExtraData length on epoch transition
                  if (this.extraData.length !== minLength) {
                      const msg = this._errorMsg(`extraData must be ${minLength} bytes on non-epoch transition blocks, received ${this.extraData.length} bytes`);
                      throw new Error(msg);
                  }
              }
              else {
                  const signerLength = this.extraData.length - minLength;
                  if (signerLength % 20 !== 0) {
                      const msg = this._errorMsg(`invalid signer list length in extraData, received signer length of ${signerLength} (not divisible by 20)`);
                      throw new Error(msg);
                  }
                  // coinbase (beneficiary) on epoch transition
                  if (!this.coinbase.isZero()) {
                      const msg = this._errorMsg(`coinbase must be filled with zeros on epoch transition blocks, received ${this.coinbase}`);
                      throw new Error(msg);
                  }
              }
              // MixHash format
              if (!this.mixHash.equals(Buffer$8.alloc(32))) {
                  const msg = this._errorMsg(`mixHash must be filled with zeros, received ${this.mixHash}`);
                  throw new Error(msg);
              }
          }
          // Validation for PoS blocks (EIP-3675)
          if (this._common.consensusType() === common_1$9.ConsensusType.ProofOfStake) {
              let error = false;
              let errorMsg = '';
              if (!uncleHash.equals(util_1$c.KECCAK256_RLP_ARRAY)) {
                  errorMsg += `, uncleHash: ${uncleHash.toString('hex')} (expected: ${util_1$c.KECCAK256_RLP_ARRAY.toString('hex')})`;
                  error = true;
              }
              if (difficulty !== BigInt(0)) {
                  errorMsg += `, difficulty: ${difficulty} (expected: 0)`;
                  error = true;
              }
              if (extraData.length > 32) {
                  errorMsg += `, extraData: ${extraData.toString('hex')} (cannot exceed 32 bytes length, received ${extraData.length} bytes)`;
                  error = true;
              }
              if (!nonce.equals((0, util_1$c.zeros)(8))) {
                  errorMsg += `, nonce: ${nonce.toString('hex')} (expected: ${(0, util_1$c.zeros)(8).toString('hex')})`;
                  error = true;
              }
              if (error) {
                  const msg = this._errorMsg(`Invalid PoS block${errorMsg}`);
                  throw new Error(msg);
              }
          }
      }
      /**
       * Validates if the block gasLimit remains in the boundaries set by the protocol.
       * Throws if out of bounds.
       *
       * @param parentBlockHeader - the header from the parent `Block` of this header
       */
      validateGasLimit(parentBlockHeader) {
          let parentGasLimit = parentBlockHeader.gasLimit;
          // EIP-1559: assume double the parent gas limit on fork block
          // to adopt to the new gas target centered logic
          const londonHardforkBlock = this._common.hardforkBlock(common_1$9.Hardfork.London);
          if ((0, util_1$c.isTruthy)(londonHardforkBlock) && this.number === londonHardforkBlock) {
              const elasticity = this._common.param('gasConfig', 'elasticityMultiplier');
              parentGasLimit = parentGasLimit * elasticity;
          }
          const gasLimit = this.gasLimit;
          const hardfork = this._common.hardfork();
          const a = parentGasLimit / this._common.paramByHardfork('gasConfig', 'gasLimitBoundDivisor', hardfork);
          const maxGasLimit = parentGasLimit + a;
          const minGasLimit = parentGasLimit - a;
          if (gasLimit >= maxGasLimit) {
              const msg = this._errorMsg('gas limit increased too much');
              throw new Error(msg);
          }
          if (gasLimit <= minGasLimit) {
              const msg = this._errorMsg('gas limit decreased too much');
              throw new Error(msg);
          }
          if (gasLimit < this._common.paramByHardfork('gasConfig', 'minGasLimit', hardfork)) {
              const msg = this._errorMsg(`gas limit decreased below minimum gas limit for hardfork=${hardfork}`);
              throw new Error(msg);
          }
      }
      /**
       * Calculates the base fee for a potential next block
       */
      calcNextBaseFee() {
          if (this._common.isActivatedEIP(1559) === false) {
              const msg = this._errorMsg('calcNextBaseFee() can only be called with EIP1559 being activated');
              throw new Error(msg);
          }
          let nextBaseFee;
          const elasticity = this._common.param('gasConfig', 'elasticityMultiplier');
          const parentGasTarget = this.gasLimit / elasticity;
          if (parentGasTarget === this.gasUsed) {
              nextBaseFee = this.baseFeePerGas;
          }
          else if (this.gasUsed > parentGasTarget) {
              const gasUsedDelta = this.gasUsed - parentGasTarget;
              const baseFeeMaxChangeDenominator = this._common.param('gasConfig', 'baseFeeMaxChangeDenominator');
              const calculatedDelta = (this.baseFeePerGas * gasUsedDelta) / parentGasTarget / baseFeeMaxChangeDenominator;
              nextBaseFee =
                  (calculatedDelta > BigInt(1) ? calculatedDelta : BigInt(1)) + this.baseFeePerGas;
          }
          else {
              const gasUsedDelta = parentGasTarget - this.gasUsed;
              const baseFeeMaxChangeDenominator = this._common.param('gasConfig', 'baseFeeMaxChangeDenominator');
              const calculatedDelta = (this.baseFeePerGas * gasUsedDelta) / parentGasTarget / baseFeeMaxChangeDenominator;
              nextBaseFee =
                  this.baseFeePerGas - calculatedDelta > BigInt(0)
                      ? this.baseFeePerGas - calculatedDelta
                      : BigInt(0);
          }
          return nextBaseFee;
      }
      /**
       * Returns a Buffer Array of the raw Buffers in this header, in order.
       */
      raw() {
          const rawItems = [
              this.parentHash,
              this.uncleHash,
              this.coinbase.buf,
              this.stateRoot,
              this.transactionsTrie,
              this.receiptTrie,
              this.logsBloom,
              (0, util_1$c.bigIntToUnpaddedBuffer)(this.difficulty),
              (0, util_1$c.bigIntToUnpaddedBuffer)(this.number),
              (0, util_1$c.bigIntToUnpaddedBuffer)(this.gasLimit),
              (0, util_1$c.bigIntToUnpaddedBuffer)(this.gasUsed),
              (0, util_1$c.bigIntToUnpaddedBuffer)(this.timestamp ?? BigInt(0)),
              this.extraData,
              this.mixHash,
              this.nonce,
          ];
          if (this._common.isActivatedEIP(1559) === true) {
              rawItems.push((0, util_1$c.bigIntToUnpaddedBuffer)(this.baseFeePerGas));
          }
          return rawItems;
      }
      /**
       * Returns the hash of the block header.
       */
      hash() {
          if (Object.isFrozen(this)) {
              if (!this.cache.hash) {
                  this.cache.hash = Buffer$8.from((0, keccak_1$4.keccak256)(rlp_1$7.RLP.encode((0, util_1$c.bufArrToArr)(this.raw()))));
              }
              return this.cache.hash;
          }
          return Buffer$8.from((0, keccak_1$4.keccak256)(rlp_1$7.RLP.encode((0, util_1$c.bufArrToArr)(this.raw()))));
      }
      /**
       * Checks if the block header is a genesis header.
       */
      isGenesis() {
          return this.number === BigInt(0);
      }
      _requireClique(name) {
          if (this._common.consensusAlgorithm() !== common_1$9.ConsensusAlgorithm.Clique) {
              const msg = this._errorMsg(`BlockHeader.${name}() call only supported for clique PoA networks`);
              throw new Error(msg);
          }
      }
      /**
       * Returns the canonical difficulty for this block.
       *
       * @param parentBlockHeader - the header from the parent `Block` of this header
       */
      ethashCanonicalDifficulty(parentBlockHeader) {
          if (this._common.consensusType() !== common_1$9.ConsensusType.ProofOfWork) {
              const msg = this._errorMsg('difficulty calculation is only supported on PoW chains');
              throw new Error(msg);
          }
          if (this._common.consensusAlgorithm() !== common_1$9.ConsensusAlgorithm.Ethash) {
              const msg = this._errorMsg('difficulty calculation currently only supports the ethash algorithm');
              throw new Error(msg);
          }
          const hardfork = this._common.hardfork();
          const blockTs = this.timestamp;
          const { timestamp: parentTs, difficulty: parentDif } = parentBlockHeader;
          const minimumDifficulty = this._common.paramByHardfork('pow', 'minimumDifficulty', hardfork);
          const offset = parentDif / this._common.paramByHardfork('pow', 'difficultyBoundDivisor', hardfork);
          let num = this.number;
          // We use a ! here as TS cannot follow this hardfork-dependent logic, but it always gets assigned
          let dif;
          if (this._common.hardforkGteHardfork(hardfork, common_1$9.Hardfork.Byzantium) === true) {
              // max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99) (EIP100)
              const uncleAddend = parentBlockHeader.uncleHash.equals(util_1$c.KECCAK256_RLP_ARRAY) ? 1 : 2;
              let a = BigInt(uncleAddend) - (blockTs - parentTs) / BigInt(9);
              const cutoff = BigInt(-99);
              // MAX(cutoff, a)
              if (cutoff > a) {
                  a = cutoff;
              }
              dif = parentDif + offset * a;
          }
          if (this._common.hardforkGteHardfork(hardfork, common_1$9.Hardfork.Byzantium) === true) {
              // Get delay as parameter from common
              num = num - this._common.param('pow', 'difficultyBombDelay');
              if (num < BigInt(0)) {
                  num = BigInt(0);
              }
          }
          else if (this._common.hardforkGteHardfork(hardfork, common_1$9.Hardfork.Homestead) === true) {
              // 1 - (block_timestamp - parent_timestamp) // 10
              let a = BigInt(1) - (blockTs - parentTs) / BigInt(10);
              const cutoff = BigInt(-99);
              // MAX(cutoff, a)
              if (cutoff > a) {
                  a = cutoff;
              }
              dif = parentDif + offset * a;
          }
          else {
              // pre-homestead
              if (parentTs + this._common.paramByHardfork('pow', 'durationLimit', hardfork) > blockTs) {
                  dif = offset + parentDif;
              }
              else {
                  dif = parentDif - offset;
              }
          }
          const exp = num / BigInt(100000) - BigInt(2);
          if (exp >= 0) {
              dif = dif + BigInt(2) ** exp;
          }
          if (dif < minimumDifficulty) {
              dif = minimumDifficulty;
          }
          return dif;
      }
      /**
       * PoA clique signature hash without the seal.
       */
      cliqueSigHash() {
          this._requireClique('cliqueSigHash');
          const raw = this.raw();
          raw[12] = this.extraData.slice(0, this.extraData.length - clique_1.CLIQUE_EXTRA_SEAL);
          return Buffer$8.from((0, keccak_1$4.keccak256)(rlp_1$7.RLP.encode((0, util_1$c.bufArrToArr)(raw))));
      }
      /**
       * Checks if the block header is an epoch transition
       * header (only clique PoA, throws otherwise)
       */
      cliqueIsEpochTransition() {
          this._requireClique('cliqueIsEpochTransition');
          const epoch = BigInt(this._common.consensusConfig().epoch);
          // Epoch transition block if the block number has no
          // remainder on the division by the epoch length
          return this.number % epoch === BigInt(0);
      }
      /**
       * Returns extra vanity data
       * (only clique PoA, throws otherwise)
       */
      cliqueExtraVanity() {
          this._requireClique('cliqueExtraVanity');
          return this.extraData.slice(0, clique_1.CLIQUE_EXTRA_VANITY);
      }
      /**
       * Returns extra seal data
       * (only clique PoA, throws otherwise)
       */
      cliqueExtraSeal() {
          this._requireClique('cliqueExtraSeal');
          return this.extraData.slice(-clique_1.CLIQUE_EXTRA_SEAL);
      }
      /**
       * Seal block with the provided signer.
       * Returns the final extraData field to be assigned to `this.extraData`.
       * @hidden
       */
      cliqueSealBlock(privateKey) {
          this._requireClique('cliqueSealBlock');
          const signature = (0, util_1$c.ecsign)(this.cliqueSigHash(), privateKey);
          const signatureB = Buffer$8.concat([
              signature.r,
              signature.s,
              (0, util_1$c.bigIntToBuffer)(signature.v - BigInt(27)),
          ]);
          const extraDataWithoutSeal = this.extraData.slice(0, this.extraData.length - clique_1.CLIQUE_EXTRA_SEAL);
          const extraData = Buffer$8.concat([extraDataWithoutSeal, signatureB]);
          return extraData;
      }
      /**
       * Returns a list of signers
       * (only clique PoA, throws otherwise)
       *
       * This function throws if not called on an epoch
       * transition block and should therefore be used
       * in conjunction with {@link BlockHeader.cliqueIsEpochTransition}
       */
      cliqueEpochTransitionSigners() {
          this._requireClique('cliqueEpochTransitionSigners');
          if (!this.cliqueIsEpochTransition()) {
              const msg = this._errorMsg('Signers are only included in epoch transition blocks (clique)');
              throw new Error(msg);
          }
          const start = clique_1.CLIQUE_EXTRA_VANITY;
          const end = this.extraData.length - clique_1.CLIQUE_EXTRA_SEAL;
          const signerBuffer = this.extraData.slice(start, end);
          const signerList = [];
          const signerLength = 20;
          for (let start = 0; start <= signerBuffer.length - signerLength; start += signerLength) {
              signerList.push(signerBuffer.slice(start, start + signerLength));
          }
          return signerList.map((buf) => new util_1$c.Address(buf));
      }
      /**
       * Verifies the signature of the block (last 65 bytes of extraData field)
       * (only clique PoA, throws otherwise)
       *
       *  Method throws if signature is invalid
       */
      cliqueVerifySignature(signerList) {
          this._requireClique('cliqueVerifySignature');
          const signerAddress = this.cliqueSigner();
          const signerFound = signerList.find((signer) => {
              return signer.equals(signerAddress);
          });
          return !!signerFound;
      }
      /**
       * Returns the signer address
       */
      cliqueSigner() {
          this._requireClique('cliqueSigner');
          const extraSeal = this.cliqueExtraSeal();
          // Reasonable default for default blocks
          if (extraSeal.length === 0 || extraSeal.equals(Buffer$8.alloc(65).fill(0))) {
              return util_1$c.Address.zero();
          }
          const r = extraSeal.slice(0, 32);
          const s = extraSeal.slice(32, 64);
          const v = (0, util_1$c.bufferToBigInt)(extraSeal.slice(64, 65)) + BigInt(27);
          const pubKey = (0, util_1$c.ecrecover)(this.cliqueSigHash(), v, r, s);
          return util_1$c.Address.fromPublicKey(pubKey);
      }
      /**
       * Returns the rlp encoding of the block header.
       */
      serialize() {
          return Buffer$8.from(rlp_1$7.RLP.encode((0, util_1$c.bufArrToArr)(this.raw())));
      }
      /**
       * Returns the block header in JSON format.
       */
      toJSON() {
          const jsonDict = {
              parentHash: '0x' + this.parentHash.toString('hex'),
              uncleHash: '0x' + this.uncleHash.toString('hex'),
              coinbase: this.coinbase.toString(),
              stateRoot: '0x' + this.stateRoot.toString('hex'),
              transactionsTrie: '0x' + this.transactionsTrie.toString('hex'),
              receiptTrie: '0x' + this.receiptTrie.toString('hex'),
              logsBloom: '0x' + this.logsBloom.toString('hex'),
              difficulty: (0, util_1$c.bigIntToHex)(this.difficulty),
              number: (0, util_1$c.bigIntToHex)(this.number),
              gasLimit: (0, util_1$c.bigIntToHex)(this.gasLimit),
              gasUsed: (0, util_1$c.bigIntToHex)(this.gasUsed),
              timestamp: (0, util_1$c.bigIntToHex)(this.timestamp),
              extraData: '0x' + this.extraData.toString('hex'),
              mixHash: '0x' + this.mixHash.toString('hex'),
              nonce: '0x' + this.nonce.toString('hex'),
          };
          if (this._common.isActivatedEIP(1559) === true) {
              jsonDict.baseFeePerGas = (0, util_1$c.bigIntToHex)(this.baseFeePerGas);
          }
          return jsonDict;
      }
      /**
       * Validates extra data is DAO_ExtraData for DAO_ForceExtraDataRange blocks after DAO
       * activation block (see: https://blog.slock.it/hard-fork-specification-24b889e70703)
       */
      _validateDAOExtraData() {
          if (this._common.hardforkIsActiveOnBlock(common_1$9.Hardfork.Dao, this.number) === false) {
              return;
          }
          const DAOActivationBlock = this._common.hardforkBlock(common_1$9.Hardfork.Dao);
          if ((0, util_1$c.isFalsy)(DAOActivationBlock) || this.number < DAOActivationBlock) {
              return;
          }
          const DAO_ExtraData = Buffer$8.from('64616f2d686172642d666f726b', 'hex');
          const DAO_ForceExtraDataRange = BigInt(9);
          const drift = this.number - DAOActivationBlock;
          if (drift <= DAO_ForceExtraDataRange && !this.extraData.equals(DAO_ExtraData)) {
              const msg = this._errorMsg("extraData should be 'dao-hard-fork'");
              throw new Error(msg);
          }
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
          let hash = '';
          try {
              hash = (0, util_1$c.bufferToHex)(this.hash());
          }
          catch (e) {
              hash = 'error';
          }
          let hf = '';
          try {
              hf = this._common.hardfork();
          }
          catch (e) {
              hf = 'error';
          }
          let errorStr = `block header number=${this.number} hash=${hash} `;
          errorStr += `hf=${hf} baseFeePerGas=${this.baseFeePerGas ?? 'none'}`;
          return errorStr;
      }
      /**
       * Helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
          return `${msg} (${this.errorStr()})`;
      }
  }
  header.BlockHeader = BlockHeader;

  Object.defineProperty(block, "__esModule", { value: true });
  block.Block = void 0;
  const common_1$8 = dist$8;
  const rlp_1$6 = dist$9;
  const trie_1$4 = dist$5;
  const tx_1$1 = dist$3;
  const util_1$b = dist$a;
  const keccak_1$3 = keccak;
  const header_1 = header;
  /**
   * An object that represents the block.
   */
  class Block {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       * Use the static factory methods to assist in creating a Block object from varying data types and options.
       */
      constructor(header, transactions = [], uncleHeaders = [], opts = {}) {
          this.transactions = [];
          this.uncleHeaders = [];
          this.txTrie = new trie_1$4.Trie();
          this.header = header ?? header_1.BlockHeader.fromHeaderData({}, opts);
          this.transactions = transactions;
          this.uncleHeaders = uncleHeaders;
          this._common = this.header._common;
          if (uncleHeaders.length > 0) {
              this.validateUncles();
              if (this._common.consensusType() === common_1$8.ConsensusType.ProofOfAuthority) {
                  const msg = this._errorMsg('Block initialization with uncleHeaders on a PoA network is not allowed');
                  throw new Error(msg);
              }
              if (this._common.consensusType() === common_1$8.ConsensusType.ProofOfStake) {
                  const msg = this._errorMsg('Block initialization with uncleHeaders on a PoS network is not allowed');
                  throw new Error(msg);
              }
          }
          const freeze = opts?.freeze ?? true;
          if (freeze) {
              Object.freeze(this);
          }
      }
      /**
       * Static constructor to create a block from a block data dictionary
       *
       * @param blockData
       * @param opts
       */
      static fromBlockData(blockData = {}, opts) {
          const { header: headerData, transactions: txsData, uncleHeaders: uhsData } = blockData;
          const header = header_1.BlockHeader.fromHeaderData(headerData, opts);
          // parse transactions
          const transactions = [];
          for (const txData of txsData ?? []) {
              const tx = tx_1$1.TransactionFactory.fromTxData(txData, {
                  ...opts,
                  // Use header common in case of hardforkByBlockNumber being activated
                  common: header._common,
              });
              transactions.push(tx);
          }
          // parse uncle headers
          const uncleHeaders = [];
          const uncleOpts = {
              hardforkByBlockNumber: true,
              ...opts,
              // Use header common in case of hardforkByBlockNumber being activated
              common: header._common,
              // Disable this option here (all other options carried over), since this overwrites the provided Difficulty to an incorrect value
              calcDifficultyFromHeader: undefined,
              // Uncles are obsolete post-merge (no use for hardforkByTTD)
              hardforkByTTD: undefined,
          };
          for (const uhData of uhsData ?? []) {
              const uh = header_1.BlockHeader.fromHeaderData(uhData, uncleOpts);
              uncleHeaders.push(uh);
          }
          return new Block(header, transactions, uncleHeaders, opts);
      }
      /**
       * Static constructor to create a block from a RLP-serialized block
       *
       * @param serialized
       * @param opts
       */
      static fromRLPSerializedBlock(serialized, opts) {
          const values = (0, util_1$b.arrToBufArr)(rlp_1$6.RLP.decode(Uint8Array.from(serialized)));
          if (!Array.isArray(values)) {
              throw new Error('Invalid serialized block input. Must be array');
          }
          return Block.fromValuesArray(values, opts);
      }
      /**
       * Static constructor to create a block from an array of Buffer values
       *
       * @param values
       * @param opts
       */
      static fromValuesArray(values, opts) {
          if (values.length > 3) {
              throw new Error('invalid block. More values than expected were received');
          }
          const [headerData, txsData, uhsData] = values;
          const header = header_1.BlockHeader.fromValuesArray(headerData, opts);
          // parse transactions
          const transactions = [];
          for (const txData of (0, util_1$b.isTruthy)(txsData) ? txsData : []) {
              transactions.push(tx_1$1.TransactionFactory.fromBlockBodyData(txData, {
                  ...opts,
                  // Use header common in case of hardforkByBlockNumber being activated
                  common: header._common,
              }));
          }
          // parse uncle headers
          const uncleHeaders = [];
          const uncleOpts = {
              hardforkByBlockNumber: true,
              ...opts,
              // Use header common in case of hardforkByBlockNumber being activated
              common: header._common,
              // Disable this option here (all other options carried over), since this overwrites the provided Difficulty to an incorrect value
              calcDifficultyFromHeader: undefined,
          };
          if ((0, util_1$b.isTruthy)(uncleOpts.hardforkByTTD)) {
              delete uncleOpts.hardforkByBlockNumber;
          }
          for (const uncleHeaderData of (0, util_1$b.isTruthy)(uhsData) ? uhsData : []) {
              uncleHeaders.push(header_1.BlockHeader.fromValuesArray(uncleHeaderData, uncleOpts));
          }
          return new Block(header, transactions, uncleHeaders, opts);
      }
      /**
       * Returns a Buffer Array of the raw Buffers of this block, in order.
       */
      raw() {
          return [
              this.header.raw(),
              this.transactions.map((tx) => tx.supports(tx_1$1.Capability.EIP2718TypedTransaction) ? tx.serialize() : tx.raw()),
              this.uncleHeaders.map((uh) => uh.raw()),
          ];
      }
      /**
       * Returns the hash of the block.
       */
      hash() {
          return this.header.hash();
      }
      /**
       * Determines if this block is the genesis block.
       */
      isGenesis() {
          return this.header.isGenesis();
      }
      /**
       * Returns the rlp encoding of the block.
       */
      serialize() {
          return Buffer$8.from(rlp_1$6.RLP.encode((0, util_1$b.bufArrToArr)(this.raw())));
      }
      /**
       * Generates transaction trie for validation.
       */
      async genTxTrie() {
          const { transactions, txTrie } = this;
          for (let i = 0; i < transactions.length; i++) {
              const tx = transactions[i];
              const key = Buffer$8.from(rlp_1$6.RLP.encode(i));
              const value = tx.serialize();
              await txTrie.put(key, value);
          }
      }
      /**
       * Validates the transaction trie by generating a trie
       * and do a check on the root hash.
       */
      async validateTransactionsTrie() {
          let result;
          if (this.transactions.length === 0) {
              result = this.header.transactionsTrie.equals(util_1$b.KECCAK256_RLP);
              return result;
          }
          if (this.txTrie.root.equals(util_1$b.KECCAK256_RLP)) {
              await this.genTxTrie();
          }
          result = this.txTrie.root.equals(this.header.transactionsTrie);
          return result;
      }
      validateTransactions(stringError = false) {
          const errors = [];
          this.transactions.forEach((tx, i) => {
              const errs = tx.validate(true);
              if (this._common.isActivatedEIP(1559) === true) {
                  if (tx.supports(tx_1$1.Capability.EIP1559FeeMarket)) {
                      tx = tx;
                      if (tx.maxFeePerGas < this.header.baseFeePerGas) {
                          errs.push('tx unable to pay base fee (EIP-1559 tx)');
                      }
                  }
                  else {
                      tx = tx;
                      if (tx.gasPrice < this.header.baseFeePerGas) {
                          errs.push('tx unable to pay base fee (non EIP-1559 tx)');
                      }
                  }
              }
              if (errs.length > 0) {
                  errors.push(`errors at tx ${i}: ${errs.join(', ')}`);
              }
          });
          return stringError ? errors : errors.length === 0;
      }
      /**
       * Validates the block data, throwing if invalid.
       * This can be checked on the Block itself without needing access to any parent block
       * It checks:
       * - All transactions are valid
       * - The transactions trie is valid
       * - The uncle hash is valid
       * @param onlyHeader if only passed the header, skip validating txTrie and unclesHash (default: false)
       */
      async validateData(onlyHeader = false) {
          const txErrors = this.validateTransactions(true);
          if (txErrors.length > 0) {
              const msg = this._errorMsg(`invalid transactions: ${txErrors.join(' ')}`);
              throw new Error(msg);
          }
          if (onlyHeader) {
              return;
          }
          const validateTxTrie = await this.validateTransactionsTrie();
          if (!validateTxTrie) {
              const msg = this._errorMsg('invalid transaction trie');
              throw new Error(msg);
          }
          if (!this.validateUnclesHash()) {
              const msg = this._errorMsg('invalid uncle hash');
              throw new Error(msg);
          }
      }
      /**
       * Validates the uncle's hash.
       */
      validateUnclesHash() {
          const uncles = this.uncleHeaders.map((uh) => uh.raw());
          const raw = rlp_1$6.RLP.encode((0, util_1$b.bufArrToArr)(uncles));
          return Buffer$8.from((0, keccak_1$3.keccak256)(raw)).equals(this.header.uncleHash);
      }
      /**
       * Consistency checks for uncles included in the block, if any.
       *
       * Throws if invalid.
       *
       * The rules for uncles checked are the following:
       * Header has at most 2 uncles.
       * Header does not count an uncle twice.
       */
      validateUncles() {
          if (this.isGenesis()) {
              return;
          }
          // Header has at most 2 uncles
          if (this.uncleHeaders.length > 2) {
              const msg = this._errorMsg('too many uncle headers');
              throw new Error(msg);
          }
          // Header does not count an uncle twice.
          const uncleHashes = this.uncleHeaders.map((header) => header.hash().toString('hex'));
          if (!(new Set(uncleHashes).size === uncleHashes.length)) {
              const msg = this._errorMsg('duplicate uncles');
              throw new Error(msg);
          }
      }
      /**
       * Returns the canonical difficulty for this block.
       *
       * @param parentBlock - the parent of this `Block`
       */
      ethashCanonicalDifficulty(parentBlock) {
          return this.header.ethashCanonicalDifficulty(parentBlock.header);
      }
      /**
       * Validates if the block gasLimit remains in the boundaries set by the protocol.
       * Throws if invalid
       *
       * @param parentBlock - the parent of this `Block`
       */
      validateGasLimit(parentBlock) {
          return this.header.validateGasLimit(parentBlock.header);
      }
      /**
       * Returns the block in JSON format.
       */
      toJSON() {
          return {
              header: this.header.toJSON(),
              transactions: this.transactions.map((tx) => tx.toJSON()),
              uncleHeaders: this.uncleHeaders.map((uh) => uh.toJSON()),
          };
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
          let hash = '';
          try {
              hash = (0, util_1$b.bufferToHex)(this.hash());
          }
          catch (e) {
              hash = 'error';
          }
          let hf = '';
          try {
              hf = this._common.hardfork();
          }
          catch (e) {
              hf = 'error';
          }
          let errorStr = `block number=${this.header.number} hash=${hash} `;
          errorStr += `hf=${hf} baseFeePerGas=${this.header.baseFeePerGas ?? 'none'} `;
          errorStr += `txs=${this.transactions.length} uncles=${this.uncleHeaders.length}`;
          return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
          return `${msg} (${this.errorStr()})`;
      }
  }
  block.Block = Block;

  var types = {};

  Object.defineProperty(types, "__esModule", { value: true });

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlockHeader = exports.Block = void 0;
  var block_1 = block;
  Object.defineProperty(exports, "Block", { enumerable: true, get: function () { return block_1.Block; } });
  var header_1 = header;
  Object.defineProperty(exports, "BlockHeader", { enumerable: true, get: function () { return header_1.BlockHeader; } });
  __exportStar(types, exports);

  }(dist$6));

  var consensus = {};

  var casper = {};

  Object.defineProperty(casper, "__esModule", { value: true });
  casper.CasperConsensus = void 0;
  const common_1$7 = dist$8;
  /**
   * This class encapsulates Casper-related consensus functionality when used with the Blockchain class.
   */
  class CasperConsensus {
      constructor() {
          this.algorithm = common_1$7.ConsensusAlgorithm.Casper;
      }
      async genesisInit() { }
      async setup() { }
      async validateConsensus() { }
      async validateDifficulty(header) {
          if (header.difficulty !== BigInt(0)) {
              const msg = 'invalid difficulty.  PoS blocks must have difficulty 0';
              throw new Error(`${msg} ${header.errorStr()}`);
          }
      }
      async newBlock() { }
  }
  casper.CasperConsensus = CasperConsensus;

  var clique = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CliqueConsensus = exports.CLIQUE_DIFF_NOTURN = exports.CLIQUE_DIFF_INTURN = exports.CLIQUE_NONCE_DROP = exports.CLIQUE_NONCE_AUTH = void 0;
  const common_1 = dist$8;
  const rlp_1 = dist$9;
  const util_1 = dist$a;
  const debug_1 = src$1.exports;
  const debug = (0, debug_1.debug)('blockchain:clique');
  // Magic nonce number to vote on adding a new signer
  exports.CLIQUE_NONCE_AUTH = Buffer$8.from('ffffffffffffffff', 'hex');
  // Magic nonce number to vote on removing a signer.
  exports.CLIQUE_NONCE_DROP = Buffer$8.alloc(8);
  const CLIQUE_SIGNERS_KEY = 'CliqueSigners';
  const CLIQUE_VOTES_KEY = 'CliqueVotes';
  const CLIQUE_BLOCK_SIGNERS_SNAPSHOT_KEY = 'CliqueBlockSignersSnapshot';
  // Block difficulty for in-turn signatures
  exports.CLIQUE_DIFF_INTURN = BigInt(2);
  // Block difficulty for out-of-turn signatures
  exports.CLIQUE_DIFF_NOTURN = BigInt(1);
  const DB_OPTS = {
      keyEncoding: 'buffer',
      valueEncoding: 'buffer',
  };
  /**
   * This class encapsulates Clique-related consensus functionality when used with the Blockchain class.
   */
  class CliqueConsensus {
      constructor() {
          /**
           * Keep signer history data (signer states and votes)
           * for all block numbers >= HEAD_BLOCK - CLIQUE_SIGNER_HISTORY_BLOCK_LIMIT
           *
           * This defines a limit for reorgs on PoA clique chains.
           */
          this.CLIQUE_SIGNER_HISTORY_BLOCK_LIMIT = 100;
          /**
           * List with the latest signer states checkpointed on blocks where
           * a change (added new or removed a signer) occurred.
           *
           * Format:
           * [ [BLOCK_NUMBER_1, [SIGNER1, SIGNER 2,]], [BLOCK_NUMBER2, [SIGNER1, SIGNER3]], ...]
           *
           * The top element from the array represents the list of current signers.
           * On reorgs elements from the array are removed until BLOCK_NUMBER > REORG_BLOCK.
           *
           * Always keep at least one item on the stack.
           */
          this._cliqueLatestSignerStates = [];
          /**
           * List with the latest signer votes.
           *
           * Format:
           * [ [BLOCK_NUMBER_1, [SIGNER, BENEFICIARY, AUTH]], [BLOCK_NUMBER_1, [SIGNER, BENEFICIARY, AUTH]] ]
           * where AUTH = CLIQUE_NONCE_AUTH | CLIQUE_NONCE_DROP
           *
           * For votes all elements here must be taken into account with a
           * block number >= LAST_EPOCH_BLOCK
           * (nevertheless keep entries with blocks before EPOCH_BLOCK in case a reorg happens
           * during an epoch change)
           *
           * On reorgs elements from the array are removed until BLOCK_NUMBER > REORG_BLOCK.
           */
          this._cliqueLatestVotes = [];
          /**
           * List of signers for the last consecutive {@link Blockchain.cliqueSignerLimit} blocks.
           * Kept as a snapshot for quickly checking for "recently signed" error.
           * Format: [ [BLOCK_NUMBER, SIGNER_ADDRESS], ...]
           *
           * On reorgs elements from the array are removed until BLOCK_NUMBER > REORG_BLOCK.
           */
          this._cliqueLatestBlockSigners = [];
          this.algorithm = common_1.ConsensusAlgorithm.Clique;
      }
      /**
       *
       * @param param dictionary containin a {@link Blockchain} object
       *
       * Note: this method must be called before consensus checks are used or type errors will occur
       */
      async setup({ blockchain }) {
          this.blockchain = blockchain;
          this._cliqueLatestSignerStates = await this.getCliqueLatestSignerStates();
          this._cliqueLatestVotes = await this.getCliqueLatestVotes();
          this._cliqueLatestBlockSigners = await this.getCliqueLatestBlockSigners();
      }
      async genesisInit(genesisBlock) {
          await this.cliqueSaveGenesisSigners(genesisBlock);
      }
      async validateConsensus(block) {
          if (!this.blockchain) {
              throw new Error('blockchain not provided');
          }
          const { header } = block;
          const valid = header.cliqueVerifySignature(this.cliqueActiveSigners());
          if (!valid) {
              throw new Error('invalid PoA block signature (clique)');
          }
          if (this.cliqueCheckRecentlySigned(header)) {
              throw new Error('recently signed');
          }
          // validate checkpoint signers towards active signers on epoch transition blocks
          if (header.cliqueIsEpochTransition()) {
              // note: keep votes on epoch transition blocks in case of reorgs.
              // only active (non-stale) votes will counted (if vote.blockNumber >= lastEpochBlockNumber
              const checkpointSigners = header.cliqueEpochTransitionSigners();
              const activeSigners = this.cliqueActiveSigners();
              for (const [i, cSigner] of checkpointSigners.entries()) {
                  if (activeSigners[i]?.equals(cSigner) !== true) {
                      throw new Error(`checkpoint signer not found in active signers list at index ${i}: ${cSigner}`);
                  }
              }
          }
      }
      async validateDifficulty(header) {
          if (!this.blockchain) {
              throw new Error('blockchain not provided');
          }
          if (header.difficulty !== exports.CLIQUE_DIFF_INTURN && header.difficulty !== exports.CLIQUE_DIFF_NOTURN) {
              const msg = `difficulty for clique block must be INTURN (2) or NOTURN (1), received: ${header.difficulty}`;
              throw new Error(`${msg} ${header.errorStr()}`);
          }
          const signers = this.cliqueActiveSigners();
          if (signers.length === 0) {
              // abort if signers are unavailable
              const msg = 'no signers available';
              throw new Error(`${msg} ${header.errorStr()}`);
          }
          const signerIndex = signers.findIndex((address) => address.equals(header.cliqueSigner()));
          const inTurn = header.number % BigInt(signers.length) === BigInt(signerIndex);
          if ((inTurn && header.difficulty === exports.CLIQUE_DIFF_INTURN) ||
              (!inTurn && header.difficulty === exports.CLIQUE_DIFF_NOTURN)) {
              return;
          }
          throw new Error(`'invalid clique difficulty ${header.errorStr()}`);
      }
      async newBlock(block, commonAncestor) {
          // Clique: update signer votes and state
          const { header } = block;
          const commonAncestorNumber = commonAncestor?.number;
          if (commonAncestorNumber !== undefined) {
              await this._cliqueDeleteSnapshots(commonAncestorNumber + BigInt(1));
              for (let number = commonAncestorNumber + BigInt(1); number <= header.number; number++) {
                  const canonicalHeader = await this.blockchain.getCanonicalHeader(number);
                  await this._cliqueBuildSnapshots(canonicalHeader);
              }
          }
      }
      /**
       * Save genesis signers to db
       * @param genesisBlock genesis block
       * @hidden
       */
      async cliqueSaveGenesisSigners(genesisBlock) {
          const genesisSignerState = [
              BigInt(0),
              genesisBlock.header.cliqueEpochTransitionSigners(),
          ];
          await this.cliqueUpdateSignerStates(genesisSignerState);
          debug(`[Block 0] Genesis block -> update signer states`);
          await this.cliqueUpdateVotes();
      }
      /**
       * Save signer state to db
       * @param signerState
       * @hidden
       */
      async cliqueUpdateSignerStates(signerState) {
          if (signerState) {
              this._cliqueLatestSignerStates.push(signerState);
          }
          // trim to CLIQUE_SIGNER_HISTORY_BLOCK_LIMIT
          const limit = this.CLIQUE_SIGNER_HISTORY_BLOCK_LIMIT;
          const blockSigners = this._cliqueLatestBlockSigners;
          const lastBlockNumber = blockSigners[blockSigners.length - 1]?.[0];
          if (lastBlockNumber) {
              const blockLimit = lastBlockNumber - BigInt(limit);
              const states = this._cliqueLatestSignerStates;
              const lastItem = states[states.length - 1];
              this._cliqueLatestSignerStates = states.filter((state) => state[0] >= blockLimit);
              if (this._cliqueLatestSignerStates.length === 0) {
                  // always keep at least one item on the stack
                  this._cliqueLatestSignerStates.push(lastItem);
              }
          }
          // save to db
          const formatted = this._cliqueLatestSignerStates.map((state) => [
              (0, util_1.bigIntToBuffer)(state[0]),
              state[1].map((a) => a.toBuffer()),
          ]);
          await this.blockchain.db.put(CLIQUE_SIGNERS_KEY, Buffer$8.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(formatted))), DB_OPTS);
          // Output active signers for debugging purposes
          let i = 0;
          for (const signer of this.cliqueActiveSigners()) {
              debug(`Clique signer [${i}]: ${signer}`);
              i++;
          }
      }
      /**
       * Update clique votes and save to db
       * @param header BlockHeader
       * @hidden
       */
      async cliqueUpdateVotes(header) {
          // Block contains a vote on a new signer
          if (header && !header.coinbase.isZero()) {
              const signer = header.cliqueSigner();
              const beneficiary = header.coinbase;
              const nonce = header.nonce;
              const latestVote = [header.number, [signer, beneficiary, nonce]];
              // Do two rounds here, one to execute on a potential previously reached consensus
              // on the newly touched beneficiary, one with the added new vote
              for (let round = 1; round <= 2; round++) {
                  // See if there is a new majority consensus to update the signer list
                  const lastEpochBlockNumber = header.number -
                      (header.number %
                          BigInt(this.blockchain._common.consensusConfig().epoch));
                  const limit = this.cliqueSignerLimit();
                  let activeSigners = this.cliqueActiveSigners();
                  let consensus = false;
                  // AUTH vote analysis
                  let votes = this._cliqueLatestVotes.filter((vote) => {
                      return (vote[0] >= BigInt(lastEpochBlockNumber) &&
                          !vote[1][0].equals(signer) &&
                          vote[1][1].equals(beneficiary) &&
                          vote[1][2].equals(exports.CLIQUE_NONCE_AUTH));
                  });
                  const beneficiaryVotesAUTH = [];
                  for (const vote of votes) {
                      const num = beneficiaryVotesAUTH.filter((voteCMP) => {
                          return voteCMP.equals(vote[1][0]);
                      }).length;
                      if (num === 0) {
                          beneficiaryVotesAUTH.push(vote[1][0]);
                      }
                  }
                  let numBeneficiaryVotesAUTH = beneficiaryVotesAUTH.length;
                  if (round === 2 && nonce.equals(exports.CLIQUE_NONCE_AUTH)) {
                      numBeneficiaryVotesAUTH += 1;
                  }
                  // Majority consensus
                  if (numBeneficiaryVotesAUTH >= limit) {
                      consensus = true;
                      // Authorize new signer
                      activeSigners.push(beneficiary);
                      activeSigners.sort((a, b) => {
                          // Sort by buffer size
                          return a.toBuffer().compare(b.toBuffer());
                      });
                      // Discard votes for added signer
                      this._cliqueLatestVotes = this._cliqueLatestVotes.filter((vote) => !vote[1][1].equals(beneficiary));
                      debug(`[Block ${header.number}] Clique majority consensus (AUTH ${beneficiary})`);
                  }
                  // DROP vote
                  votes = this._cliqueLatestVotes.filter((vote) => {
                      return (vote[0] >= BigInt(lastEpochBlockNumber) &&
                          !vote[1][0].equals(signer) &&
                          vote[1][1].equals(beneficiary) &&
                          vote[1][2].equals(exports.CLIQUE_NONCE_DROP));
                  });
                  const beneficiaryVotesDROP = [];
                  for (const vote of votes) {
                      const num = beneficiaryVotesDROP.filter((voteCMP) => {
                          return voteCMP.equals(vote[1][0]);
                      }).length;
                      if (num === 0) {
                          beneficiaryVotesDROP.push(vote[1][0]);
                      }
                  }
                  let numBeneficiaryVotesDROP = beneficiaryVotesDROP.length;
                  if (round === 2 && nonce.equals(exports.CLIQUE_NONCE_DROP)) {
                      numBeneficiaryVotesDROP += 1;
                  }
                  // Majority consensus
                  if (numBeneficiaryVotesDROP >= limit) {
                      consensus = true;
                      // Drop signer
                      activeSigners = activeSigners.filter((signer) => !signer.equals(beneficiary));
                      this._cliqueLatestVotes = this._cliqueLatestVotes.filter(
                      // Discard votes from removed signer and for removed signer
                      (vote) => !vote[1][0].equals(beneficiary) && !vote[1][1].equals(beneficiary));
                      debug(`[Block ${header.number}] Clique majority consensus (DROP ${beneficiary})`);
                  }
                  if (round === 1) {
                      // Always add the latest vote to the history no matter if already voted
                      // the same vote or not
                      this._cliqueLatestVotes.push(latestVote);
                      debug(`[Block ${header.number}] New clique vote: ${signer} -> ${beneficiary} ${nonce.equals(exports.CLIQUE_NONCE_AUTH) ? 'AUTH' : 'DROP'}`);
                  }
                  if (consensus) {
                      if (round === 1) {
                          debug(`[Block ${header.number}] Clique majority consensus on existing votes -> update signer states`);
                      }
                      else {
                          debug(`[Block ${header.number}] Clique majority consensus on new vote -> update signer states`);
                      }
                      const newSignerState = [header.number, activeSigners];
                      await this.cliqueUpdateSignerStates(newSignerState);
                      return;
                  }
              }
          }
          // trim to lastEpochBlockNumber - CLIQUE_SIGNER_HISTORY_BLOCK_LIMIT
          const limit = this.CLIQUE_SIGNER_HISTORY_BLOCK_LIMIT;
          const blockSigners = this._cliqueLatestBlockSigners;
          const lastBlockNumber = blockSigners[blockSigners.length - 1]?.[0];
          if (lastBlockNumber) {
              const lastEpochBlockNumber = lastBlockNumber -
                  (lastBlockNumber %
                      BigInt(this.blockchain._common.consensusConfig().epoch));
              const blockLimit = lastEpochBlockNumber - BigInt(limit);
              this._cliqueLatestVotes = this._cliqueLatestVotes.filter((state) => state[0] >= blockLimit);
          }
          // save votes to db
          const formatted = this._cliqueLatestVotes.map((v) => [
              (0, util_1.bigIntToBuffer)(v[0]),
              [v[1][0].toBuffer(), v[1][1].toBuffer(), v[1][2]],
          ]);
          await this.blockchain.db.put(CLIQUE_VOTES_KEY, Buffer$8.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(formatted))), DB_OPTS);
      }
      /**
       * Returns a list with the current block signers
       */
      cliqueActiveSigners() {
          const signers = this._cliqueLatestSignerStates;
          if (signers.length === 0) {
              return [];
          }
          return [...signers[signers.length - 1][1]];
      }
      /**
       * Number of consecutive blocks out of which a signer may only sign one.
       * Defined as `Math.floor(SIGNER_COUNT / 2) + 1` to enforce majority consensus.
       * signer count -> signer limit:
       *   1 -> 1, 2 -> 2, 3 -> 2, 4 -> 2, 5 -> 3, ...
       * @hidden
       */
      cliqueSignerLimit() {
          return Math.floor(this.cliqueActiveSigners().length / 2) + 1;
      }
      /**
       * Checks if signer was recently signed.
       * Returns true if signed too recently: more than once per {@link CliqueConsensus.cliqueSignerLimit} consecutive blocks.
       * @param header BlockHeader
       * @hidden
       */
      cliqueCheckRecentlySigned(header) {
          if (header.isGenesis() || header.number === BigInt(1)) {
              // skip genesis, first block
              return false;
          }
          const limit = this.cliqueSignerLimit();
          // construct recent block signers list with this block
          let signers = this._cliqueLatestBlockSigners;
          signers = signers.slice(signers.length < limit ? 0 : 1);
          if (signers.length > 0 && signers[signers.length - 1][0] !== header.number - BigInt(1)) {
              // if the last signed block is not one minus the head we are trying to compare
              // we do not have a complete picture of the state to verify if too recently signed
              return false;
          }
          signers.push([header.number, header.cliqueSigner()]);
          const seen = signers.filter((s) => s[1].equals(header.cliqueSigner())).length;
          return seen > 1;
      }
      /**
       * Remove clique snapshots with blockNumber higher than input.
       * @param blockNumber - the block number from which we start deleting
       * @hidden
       */
      async _cliqueDeleteSnapshots(blockNumber) {
          // remove blockNumber from clique snapshots
          // (latest signer states, latest votes, latest block signers)
          this._cliqueLatestSignerStates = this._cliqueLatestSignerStates.filter((s) => s[0] <= blockNumber);
          await this.cliqueUpdateSignerStates();
          this._cliqueLatestVotes = this._cliqueLatestVotes.filter((v) => v[0] <= blockNumber);
          await this.cliqueUpdateVotes();
          this._cliqueLatestBlockSigners = this._cliqueLatestBlockSigners.filter((s) => s[0] <= blockNumber);
          await this.cliqueUpdateLatestBlockSigners();
      }
      /**
       * Update snapshot of latest clique block signers.
       * Used for checking for 'recently signed' error.
       * Length trimmed to {@link Blockchain.cliqueSignerLimit}.
       * @param header BlockHeader
       * @hidden
       */
      async cliqueUpdateLatestBlockSigners(header) {
          if (header) {
              if (header.isGenesis()) {
                  return;
              }
              // add this block's signer
              const signer = [header.number, header.cliqueSigner()];
              this._cliqueLatestBlockSigners.push(signer);
              // trim length to `this.cliqueSignerLimit()`
              const length = this._cliqueLatestBlockSigners.length;
              const limit = this.cliqueSignerLimit();
              if (length > limit) {
                  this._cliqueLatestBlockSigners = this._cliqueLatestBlockSigners.slice(length - limit, length);
              }
          }
          // save to db
          const formatted = this._cliqueLatestBlockSigners.map((b) => [
              (0, util_1.bigIntToBuffer)(b[0]),
              b[1].toBuffer(),
          ]);
          await this.blockchain.db.put(CLIQUE_BLOCK_SIGNERS_SNAPSHOT_KEY, Buffer$8.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(formatted))), DB_OPTS);
      }
      /**
       * Fetches clique signers.
       * @hidden
       */
      async getCliqueLatestSignerStates() {
          try {
              const signerStates = await this.blockchain.db.get(CLIQUE_SIGNERS_KEY, DB_OPTS);
              const states = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(signerStates)));
              return states.map((state) => {
                  const blockNum = (0, util_1.bufferToBigInt)(state[0]);
                  const addrs = state[1].map((buf) => new util_1.Address(buf));
                  return [blockNum, addrs];
              });
          }
          catch (error) {
              if (error.code === 'LEVEL_NOT_FOUND') {
                  return [];
              }
              throw error;
          }
      }
      /**
       * Fetches clique votes.
       * @hidden
       */
      async getCliqueLatestVotes() {
          try {
              const signerVotes = await this.blockchain.db.get(CLIQUE_VOTES_KEY, DB_OPTS);
              const votes = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(signerVotes)));
              return votes.map((vote) => {
                  const blockNum = (0, util_1.bufferToBigInt)(vote[0]);
                  const signer = new util_1.Address(vote[1][0]);
                  const beneficiary = new util_1.Address(vote[1][1]);
                  const nonce = vote[1][2];
                  return [blockNum, [signer, beneficiary, nonce]];
              });
          }
          catch (error) {
              if (error.code === 'LEVEL_NOT_FOUND') {
                  return [];
              }
              throw error;
          }
      }
      /**
       * Fetches snapshot of clique signers.
       * @hidden
       */
      async getCliqueLatestBlockSigners() {
          try {
              const blockSigners = await this.blockchain.db.get(CLIQUE_BLOCK_SIGNERS_SNAPSHOT_KEY, DB_OPTS);
              const signers = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(blockSigners)));
              return signers.map((s) => {
                  const blockNum = (0, util_1.bufferToBigInt)(s[0]);
                  const signer = new util_1.Address(s[1]);
                  return [blockNum, signer];
              });
          }
          catch (error) {
              if (error.code === 'LEVEL_NOT_FOUND') {
                  return [];
              }
              throw error;
          }
      }
      /**
       * Build clique snapshots.
       * @param header - the new block header
       * @hidden
       */
      async _cliqueBuildSnapshots(header) {
          if (!header.cliqueIsEpochTransition()) {
              await this.cliqueUpdateVotes(header);
          }
          await this.cliqueUpdateLatestBlockSigners(header);
      }
      /**
       * Helper to determine if a signer is in or out of turn for the next block.
       * @param signer The signer address
       */
      async cliqueSignerInTurn(signer) {
          const signers = this.cliqueActiveSigners();
          const signerIndex = signers.findIndex((address) => address.equals(signer));
          if (signerIndex === -1) {
              throw new Error('Signer not found');
          }
          const { number } = await this.blockchain.getCanonicalHeadHeader();
          //eslint-disable-next-line
          return (number + BigInt(1)) % BigInt(signers.length) === BigInt(signerIndex);
      }
  }
  exports.CliqueConsensus = CliqueConsensus;

  }(clique));

  var ethash = {};

  var dist$2 = {};

  var util = {};

  /**
   * Absolute value. abs(a)==a if a>=0. abs(a)==-a if a<0
   *
   * @param a
   *
   * @returns The absolute value of a
   */
  function abs(a) {
      return (a >= 0) ? a : -a;
  }

  /**
   * Returns the bitlength of a number
   *
   * @param a
   * @returns The bit length
   */
  function bitLength(a) {
      if (typeof a === 'number')
          a = BigInt(a);
      if (a === 1n) {
          return 1;
      }
      let bits = 1;
      do {
          bits++;
      } while ((a >>= 1n) > 1n);
      return bits;
  }

  /**
   * An iterative implementation of the extended euclidean algorithm or extended greatest common divisor algorithm.
   * Take positive integers a, b as input, and return a triple (g, x, y), such that ax + by = g = gcd(a, b).
   *
   * @param a
   * @param b
   *
   * @throws {RangeError}
   * This excepction is thrown if a or b are less than 0
   *
   * @returns A triple (g, x, y), such that ax + by = g = gcd(a, b).
   */
  function eGcd(a, b) {
      if (typeof a === 'number')
          a = BigInt(a);
      if (typeof b === 'number')
          b = BigInt(b);
      if (a <= 0n || b <= 0n)
          throw new RangeError('a and b MUST be > 0'); // a and b MUST be positive
      let x = 0n;
      let y = 1n;
      let u = 1n;
      let v = 0n;
      while (a !== 0n) {
          const q = b / a;
          const r = b % a;
          const m = x - (u * q);
          const n = y - (v * q);
          b = a;
          a = r;
          x = u;
          y = v;
          u = m;
          v = n;
      }
      return {
          g: b,
          x: x,
          y: y
      };
  }

  /**
   * Greatest-common divisor of two integers based on the iterative binary algorithm.
   *
   * @param a
   * @param b
   *
   * @returns The greatest common divisor of a and b
   */
  function gcd(a, b) {
      let aAbs = (typeof a === 'number') ? BigInt(abs(a)) : abs(a);
      let bAbs = (typeof b === 'number') ? BigInt(abs(b)) : abs(b);
      if (aAbs === 0n) {
          return bAbs;
      }
      else if (bAbs === 0n) {
          return aAbs;
      }
      let shift = 0n;
      while (((aAbs | bAbs) & 1n) === 0n) {
          aAbs >>= 1n;
          bAbs >>= 1n;
          shift++;
      }
      while ((aAbs & 1n) === 0n)
          aAbs >>= 1n;
      do {
          while ((bAbs & 1n) === 0n)
              bAbs >>= 1n;
          if (aAbs > bAbs) {
              const x = aAbs;
              aAbs = bAbs;
              bAbs = x;
          }
          bAbs -= aAbs;
      } while (bAbs !== 0n);
      // rescale
      return aAbs << shift;
  }

  /**
   * The least common multiple computed as abs(a*b)/gcd(a,b)
   * @param a
   * @param b
   *
   * @returns The least common multiple of a and b
   */
  function lcm(a, b) {
      if (typeof a === 'number')
          a = BigInt(a);
      if (typeof b === 'number')
          b = BigInt(b);
      if (a === 0n && b === 0n)
          return BigInt(0);
      // return abs(a * b) as bigint / gcd(a, b)
      return abs((a / gcd(a, b)) * b);
  }

  /**
   * Maximum. max(a,b)==a if a>=b. max(a,b)==b if a<=b
   *
   * @param a
   * @param b
   *
   * @returns Maximum of numbers a and b
   */
  function max(a, b) {
      return (a >= b) ? a : b;
  }

  /**
   * Minimum. min(a,b)==b if a>=b. min(a,b)==a if a<=b
   *
   * @param a
   * @param b
   *
   * @returns Minimum of numbers a and b
   */
  function min(a, b) {
      return (a >= b) ? b : a;
  }

  /**
   * Finds the smallest positive element that is congruent to a in modulo n
   *
   * @remarks
   * a and b must be the same type, either number or bigint
   *
   * @param a - An integer
   * @param n - The modulo
   *
   * @throws {RangeError}
   * Excpeption thrown when n is not > 0
   *
   * @returns A bigint with the smallest positive representation of a modulo n
   */
  function toZn(a, n) {
      if (typeof a === 'number')
          a = BigInt(a);
      if (typeof n === 'number')
          n = BigInt(n);
      if (n <= 0n) {
          throw new RangeError('n must be > 0');
      }
      const aZn = a % n;
      return (aZn < 0n) ? aZn + n : aZn;
  }

  /**
   * Modular inverse.
   *
   * @param a The number to find an inverse for
   * @param n The modulo
   *
   * @throws {RangeError}
   * Excpeption thorwn when a does not have inverse modulo n
   *
   * @returns The inverse modulo n
   */
  function modInv(a, n) {
      const egcd = eGcd(toZn(a, n), n);
      if (egcd.g !== 1n) {
          throw new RangeError(`${a.toString()} does not have inverse modulo ${n.toString()}`); // modular inverse does not exist
      }
      else {
          return toZn(egcd.x, n);
      }
  }

  /**
   * Modular exponentiation b**e mod n. Currently using the right-to-left binary method
   *
   * @param b base
   * @param e exponent
   * @param n modulo
   *
   * @throws {RangeError}
   * Excpeption thrown when n is not > 0
   *
   * @returns b**e mod n
   */
  function modPow(b, e, n) {
      if (typeof b === 'number')
          b = BigInt(b);
      if (typeof e === 'number')
          e = BigInt(e);
      if (typeof n === 'number')
          n = BigInt(n);
      if (n <= 0n) {
          throw new RangeError('n must be > 0');
      }
      else if (n === 1n) {
          return 0n;
      }
      b = toZn(b, n);
      if (e < 0n) {
          return modInv(modPow(b, abs(e), n), n);
      }
      let r = 1n;
      while (e > 0) {
          if ((e % 2n) === 1n) {
              r = r * b % n;
          }
          e = e / 2n;
          b = b ** 2n % n;
      }
      return r;
  }

  function fromBuffer(buf) {
      let ret = 0n;
      for (const i of buf.values()) {
          const bi = BigInt(i);
          ret = (ret << 8n) + bi;
      }
      return ret;
  }

  /**
   * Secure random bytes for both node and browsers. Node version uses crypto.randomBytes() and browser one self.crypto.getRandomValues()
   *
   * @param byteLength - The desired number of random bytes
   * @param forceLength - If we want to force the output to have a bit length of 8*byteLength. It basically forces the msb to be 1
   *
   * @throws {RangeError}
   * byteLength MUST be > 0
   *
   * @returns A promise that resolves to a UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bytes
   */
  function randBytes(byteLength, forceLength = false) {
      if (byteLength < 1)
          throw new RangeError('byteLength MUST be > 0');
      return new Promise(function (resolve, reject) {
          { // browser
              const buf = new Uint8Array(byteLength);
              self.crypto.getRandomValues(buf);
              // If fixed length is required we put the first bit to 1 -> to get the necessary bitLength
              if (forceLength)
                  buf[0] = buf[0] | 128;
              resolve(buf);
          }
      });
  }
  /**
   * Secure random bytes for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()
   *
   * @param byteLength - The desired number of random bytes
   * @param forceLength - If we want to force the output to have a bit length of 8*byteLength. It basically forces the msb to be 1
   *
   * @throws {RangeError}
   * byteLength MUST be > 0
   *
   * @returns A UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bytes
   */
  function randBytesSync(byteLength, forceLength = false) {
      if (byteLength < 1)
          throw new RangeError('byteLength MUST be > 0');
      /* eslint-disable no-lone-blocks */
      { // browser
          const buf = new Uint8Array(byteLength);
          self.crypto.getRandomValues(buf);
          // If fixed length is required we put the first bit to 1 -> to get the necessary bitLength
          if (forceLength)
              buf[0] = buf[0] | 128;
          return buf;
      }
      /* eslint-enable no-lone-blocks */
  }

  /**
   * Secure random bits for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()
   *
   * @param bitLength - The desired number of random bits
   * @param forceLength - If we want to force the output to have a specific bit length. It basically forces the msb to be 1
   *
   * @throws {RangeError}
   * bitLength MUST be > 0
   *
   * @returns A Promise that resolves to a UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bits
   */
  function randBits(bitLength, forceLength = false) {
      if (bitLength < 1)
          throw new RangeError('bitLength MUST be > 0');
      const byteLength = Math.ceil(bitLength / 8);
      const bitLengthMod8 = bitLength % 8;
      return new Promise((resolve, reject) => {
          randBytes(byteLength, false).then(function (rndBytes) {
              if (bitLengthMod8 !== 0) {
                  // Fill with 0's the extra bits
                  rndBytes[0] = rndBytes[0] & (2 ** bitLengthMod8 - 1);
              }
              if (forceLength) {
                  const mask = (bitLengthMod8 !== 0) ? 2 ** (bitLengthMod8 - 1) : 128;
                  rndBytes[0] = rndBytes[0] | mask;
              }
              resolve(rndBytes);
          });
      });
  }
  /**
   * Secure random bits for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()
   * @param bitLength - The desired number of random bits
   * @param forceLength - If we want to force the output to have a specific bit length. It basically forces the msb to be 1
   *
   * @throws {RangeError}
   * bitLength MUST be > 0
   *
   * @returns A Uint8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bits
   */
  function randBitsSync(bitLength, forceLength = false) {
      if (bitLength < 1)
          throw new RangeError('bitLength MUST be > 0');
      const byteLength = Math.ceil(bitLength / 8);
      const rndBytes = randBytesSync(byteLength, false);
      const bitLengthMod8 = bitLength % 8;
      if (bitLengthMod8 !== 0) {
          // Fill with 0's the extra bits
          rndBytes[0] = rndBytes[0] & (2 ** bitLengthMod8 - 1);
      }
      if (forceLength) {
          const mask = (bitLengthMod8 !== 0) ? 2 ** (bitLengthMod8 - 1) : 128;
          rndBytes[0] = rndBytes[0] | mask;
      }
      return rndBytes;
  }

  /**
   * Returns a cryptographically secure random integer between [min,max].
   * @param max Returned value will be <= max
   * @param min Returned value will be >= min
   *
   * @throws {RangeError}
   * Arguments MUST be: max > min
   *
   * @returns A cryptographically secure random bigint between [min,max]
   */
  function randBetween(max, min = 1n) {
      if (max <= min)
          throw new RangeError('Arguments MUST be: max > min');
      const interval = max - min;
      const bitLen = bitLength(interval);
      let rnd;
      do {
          const buf = randBitsSync(bitLen);
          rnd = fromBuffer(buf);
      } while (rnd > interval);
      return rnd + min;
  }

  function _workerUrl(workerCode) {
      workerCode = `(() => {${workerCode}})()`; // encapsulate IIFE
      const _blob = new Blob([workerCode], { type: 'text/javascript' });
      return window.URL.createObjectURL(_blob);
  }
  let _useWorkers = false; // The following is just to check whether we can use workers
  /* eslint-disable no-lone-blocks */
  { // Native JS
      if (self.Worker !== undefined)
          _useWorkers = true;
  }

  /**
   * The test first tries if any of the first 250 small primes are a factor of the input number and then passes several
   * iterations of Miller-Rabin Probabilistic Primality Test (FIPS 186-4 C.3.1)
   *
   * @param w - A positive integer to be tested for primality
   * @param iterations - The number of iterations for the primality test. The value shall be consistent with Table C.1, C.2 or C.3
   * @param disableWorkers - Disable the use of workers for the primality test
   *
   * @throws {RangeError}
   * w MUST be >= 0
   *
   * @returns A promise that resolves to a boolean that is either true (a probably prime number) or false (definitely composite)
   */
  function isProbablyPrime(w, iterations = 16, disableWorkers = false) {
      if (typeof w === 'number') {
          w = BigInt(w);
      }
      if (w < 0n)
          throw RangeError('w MUST be >= 0');
      { // browser
          return new Promise((resolve, reject) => {
              const worker = new Worker(_isProbablyPrimeWorkerUrl());
              worker.onmessage = (event) => {
                  worker.terminate();
                  resolve(event.data.isPrime);
              };
              worker.onmessageerror = (event) => {
                  reject(event);
              };
              const msg = {
                  rnd: w,
                  iterations: iterations,
                  id: 0
              };
              worker.postMessage(msg);
          });
      }
  }
  function _isProbablyPrime(w, iterations) {
      /*
      PREFILTERING. Even values but 2 are not primes, so don't test.
      1 is not a prime and the M-R algorithm needs w>1.
      */
      if (w === 2n)
          return true;
      else if ((w & 1n) === 0n || w === 1n)
          return false;
      /*
        Test if any of the first 250 small primes are a factor of w. 2 is not tested because it was already tested above.
        */
      const firstPrimes = [
          3n,
          5n,
          7n,
          11n,
          13n,
          17n,
          19n,
          23n,
          29n,
          31n,
          37n,
          41n,
          43n,
          47n,
          53n,
          59n,
          61n,
          67n,
          71n,
          73n,
          79n,
          83n,
          89n,
          97n,
          101n,
          103n,
          107n,
          109n,
          113n,
          127n,
          131n,
          137n,
          139n,
          149n,
          151n,
          157n,
          163n,
          167n,
          173n,
          179n,
          181n,
          191n,
          193n,
          197n,
          199n,
          211n,
          223n,
          227n,
          229n,
          233n,
          239n,
          241n,
          251n,
          257n,
          263n,
          269n,
          271n,
          277n,
          281n,
          283n,
          293n,
          307n,
          311n,
          313n,
          317n,
          331n,
          337n,
          347n,
          349n,
          353n,
          359n,
          367n,
          373n,
          379n,
          383n,
          389n,
          397n,
          401n,
          409n,
          419n,
          421n,
          431n,
          433n,
          439n,
          443n,
          449n,
          457n,
          461n,
          463n,
          467n,
          479n,
          487n,
          491n,
          499n,
          503n,
          509n,
          521n,
          523n,
          541n,
          547n,
          557n,
          563n,
          569n,
          571n,
          577n,
          587n,
          593n,
          599n,
          601n,
          607n,
          613n,
          617n,
          619n,
          631n,
          641n,
          643n,
          647n,
          653n,
          659n,
          661n,
          673n,
          677n,
          683n,
          691n,
          701n,
          709n,
          719n,
          727n,
          733n,
          739n,
          743n,
          751n,
          757n,
          761n,
          769n,
          773n,
          787n,
          797n,
          809n,
          811n,
          821n,
          823n,
          827n,
          829n,
          839n,
          853n,
          857n,
          859n,
          863n,
          877n,
          881n,
          883n,
          887n,
          907n,
          911n,
          919n,
          929n,
          937n,
          941n,
          947n,
          953n,
          967n,
          971n,
          977n,
          983n,
          991n,
          997n,
          1009n,
          1013n,
          1019n,
          1021n,
          1031n,
          1033n,
          1039n,
          1049n,
          1051n,
          1061n,
          1063n,
          1069n,
          1087n,
          1091n,
          1093n,
          1097n,
          1103n,
          1109n,
          1117n,
          1123n,
          1129n,
          1151n,
          1153n,
          1163n,
          1171n,
          1181n,
          1187n,
          1193n,
          1201n,
          1213n,
          1217n,
          1223n,
          1229n,
          1231n,
          1237n,
          1249n,
          1259n,
          1277n,
          1279n,
          1283n,
          1289n,
          1291n,
          1297n,
          1301n,
          1303n,
          1307n,
          1319n,
          1321n,
          1327n,
          1361n,
          1367n,
          1373n,
          1381n,
          1399n,
          1409n,
          1423n,
          1427n,
          1429n,
          1433n,
          1439n,
          1447n,
          1451n,
          1453n,
          1459n,
          1471n,
          1481n,
          1483n,
          1487n,
          1489n,
          1493n,
          1499n,
          1511n,
          1523n,
          1531n,
          1543n,
          1549n,
          1553n,
          1559n,
          1567n,
          1571n,
          1579n,
          1583n,
          1597n
      ];
      for (let i = 0; i < firstPrimes.length && (firstPrimes[i] <= w); i++) {
          const p = firstPrimes[i];
          if (w === p)
              return true;
          else if (w % p === 0n)
              return false;
      }
      /*
        1. Let a be the largest integer such that 2**a divides w−1.
        2. m = (w−1) / 2**a.
        3. wlen = len (w).
        4. For i = 1 to iterations do
            4.1 Obtain a string b of wlen bits from an RBG.
            Comment: Ensure that 1 < b < w−1.
            4.2 If ((b ≤ 1) or (b ≥ w−1)), then go to step 4.1.
            4.3 z = b**m mod w.
            4.4 If ((z = 1) or (z = w − 1)), then go to step 4.7.
            4.5 For j = 1 to a − 1 do.
            4.5.1 z = z**2 mod w.
            4.5.2 If (z = w−1), then go to step 4.7.
            4.5.3 If (z = 1), then go to step 4.6.
            4.6 Return COMPOSITE.
            4.7 Continue.
            Comment: Increment i for the do-loop in step 4.
        5. Return PROBABLY PRIME.
        */
      let a = 0n;
      const d = w - 1n;
      let aux = d;
      while (aux % 2n === 0n) {
          aux /= 2n;
          ++a;
      }
      const m = d / (2n ** a);
      do {
          const b = randBetween(d, 2n);
          let z = modPow(b, m, w);
          if (z === 1n || z === d)
              continue;
          let j = 1;
          while (j < a) {
              z = modPow(z, 2n, w);
              if (z === d)
                  break;
              if (z === 1n)
                  return false;
              j++;
          }
          if (z !== d)
              return false;
      } while (--iterations !== 0);
      return true;
  }
  function _isProbablyPrimeWorkerUrl() {
      // Let's us first add all the required functions
      let workerCode = `'use strict';const ${eGcd.name}=${eGcd.toString()};const ${modInv.name}=${modInv.toString()};const ${modPow.name}=${modPow.toString()};const ${toZn.name}=${toZn.toString()};const ${randBitsSync.name}=${randBitsSync.toString()};const ${randBytesSync.name}=${randBytesSync.toString()};const ${randBetween.name}=${randBetween.toString()};const ${isProbablyPrime.name}=${_isProbablyPrime.toString()};${bitLength.toString()};${fromBuffer.toString()};`;
      workerCode += `onmessage=async function(_e){const _m={isPrime:await ${isProbablyPrime.name}(_e.data.rnd,_e.data.iterations),value:_e.data.rnd,id:_e.data.id};postMessage(_m);}`;
      return _workerUrl(workerCode);
  }

  /**
   * A probably-prime (Miller-Rabin), cryptographically-secure, random-number generator.
   * The browser version uses web workers to parallelise prime look up. Therefore, it does not lock the UI
   * main process, and it can be much faster (if several cores or cpu are available).
   * The node version can also use worker_threads if they are available (enabled by default with Node 11 and
   * and can be enabled at runtime executing node --experimental-worker with node >=10.5.0).
   *
   * @param bitLength - The required bit length for the generated prime
   * @param iterations - The number of iterations for the Miller-Rabin Probabilistic Primality Test
   *
   * @throws {RangeError}
   * bitLength MUST be > 0
   *
   * @returns A promise that resolves to a bigint probable prime of bitLength bits.
   */
  function prime(bitLength, iterations = 16) {
      if (bitLength < 1)
          throw new RangeError('bitLength MUST be > 0');
      /* c8 ignore start */
      if (!_useWorkers) { // If there is no support for workers
          let rnd = 0n;
          do {
              rnd = fromBuffer(randBitsSync(bitLength, true));
          } while (!_isProbablyPrime(rnd, iterations));
          return new Promise((resolve) => { resolve(rnd); });
      }
      /* c8 ignore stop */
      return new Promise((resolve, reject) => {
          const workerList = [];
          const _onmessage = (msg, newWorker) => {
              if (msg.isPrime) {
                  // if a prime number has been found, stop all the workers, and return it
                  for (let j = 0; j < workerList.length; j++) {
                      workerList[j].terminate(); // eslint-disable-line @typescript-eslint/no-floating-promises
                  }
                  while (workerList.length > 0) {
                      workerList.pop();
                  }
                  resolve(msg.value);
              }
              else { // if a composite is found, make the worker test another random number
                  const buf = randBitsSync(bitLength, true);
                  const rnd = fromBuffer(buf);
                  try {
                      const msgToWorker = {
                          rnd: rnd,
                          iterations: iterations,
                          id: msg.id
                      };
                      newWorker.postMessage(msgToWorker);
                  }
                  catch (error) {
                      // The worker has already terminated. There is nothing to handle here
                  }
              }
          };
          { // browser
              const workerURL = _isProbablyPrimeWorkerUrl();
              for (let i = 0; i < self.navigator.hardwareConcurrency - 1; i++) {
                  const newWorker = new Worker(workerURL);
                  newWorker.onmessage = (event) => _onmessage(event.data, newWorker);
                  workerList.push(newWorker);
              }
          }
          for (let i = 0; i < workerList.length; i++) {
              randBits(bitLength, true).then(function (buf) {
                  const rnd = fromBuffer(buf);
                  workerList[i].postMessage({
                      rnd: rnd,
                      iterations: iterations,
                      id: i
                  });
              }).catch(reject);
          }
      });
  }
  /**
   * A probably-prime (Miller-Rabin), cryptographically-secure, random-number generator.
   * The sync version is NOT RECOMMENDED since it won't use workers and thus it'll be slower and may freeze thw window in browser's javascript. Please consider using prime() instead.
   *
   * @param bitLength - The required bit length for the generated prime
   * @param iterations - The number of iterations for the Miller-Rabin Probabilistic Primality Test
   *
   * @throws {RangeError}
   * bitLength MUST be > 0
   *
   * @returns A bigint probable prime of bitLength bits.
   */
  function primeSync(bitLength, iterations = 16) {
      if (bitLength < 1)
          throw new RangeError('bitLength MUST be > 0');
      let rnd = 0n;
      do {
          rnd = fromBuffer(randBitsSync(bitLength, true));
      } while (!_isProbablyPrime(rnd, iterations));
      return rnd;
  }

  var index_browser = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abs: abs,
    bitLength: bitLength,
    eGcd: eGcd,
    gcd: gcd,
    isProbablyPrime: isProbablyPrime,
    lcm: lcm,
    max: max,
    min: min,
    modInv: modInv,
    modPow: modPow,
    prime: prime,
    primeSync: primeSync,
    randBetween: randBetween,
    randBits: randBits,
    randBitsSync: randBitsSync,
    randBytes: randBytes,
    randBytesSync: randBytesSync,
    toZn: toZn
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(index_browser);

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufReverse = exports.fnvBuffer = exports.fnv = exports.getSeed = exports.getEpoc = exports.getFullSize = exports.getCacheSize = exports.params = void 0;
  const bigint_crypto_utils_1 = require$$0;
  const keccak_1 = keccak;
  exports.params = {
      DATASET_BYTES_INIT: 1073741824,
      DATASET_BYTES_GROWTH: 8388608,
      CACHE_BYTES_INIT: 16777216,
      CACHE_BYTES_GROWTH: 131072,
      CACHE_MULTIPLIER: 1024,
      EPOCH_LENGTH: 30000,
      MIX_BYTES: 128,
      HASH_BYTES: 64,
      DATASET_PARENTS: 256,
      CACHE_ROUNDS: 3,
      ACCESSES: 64,
      WORD_BYTES: 4,
  };
  async function getCacheSize(epoc) {
      const { CACHE_BYTES_INIT, CACHE_BYTES_GROWTH, HASH_BYTES } = exports.params;
      let sz = CACHE_BYTES_INIT + CACHE_BYTES_GROWTH * epoc;
      sz -= HASH_BYTES;
      while (!(await (0, bigint_crypto_utils_1.isProbablyPrime)(sz / HASH_BYTES, undefined, true))) {
          sz -= 2 * HASH_BYTES;
      }
      return sz;
  }
  exports.getCacheSize = getCacheSize;
  async function getFullSize(epoc) {
      const { DATASET_BYTES_INIT, DATASET_BYTES_GROWTH, MIX_BYTES } = exports.params;
      let sz = DATASET_BYTES_INIT + DATASET_BYTES_GROWTH * epoc;
      sz -= MIX_BYTES;
      while (!(await (0, bigint_crypto_utils_1.isProbablyPrime)(sz / MIX_BYTES, undefined, true))) {
          sz -= 2 * MIX_BYTES;
      }
      return sz;
  }
  exports.getFullSize = getFullSize;
  function getEpoc(blockNumber) {
      return Number(blockNumber / BigInt(exports.params.EPOCH_LENGTH));
  }
  exports.getEpoc = getEpoc;
  /**
   * Generates a seed give the end epoc and optional the begining epoc and the
   * begining epoc seed
   * @method getSeed
   * @param seed Buffer
   * @param begin Number
   * @param end Number
   */
  function getSeed(seed, begin, end) {
      for (let i = begin; i < end; i++) {
          seed = Buffer$8.from((0, keccak_1.keccak256)(seed));
      }
      return seed;
  }
  exports.getSeed = getSeed;
  function fnv(x, y) {
      return ((((x * 0x01000000) | 0) + ((x * 0x193) | 0)) ^ y) >>> 0;
  }
  exports.fnv = fnv;
  function fnvBuffer(a, b) {
      const r = Buffer$8.alloc(a.length);
      for (let i = 0; i < a.length; i = i + 4) {
          r.writeUInt32LE(fnv(a.readUInt32LE(i), b.readUInt32LE(i)), i);
      }
      return r;
  }
  exports.fnvBuffer = fnvBuffer;
  function bufReverse(a) {
      const length = a.length;
      const b = Buffer$8.alloc(length);
      for (let i = 0; i < length; i++) {
          b[i] = a[length - i - 1];
      }
      return b;
  }
  exports.bufReverse = bufReverse;

  }(util));

  var Buffer = safeBuffer.exports.Buffer;

  var bufferXor = function xor (a, b) {
    var length = Math.max(a.length, b.length);
    var buffer = Buffer.allocUnsafe(length);

    for (var i = 0; i < length; ++i) {
      buffer[i] = a[i] ^ b[i];
    }

    return buffer
  };

  Object.defineProperty(dist$2, "__esModule", { value: true });
  dist$2.Ethash = dist$2.Miner = void 0;
  const block_1$5 = dist$6;
  const rlp_1$5 = dist$9;
  const util_1$a = dist$a;
  const keccak_1$2 = keccak;
  const util_2$1 = util;
  const xor = bufferXor;
  class Miner {
      /**
       * Create a Miner object
       * @param mineObject - The object to mine on, either a `BlockHeader` or a `Block` object
       * @param ethash - Ethash object to use for mining
       */
      constructor(mineObject, ethash) {
          if (mineObject instanceof block_1$5.BlockHeader) {
              this.blockHeader = mineObject;
          }
          else if (mineObject instanceof block_1$5.Block) {
              this.block = mineObject;
              this.blockHeader = mineObject.header;
          }
          else {
              throw new Error('unsupported mineObject');
          }
          this.currentNonce = BigInt(0);
          this.ethash = ethash;
          this.stopMining = false;
      }
      /**
       * Stop the miner on the next iteration
       */
      stop() {
          this.stopMining = true;
      }
      /**
       * Iterate `iterations` time over nonces, returns a `BlockHeader` or `Block` if a solution is found, `undefined` otherwise
       * @param iterations - Number of iterations to iterate over. If `-1` is passed, the loop runs until a solution is found
       * @returns - `undefined` if no solution was found within the iterations, or a `BlockHeader` or `Block`
       *           with valid PoW based upon what was passed in the constructor
       */
      async mine(iterations = 0) {
          const solution = await this.iterate(iterations);
          if (solution) {
              if (this.block) {
                  const data = this.block.toJSON();
                  data.header.mixHash = solution.mixHash;
                  data.header.nonce = solution.nonce;
                  return block_1$5.Block.fromBlockData(data, { common: this.block._common });
              }
              else {
                  const data = this.blockHeader.toJSON();
                  data.mixHash = solution.mixHash;
                  data.nonce = solution.nonce;
                  return block_1$5.BlockHeader.fromHeaderData(data, { common: this.blockHeader._common });
              }
          }
      }
      /**
       * Iterate `iterations` times over nonces to find a valid PoW. Caches solution if one is found
       * @param iterations - Number of iterations to iterate over. If `-1` is passed, the loop runs until a solution is found
       * @returns - `undefined` if no solution was found, or otherwise a `Solution` object
       */
      async iterate(iterations = 0) {
          if (this.solution) {
              return this.solution;
          }
          if (!this.headerHash) {
              this.headerHash = this.ethash.headerHash(this.blockHeader.raw());
          }
          const headerHash = this.headerHash;
          const { number, difficulty } = this.blockHeader;
          await this.ethash.loadEpoc(number);
          while (iterations !== 0 && !this.stopMining) {
              // The promise/setTimeout construction is necessary to ensure we jump out of the event loop
              // Without this, for high-difficulty blocks JS never jumps out of the Promise
              const solution = await new Promise((resolve) => {
                  setTimeout(() => {
                      const nonce = (0, util_1$a.setLengthLeft)((0, util_1$a.bigIntToBuffer)(this.currentNonce), 8);
                      const a = this.ethash.run(headerHash, nonce);
                      const result = (0, util_1$a.bufferToBigInt)(a.hash);
                      if (util_1$a.TWO_POW256 / difficulty > result) {
                          const solution = {
                              mixHash: a.mix,
                              nonce,
                          };
                          this.solution = solution;
                          resolve(solution);
                          return;
                      }
                      this.currentNonce++;
                      iterations--;
                      resolve(null);
                  }, 0);
              });
              if ((0, util_1$a.isTruthy)(solution)) {
                  return solution;
              }
          }
      }
  }
  dist$2.Miner = Miner;
  class Ethash {
      constructor(cacheDB) {
          this.dbOpts = {
              valueEncoding: 'json',
          };
          this.cacheDB = cacheDB;
          this.cache = [];
      }
      mkcache(cacheSize, seed) {
          // console.log(`generating cache\nsize: ${cacheSize}\nseed: ${seed.toString('hex')}`)
          const n = Math.floor(cacheSize / util_2$1.params.HASH_BYTES);
          const o = [Buffer$8.from((0, keccak_1$2.keccak512)(seed))];
          let i;
          for (i = 1; i < n; i++) {
              o.push(Buffer$8.from((0, keccak_1$2.keccak512)(o[o.length - 1])));
          }
          for (let _ = 0; _ < util_2$1.params.CACHE_ROUNDS; _++) {
              for (i = 0; i < n; i++) {
                  const v = o[i].readUInt32LE(0) % n;
                  o[i] = Buffer$8.from((0, keccak_1$2.keccak512)(xor(o[(i - 1 + n) % n], o[v])));
              }
          }
          this.cache = o;
          return this.cache;
      }
      calcDatasetItem(i) {
          const n = this.cache.length;
          const r = Math.floor(util_2$1.params.HASH_BYTES / util_2$1.params.WORD_BYTES);
          let mix = Buffer$8.from(this.cache[i % n]);
          mix.writeInt32LE(mix.readUInt32LE(0) ^ i, 0);
          mix = Buffer$8.from((0, keccak_1$2.keccak512)(mix));
          for (let j = 0; j < util_2$1.params.DATASET_PARENTS; j++) {
              const cacheIndex = (0, util_2$1.fnv)(i ^ j, mix.readUInt32LE((j % r) * 4));
              mix = (0, util_2$1.fnvBuffer)(mix, this.cache[cacheIndex % n]);
          }
          return Buffer$8.from((0, keccak_1$2.keccak512)(mix));
      }
      run(val, nonce, fullSize) {
          if ((0, util_1$a.isFalsy)(fullSize) && (0, util_1$a.isTruthy)(this.fullSize)) {
              fullSize = this.fullSize;
          }
          if ((0, util_1$a.isFalsy)(fullSize)) {
              throw new Error('fullSize needed');
          }
          const n = Math.floor(fullSize / util_2$1.params.HASH_BYTES);
          const w = Math.floor(util_2$1.params.MIX_BYTES / util_2$1.params.WORD_BYTES);
          const s = Buffer$8.from((0, keccak_1$2.keccak512)(Buffer$8.concat([val, (0, util_2$1.bufReverse)(nonce)])));
          const mixhashes = Math.floor(util_2$1.params.MIX_BYTES / util_2$1.params.HASH_BYTES);
          let mix = Buffer$8.concat(Array(mixhashes).fill(s));
          let i;
          for (i = 0; i < util_2$1.params.ACCESSES; i++) {
              const p = ((0, util_2$1.fnv)(i ^ s.readUInt32LE(0), mix.readUInt32LE((i % w) * 4)) % Math.floor(n / mixhashes)) *
                  mixhashes;
              const newdata = [];
              for (let j = 0; j < mixhashes; j++) {
                  newdata.push(this.calcDatasetItem(p + j));
              }
              mix = (0, util_2$1.fnvBuffer)(mix, Buffer$8.concat(newdata));
          }
          const cmix = Buffer$8.alloc(mix.length / 4);
          for (i = 0; i < mix.length / 4; i = i + 4) {
              const a = (0, util_2$1.fnv)(mix.readUInt32LE(i * 4), mix.readUInt32LE((i + 1) * 4));
              const b = (0, util_2$1.fnv)(a, mix.readUInt32LE((i + 2) * 4));
              const c = (0, util_2$1.fnv)(b, mix.readUInt32LE((i + 3) * 4));
              cmix.writeUInt32LE(c, i);
          }
          return {
              mix: cmix,
              hash: Buffer$8.from((0, keccak_1$2.keccak256)(Buffer$8.concat([s, cmix]))),
          };
      }
      cacheHash() {
          return Buffer$8.from((0, keccak_1$2.keccak256)(Buffer$8.concat(this.cache)));
      }
      headerHash(rawHeader) {
          return Buffer$8.from((0, keccak_1$2.keccak256)(rlp_1$5.RLP.encode((0, util_1$a.bufArrToArr)(rawHeader.slice(0, -2)))));
      }
      /**
       * Loads the seed and cache given a block number.
       */
      async loadEpoc(number) {
          const epoc = (0, util_2$1.getEpoc)(number);
          if (this.epoc === epoc) {
              return;
          }
          this.epoc = epoc;
          if (!this.cacheDB) {
              throw new Error('cacheDB needed');
          }
          // gives the seed the first epoc found
          const findLastSeed = async (epoc) => {
              if (epoc === 0) {
                  return [(0, util_1$a.zeros)(32), 0];
              }
              let data;
              try {
                  data = await this.cacheDB.get(epoc, this.dbOpts);
              }
              catch (error) {
                  if (error.code !== 'LEVEL_NOT_FOUND') {
                      throw error;
                  }
              }
              if (data) {
                  return [data.seed, epoc];
              }
              else {
                  return findLastSeed(epoc - 1);
              }
          };
          let data;
          try {
              data = await this.cacheDB.get(epoc, this.dbOpts);
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
          }
          if (!data) {
              this.cacheSize = await (0, util_2$1.getCacheSize)(epoc);
              this.fullSize = await (0, util_2$1.getFullSize)(epoc);
              const [seed, foundEpoc] = await findLastSeed(epoc);
              this.seed = (0, util_2$1.getSeed)(seed, foundEpoc, epoc);
              const cache = this.mkcache(this.cacheSize, this.seed);
              // store the generated cache
              await this.cacheDB.put(epoc, {
                  cacheSize: this.cacheSize,
                  fullSize: this.fullSize,
                  seed: this.seed,
                  cache: cache,
              }, this.dbOpts);
          }
          else {
              this.cache = data.cache.map((a) => {
                  return Buffer$8.from(a);
              });
              this.cacheSize = data.cacheSize;
              this.fullSize = data.fullSize;
              this.seed = Buffer$8.from(data.seed);
          }
      }
      /**
       * Returns a `Miner` object
       * To mine a `BlockHeader` or `Block`, use the one-liner `await ethash.getMiner(block).mine(-1)`
       * @param mineObject - Object to mine on, either a `BlockHeader` or a `Block`
       * @returns - A miner object
       */
      getMiner(mineObject) {
          return new Miner(mineObject, this);
      }
      async _verifyPOW(header) {
          const headerHash = this.headerHash(header.raw());
          const { number, difficulty, mixHash, nonce } = header;
          await this.loadEpoc(number);
          const a = this.run(headerHash, nonce);
          const result = (0, util_1$a.bufferToBigInt)(a.hash);
          return a.mix.equals(mixHash) && util_1$a.TWO_POW256 / difficulty > result;
      }
      async verifyPOW(block) {
          // don't validate genesis blocks
          if (block.header.isGenesis()) {
              return true;
          }
          const valid = await this._verifyPOW(block.header);
          if (!valid) {
              return false;
          }
          for (let index = 0; index < block.uncleHeaders.length; index++) {
              const valid = await this._verifyPOW(block.uncleHeaders[index]);
              if (!valid) {
                  return false;
              }
          }
          return true;
      }
  }
  dist$2.Ethash = Ethash;

  Object.defineProperty(ethash, "__esModule", { value: true });
  ethash.EthashConsensus = void 0;
  const common_1$6 = dist$8;
  const ethash_1 = dist$2;
  /**
   * This class encapsulates Ethash-related consensus functionality when used with the Blockchain class.
   */
  class EthashConsensus {
      constructor() {
          this.algorithm = common_1$6.ConsensusAlgorithm.Ethash;
      }
      async validateConsensus(block) {
          if (!this._ethash) {
              throw new Error('blockchain not provided');
          }
          const valid = await this._ethash.verifyPOW(block);
          if (!valid) {
              throw new Error('invalid POW');
          }
      }
      /**
       * Checks that the block's `difficulty` matches the canonical difficulty of the parent header.
       * @param header - header of block to be checked
       */
      async validateDifficulty(header) {
          if (!this.blockchain) {
              throw new Error('blockchain not provided');
          }
          const parentHeader = (await this.blockchain.getBlock(header.parentHash)).header;
          if (header.ethashCanonicalDifficulty(parentHeader) !== header.difficulty) {
              throw new Error(`invalid difficulty ${header.errorStr()}`);
          }
      }
      async genesisInit() { }
      async setup({ blockchain }) {
          this.blockchain = blockchain;
          this._ethash = new ethash_1.Ethash(this.blockchain.db);
      }
      async newBlock() { }
  }
  ethash.EthashConsensus = EthashConsensus;

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EthashConsensus = exports.CliqueConsensus = exports.CasperConsensus = void 0;
  const casper_1 = casper;
  Object.defineProperty(exports, "CasperConsensus", { enumerable: true, get: function () { return casper_1.CasperConsensus; } });
  const clique_1 = clique;
  Object.defineProperty(exports, "CliqueConsensus", { enumerable: true, get: function () { return clique_1.CliqueConsensus; } });
  const ethash_1 = ethash;
  Object.defineProperty(exports, "EthashConsensus", { enumerable: true, get: function () { return ethash_1.EthashConsensus; } });

  }(consensus));

  var helpers = {};

  var constants = {};

  Object.defineProperty(constants, "__esModule", { value: true });
  constants.tdKey = constants.numberToHashKey = constants.HEADS_KEY = constants.headerKey = constants.HEAD_HEADER_KEY = constants.HEAD_BLOCK_KEY = constants.hashToNumberKey = constants.bufBE8 = constants.bodyKey = void 0;
  const util_1$9 = dist$a;
  // Geth compatible DB keys
  const HEADS_KEY = 'heads';
  constants.HEADS_KEY = HEADS_KEY;
  /**
   * Current canonical head for light sync
   */
  const HEAD_HEADER_KEY = 'LastHeader';
  constants.HEAD_HEADER_KEY = HEAD_HEADER_KEY;
  /**
   * Current canonical head for full sync
   */
  const HEAD_BLOCK_KEY = 'LastBlock';
  constants.HEAD_BLOCK_KEY = HEAD_BLOCK_KEY;
  /**
   * headerPrefix + number + hash -> header
   */
  const HEADER_PREFIX = Buffer$8.from('h');
  /**
   * headerPrefix + number + hash + tdSuffix -> td
   */
  const TD_SUFFIX = Buffer$8.from('t');
  /**
   * headerPrefix + number + numSuffix -> hash
   */
  const NUM_SUFFIX = Buffer$8.from('n');
  /**
   * blockHashPrefix + hash -> number
   */
  const BLOCK_HASH_PEFIX = Buffer$8.from('H');
  /**
   * bodyPrefix + number + hash -> block body
   */
  const BODY_PREFIX = Buffer$8.from('b');
  // Utility functions
  /**
   * Convert bigint to big endian Buffer
   */
  const bufBE8 = (n) => (0, util_1$9.bigIntToBuffer)(BigInt.asUintN(64, n));
  constants.bufBE8 = bufBE8;
  const tdKey = (n, hash) => Buffer$8.concat([HEADER_PREFIX, bufBE8(n), hash, TD_SUFFIX]);
  constants.tdKey = tdKey;
  const headerKey = (n, hash) => Buffer$8.concat([HEADER_PREFIX, bufBE8(n), hash]);
  constants.headerKey = headerKey;
  const bodyKey = (n, hash) => Buffer$8.concat([BODY_PREFIX, bufBE8(n), hash]);
  constants.bodyKey = bodyKey;
  const numberToHashKey = (n) => Buffer$8.concat([HEADER_PREFIX, bufBE8(n), NUM_SUFFIX]);
  constants.numberToHashKey = numberToHashKey;
  const hashToNumberKey = (hash) => Buffer$8.concat([BLOCK_HASH_PEFIX, hash]);
  constants.hashToNumberKey = hashToNumberKey;

  var operation = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DBOp = exports.DBTarget = void 0;
  const util_1 = dist$a;
  const constants_1 = constants;
  var DBTarget;
  (function (DBTarget) {
      DBTarget[DBTarget["Heads"] = 0] = "Heads";
      DBTarget[DBTarget["HeadHeader"] = 1] = "HeadHeader";
      DBTarget[DBTarget["HeadBlock"] = 2] = "HeadBlock";
      DBTarget[DBTarget["HashToNumber"] = 3] = "HashToNumber";
      DBTarget[DBTarget["NumberToHash"] = 4] = "NumberToHash";
      DBTarget[DBTarget["TotalDifficulty"] = 5] = "TotalDifficulty";
      DBTarget[DBTarget["Body"] = 6] = "Body";
      DBTarget[DBTarget["Header"] = 7] = "Header";
      DBTarget[DBTarget["CliqueSignerStates"] = 8] = "CliqueSignerStates";
      DBTarget[DBTarget["CliqueVotes"] = 9] = "CliqueVotes";
      DBTarget[DBTarget["CliqueBlockSigners"] = 10] = "CliqueBlockSigners";
  })(DBTarget = exports.DBTarget || (exports.DBTarget = {}));
  /**
   * The DBOp class aids creating database operations which is used by `level` using a more high-level interface
   */
  class DBOp {
      constructor(operationTarget, key) {
          this.operationTarget = operationTarget;
          this.baseDBOp = {
              key: '',
              keyEncoding: 'buffer',
              valueEncoding: 'buffer',
          };
          switch (operationTarget) {
              case DBTarget.Heads: {
                  this.baseDBOp.key = constants_1.HEADS_KEY;
                  this.baseDBOp.valueEncoding = 'json';
                  break;
              }
              case DBTarget.HeadHeader: {
                  this.baseDBOp.key = constants_1.HEAD_HEADER_KEY;
                  break;
              }
              case DBTarget.HeadBlock: {
                  this.baseDBOp.key = constants_1.HEAD_BLOCK_KEY;
                  break;
              }
              case DBTarget.HashToNumber: {
                  this.baseDBOp.key = (0, constants_1.hashToNumberKey)(key.blockHash);
                  this.cacheString = 'hashToNumber';
                  break;
              }
              case DBTarget.NumberToHash: {
                  this.baseDBOp.key = (0, constants_1.numberToHashKey)(key.blockNumber);
                  this.cacheString = 'numberToHash';
                  break;
              }
              case DBTarget.TotalDifficulty: {
                  this.baseDBOp.key = (0, constants_1.tdKey)(key.blockNumber, key.blockHash);
                  this.cacheString = 'td';
                  break;
              }
              case DBTarget.Body: {
                  this.baseDBOp.key = (0, constants_1.bodyKey)(key.blockNumber, key.blockHash);
                  this.cacheString = 'body';
                  break;
              }
              case DBTarget.Header: {
                  this.baseDBOp.key = (0, constants_1.headerKey)(key.blockNumber, key.blockHash);
                  this.cacheString = 'header';
                  break;
              }
          }
      }
      static get(operationTarget, key) {
          return new DBOp(operationTarget, key);
      }
      // set operation: note: value/key is not in default order
      static set(operationTarget, value, key) {
          const dbOperation = new DBOp(operationTarget, key);
          dbOperation.baseDBOp.value = value;
          dbOperation.baseDBOp.type = 'put';
          if (operationTarget == DBTarget.Heads) {
              dbOperation.baseDBOp.valueEncoding = 'json';
          }
          else {
              dbOperation.baseDBOp.valueEncoding = 'binary';
          }
          return dbOperation;
      }
      static del(operationTarget, key) {
          const dbOperation = new DBOp(operationTarget, key);
          dbOperation.baseDBOp.type = 'del';
          return dbOperation;
      }
      updateCache(cacheMap) {
          if ((0, util_1.isTruthy)(this.cacheString) && (0, util_1.isTruthy)(cacheMap[this.cacheString])) {
              if (this.baseDBOp.type == 'put') {
                  Buffer$8.isBuffer(this.baseDBOp.value) &&
                      cacheMap[this.cacheString].set(this.baseDBOp.key, this.baseDBOp.value);
              }
              else if (this.baseDBOp.type == 'del') {
                  cacheMap[this.cacheString].del(this.baseDBOp.key);
              }
              else {
                  throw new Error('unsupported db operation on cache');
              }
          }
      }
  }
  exports.DBOp = DBOp;

  }(operation));

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DBSetTD = exports.DBSetHashToNumber = exports.DBSetBlockOrHeader = exports.DBSaveLookups = exports.DBOp = void 0;
  const block_1 = dist$6;
  const rlp_1 = dist$9;
  const util_1 = dist$a;
  const constants_1 = constants;
  const operation_1 = operation;
  Object.defineProperty(exports, "DBOp", { enumerable: true, get: function () { return operation_1.DBOp; } });
  /*
   * This extra helper file serves as an interface between the blockchain API functionality
   * and the DB operations from `db/operation.ts` and also handles the right encoding of the keys
   */
  function DBSetTD(TD, blockNumber, blockHash) {
      return operation_1.DBOp.set(operation_1.DBTarget.TotalDifficulty, Buffer$8.from(rlp_1.RLP.encode(TD)), {
          blockNumber,
          blockHash,
      });
  }
  exports.DBSetTD = DBSetTD;
  /*
   * This method accepts either a BlockHeader or a Block and returns a list of DatabaseOperation instances
   *
   * - A "Set Header Operation" is always added
   * - A "Set Body Operation" is only added if the body is not empty (it has transactions/uncles) or if the block is the genesis block
   * (if there is a header but no block saved the DB will implicitly assume the block to be empty)
   */
  function DBSetBlockOrHeader(blockBody) {
      const header = blockBody instanceof block_1.Block ? blockBody.header : blockBody;
      const dbOps = [];
      const blockNumber = header.number;
      const blockHash = header.hash();
      const headerValue = header.serialize();
      dbOps.push(operation_1.DBOp.set(operation_1.DBTarget.Header, headerValue, {
          blockNumber,
          blockHash,
      }));
      const isGenesis = header.number === BigInt(0);
      if (isGenesis ||
          (blockBody instanceof block_1.Block && (blockBody.transactions.length || blockBody.uncleHeaders.length))) {
          const bodyValue = Buffer$8.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(blockBody.raw()).slice(1)));
          dbOps.push(operation_1.DBOp.set(operation_1.DBTarget.Body, bodyValue, {
              blockNumber,
              blockHash,
          }));
      }
      return dbOps;
  }
  exports.DBSetBlockOrHeader = DBSetBlockOrHeader;
  function DBSetHashToNumber(blockHash, blockNumber) {
      const blockNumber8Byte = (0, constants_1.bufBE8)(blockNumber);
      return operation_1.DBOp.set(operation_1.DBTarget.HashToNumber, blockNumber8Byte, {
          blockHash,
      });
  }
  exports.DBSetHashToNumber = DBSetHashToNumber;
  function DBSaveLookups(blockHash, blockNumber) {
      const ops = [];
      ops.push(operation_1.DBOp.set(operation_1.DBTarget.NumberToHash, blockHash, { blockNumber }));
      const blockNumber8Bytes = (0, constants_1.bufBE8)(blockNumber);
      ops.push(operation_1.DBOp.set(operation_1.DBTarget.HashToNumber, blockNumber8Bytes, {
          blockHash,
      }));
      return ops;
  }
  exports.DBSaveLookups = DBSaveLookups;

  }(helpers));

  var manager = {};

  var cache$1 = {};

  var yallist = Yallist$1;

  Yallist$1.Node = Node;
  Yallist$1.create = Yallist$1;

  function Yallist$1 (list) {
    var self = this;
    if (!(self instanceof Yallist$1)) {
      self = new Yallist$1();
    }

    self.tail = null;
    self.head = null;
    self.length = 0;

    if (list && typeof list.forEach === 'function') {
      list.forEach(function (item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }

    return self
  }

  Yallist$1.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list')
    }

    var next = node.next;
    var prev = node.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }

    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;

    return next
  };

  Yallist$1.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }

    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };

  Yallist$1.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }

    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };

  Yallist$1.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length
  };

  Yallist$1.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length
  };

  Yallist$1.prototype.pop = function () {
    if (!this.tail) {
      return undefined
    }

    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res
  };

  Yallist$1.prototype.shift = function () {
    if (!this.head) {
      return undefined
    }

    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res
  };

  Yallist$1.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };

  Yallist$1.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };

  Yallist$1.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      // abort out of the list early if we hit a cycle
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value
    }
  };

  Yallist$1.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      // abort out of the list early if we hit a cycle
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value
    }
  };

  Yallist$1.prototype.map = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist$1();
    for (var walker = this.head; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res
  };

  Yallist$1.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist$1();
    for (var walker = this.tail; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res
  };

  Yallist$1.prototype.reduce = function (fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value')
    }

    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }

    return acc
  };

  Yallist$1.prototype.reduceReverse = function (fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value')
    }

    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }

    return acc
  };

  Yallist$1.prototype.toArray = function () {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr
  };

  Yallist$1.prototype.toArrayReverse = function () {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr
  };

  Yallist$1.prototype.slice = function (from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist$1();
    if (to < from || to < 0) {
      return ret
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret
  };

  Yallist$1.prototype.sliceReverse = function (from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist$1();
    if (to < from || to < 0) {
      return ret
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret
  };

  Yallist$1.prototype.splice = function (start, deleteCount /*, ...nodes */) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }

    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }

    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }

    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }

    for (var i = 2; i < arguments.length; i++) {
      walker = insert(this, walker, arguments[i]);
    }
    return ret;
  };

  Yallist$1.prototype.reverse = function () {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this
  };

  function insert (self, node, value) {
    var inserted = node === self.head ?
      new Node(value, null, node, self) :
      new Node(value, node, node.next, self);

    if (inserted.next === null) {
      self.tail = inserted;
    }
    if (inserted.prev === null) {
      self.head = inserted;
    }

    self.length++;

    return inserted
  }

  function push (self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
      self.head = self.tail;
    }
    self.length++;
  }

  function unshift (self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
      self.tail = self.head;
    }
    self.length++;
  }

  function Node (value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list)
    }

    this.list = list;
    this.value = value;

    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }

    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }

  try {
    // add if support for Symbol.iterator is present
    require('./iterator.js')(Yallist$1);
  } catch (er) {}

  // A linked list to keep track of recently-used-ness
  const Yallist = yallist;

  const MAX = Symbol('max');
  const LENGTH = Symbol('length');
  const LENGTH_CALCULATOR = Symbol('lengthCalculator');
  const ALLOW_STALE = Symbol('allowStale');
  const MAX_AGE = Symbol('maxAge');
  const DISPOSE = Symbol('dispose');
  const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
  const LRU_LIST = Symbol('lruList');
  const CACHE = Symbol('cache');
  const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

  const naiveLength = () => 1;

  // lruList is a yallist where the head is the youngest
  // item, and the tail is the oldest.  the list contains the Hit
  // objects as the entries.
  // Each Hit object has a reference to its Yallist.Node.  This
  // never changes.
  //
  // cache is a Map (or PseudoMap) that matches the keys to
  // the Yallist.Node object.
  class LRUCache$1 {
    constructor (options) {
      if (typeof options === 'number')
        options = { max: options };

      if (!options)
        options = {};

      if (options.max && (typeof options.max !== 'number' || options.max < 0))
        throw new TypeError('max must be a non-negative number')
      // Kind of weird to have a default max of Infinity, but oh well.
      this[MAX] = options.max || Infinity;

      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== 'number')
        throw new TypeError('maxAge must be a number')
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }

    // resize the cache when the max changes.
    set max (mL) {
      if (typeof mL !== 'number' || mL < 0)
        throw new TypeError('max must be a non-negative number')

      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max () {
      return this[MAX]
    }

    set allowStale (allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale () {
      return this[ALLOW_STALE]
    }

    set maxAge (mA) {
      if (typeof mA !== 'number')
        throw new TypeError('maxAge must be a non-negative number')

      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge () {
      return this[MAX_AGE]
    }

    // resize the cache when the lengthCalculator changes.
    set lengthCalculator (lC) {
      if (typeof lC !== 'function')
        lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(hit => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator () { return this[LENGTH_CALCULATOR] }

    get length () { return this[LENGTH] }
    get itemCount () { return this[LRU_LIST].length }

    rforEach (fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null;) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }

    forEach (fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null;) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }

    keys () {
      return this[LRU_LIST].toArray().map(k => k.key)
    }

    values () {
      return this[LRU_LIST].toArray().map(k => k.value)
    }

    reset () {
      if (this[DISPOSE] &&
          this[LRU_LIST] &&
          this[LRU_LIST].length) {
        this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
      }

      this[CACHE] = new Map(); // hash of items by key
      this[LRU_LIST] = new Yallist(); // list of items in order of use recency
      this[LENGTH] = 0; // length of items in the list
    }

    dump () {
      return this[LRU_LIST].map(hit =>
        isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter(h => h)
    }

    dumpLru () {
      return this[LRU_LIST]
    }

    set (key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];

      if (maxAge && typeof maxAge !== 'number')
        throw new TypeError('maxAge must be a number')

      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false
        }

        const node = this[CACHE].get(key);
        const item = node.value;

        // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true
      }

      const hit = new Entry(key, value, len, now, maxAge);

      // oversized objects fall out of cache automatically.
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);

        return false
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true
    }

    has (key) {
      if (!this[CACHE].has(key)) return false
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit)
    }

    get (key) {
      return get(this, key, true)
    }

    peek (key) {
      return get(this, key, false)
    }

    pop () {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null

      del(this, node);
      return node.value
    }

    del (key) {
      del(this, this[CACHE].get(key));
    }

    load (arr) {
      // reset the cache
      this.reset();

      const now = Date.now();
      // A previous serialized cache has the most recent items first
      for (let l = arr.length - 1; l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          // dont add already expired items
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }

    prune () {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  }

  const get = (self, key, doUse) => {
    const node = self[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          return undefined
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value
    }
  };

  const isStale = (self, hit) => {
    if (!hit || (!hit.maxAge && !self[MAX_AGE]))
      return false

    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge
      : self[MAX_AGE] && (diff > self[MAX_AGE])
  };

  const trim = self => {
    if (self[LENGTH] > self[MAX]) {
      for (let walker = self[LRU_LIST].tail;
        self[LENGTH] > self[MAX] && walker !== null;) {
        // We know that we're about to delete this one, and also
        // what the next least recently used key will be, so just
        // go ahead and set it now.
        const prev = walker.prev;
        del(self, walker);
        walker = prev;
      }
    }
  };

  const del = (self, node) => {
    if (node) {
      const hit = node.value;
      if (self[DISPOSE])
        self[DISPOSE](hit.key, hit.value);

      self[LENGTH] -= hit.length;
      self[CACHE].delete(hit.key);
      self[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor (key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }

  const forEachStep = (self, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self);
  };

  var lruCache = LRUCache$1;

  Object.defineProperty(cache$1, "__esModule", { value: true });
  cache$1.Cache = void 0;
  const LRUCache = lruCache;
  /**
   * Simple LRU Cache that allows for keys of type Buffer
   * @hidden
   */
  class Cache$1 {
      constructor(opts) {
          this._cache = new LRUCache(opts);
      }
      set(key, value) {
          if (key instanceof Buffer$8) {
              key = key.toString('hex');
          }
          this._cache.set(key, value);
      }
      get(key) {
          if (key instanceof Buffer$8) {
              key = key.toString('hex');
          }
          return this._cache.get(key);
      }
      del(key) {
          if (key instanceof Buffer$8) {
              key = key.toString('hex');
          }
          this._cache.del(key);
      }
  }
  cache$1.Cache = Cache$1;

  Object.defineProperty(manager, "__esModule", { value: true });
  manager.DBManager = void 0;
  const block_1$4 = dist$6;
  const rlp_1$4 = dist$9;
  const util_1$8 = dist$a;
  const cache_1$1 = cache$1;
  const operation_1$1 = operation;
  class NotFoundError extends Error {
      constructor(blockNumber) {
          super(`Key ${blockNumber.toString()} was not found`);
          this.code = 'LEVEL_NOT_FOUND';
          // `Error.captureStackTrace` is not defined in some browser contexts
          if (typeof Error.captureStackTrace !== 'undefined') {
              Error.captureStackTrace(this, this.constructor);
          }
      }
  }
  /**
   * Abstraction over a DB to facilitate storing/fetching blockchain-related
   * data, such as blocks and headers, indices, and the head block.
   * @hidden
   */
  class DBManager {
      constructor(db, common) {
          this._db = db;
          this._common = common;
          this._cache = {
              td: new cache_1$1.Cache({ max: 1024 }),
              header: new cache_1$1.Cache({ max: 512 }),
              body: new cache_1$1.Cache({ max: 256 }),
              numberToHash: new cache_1$1.Cache({ max: 2048 }),
              hashToNumber: new cache_1$1.Cache({ max: 2048 }),
          };
      }
      /**
       * Fetches iterator heads from the db.
       */
      async getHeads() {
          const heads = await this.get(operation_1$1.DBTarget.Heads);
          for (const key of Object.keys(heads)) {
              heads[key] = Buffer$8.from(heads[key]);
          }
          return heads;
      }
      /**
       * Fetches header of the head block.
       */
      async getHeadHeader() {
          return this.get(operation_1$1.DBTarget.HeadHeader);
      }
      /**
       * Fetches head block.
       */
      async getHeadBlock() {
          return this.get(operation_1$1.DBTarget.HeadBlock);
      }
      /**
       * Fetches a block (header and body) given a block id,
       * which can be either its hash or its number.
       */
      async getBlock(blockId) {
          if (typeof blockId === 'number' && Number.isInteger(blockId)) {
              blockId = BigInt(blockId);
          }
          let number;
          let hash;
          if (Buffer$8.isBuffer(blockId)) {
              hash = blockId;
              number = await this.hashToNumber(blockId);
          }
          else if (typeof blockId === 'bigint') {
              number = blockId;
              hash = await this.numberToHash(blockId);
          }
          else {
              throw new Error('Unknown blockId type');
          }
          const header = await this.getHeader(hash, number);
          let body = [[], []];
          try {
              body = await this.getBody(hash, number);
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
          }
          const blockData = [header.raw(), ...body];
          const opts = { common: this._common };
          if (number === BigInt(0)) {
              opts.hardforkByBlockNumber = true;
          }
          else {
              opts.hardforkByTTD = await this.getTotalDifficulty(header.parentHash, number - BigInt(1));
          }
          return block_1$4.Block.fromValuesArray(blockData, opts);
      }
      /**
       * Fetches body of a block given its hash and number.
       */
      async getBody(blockHash, blockNumber) {
          const body = await this.get(operation_1$1.DBTarget.Body, { blockHash, blockNumber });
          return (0, util_1$8.arrToBufArr)(rlp_1$4.RLP.decode(Uint8Array.from(body)));
      }
      /**
       * Fetches header of a block given its hash and number.
       */
      async getHeader(blockHash, blockNumber) {
          const encodedHeader = await this.get(operation_1$1.DBTarget.Header, { blockHash, blockNumber });
          const opts = { common: this._common };
          if (blockNumber === BigInt(0)) {
              opts.hardforkByBlockNumber = true;
          }
          else {
              const parentHash = await this.numberToHash(blockNumber - BigInt(1));
              opts.hardforkByTTD = await this.getTotalDifficulty(parentHash, blockNumber - BigInt(1));
          }
          return block_1$4.BlockHeader.fromRLPSerializedHeader(encodedHeader, opts);
      }
      /**
       * Fetches total difficulty for a block given its hash and number.
       */
      async getTotalDifficulty(blockHash, blockNumber) {
          const td = await this.get(operation_1$1.DBTarget.TotalDifficulty, { blockHash, blockNumber });
          return (0, util_1$8.bufferToBigInt)(Buffer$8.from(rlp_1$4.RLP.decode(Uint8Array.from(td))));
      }
      /**
       * Performs a block hash to block number lookup.
       */
      async hashToNumber(blockHash) {
          const value = await this.get(operation_1$1.DBTarget.HashToNumber, { blockHash });
          return (0, util_1$8.bufferToBigInt)(value);
      }
      /**
       * Performs a block number to block hash lookup.
       */
      async numberToHash(blockNumber) {
          if (blockNumber < BigInt(0)) {
              throw new NotFoundError(blockNumber);
          }
          return this.get(operation_1$1.DBTarget.NumberToHash, { blockNumber });
      }
      /**
       * Fetches a key from the db. If `opts.cache` is specified
       * it first tries to load from cache, and on cache miss will
       * try to put the fetched item on cache afterwards.
       */
      async get(dbOperationTarget, key) {
          const dbGetOperation = operation_1$1.DBOp.get(dbOperationTarget, key);
          const cacheString = dbGetOperation.cacheString;
          const dbKey = dbGetOperation.baseDBOp.key;
          const dbOpts = dbGetOperation.baseDBOp;
          if ((0, util_1$8.isTruthy)(cacheString)) {
              if ((0, util_1$8.isFalsy)(this._cache[cacheString])) {
                  throw new Error(`Invalid cache: ${cacheString}`);
              }
              let value = this._cache[cacheString].get(dbKey);
              if (!value) {
                  value = await this._db.get(dbKey, dbOpts);
                  if (value) {
                      this._cache[cacheString].set(dbKey, value);
                  }
              }
              return value;
          }
          return this._db.get(dbKey, dbOpts);
      }
      /**
       * Performs a batch operation on db.
       */
      async batch(ops) {
          const convertedOps = ops.map((op) => op.baseDBOp);
          // update the current cache for each operation
          ops.map((op) => op.updateCache(this._cache));
          return this._db.batch(convertedOps);
      }
  }
  manager.DBManager = DBManager;

  var genesisStates = {};

  Object.defineProperty(genesisStates, "__esModule", { value: true });
  genesisStates.genesisStateRoot = void 0;
  const rlp_1$3 = dist$9;
  const trie_1$3 = dist$5;
  const util_1$7 = dist$a;
  const keccak_1$1 = keccak;
  /**
   * Derives the stateRoot of the genesis block based on genesis allocations
   */
  async function genesisStateRoot(genesisState) {
      const trie = new trie_1$3.SecureTrie();
      for (const [key, value] of Object.entries(genesisState)) {
          const address = (0, util_1$7.isHexPrefixed)(key) ? (0, util_1$7.toBuffer)(key) : Buffer$8.from(key, 'hex');
          const account = new util_1$7.Account();
          if (typeof value === 'string') {
              account.balance = BigInt(value);
          }
          else {
              const [balance, code, storage] = value;
              if ((0, util_1$7.isTruthy)(balance)) {
                  account.balance = BigInt(balance);
              }
              if ((0, util_1$7.isTruthy)(code)) {
                  account.codeHash = Buffer$8.from((0, keccak_1$1.keccak256)((0, util_1$7.toBuffer)(code)));
              }
              if ((0, util_1$7.isTruthy)(storage)) {
                  const storageTrie = new trie_1$3.SecureTrie();
                  for (const [k, val] of storage) {
                      const storageKey = (0, util_1$7.isHexPrefixed)(k) ? (0, util_1$7.toBuffer)(k) : Buffer$8.from(k, 'hex');
                      const storageVal = Buffer$8.from(rlp_1$3.RLP.encode(Uint8Array.from((0, util_1$7.unpadBuffer)((0, util_1$7.isHexPrefixed)(val) ? (0, util_1$7.toBuffer)(val) : Buffer$8.from(val, 'hex')))));
                      await storageTrie.put(storageKey, storageVal);
                  }
                  account.stateRoot = storageTrie.root;
              }
          }
          await trie.put(address, account.serialize());
      }
      return trie.root;
  }
  genesisStates.genesisStateRoot = genesisStateRoot;

  var require$$10 = {
  	"0x000d836201318ec6899a67540690382780743280": "0xad78ebc5ac6200000",
  	"0x001762430ea9c3a26e5749afdb70da5f78ddbb8c": "0xad78ebc5ac6200000",
  	"0x001d14804b399c6ef80e64576f657660804fec0b": "0xe3aeb5737240a00000",
  	"0x0032403587947b9f15622a68d104d54d33dbd1cd": "0x433874f632cc60000",
  	"0x00497e92cdc0e0b963d752b2296acb87da828b24": "0xa8f649fe7c6180000",
  	"0x004bfbe1546bc6c65b5c7eaa55304b38bbfec6d3": "0x6c6b935b8bbd400000",
  	"0x005a9c03f69d17d66cbb8ad721008a9ebbb836fb": "0x6c6b935b8bbd400000",
  	"0x005d0ee8155ec0a6ff6808552ca5f16bb5be323a": "0xaadec983fcff40000",
  	"0x007622d84a234bb8b078230fcf84b67ae9a8acae": "0x25e1cc519952f80000",
  	"0x007b9fc31905b4994b04c9e2cfdc5e2770503f42": "0x6c5db2a4d815dc0000",
  	"0x007f4a23ca00cd043d25c2888c1aa5688f81a344": "0x29f0a95bfbf7290000",
  	"0x008639dabbe3aeac887b5dc0e43e13bcd287d76c": "0x10d0e3c87d6e2c0000",
  	"0x0089508679abf8c71bf6781687120e3e6a84584d": "0x6194049f30f7200000",
  	"0x008fc7cbadffbd0d7fe44f8dfd60a79d721a1c9c": "0x3635c9adc5dea00000",
  	"0x009560a3de627868f91fa8bfe1c1b7afaf08186b": "0x1c67f5f7baa0b00000",
  	"0x00969747f7a5b30645fe00e44901435ace24cc37": "0x5c283d410394100000",
  	"0x009a6d7db326679b77c90391a7476d238f3ba33e": "0xada55474b81340000",
  	"0x009eef0a0886056e3f69211853b9b7457f3782e4": "0xa2a878069b28e00000",
  	"0x009fdbf44e1f4a6362b769c39a475f95a96c2bc7": "0x1e931283ccc8500000",
  	"0x00a5797f52c9d58f189f36b1d45d1bf6041f2f6b": "0x127d1b3461acd1a0000",
  	"0x00aa5381b2138ebeffc191d5d8c391753b7098d2": "0x35abb09ffedeb68000",
  	"0x00aada25ea2286709abb422d41923fd380cd04c7": "0x233df3299f61720000",
  	"0x00acbfb2f25a5485c739ef70a44eeeeb7c65a66f": "0x56bc75e2d63100000",
  	"0x00acc6f082a442828764d11f58d6894ae408f073": "0xcb49b44ba602d800000",
  	"0x00b277b099a8e866ca0ec65bcb87284fd142a582": "0x6acb3df27e1f880000",
  	"0x00bdd4013aa31c04616c2bc9785f2788f915679b": "0xb9f65d00f63c0000",
  	"0x00c27d63fde24b92ee8a1e7ed5d26d8dc5c83b03": "0x6c6b935b8bbd400000",
  	"0x00c40fe2095423509b9fd9b754323158af2310f3": "0x0",
  	"0x00d75ed60c774f8b3a5a5173fb1833ad7105a2d9": "0x6cb7e74867d5e60000",
  	"0x00d78d89b35f472716eceafebf600527d3a1f969": "0x5e0549c9632e1d80000",
  	"0x00dae27b350bae20c5652124af5d8b5cba001ec1": "0x22b1c8c1227a00000",
  	"0x00dc01cbf44978a42e8de8e436edf94205cfb6ec": "0x4f0febbcda8cb40000",
  	"0x00e681bc2d10db62de85848324492250348e90bf": "0x43c33c1937564800000",
  	"0x00f463e137dcf625fbf3bca39eca98d2b968cf7f": "0x14061b9d77a5e980000",
  	"0x010007394b8b7565a1658af88ce463499135d6b7": "0x56bc75e2d63100000",
  	"0x010df1df4bed23760d2d1c03781586ddf7918e54": "0x340aad21b3b700000",
  	"0x010f4a98dfa1d9799bf5c796fb550efbe7ecd877": "0x1b2f292236292c70000",
  	"0x01155057002f6b0d18acb9388d3bc8129f8f7a20": "0x48a43c54602f700000",
  	"0x01226e0ad8d62277b162621c62c928e96e0b9a8c": "0x6c6b935b8bbd400000",
  	"0x0126e12ebc17035f35c0e9d11dd148393c405d7a": "0x6c660645aa47180000",
  	"0x012f396a2b5eb83559bac515e5210df2c8c362ba": "0xad78ebc5ac6200000",
  	"0x0134ff38155fabae94fd35c4ffe1d79de7ef9c59": "0x35659ef93f0fc40000",
  	"0x0136a5af6c3299c6b5f005fdaddb148c070b299b": "0x11aa9ac15f1280000",
  	"0x01488ad3da603c4cdd6cb0b7a1e30d2a30c8fc38": "0xad78ebc5ac6200000",
  	"0x014974a1f46bf204944a853111e52f1602617def": "0x6c6b935b8bbd400000",
  	"0x014b7f67b14f5d983d87014f570c8b993b9872b5": "0xad78ebc5ac6200000",
  	"0x0151fa5d17a2dce2d7f1eb39ef7fe2ad213d5d89": "0xd8d726b7177a800000",
  	"0x01577afd4e50890247c9b10d44af73229aec884f": "0x24dce54d34a1a00000",
  	"0x015f097d9acddcddafaf2a107eb93a40fc94b04c": "0x43c33c1937564800000",
  	"0x0169c1c210eae845e56840412e1f65993ea90fb4": "0x6c6b935b8bbd400000",
  	"0x016b60bb6d67928c29fd0313c666da8f1698d9c5": "0x6c6b935b8bbd400000",
  	"0x016c85e1613b900fa357b8283b120e65aefcdd08": "0x2b5d9784a97cd50000",
  	"0x018492488ba1a292342247b31855a55905fef269": "0x796e3ea3f8ab00000",
  	"0x018f20a27b27ec441af723fd9099f2cbb79d6263": "0x75792a8abdef7c0000",
  	"0x0191eb547e7bf6976b9b1b577546761de65622e2": "0x6c6b4c4da6ddbe0000",
  	"0x019d709579ff4bc09fdcdde431dc1447d2c260bc": "0x1158e460913d00000",
  	"0x01a25a5f5af0169b30864c3be4d7563ccd44f09e": "0x4d853c8f8908980000",
  	"0x01a7d9fa7d0eb1185c67e54da83c2e75db69e39f": "0x19d4addd0d8bc960000",
  	"0x01a818135a414210c37c62b625aca1a54611ac36": "0xe18398e7601900000",
  	"0x01b1cae91a3b9559afb33cdc6d689442fdbfe037": "0xad78ebc5ac6200000",
  	"0x01b5b5bc5a117fa08b34ed1db9440608597ac548": "0xad78ebc5ac6200000",
  	"0x01bbc14f67af0639aab1441e6a08d4ce7162090f": "0x46fcf68ff8be060000",
  	"0x01d03815c61f416b71a2610a2daba59ff6a6de5b": "0x205dfe50b81c82e0000",
  	"0x01d599ee0d5f8c38ab2d392e2c65b74c3ce31820": "0x1ba5abf9e779380000",
  	"0x01e40521122530d9ac91113c06a0190b6d63850b": "0x487a9a304539440000",
  	"0x01e6415d587b065490f1ed7f21d6e0f386ee6747": "0x6c6b935b8bbd400000",
  	"0x01e864d354741b423e6f42851724468c74f5aa9c": "0x43c33c1937564800000",
  	"0x01ed5fba8d2eab673aec042d30e4e8a611d8c55a": "0x6c6b935b8bbd400000",
  	"0x01fb8ec12425a04f813e46c54c05748ca6b29aa9": "0xe15730385467c0000",
  	"0x01ff1eb1dead50a7f2f9638fdee6eccf3a7b2ac8": "0x2086ac351052600000",
  	"0x020362c3ade878ca90d6b2d889a4cc5510eed5f3": "0x3888e8b311adb38000",
  	"0x0203ae01d4c41cae1865e04b1f5b53cdfaecae31": "0x3689cdceb28cd70000",
  	"0x02089361a3fe7451fb1f87f01a2d866653dc0b07": "0x22ac74832b5040000",
  	"0x021f69043de88c4917ca10f1842897eec0589c7c": "0x6b44cfb81487f40000",
  	"0x02290fb5f9a517f82845acdeca0fc846039be233": "0x6c6b935b8bbd400000",
  	"0x0239b4f21f8e05cd01512b2be7a0e18a6d974607": "0x3635c9adc5dea00000",
  	"0x02477212ffdd75e5155651b76506b1646671a1eb": "0x5f68e8131ecf800000",
  	"0x024a098ae702bef5406c9c22b78bd4eb2cc7a293": "0xd8d726b7177a800000",
  	"0x024bdd2c7bfd500ee7404f7fb3e9fb31dd20fbd1": "0x9c2007651b2500000",
  	"0x025367960304beee34591118e9ac2d1358d8021a": "0x6c6b935b8bbd400000",
  	"0x0256149f5b5063bea14e15661ffb58f9b459a957": "0x2629f66e0c53000000",
  	"0x02603d7a3bb297c67c877e5d34fbd5b913d4c63a": "0x1158e460913d00000",
  	"0x0261ad3a172abf1315f0ffec3270986a8409cb25": "0xb08213bcf8ffe0000",
  	"0x026432af37dc5113f1f46d480a4de0b28052237e": "0x1349b786e40bfc0000",
  	"0x0266ab1c6b0216230b9395443d5fa75e684568c6": "0x3635c9adc5dea00000",
  	"0x02751dc68cb5bd737027abf7ddb77390cd77c16b": "0x1158e460913d00000",
  	"0x02778e390fa17510a3428af2870c4273547d386c": "0x36c3c66170c0d720000",
  	"0x02ade5db22f8b758ee1443626c64ec2f32aa0a15": "0x43c33c1937564800000",
  	"0x02af2459a93d0b3f4d062636236cd4b29e3bcecf": "0x678a932062e4180000",
  	"0x02b1af72339b2a2256389fd64607de24f0de600a": "0x6c6b935b8bbd400000",
  	"0x02b643d6fabd437a851accbe79abb7fde126dccf": "0x18650127cc3dc800000",
  	"0x02b6d65cb00b7b36e1fb5ed3632c4cb20a894130": "0x43c33c1937564800000",
  	"0x02b7b1d6b34ce053a40eb65cd4a4f7dddd0e9f30": "0x252248deb6e6940000",
  	"0x02c9f7940a7b8b7a410bf83dc9c22333d4275dd3": "0x10f0cf064dd59200000",
  	"0x02d4a30968a39e2b3498c3a6a4ed45c1c6646822": "0x6c6b935b8bbd400000",
  	"0x02dfcb17a1b87441036374b762a5d3418b1cb4d4": "0x48b02ba9d1ba460000",
  	"0x02e4cb22be46258a40e16d4338d802fffd00c151": "0x149696eaceba810000",
  	"0x02e816afc1b5c0f39852131959d946eb3b07b5ad": "0x3635c9adc5dea00000",
  	"0x02f7f67209b16a17550c694c72583819c80b54ad": "0x5559306a78a700000",
  	"0x030973807b2f426914ad00181270acd27b8ff61f": "0x121ea68c114e5100000",
  	"0x03097923ba155e16d82f3ad3f6b815540884b92c": "0x62a992e53a0af00000",
  	"0x030fb3401f72bd3418b7d1da75bf8c519dd707dc": "0xa2a15d09519be00000",
  	"0x031e25db516b0f099faebfd94f890cf96660836b": "0x6c6b935b8bbd400000",
  	"0x0328510c09dbcd85194a98d67c33ac49f2f94d60": "0x2544faa778090e00000",
  	"0x0329188f080657ab3a2afa522467178279832085": "0xbbf510ddfcb260000",
  	"0x03317826d1f70aa4bddfa09be0c4105552d2358b": "0x21a754a6dc5280000",
  	"0x03337012ae1d7ff3ee7f697c403e7780188bf0ef": "0xad78ebc5ac6200000",
  	"0x03377c0e556b640103289a6189e1aeae63493467": "0x43c33c1937564800000",
  	"0x0349634dc2a9e80c3f7721ee2b5046aeaaedfbb5": "0xd8d726b7177a800000",
  	"0x0355bcacbd21441e95adeedc30c17218c8a408ce": "0x15af1d78b58c400000",
  	"0x036eeff5ba90a6879a14dff4c5043b18ca0460c9": "0x56bc75e2d63100000",
  	"0x03714b41d2a6f751008ef8dd4d2b29aecab8f36e": "0x14542ba12a337c00000",
  	"0x0372e852582e0934344a0fed2178304df25d4628": "0x43c33c1937564800000",
  	"0x0372ee5508bf8163ed284e5eef94ce4d7367e522": "0x56bc75e2d63100000",
  	"0x037dd056e7fdbd641db5b6bea2a8780a83fae180": "0x796e3ea3f8ab00000",
  	"0x038323b184cff7a82ae2e1bda7793fe4319ca0bf": "0x43c33c1937564800000",
  	"0x038779ca2dbe663e63db3fe75683ea0ec62e2383": "0x5a87e7d7f5f6580000",
  	"0x038e45eadd3d88b87fe4dab066680522f0dfc8f9": "0x21e19e0c9bab2400000",
  	"0x0392549a727f81655429cb928b529f25df4d1385": "0x16c43a0eea0740000",
  	"0x0394b90fadb8604f86f43fc1e35d3124b32a5989": "0x296aa140278e700000",
  	"0x039e7a4ebc284e2ccd42b1bdd60bd6511c0f7706": "0xf015f25736420000",
  	"0x039ef1ce52fe7963f166d5a275c4b1069fe3a832": "0x15af39e4aab2740000",
  	"0x03a26cfc4c18316f70d59e9e1a79ee3e8b962f4c": "0x6c6b935b8bbd400000",
  	"0x03aa622881236dd0f4940c24c324ff8b7b7e2186": "0xad78ebc5ac62000000",
  	"0x03af7ad9d5223cf7c8c13f20df67ebe5ffc5bb41": "0xad78ebc5ac6200000",
  	"0x03b0f17cd4469ddccfb7da697e82a91a5f9e7774": "0x1158e460913d00000",
  	"0x03b41b51f41df20dd279bae18c12775f77ad771c": "0x3635c9adc5dea00000",
  	"0x03be5b4629aefbbcab9de26d39576cb7f691d764": "0xadf30ba70c8970000",
  	"0x03c647a9f929b0781fe9ae01caa3e183e876777e": "0x182ab7c20ce5240000",
  	"0x03c91d92943603e752203e05340e566013b90045": "0x2b7cc2e9c3225c0000",
  	"0x03cb4c4f4516c4ff79a1b6244fbf572e1c7fea79": "0x9489237adb9a500000",
  	"0x03cb98d7acd817de9d886d22fab3f1b57d92a608": "0x56bc75e2d631000000",
  	"0x03cc9d2d21f86b84ac8ceaf971dba78a90e62570": "0x57473d05dabae80000",
  	"0x03d1724fd00e54aabcd2de2a91e8462b1049dd3a": "0x8f1d5c1cae37400000",
  	"0x03dedfcd0b3c2e17c705da248790ef98a6bd5751": "0x487a9a304539440000",
  	"0x03e8b084537557e709eae2e1e1a5a6bce1ef8314": "0x1158e460913d00000",
  	"0x03ea6d26d080e57aee3926b18e8ed73a4e5b2826": "0xad78ebc5ac6200000",
  	"0x03eb3cb860f6028da554d344a2bb5a500ae8b86f": "0x6c6b935b8bbd400000",
  	"0x03ebc63fda6660a465045e235fbe6e5cf195735f": "0x7b06ce87fdd680000",
  	"0x03ef6ad20ff7bd4f002bac58d47544cf879ae728": "0x175c758d0b96e5c0000",
  	"0x03f7b92008813ae0a676eb212814afab35221069": "0x6c6b935b8bbd400000",
  	"0x041170f581de80e58b2a045c8f7c1493b001b7cb": "0x303c74a1a336940000",
  	"0x0413d0cf78c001898a378b918cd6e498ea773c4d": "0xf2dc7d47f15600000",
  	"0x04241b41ecbd0bfdf1295e9d4fa59ea09e6c6186": "0x655f769450bc780000",
  	"0x043707071e2ae21eed977891dc79cd5d8ee1c2da": "0x6c6b935b8bbd400000",
  	"0x044e853144e3364495e7a69fa1d46abea3ac0964": "0x2ab2254b1dc9a8000",
  	"0x0455dcec8a7fc4461bfd7f37456fce3f4c3caac7": "0x15af1d78b58c400000",
  	"0x045ed7f6d9ee9f252e073268db022c6326adfc5b": "0x56bc75e2d63100000",
  	"0x046377f864b0143f282174a892a73d3ec8ec6132": "0xa5aa85009e39c0000",
  	"0x0469e8c440450b0e512626fe817e6754a8152830": "0x6c6b935b8bbd400000",
  	"0x046d274b1af615fb505a764ad8dda770b1db2f3d": "0x6c6b935b8bbd400000",
  	"0x047d5a26d7ad8f8e70600f70a398ddaa1c2db26f": "0x14542ba12a337c00000",
  	"0x047e87c8f7d1fce3b01353a85862a948ac049f3e": "0x50c5e761a444080000",
  	"0x047f9bf1529daf87d407175e6f171b5e59e9ff3e": "0x233c8fe42703e80000",
  	"0x04852732b4c652f6c2e58eb36587e60a62da14db": "0x43c33c1937564800000",
  	"0x048a8970ea4145c64d5517b8de5b46d0595aad06": "0x43c33c1937564800000",
  	"0x049c5d4bc6f25d4e456c697b52a07811ccd19fb1": "0x104400a2470e680000",
  	"0x04a1cada1cc751082ff8da928e3cfa000820a9e9": "0x22b1c8c1227a00000",
  	"0x04a80afad53ef1f84165cfd852b0fdf1b1c24ba8": "0x324e964b3eca80000",
  	"0x04aafc8ae5ce6f4903c89d7fac9cb19512224777": "0x1b1ae4d6e2ef500000",
  	"0x04ba4bb87140022c214a6fac42db5a16dd954045": "0x3635c9adc5dea00000",
  	"0x04ba8a3f03f08b895095994dda619edaacee3e7a": "0x6c6b935b8bbd400000",
  	"0x04c2c64bb54c3eccd05585e10ec6f99a0cdb01a3": "0x56bc75e2d63100000",
  	"0x04ce45f600db18a9d0851b29d9393ebdaafe3dc5": "0x1158e460913d00000",
  	"0x04d6b8d4da867407bb997749debbcdc0b358538a": "0x3635c9adc5dea00000",
  	"0x04d73896cf6593a691972a13a6e4871ff2c42b13": "0x6c6b935b8bbd400000",
  	"0x04d82af9e01a936d97f8f85940b970f9d4db9936": "0xad78ebc5ac6200000",
  	"0x04e5f5bc7c923fd1e31735e72ef968fd67110c6e": "0x57551dbc8e624c0000",
  	"0x04eca501630abce35218b174956b891ba25efb23": "0x36369ed7747d260000",
  	"0x0505a08e22a109015a22f685305354662a5531d5": "0x8cf23f909c0fa00000",
  	"0x0514954c3c2fb657f9a06f510ea22748f027cdd3": "0x15af1d78b58c400000",
  	"0x051633080d07a557adde319261b074997f14692d": "0x13a6b2b564871a00000",
  	"0x0517448dada761cc5ba4033ee881c83037036400": "0x6c4fd1ee246e780000",
  	"0x051d424276b21239665186133d653bb8b1862f89": "0x3635c9adc5dea00000",
  	"0x0521bc3a9f8711fecb10f50797d71083e341eb9d": "0x1158e460913d00000",
  	"0x05236d4c90d065f9e3938358aaffd777b86aec49": "0x1b1ae4d6e2ef500000",
  	"0x052a58e035f1fe9cdd169bcf20970345d12b9c51": "0x50c5e761a444080000",
  	"0x052eab1f61b6d45517283f41d1441824878749d0": "0xd8d726b7177a800000",
  	"0x05336e9a722728d963e7a1cf2759fd0274530fca": "0x31a2443f888a798000",
  	"0x053471cd9a41925b3904a5a8ffca3659e034be23": "0xad201a6794ff80000",
  	"0x05361d8eb6941d4e90fb7e1418a95a32d5257732": "0x1158e460913d00000",
  	"0x05423a54c8d0f9707e704173d923b946edc8e700": "0x6ea03c2bf8ba58000",
  	"0x05440c5b073b529b4829209dff88090e07c4f6f5": "0x45d29737e22f200000",
  	"0x055ab658c6f0ed4f875ed6742e4bc7292d1abbf0": "0x486cb9799191e0000",
  	"0x055bd02caf19d6202bbcdc836d187bd1c01cf261": "0x56bc75e2d63100000",
  	"0x055eac4f1ad3f58f0bd024d68ea60dbe01c6afb3": "0x56bc75e2d63100000",
  	"0x05665155cc49cbf6aabdd5ae92cbfaad82b8c0c1": "0x15af1d78b58c400000",
  	"0x056686078fb6bcf9ba0a8a8dc63a906f5feac0ea": "0x1b181e4bf2343c0000",
  	"0x05696b73916bd3033e05521e3211dfec026e98e4": "0x6c6b935b8bbd400000",
  	"0x056b1546894f9a85e203fb336db569b16c25e04f": "0x92edb09ff08d88000",
  	"0x057949e1ca0570469e4ce3c690ae613a6b01c559": "0xad78ebc5ac6200000",
  	"0x057dd29f2d19aa3da42327ea50bce86ff5c911d9": "0xd8d726b7177a800000",
  	"0x057f7f81cd7a406fc45994408b5049912c566463": "0x5c283d410394100000",
  	"0x05915d4e225a668162aee7d6c25fcfc6ed18db03": "0x398c37279259e0000",
  	"0x0596a27dc3ee115fce2f94b481bc207a9e261525": "0x3635c9adc5dea00000",
  	"0x05a830724302bc0f6ebdaa1ebeeeb46e6ce00b39": "0x556f64c1fe7fa0000",
  	"0x05ae7fd4bbcc80ca11a90a1ec7a301f7cccc83db": "0x3154c9729d05780000",
  	"0x05bb64a916be66f460f5e3b64332110d209e19ae": "0xe3aeb5737240a00000",
  	"0x05bf4fcfe772e45b826443852e6c351350ce72a2": "0x1b1ae4d6e2ef5000000",
  	"0x05c64004a9a826e94e5e4ee267fa2a7632dd4e6f": "0x36dc42ebff90b7f8000",
  	"0x05c736d365aa37b5c0be9c12c8ad5cd903c32cf9": "0x1455e7b800a86880000",
  	"0x05cb6c3b0072d3116761b532b218443b53e8f6c5": "0x1e02c3d7fca9b6280000",
  	"0x05d0f4d728ebe82e84bf597515ad41b60bf28b39": "0xe3aeb5737240a00000",
  	"0x05d68dad61d3bbdfb3f779265c49474aff3fcd30": "0x222c55dc1519d8000",
  	"0x05e671de55afec964b074de574d5158d5d21b0a3": "0xd5967be4fc3f100000",
  	"0x05e97b09492cd68f63b12b892ed1d11d152c0eca": "0x3708baed3d68900000",
  	"0x05f3631f5664bdad5d0132c8388d36d7d8920918": "0x1158e460913d00000",
  	"0x0609d83a6ce1ffc9b690f3e9a81e983e8bdc4d9d": "0xed2b525841adfc00000",
  	"0x061ea4877cd08944eb64c2966e9db8dedcfec06b": "0x3635c9adc5dea00000",
  	"0x0625d06056968b002206ff91980140242bfaa499": "0x3635c9adc5dea00000",
  	"0x0628bfbe5535782fb588406bc96660a49b011af5": "0x52663ccab1e1c00000",
  	"0x0631d18bbbbd30d9e1732bf36edae2ce8901ab80": "0xa3f98855ec39900000",
  	"0x0631dc40d74e5095e3729eddf49544ecd4396f67": "0x8ac7230489e800000",
  	"0x063759dd1c4e362eb19398951ff9f8fad1d31068": "0x21e19e0c9bab2400000",
  	"0x065ff575fd9c16d3cb6fd68ffc8f483fc32ec835": "0xad78ebc5ac6200000",
  	"0x06618e9d5762df62028601a81d4487d6a0ecb80e": "0x487a9a304539440000",
  	"0x066647cfc85d23d37605573d208ca154b244d76c": "0x21e19e0c9bab2400000",
  	"0x0678654ac6761db904a2f7e8595ec1eaac734308": "0x2f98b29c2818f80000",
  	"0x06860a93525955ff624940fadcffb8e149fd599c": "0x6c68ccd09b022c0000",
  	"0x068ce8bd6e902a45cb83b51541b40f39c4469712": "0x11c0f9bad4a46e00000",
  	"0x068e29b3f191c812a6393918f71ab933ae6847f2": "0x6c6acc67d7b1d40000",
  	"0x068e655766b944fb263619658740b850c94afa31": "0x1e87f85809dc00000",
  	"0x06964e2d17e9189f88a8203936b40ac96e533c06": "0xfc936392801c0000",
  	"0x06994cd83aa2640a97b2600b41339d1e0d3ede6c": "0xd8d726b7177a80000",
  	"0x069ed0ab7aa77de571f16106051d92afe195f2d0": "0xad78ebc5ac6200000",
  	"0x06ac26ad92cb859bd5905ddce4266aa0ec50a9c5": "0x2a034919dfbfbc0000",
  	"0x06b0c1e37f5a5ec4bbf50840548f9d3ac0288897": "0xd8d882e1928e7d0000",
  	"0x06b0ff834073cce1cbc9ea557ea87b605963e8b4": "0x1043561a8829300000",
  	"0x06b106649aa8c421ddcd1b8c32cd0418cf30da1f": "0x878678326eac9000000",
  	"0x06b5ede6fdf1d6e9a34721379aeaa17c713dd82a": "0x6c6b935b8bbd400000",
  	"0x06cbfa08cdd4fba737bac407be8224f4eef35828": "0x202be5e8382e8b8000",
  	"0x06d6cb308481c336a6e1a225a912f6e6355940a1": "0x5f68e8131ecf800000",
  	"0x06dc7f18cee7edab5b795337b1df6a9e8bd8ae59": "0x15af1d78b58c400000",
  	"0x06f68de3d739db41121eacf779aada3de8762107": "0x18493fba64ef00000",
  	"0x06f7dc8d1b9462cef6feb13368a7e3974b097f9f": "0x6c6b935b8bbd400000",
  	"0x0701f9f147ec486856f5e1b71de9f117e99e2105": "0x965da717fd5b80000",
  	"0x070d5d364cb7bbf822fc2ca91a35bdd441b215d5": "0x6c6b935b8bbd400000",
  	"0x071dd90d14d41f4ff7c413c24238d3359cd61a07": "0x7b53f79e888dac00000",
  	"0x0726c42e00f45404836eb1e280d073e7059687f5": "0x58003e3fb947a38000",
  	"0x0727be0a2a00212048b5520fbefb953ebc9d54a0": "0x21e19e0c9bab2400000",
  	"0x0729a8a4a5ba23f579d0025b1ad0f8a0d35cdfd2": "0x20dd68aaf3289100000",
  	"0x0729b4b47c09eb16158464c8aa7fd9690b438839": "0x6c68ccd09b022c0000",
  	"0x0734a0a81c9562f4d9e9e10a8503da15db46d76e": "0xfc936392801c0000",
  	"0x073c67e09b5c713c5221c8a0c7f3f74466c347b0": "0x41bad155e6512200000",
  	"0x073f1ed1c9c3e9c52a9b0249a5c1caa0571fdf05": "0x3d0ff0b013b800000",
  	"0x0748713145ef83c3f0ef4d31d823786f7e9cc689": "0xf3f20b8dfa69d00000",
  	"0x075d15e2d33d8b4fa7dba8b9e607f04a261e340b": "0x678a932062e4180000",
  	"0x076561a856455d7ef86e63f87c73dbb628a55f45": "0x30ca024f987b900000",
  	"0x076ee99d3548623a03b5f99859d2d785a1778d48": "0xad78ebc5ac6200000",
  	"0x0770b43dbae4b1f35a927b4fa8124d3866caf97b": "0x37193ea7ef5b470000",
  	"0x0770c61be78772230cb5a3bb2429a72614a0b336": "0x16ee0a299b713418000",
  	"0x07723e3c30e8b731ee456a291ee0e798b0204a77": "0x6c6b935b8bbd400000",
  	"0x0773eeacc050f74720b4a1bd57895b1cceeb495d": "0x21e19e0c9bab2400000",
  	"0x07800d2f8068e448c79a4f69b1f15ef682aae5f6": "0x41bad155e6512200000",
  	"0x07a8dadec142571a7d53a4297051786d072cba55": "0x13b6da1139bda8000",
  	"0x07af938c1237a27c9030094dcf240750246e3d2c": "0x1b1ae4d6e2ef500000",
  	"0x07b1a306cb4312df66482c2cae72d1e061400fcd": "0x43c33c1937564800000",
  	"0x07b7a57033f8f11330e4665e185d234e83ec140b": "0xea7ee92a0c9a0b8000",
  	"0x07bc2cc8eedc01970700efc9c4fb36735e98cd71": "0xd8d726b7177a800000",
  	"0x07d41217badca5e0e60327d845a3464f0f27f84a": "0xd8d726b7177a800000",
  	"0x07d4334ec385e8aa54eedaeadb30022f0cdfa4ab": "0x8e91d520f2eb790000",
  	"0x07dae622630d1136381933d2ad6b22b839d82102": "0xad78ebc5ac6200000",
  	"0x07dc2bf83bc6af19a842ffea661af5b41b67fda1": "0x5150ae84a8cdf00000",
  	"0x07dc8c8b927adbedfa8f5d639b4352351f2f36d2": "0x110aed3b5530db0000",
  	"0x07ddd0422c86ef65bf0c7fc3452862b1228b08b8": "0x6ff5d2aa8f9fcf0000",
  	"0x07e1162ceae3cf21a3f62d105990302e307f4e3b": "0x52f103edb66ba80000",
  	"0x07e2b4cdeed9d087b12e556d9e770c13c099615f": "0x243d4d18229ca20000",
  	"0x07feef54c136850829badc4b49c3f2a73c89fb9e": "0x6685ac1bfe32c0000",
  	"0x080546508a3d2682c8b9884f13637b8847b44db3": "0x6c6b935b8bbd400000",
  	"0x08090876baadfee65c3d363ba55312748cfa873d": "0x5c2a99371cffe10000",
  	"0x08166f02313feae18bb044e7877c808b55b5bf58": "0x6acb3df27e1f880000",
  	"0x0829d0f7bb7c446cfbb0deadb2394d9db7249a87": "0x22ca3587cf4eb0000",
  	"0x08306de51981e7aca1856859b7c778696a6b69f9": "0xad78ebc5ac62000000",
  	"0x0837539b5f6a522a482cdcd3a9bb7043af39bdd2": "0x14542ba12a337c00000",
  	"0x0838a7768d9c2aca8ba279adfee4b1f491e326f1": "0xad78ebc5ac6200000",
  	"0x08411652c871713609af0062a8a1281bf1bbcfd9": "0x4be4e7267b6ae00000",
  	"0x084d103254759b343cb2b9c2d8ff9e1ac5f14596": "0x19bff2ff57968c00000",
  	"0x08504f05643fab5919f5eea55925d7a3ed7d807a": "0x1158e460913d00000",
  	"0x085b4ab75d8362d914435cedee1daa2b1ee1a23b": "0xd255d112e103a00000",
  	"0x085ba65febe23eefc2c802666ab1262382cfc494": "0x15af1d78b58c400000",
  	"0x087498c0464668f31150f4d3c4bcdda5221ba102": "0x1158e460913d00000",
  	"0x0877eeaeab78d5c00e83c32b2d98fa79ad51482f": "0x17d22d71da62260000",
  	"0x08936a37df85b3a158cafd9de021f58137681347": "0xfc936392801c0000",
  	"0x08a9a44e1f41de3dbba7a363a3ab412c124cd15e": "0xad78ebc5ac6200000",
  	"0x08b7bdcf944d5570838be70460243a8694485858": "0x6c6b935b8bbd400000",
  	"0x08b84536b74c8c01543da88b84d78bb95747d822": "0xad78ebc5ac6200000",
  	"0x08c2f236ac4adcd3fda9fbc6e4532253f9da3bec": "0x1158e460913d00000",
  	"0x08c802f87758349fa03e6bc2e2fd0791197eea9a": "0x6c6b935b8bbd400000",
  	"0x08c9f1bfb689fdf804d769f82123360215aff93b": "0x6acb3df27e1f880000",
  	"0x08cac8952641d8fc526ec1ab4f2df826a5e7710f": "0x1043561a8829300000",
  	"0x08ccda50e4b26a0ffc0ef92e9205310706bec2c7": "0x149756c3857c6000000",
  	"0x08d0864dc32f9acb36bf4ea447e8dd6726906a15": "0x6c6e59e67c78540000",
  	"0x08d4267feb15da9700f7ccc3c84a8918bf17cfde": "0x61093d7c2c6d380000",
  	"0x08d4311c9c1bbaf87fabe1a1d01463828d5d98ce": "0x130ee8e7179044400000",
  	"0x08d54e83ad486a934cfaeae283a33efd227c0e99": "0x38530583245edc0000",
  	"0x08d97eadfcb7b064e1ccd9c8979fbee5e77a9719": "0xe6c5da8d67ac18000",
  	"0x08da3a7a0f452161cfbcec311bb68ebfdee17e88": "0x6c6b935b8bbd400000",
  	"0x08e38ee0ce48c9ca645c1019f73b5355581c56e6": "0x56bc75e2d631000000",
  	"0x08ef3fa4c43ccdc57b22a4b9b2331a82e53818f2": "0xd8d726b7177a800000",
  	"0x0909648c18a3ce5bae7a047ec2f868d24cdda81d": "0xcf152640c5c8300000",
  	"0x090cd67b60e81d54e7b5f6078f3e021ba65b9a1e": "0x3635c9adc5dea00000",
  	"0x090cebef292c3eb081a05fd8aaf7d39bf07b89d4": "0xd8d726b7177a800000",
  	"0x090fa9367bda57d0d3253a0a8ff76ce0b8e19a73": "0x3635c9adc5dea00000",
  	"0x09146ea3885176f07782e1fe30dce3ce24c49e1f": "0x1158e460913d00000",
  	"0x0921605f99164e3bcc28f31caece78973182561d": "0x2b07692a9065a80000",
  	"0x09261f9acb451c3788844f0c1451a35bad5098e3": "0x1d5ad27502920600000",
  	"0x0927220492194b2eda9fc4bbe38f25d681dfd36c": "0x14542ba12a337c00000",
  	"0x092acb624b08c05510189bbbe21e6524d644ccad": "0xfc936392801c0000",
  	"0x092e815558402d67f90d6bfe6da0b2fffa91455a": "0x340aad21b3b700000",
  	"0x095030e4b82692dcf8b8d0912494b9b378ec9328": "0x48a43c54602f700000",
  	"0x095270cc42141dd998ad2862dbd1fe9b44e7e650": "0x410d586a20a4c00000",
  	"0x095457f8ef8e2bdc362196b9a9125da09c67e3ab": "0xad78ebc5ac6200000",
  	"0x0954a8cb5d321fc3351a7523a617d0f58da676a7": "0x87d9bc7aa498e80000",
  	"0x095b0ea2b218d82e0aea7c2889238a39c9bf9077": "0x43c33c1937564800000",
  	"0x095b949de3333a377d5019d893754a5e4656ff97": "0x126e72a69a50d00000",
  	"0x095e0174829f34c3781be1a5e38d1541ea439b7f": "0x14542ba12a337c00000",
  	"0x095f5a51d06f6340d80b6d29ea2e88118ad730fe": "0x6c6e59e67c78540000",
  	"0x0968ee5a378f8cadb3bafdbed1d19aaacf936711": "0x3635c9adc5dea00000",
  	"0x0977bfba038a44fb49b03970d8d8cf2cb61f8b25": "0x16c4abbebea0100000",
  	"0x097da12cfc1f7c1a2464def08c29bed5e2f851e9": "0x1158e460913d00000",
  	"0x097ecda22567c2d91cb03f8c5215c22e9dcda949": "0x11651ac3e7a758000",
  	"0x0989c200440b878991b69d6095dfe69e33a22e70": "0x678a932062e4180000",
  	"0x0990e81cd785599ea236bd1966cf526302c35b9c": "0x3635c9adc5dea00000",
  	"0x0998d8273115b56af43c505e087aff0676ed3659": "0xd8d6eddf2d2e180000",
  	"0x09a025316f967fa8b9a1d60700063f5a68001caa": "0x21221a99b93ec0000",
  	"0x09a928d528ec1b3e25ffc83e218c1e0afe8928c7": "0xfc936392801c0000",
  	"0x09ae49e37f121df5dc158cfde806f173a06b0c7f": "0xd8309e26aba1d00000",
  	"0x09afa73bc047ef46b977fd9763f87286a6be68c6": "0x1b2fb5e8f06a660000",
  	"0x09b4668696f86a080f8bebb91db8e6f87015915a": "0x238ff7b34f60010000",
  	"0x09b59b8698a7fbd3d2f8c73a008988de3e406b2b": "0x878678326eac9000000",
  	"0x09b7a988d13ff89186736f03fdf46175b53d16e0": "0x14542ba12a337c00000",
  	"0x09c177f1ae442411ddacf187d46db956148360e7": "0x1e52e336cde22180000",
  	"0x09c88f917e4d6ad473fa12e98ea3c4472a5ed6da": "0x21e19e0c9bab2400000",
  	"0x09d0b8cd077c69d9f32d9cca43b3c208a21ed48b": "0x821d221b5291f8000",
  	"0x09d6cefd75b0c4b3f8f1d687a522c96123f1f539": "0x14542ba12a337c00000",
  	"0x09e437d448861228a232b62ee8d37965a904ed9c": "0x498cf401df8842e8000",
  	"0x09ee12b1b42b05af9cf207d5fcac255b2ec411f2": "0x331cddd47e0fe8000",
  	"0x09f3f601f605441140586ce0656fa24aa5b1d9ae": "0x5373776fe8c4540000",
  	"0x09f9575be57d004793c7a4eb84b71587f97cbb6a": "0xad78ebc5ac6200000",
  	"0x0a0650861f785ed8e4bf1005c450bbd06eb48fb6": "0xa6413b79144e7e0000",
  	"0x0a06fad7dcd7a492cbc053eeabde6934b39d8637": "0x1158e460913d00000",
  	"0x0a077db13ffeb09484c217709d5886b8bf9c5a8b": "0xd8d726b7177a800000",
  	"0x0a0ecda6636f7716ef1973614687fd89a820a706": "0x155bd9307f9fe80000",
  	"0x0a29a8a4d5fd950075ffb34d77afeb2d823bd689": "0xad78ebc5ac6200000",
  	"0x0a2ade95b2e8c66d8ae6f0ba64ca57d783be6d44": "0xd8d726b7177a800000",
  	"0x0a2b4fc5d81ace67dc4bba03f7b455413d46fe3d": "0xaadec983fcff40000",
  	"0x0a2dcb7a671701dbb8f495728088265873356c8e": "0x83f16ce08a06c0000",
  	"0x0a3de155d5ecd8e81c1ff9bbf0378301f8d4c623": "0xd8d726b7177a800000",
  	"0x0a47ad9059a249fc936b2662353da6905f75c2b9": "0x6c6b935b8bbd400000",
  	"0x0a48296f7631708c95d2b74975bc4ab88ac1392a": "0x10f0cf064dd59200000",
  	"0x0a4a011995c681bc999fdd79754e9a324ae3b379": "0x8c19ab06eb89af60000",
  	"0x0a58fddd71898de773a74fdae45e7bd84ef43646": "0x1158e460913d00000",
  	"0x0a5b79d8f23b6483dbe2bdaa62b1064cc76366ae": "0x6ac882100952c78000",
  	"0x0a652e2a8b77bd97a790d0e91361c98890dbb04e": "0x3635c9adc5dea00000",
  	"0x0a6ebe723b6ed1f9a86a69ddda68dc47465c2b1b": "0x403d2db599d5e40000",
  	"0x0a77e7f72b437b574f00128b21f2ac265133528c": "0x6c6b935b8bbd400000",
  	"0x0a917f3b5cb0b883047fd9b6593dbcd557f453b9": "0x3635c9adc5dea00000",
  	"0x0a931b449ea8f12cdbd5e2c8cc76bad2c27c0639": "0x13f9e8c79fe058000",
  	"0x0a9804137803ba6868d93a55f9985fcd540451e4": "0xb98bc829a6f90000",
  	"0x0a9ab2638b1cfd654d25dab018a0aebddf85fd55": "0x12e8cb5fe4c4a8000",
  	"0x0ab366e6e7d5abbce6b44a438d69a1cabb90d133": "0x1158e460913d000000",
  	"0x0ab4281ebb318590abb89a81df07fa3af904258a": "0x1b1ae4d6e2ef500000",
  	"0x0ab59d390702c9c059db148eb4f3fcfa7d04c7e7": "0xfc936392801c0000",
  	"0x0abfb39b11486d79572866195ba26c630b6784db": "0x19ba8737f96928f00000",
  	"0x0aca9a5626913b08cfc9a66d40508dce52b60f87": "0x678a932062e4180000",
  	"0x0ad3e44d3c001fa290b393617030544108ac6eb9": "0x6abda0bc30b2df8000",
  	"0x0aec2e426ed6cc0cf3c249c1897eac47a7faa9bd": "0xad78ebc5ac6200000",
  	"0x0af65f14784e55a6f95667fd73252a1c94072d2a": "0xa763b8e02d44f8000",
  	"0x0af6c8d539c96d50259e1ba6719e9c8060f388c2": "0x3635c9adc5dea00000",
  	"0x0b06390f2437b20ec4a3d3431b3279c6583e5ed7": "0xa844a7424d9c80000",
  	"0x0b0b3862112aeec3a03492b1b05f440eca54256e": "0xd8d726b7177a800000",
  	"0x0b0e055b28cbd03dc5ff44aa64f3dce04f5e63fb": "0x6c6b935b8bbd400000",
  	"0x0b119df99c6b8de58a1e2c3f297a6744bf552277": "0x6c6b935b8bbd400000",
  	"0x0b14891999a65c9ef73308efe3100ca1b20e8192": "0x2b5e3af16b18800000",
  	"0x0b2113504534642a1daf102eee10b9ebde76e261": "0x942cdd7c95f2bd8000",
  	"0x0b288a5a8b75f3dc4191eb0457e1c83dbd204d25": "0x10714e77bb43ab40000",
  	"0x0b369e002e1b4c7913fcf00f2d5e19c58165478f": "0x37f6516288c340000",
  	"0x0b43bd2391025581d8956ce42a072579cbbfcb14": "0x104e70464b1580000",
  	"0x0b507cf553568daaf65504ae4eaa17a8ea3cdbf5": "0x6c6b935b8bbd400000",
  	"0x0b5d66b13c87b392e94d91d5f76c0d450a552843": "0x6c6b935b8bbd400000",
  	"0x0b5e2011ebc25a007f21362960498afb8af280fb": "0x6c6b935b8bbd400000",
  	"0x0b649da3b96a102cdc6db652a0c07d65b1e443e6": "0x6c6b935b8bbd400000",
  	"0x0b6920a64b363b8d5d90802494cf564b547c430d": "0x410d586a20a4c00000",
  	"0x0b701101a4109f9cb360dc57b77442673d5e5983": "0x6c6b935b8bbd400000",
  	"0x0b71f554122469ef978e2f1fefd7cbb410982772": "0xd255d112e103a00000",
  	"0x0b7bb342f01bc9888e6a9af4a887cbf4c2dd2caf": "0x3635c9adc5dea000000",
  	"0x0b7d339371e5be6727e6e331b5821fa24bdb9d5a": "0x2e7f81868262010000",
  	"0x0b7fc9ddf70576f6330669eaaa71b6a831e99528": "0x796e3ea3f8ab00000",
  	"0x0b80fc70282cbdd5fde35bf78984db3bdb120188": "0x3638021cecdab00000",
  	"0x0b924df007e9c0878417cfe63b976ea1a382a897": "0x22b1c8c1227a00000",
  	"0x0b93fca4a4f09cac20db60e065edcccc11e0a5b6": "0xad78ebc5ac6200000",
  	"0x0b9df80fbe232009dacf0aa8cac59376e2476203": "0x6c6b935b8bbd400000",
  	"0x0ba6e46af25a13f57169255a34a4dac7ce12be04": "0x1b1ae4d6e2ef500000",
  	"0x0ba8705bf55cf219c0956b5e3fc01c4474a6cdc1": "0x525e0595d4d6b8000",
  	"0x0baf6ecdb91acb3606a8357c0bc4f45cfd2d7e6f": "0x3635c9adc5dea00000",
  	"0x0bb05f7224bb5804856556c07eeadbed87ba8f7c": "0x15be6174e1912e0000",
  	"0x0bb0c12682a2f15c9b5741b2385cbe41f034068e": "0x5150ae84a8cdf00000",
  	"0x0bb25ca7d188e71e4d693d7b170717d6f8f0a70a": "0x124302a82fadd70000",
  	"0x0bb2650ea01aca755bc0c017b64b1ab5a66d82e3": "0x487a9a304539440000",
  	"0x0bb54c72fd6610bfa4363397e020384b022b0c49": "0x487a9a304539440000",
  	"0x0bb7160aba293762f8734f3e0326ffc9a4cac190": "0x3635c9adc5dea00000",
  	"0x0bc95cb32dbb574c832fa8174a81356d38bc92ac": "0x6c6b935b8bbd400000",
  	"0x0bd67dbde07a856ebd893b5edc4f3a5be4202616": "0x6c6b935b8bbd400000",
  	"0x0bdbc54cc8bdbbb402a08911e2232a5460ce866b": "0xa2a15d09519be00000",
  	"0x0bdd58b96e7c916dd2fb30356f2aebfaaf1d8630": "0x6c6b935b8bbd400000",
  	"0x0be1bcb90343fae5303173f461bd914a4839056c": "0x14542ba12a337c00000",
  	"0x0be1fdf626ee6189102d70d13b31012c95cd1cd6": "0x6c6b935b8bbd400000",
  	"0x0be2b94ad950a2a62640c35bfccd6c67dae450f6": "0x692ae8897081d00000",
  	"0x0be6a09e4307fe48d412b8d1a1a8284dce486261": "0x40fbff85c0138300000",
  	"0x0befb54707f61b2c9fb04715ab026e1bb72042bd": "0xd8d726b7177a800000",
  	"0x0bf064428f83626722a7b5b26a9ab20421a7723e": "0x73f75d1a085ba0000",
  	"0x0bfbb6925dc75e52cf2684224bbe0550fea685d3": "0x6acb3df27e1f880000",
  	"0x0c088006c64b30c4ddafbc36cb5f05469eb62834": "0x6c6b935b8bbd400000",
  	"0x0c2073ba44d3ddbdb639c04e191039a71716237f": "0x4d853c8f8908980000",
  	"0x0c222c7c41c9b048efcce0a232434362e12d673b": "0x21e8359697677380000",
  	"0x0c2808b951ed9e872d7b32790fcc5994ae41ffdc": "0x15996e5b3cd6b3c00000",
  	"0x0c28847e4f09dfce5f9b25af7c4e530f59c880fe": "0x3635c9adc5dea00000",
  	"0x0c2d5c920538e953caaf24f0737f554cc6927742": "0x3635c9adc5dea00000",
  	"0x0c30cacc3f72269f8b4f04cf073d2b05a83d9ad1": "0x6c7974123f64a40000",
  	"0x0c3239e2e841242db989a61518c22247e8c55208": "0xe4af6471734640000",
  	"0x0c480de9f7461002908b49f60fc61e2b62d3140b": "0x21e19e0c9bab2400000",
  	"0x0c48ae62d1539788eba013d75ea60b64eeba4e80": "0x77fbdc43e030998000",
  	"0x0c5589a7a89b9ad15b02751930415948a875fbef": "0x6d499ec6c63380000",
  	"0x0c67033dd8ee7f0c8ae534d42a51f7d9d4f7978f": "0xad78ebc5ac6200000",
  	"0x0c6845bf41d5ee273c3ee6b5b0d69f6fd5eabbf7": "0xa2a1b9682e58090000",
  	"0x0c7f869f8e90d53fdc03e8b2819b016b9d18eb26": "0x43c33c1937564800000",
  	"0x0c8692eeff2a53d6d1688ed56a9ddbbd68dabba1": "0x6c6b935b8bbd400000",
  	"0x0c8f66c6017bce5b20347204b602b743bad78d60": "0x6c6b935b8bbd400000",
  	"0x0c8fd7775e54a6d9c9a3bf890e761f6577693ff0": "0x215f835bc769da80000",
  	"0x0c925ad5eb352c8ef76d0c222d115b0791b962a1": "0xac635d7fa34e300000",
  	"0x0c967e3061b87a753e84507eb60986782c8f3013": "0x56bc75e2d63100000",
  	"0x0ca12ab0b9666cf0cec6671a15292f2653476ab2": "0x2c7827c42d22d07c0000",
  	"0x0ca670eb2c8b96cba379217f5929c2b892f39ef6": "0x6c6b935b8bbd400000",
  	"0x0cae108e6db99b9e637876b064c6303eda8a65c8": "0xa2a15d09519be00000",
  	"0x0cbd921dbe121563b98a6871fecb14f1cc7e88d7": "0xad78ebc5ac6200000",
  	"0x0cbf8770f0d1082e5c20c5aead34e5fca9ae7ae2": "0x3635c9adc5dea00000",
  	"0x0cc67f8273e1bae0867fd42e8b8193d72679dbf8": "0x1b1ae4d6e2ef500000",
  	"0x0cd6a141918d126b106d9f2ebf69e102de4d3277": "0x1158e460913d00000",
  	"0x0cda12bf72d461bbc479eb92e6491d057e6b5ad1": "0x21e19e0c9bab2400000",
  	"0x0cdc960b998c141998160dc179b36c15d28470ed": "0x1b1b6bd7af64c70000",
  	"0x0cfb172335b16c87d519cd1475530d20577f5e0e": "0x152d02c7e14af6800000",
  	"0x0d1f2a57713ebc6e94de29846e8844d376665763": "0x10f0cf064dd59200000",
  	"0x0d3265d3e7bdb93d5e8e8b1ca47f210a793ecc8e": "0xad78ebc5ac6200000",
  	"0x0d35408f226566116fb8acdaa9e2c9d59b76683f": "0x32f51edbaaa3300000",
  	"0x0d551ec1a2133c981d5fc6a8c8173f9e7c4f47af": "0x6c6b935b8bbd400000",
  	"0x0d5d98565c647ca5f177a2adb9d3022fac287f21": "0xad78ebc5ac6200000",
  	"0x0d658014a199061cf6b39433140303c20ffd4e5a": "0x1bc85dc2a89bb200000",
  	"0x0d678706d037187f3e22e6f69b99a592d11ebc59": "0x55a6e79ccd1d300000",
  	"0x0d69100c395ce6c5eaadf95d05d872837ededd21": "0x15af1d78b58c400000",
  	"0x0d747ee5969bf79d57381d6fe3a2406cd0d8ce27": "0x152d02c7e14af6800000",
  	"0x0d8023929d917234ae40512b1aabb5e8a4512771": "0x805e99fdcc5d00000",
  	"0x0d8aab8f74ea862cdf766805009d3f3e42d8d00b": "0x13b80b99c5185700000",
  	"0x0d8c40a79e18994ff99ec251ee10d088c3912e80": "0x63664fcd2bbc40000",
  	"0x0d8ed7d0d15638330ed7e4eaccab8a458d75737e": "0x6c6b935b8bbd400000",
  	"0x0d92582fdba05eabc3e51538c56db8813785b328": "0xa5aa85009e39c0000",
  	"0x0d9443a79468a5bbf7c13c6e225d1de91aee07df": "0x3cb71f51fc5580000",
  	"0x0d9a825ff2bcd397cbad5b711d9dcc95f1cc112d": "0x2b5e3af16b188000000",
  	"0x0d9d3f9bc4a4c6efbd59679b69826bc1f63d9916": "0x2086ac351052600000",
  	"0x0da532c910e3ac0dfb14db61cd739a93353fd05f": "0x4878be1ffaf95d0000",
  	"0x0da7401262384e2e8b4b26dd154799b55145efa0": "0x1043561a8829300000",
  	"0x0dae3ee5b915b36487f9161f19846d101433318a": "0x678a932062e4180000",
  	"0x0dbd417c372b8b0d01bcd944706bd32e60ae28d1": "0x126e72a69a50d00000",
  	"0x0dc100b107011c7fc0a1339612a16ccec3285208": "0x6c6b935b8bbd400000",
  	"0x0dcf9d8c9804459f647c14138ed50fad563b4154": "0x960db77681e940000",
  	"0x0dcfe837ea1cf28c65fccec3bef1f84e59d150c0": "0xad78ebc5ac6200000",
  	"0x0dd4e674bbadb1b0dc824498713dce3b5156da29": "0x93739534d28680000",
  	"0x0dfbd4817050d91d9d625c02053cf61a3ee28572": "0x126e72a69a50d00000",
  	"0x0e024e7f029c6aaf3a8b910f5e080873b85795aa": "0x3635c9adc5dea00000",
  	"0x0e09646c99af438e99fa274cb2f9c856cb65f736": "0x678a932062e4180000",
  	"0x0e0c9d005ea016c295cd795cc9213e87febc33eb": "0xabbcd4ef377580000",
  	"0x0e0d6633db1e0c7f234a6df163a10e0ab39c200f": "0xad78ebc5ac6200000",
  	"0x0e11d77a8977fac30d268445e531149b31541a24": "0x6c6b935b8bbd400000",
  	"0x0e123d7da6d1e6fac2dcadd27029240bb39052fe": "0x3635c9adc5dea00000",
  	"0x0e1801e70b6262861b1134ccbc391f568afc92f7": "0xd8d726b7177a800000",
  	"0x0e2094ac1654a46ba1c4d3a40bb8c17da7f39688": "0x13683f7f3c15d80000",
  	"0x0e21af1b8dbf27fcf63f37e047b87a825cbe7c27": "0xa2a15d09519be00000",
  	"0x0e2e504a2d1122b5a9feee5cb1451bf4c2ace87b": "0xd5967be4fc3f100000",
  	"0x0e2f8e28a681f77c583bd0ecde16634bdd7e00cd": "0x52738f659bca20000",
  	"0x0e320219838e859b2f9f18b72e3d4073ca50b37d": "0x6c6b935b8bbd400000",
  	"0x0e33fcbbc003510be35785b52a9c5d216bc005f4": "0x65ea3db75546600000",
  	"0x0e3696cf1f4217b163d1bc12a5ea730f1c32a14a": "0xd8d726b7177a800000",
  	"0x0e390f44053ddfcef0d608b35e4d9c2cbe9871bb": "0x6acb3df27e1f880000",
  	"0x0e3a28c1dfafb0505bdce19fe025f506a6d01ceb": "0x6c6b935b8bbd400000",
  	"0x0e3dd7d4e429fe3930a6414035f52bdc599d784d": "0x22ca3587cf4eb0000",
  	"0x0e4765790352656bc656682c24fc5ef3e76a23c7": "0x286d7fc0cb4f50000",
  	"0x0e498800447177b8c8afc3fdfa7f69f4051bb629": "0x7405b69b8de5610000",
  	"0x0e6baaa3deb989f289620076668618e9ac332865": "0xad78ebc5ac6200000",
  	"0x0e6cd664ad9c1ed64bf98749f40644b626e3792c": "0xcb49b44ba602d800000",
  	"0x0e6dfd553b2e873d2aec15bd5fbb3f8472d8d394": "0x28a857425466f800000",
  	"0x0e6ec313376271dff55423ab5422cc3a8b06b22b": "0xd8d726b7177a800000",
  	"0x0e6ece99111cad1961c748ed3df51edd69d2a3b1": "0x152d02c7e14af6800000",
  	"0x0e83b850481ab44d49e0a229a2e464902c69539b": "0x56bc75e2d63100000",
  	"0x0e89eddd3fa0d71d8ab0ff8da5580686e3d4f74f": "0x6c6b935b8bbd400000",
  	"0x0e9096d343c060db581a120112b278607ec6e52b": "0x1158e460913d00000",
  	"0x0e9c511864a177f49be78202773f60489fe04e52": "0x14542ba12a337c00000",
  	"0x0ea2a210312b3e867ee0d1cc682ce1d666f18ed5": "0x21e19e0c9bab2400000",
  	"0x0eb189ef2c2d5762a963d6b7bdf9698ea8e7b48a": "0x487a9a304539440000",
  	"0x0eb5b662a1c718608fd52f0c25f9378830178519": "0x14a37281a612e740000",
  	"0x0ec46696ffac1f58005fa8439824f08eed1df89b": "0x21e19e0c9bab2400000",
  	"0x0ec50aa823f465b9464b0bc0c4a57724a555f5d6": "0xc83d1426ac7b1f00000",
  	"0x0ec5308b31282e218fc9e759d4fec5db3708cec4": "0x3643aa647986040000",
  	"0x0eccf617844fd61fba62cb0e445b7ac68bcc1fbe": "0x14fe4fe63565c60000",
  	"0x0ed3bb3a4eb554cfca97947d575507cdfd6d21d8": "0x1db3205fcc23d58000",
  	"0x0ed76c2c3b5d50ff8fb50b3eeacd681590be1c2d": "0x56bc75e2d63100000",
  	"0x0eda80f4ed074aea697aeddf283b63dbca3dc4da": "0x6c6b935b8bbd400000",
  	"0x0edd4b580ff10fe06c4a03116239ef96622bae35": "0xaadec983fcff40000",
  	"0x0ee391f03c765b11d69026fd1ab35395dc3802a0": "0xad78ebc5ac6200000",
  	"0x0ee414940487fd24e390378285c5d7b9334d8b65": "0x914878a8c05ee00000",
  	"0x0ef54ac7264d2254abbb5f8b41adde875157db7c": "0x22b1c8c1227a00000",
  	"0x0ef85b49d08a75198692914eddb4b22cf5fa4450": "0x6cae30621d47200000",
  	"0x0efd1789eb1244a3dede0f5de582d8963cb1f39f": "0x5150ae84a8cdf00000",
  	"0x0f042c9c2fb18766f836bb59f735f27dc329fe3c": "0x21e19e0c9bab2400000",
  	"0x0f049a8bdfd761de8ec02cee2829c4005b23c06b": "0xda933d8d8c6700000",
  	"0x0f05f120c89e9fbc93d4ab0c5e2b4a0df092b424": "0x65a4da25d3016c00000",
  	"0x0f127bbf8e311caea2ba502a33feced3f730ba42": "0xa31062beeed700000",
  	"0x0f1c249cd962b00fd114a9349f6a6cc778d76c4d": "0x6c6b935b8bbd400000",
  	"0x0f206e1a1da7207ea518b112418baa8b06260328": "0x2086ac351052600000",
  	"0x0f24105abbdaa03fa6309ef6c188e51f714a6e59": "0xad78ebc5ac6200000",
  	"0x0f26480a150961b8e30750713a94ee6f2e47fc00": "0x3635c9adc5dea00000",
  	"0x0f2d8daf04b5414a0261f549ff6477b80f2f1d07": "0x2a5a058fc295ed000000",
  	"0x0f2fb884c8aaff6f543ac6228bd08e4f60b0a5fd": "0xaa7da485136b840000",
  	"0x0f32d9cb4d0fdaa0150656bb608dcc43ed7d9301": "0x28df8bf440db790000",
  	"0x0f3665d48e9f1419cd984fc7fa92788710c8f2e4": "0x6c6b935b8bbd400000",
  	"0x0f3a1023cac04dbf44f5a5fa6a9cf8508cd4fddf": "0x62a992e53a0af00000",
  	"0x0f4073c1b99df60a1549d69789c7318d9403a814": "0x43c33c1937564800000",
  	"0x0f46c81db780c1674ac73d314f06539ee56ebc83": "0x215f835bc769da80000",
  	"0x0f4f94b9191bb7bb556aaad7c74ddb288417a50b": "0x4be4e7267b6ae00000",
  	"0x0f6000de1578619320aba5e392706b131fb1de6f": "0x1b1ab319f5ec750000",
  	"0x0f6e840a3f2a24647d8e43e09d45c7c335df4248": "0x878678326eac900000",
  	"0x0f7515ff0e808f695e0c20485ff96ed2f7b79310": "0x3638221660a5aa8000",
  	"0x0f789e30397c53bf256fc364e6ef39f853504114": "0xc55325ca7415e00000",
  	"0x0f7b61c59b016322e8226cafaee9d9e76d50a1b3": "0xd8d726b7177a800000",
  	"0x0f7bea4ef3f73ae0233df1e100718cbe29310bb0": "0x6c6b935b8bbd400000",
  	"0x0f7bf6373f771a4601762c4dae5fbbf4fedd9cc9": "0x6c6b935b8bbd400000",
  	"0x0f832a93df9d7f74cd0fb8546b7198bf5377d925": "0x7c0860e5a80dc0000",
  	"0x0f83461ba224bb1e8fdd9dae535172b735acb4e0": "0xad78ebc5ac6200000",
  	"0x0f85e42b1df321a4b3e835b50c00b06173968436": "0x35659ef93f0fc40000",
  	"0x0f88aac9346cb0e7347fba70905475ba8b3e5ece": "0x21e19e0c9bab2400000",
  	"0x0f929cf895db017af79f3ead2216b1bd69c37dc7": "0x6c6b935b8bbd400000",
  	"0x0fa010ce0c731d3b628e36b91f571300e49dbeab": "0x36330322d5238c0000",
  	"0x0fa5d8c5b3f294efd495ab69d768f81872508548": "0x6c6b935b8bbd400000",
  	"0x0fa6c7b0973d0bae2940540e247d3627e37ca347": "0x3635c9adc5dea00000",
  	"0x0fad05507cdc8f24b2be4cb7fa5d927ddb911b88": "0xa2df13f441f0098000",
  	"0x0fb5d2c673bfb1ddca141b9894fd6d3f05da6720": "0x56bc75e2d63100000",
  	"0x0fc9a0e34145fbfdd2c9d2a499b617d7a02969b9": "0x9c2007651b2500000",
  	"0x0fcfc4065008cfd323305f6286b57a4dd7eee23b": "0x43c33c1937564800000",
  	"0x0fdd65402395df9bd19fee4507ef5345f745104c": "0x10f0cf064dd59200000",
  	"0x0fec4ee0d7ca180290b6bd20f9992342f60ff68d": "0x12207f0edce9718000",
  	"0x0fee81ac331efd8f81161c57382bb4507bb9ebec": "0x15af880d8cdb830000",
  	"0x0ffea06d7113fb6aec2869f4a9dfb09007facef4": "0xc384681b1e1740000",
  	"0x10097198b4e7ee91ff82cc2f3bd95fed73c540c0": "0x6c6b935b8bbd400000",
  	"0x100b4d0977fcbad4debd5e64a0497aeae5168fab": "0x110c9073b5245a0000",
  	"0x101a0a64f9afcc448a8a130d4dfcbee89537d854": "0x337fe5feaf2d1800000",
  	"0x102c477d69aadba9a0b0f62b7459e17fbb1c1561": "0x6c6b935b8bbd400000",
  	"0x1031e0ecb54985ae21af1793950dc811888fde7c": "0x1158e460913d00000",
  	"0x10346414bec6d3dcc44e50e54d54c2b8c3734e3e": "0xd8d726b7177a800000",
  	"0x10389858b800e8c0ec32f51ed61a355946cc409b": "0xad78ebc5ac6200000",
  	"0x1059cbc63e36c43e88f30008aca7ce058eeaa096": "0x152d02c7e14af6800000",
  	"0x106ed5c719b5261477890425ae7551dc59bd255c": "0x2896a58c95be5880000",
  	"0x10711c3dda32317885f0a2fd8ae92e82069b0d0b": "0xd8d726b7177a800000",
  	"0x107379d4c467464f235bc18e55938aad3e688ad7": "0x2b5e3af16b1880000",
  	"0x1076212d4f758c8ec7121c1c7d74254926459284": "0x7695b59b5c17b4c0000",
  	"0x1078d7f61b0e56c74ee6635b2e1819ef1e3d8785": "0x3635c9adc5dea00000",
  	"0x107a03cf0842dbdeb0618fb587ca69189ec92ff5": "0x6acb3df27e1f880000",
  	"0x1080c1d8358a15bc84dac8253c6883319020df2c": "0x90f534608a72880000",
  	"0x108a2b7c336f784779d8b54d02a8d31d9a139c0a": "0x21e19e0c9bab2400000",
  	"0x108ba7c2895c50e072dc6f964932d50c282d3034": "0x1b1ae4d6e2ef500000",
  	"0x108fe8ee2a13da487b22c6ab6d582ea71064d98c": "0x15ac56edc4d12c0000",
  	"0x1091176be19b9964a8f72e0ece6bf8e3cfad6e9c": "0x21f2f6f0fc3c6100000",
  	"0x1098c774c20ca1daac5ddb620365316d353f109c": "0x56bc75e2d63100000",
  	"0x1098cc20ef84bad5146639c4cd1ca6c3996cb99b": "0xfc936392801c0000",
  	"0x10a1c42dc1ba746986b985a522a73c93eae64c63": "0x3635c9adc5dea00000",
  	"0x10a93457496f1108cd98e140a1ecdbae5e6de171": "0x15a99062d416180000",
  	"0x10b5b34d1248fcf017f8c8ffc408ce899ceef92f": "0xe7eeba3410b740000",
  	"0x10cf560964ff83c1c9674c783c0f73fcd89943fc": "0x878678326eac9000000",
  	"0x10d32416722ca4e648630548ead91edd79c06aff": "0x56bc75e2d63100000",
  	"0x10d945334ecde47beb9ca3816c173dfbbd0b5333": "0x4be4e7267b6ae00000",
  	"0x10df681506e34930ac7a5c67a54c3e89ce92b981": "0x74c1fab8adb4540000",
  	"0x10e1e3377885c42d7df218522ee7766887c05e6a": "0x1043c43cde1d398000",
  	"0x10e390ad2ba33d82b37388d09c4544c6b0225de5": "0xad78ebc5ac6200000",
  	"0x10f4bff0caa5027c0a6a2dcfc952824de2940909": "0x6c6b935b8bbd400000",
  	"0x11001b89ed873e3aaec1155634b4681643986323": "0x3635c9adc5dea00000",
  	"0x110237cf9117e767922fc4a1b78d7964da82df20": "0xd5967be4fc3f100000",
  	"0x1111e5dbf45e6f906d62866f1708101788ddd571": "0x467be6533ec2e40000",
  	"0x11172b278ddd44eea2fdf4cb1d16962391c453d9": "0xc62f3d9bfd4895f00000",
  	"0x112634b4ec30ff786e024159f796a57939ea144e": "0x6c6acc67d7b1d40000",
  	"0x11306c7d57588637780fc9fde8e98ecb008f0164": "0x6c6acc67d7b1d40000",
  	"0x113612bc3ba0ee4898b49dd20233905f2f458f62": "0x2f6f10780d22cc00000",
  	"0x11415fab61e0dfd4b90676141a557a869ba0bde9": "0x6f05b59d3b20000000",
  	"0x114cbbbf6fb52ac414be7ec61f7bb71495ce1dfa": "0xa2a15d09519be00000",
  	"0x114cfefe50170dd97ae08f0a44544978c599548d": "0x2ec887e7a14a1c0000",
  	"0x116108c12084612eeda7a93ddcf8d2602e279e5c": "0x6c6b935b8bbd400000",
  	"0x1164caaa8cc5977afe1fad8a7d6028ce2d57299b": "0x15af1d78b58c400000",
  	"0x11675a25554607a3b6c92a9ee8f36f75edd3e336": "0x8a9aba557e36c0000",
  	"0x116a09df66cb150e97578e297fb06e13040c893c": "0x6c6b935b8bbd400000",
  	"0x116fef5e601642c918cb89160fc2293ba71da936": "0x2b7cc2e9c3225c0000",
  	"0x1178501ff94add1c5881fe886136f6dfdbe61a94": "0x890b0c2e14fb80000",
  	"0x1179c60dbd068b150b074da4be23033b20c68558": "0x24dce54d34a1a00000",
  	"0x117d9aa3c4d13bee12c7500f09f5dd1c66c46504": "0xb2ad30490b2780000",
  	"0x117db836377fe15455e02c2ebda40b1ceb551b19": "0x14542ba12a337c00000",
  	"0x118c18b2dce170e8f445753ba5d7513cb7636d2d": "0x1dd0c885f9a0d800000",
  	"0x118fbd753b9792395aef7a4d78d263cdcaabd4f7": "0x36330322d5238c0000",
  	"0x11928378d27d55c520ceedf24ceb1e822d890df0": "0x1b1ae4d6e2ef5000000",
  	"0x119aa64d5b7d181dae9d3cb449955c89c1f963fa": "0x25f273933db5700000",
  	"0x11c0358aa6479de21866fe21071924b65e70f8b9": "0x7b53f79e888dac00000",
  	"0x11d2247a221e70c2d66d17ee138d38c55ffb8640": "0x21e19e0c9bab2400000",
  	"0x11d7844a471ef89a8d877555583ceebd1439ea26": "0x22369e6ba80c6880000",
  	"0x11dd6185d9a8d73ddfdaa71e9b7774431c4dfec2": "0x3635c9adc5dea00000",
  	"0x11e7997edd904503d77da6038ab0a4c834bbd563": "0x150894e849b3900000",
  	"0x11ec00f849b6319cf51aa8dd8f66b35529c0be77": "0x6c6b935b8bbd400000",
  	"0x11efb8a20451161b644a8ccebbc1d343a3bbcb52": "0xad78ebc5ac62000000",
  	"0x11fefb5dc1a4598aa712640c517775dfa1d91f8c": "0x21e19e0c9bab2400000",
  	"0x120f9de6e0af7ec02a07c609ca8447f157e6344c": "0xe7eeba3410b740000",
  	"0x1210f80bdb826c175462ab0716e69e46c24ad076": "0x56bc75e2d63100000",
  	"0x12134e7f6b017bf48e855a399ca58e2e892fa5c8": "0x3635c9adc5dea00000",
  	"0x12173074980153aeaa4b0dcbc7132eadcec21b64": "0xd02ab486cedc00000",
  	"0x121f855b70149ac83473b9706fb44d47828b983b": "0x4be4e7267b6ae00000",
  	"0x1227e10a4dbf9caca31b1780239f557615fc35c1": "0xad78ebc5ac6200000",
  	"0x122dcfd81addb97d1a0e4925c4b549806e9f3beb": "0x522035cc6e01210000",
  	"0x122f56122549d168a5c5e267f52662e5c5cce5c8": "0xa076407d3f7440000",
  	"0x12316fc7f178eac22eb2b25aedeadf3d75d00177": "0x43c33be05f6bfb98000",
  	"0x123759f333e13e3069e2034b4f05398918119d36": "0x43c33c1937564800000",
  	"0x125cc5e4d56b2bcc2ee1c709fb9e68fb177440bd": "0x6c6b935b8bbd400000",
  	"0x12632388b2765ee4452b50161d1fffd91ab81f4a": "0x281d901f4fdd100000",
  	"0x126897a311a14ad43b78e0920100c4426bfd6bdd": "0x34c726893f2d948000",
  	"0x126d91f7ad86debb0557c612ca276eb7f96d00a1": "0x56bc75e2d63100000",
  	"0x127d3fc5003bf63c0d83e93957836515fd279045": "0x610c9222e6e750000",
  	"0x127db1cadf1b771cbd7475e1b272690f558c8565": "0x2f6f10780d22cc00000",
  	"0x1284f0cee9d2ff2989b65574d06ffd9ab0f7b805": "0x15af1d78b58c400000",
  	"0x128b908fe743a434203de294c441c7e20a86ea67": "0x26ab14e0c0e13c0000",
  	"0x1293c78c7d6a443b9d74b0ba5ee7bb47fd418588": "0x16a6502f15a1e540000",
  	"0x1296acded1e063af39fe8ba0b4b63df789f70517": "0x56bf91b1a65eb0000",
  	"0x12aa7d86ddfbad301692feac8a08f841cb215c37": "0x76d41c62494840000",
  	"0x12afbcba1427a6a39e7ba4849f7ab1c4358ac31b": "0x43c33c1937564800000",
  	"0x12b5e28945bb2969f9c64c63cc05b6f1f8d6f4d5": "0x1a29e86913b74050000",
  	"0x12cf8b0e465213211a5b53dfb0dd271a282c12c9": "0xd2f13f7789f00000",
  	"0x12d20790b7d3dbd88c81a279b812039e8a603bd0": "0x56f985d38644b80000",
  	"0x12d60d65b7d9fc48840be5f891c745ce76ee501e": "0x485e5388d0c76840000",
  	"0x12d91a92d74fc861a729646db192a125b79f5374": "0xfc936392801c0000",
  	"0x12e9a4ad2ad57484dd700565bddb46423bd9bd31": "0x43c30fb0884a96c0000",
  	"0x12f32c0a1f2daab676fe69abd9e018352d4ccd45": "0x2b5e3af16b1880000",
  	"0x12f460ae646cd2780fd35c50a6af4b9accfa85c6": "0x3635c9adc5dea00000",
  	"0x12ffc1128605cb0c13709a7290506f2690977193": "0xb50fcfafebecb00000",
  	"0x13032446e7d610aa00ec8c56c9b574d36ca1c016": "0x6c6b935b8bbd400000",
  	"0x131c792c197d18bd045d7024937c1f84b60f4438": "0xd8d726b7177a800000",
  	"0x131df8d330eb7cc7147d0a55576f05de8d26a8b7": "0xa31062beeed700000",
  	"0x131faed12561bb7aee04e5185af802b1c3438d9b": "0xbdf3c4bb0328c0000",
  	"0x1321b605026f4ffb296a3e0edcb390c9c85608b7": "0x6c6b935b8bbd400000",
  	"0x1321ccf29739b974e5a516f18f3a843671e39642": "0xd8d726b7177a800000",
  	"0x1327d759d56e0ab87af37ecf63fe01f310be100a": "0x23bc3cdb68a1800000",
  	"0x1329dd19cd4baa9fc64310efeceab22117251f12": "0xad78ebc5ac6200000",
  	"0x13371f92a56ea8381e43059a95128bdc4d43c5a6": "0x3635c9adc5dea00000",
  	"0x133c490fa5bf7f372888e607d958fab7f955bae1": "0x55a6e79ccd1d300000",
  	"0x133e4f15e1e39c53435930aaedf3e0fe56fde843": "0x1158e460913d00000",
  	"0x134163be9fbbe1c5696ee255e90b13254395c318": "0xad78ebc5ac6200000",
  	"0x135cecd955e5798370769230159303d9b1839f66": "0x10f0cf064dd59200000",
  	"0x135d1719bf03e3f866312479fe338118cd387e70": "0x6c6b935b8bbd400000",
  	"0x135eb8c0e9e101deedec11f2ecdb66ae1aae8867": "0x43c33c1937564800000",
  	"0x1360e87df24c69ee6d51c76e73767ffe19a2131c": "0x4fcc1a89027f00000",
  	"0x136c834bf111326d207395295b2e583ea7f33572": "0x56bc75e2d63100000",
  	"0x136d4b662bbd1080cfe4445b0fa213864435b7f1": "0xd8d726b7177a800000",
  	"0x136f4907cab41e27084b9845069ff2fd0c9ade79": "0xd8d726b7177a800000",
  	"0x1374facd7b3f8d68649d60d4550ee69ff0484133": "0xe9ed6e11172da0000",
  	"0x137cf341e8516c815814ebcd73e6569af14cf7bc": "0x3635c9adc5dea00000",
  	"0x13848b46ea75beb7eaa85f59d866d77fd24cf21a": "0xa968163f0a57b400000",
  	"0x139d3531c9922ad56269f6309aa789fb2485f98c": "0xd8d726b7177a800000",
  	"0x139e479764b499d666208c4a8a047a97043163dd": "0x2077212aff6df00000",
  	"0x13a5eecb38305df94971ef2d9e179ae6cebab337": "0x11e3ab8395c6e80000",
  	"0x13acada8980affc7504921be84eb4944c8fbb2bd": "0x56d2aa3a5c09a00000",
  	"0x13b9b10715714c09cfd610cf9c9846051cb1d513": "0x6acb3df27e1f880000",
  	"0x13ce332dff65a6ab933897588aa23e000980fa82": "0xe020536f028f00000",
  	"0x13d67a7e25f2b12cdb85585009f8acc49b967301": "0x6c6acc67d7b1d40000",
  	"0x13dee03e3799952d0738843d4be8fc0a803fb20e": "0x6c6b935b8bbd400000",
  	"0x13e02fb448d6c84ae17db310ad286d056160da95": "0x6c6b935b8bbd400000",
  	"0x13e321728c9c57628058e93fc866a032dd0bda90": "0x26bcca23fe2ea20000",
  	"0x13ec812284026e409bc066dfebf9d5a4a2bf801e": "0x57473d05dabae80000",
  	"0x140129eaa766b5a29f5b3af2574e4409f8f6d3f1": "0x15af1d78b58c4000000",
  	"0x140518a3194bad1350b8949e650565debe6db315": "0x6c6b935b8bbd400000",
  	"0x1406854d149e081ac09cb4ca560da463f3123059": "0x487a9a304539440000",
  	"0x140ca28ff33b9f66d7f1fc0078f8c1eef69a1bc0": "0x56bc75e2d631000000",
  	"0x140fba58dbc04803d84c2130f01978f9e0c73129": "0x15af1d78b58c400000",
  	"0x141a5e39ee2f680a600fbf6fa297de90f3225cdd": "0x21e19e0c9bab2400000",
  	"0x14254ea126b52d0142da0a7e188ce255d8c47178": "0x2a034919dfbfbc0000",
  	"0x142b87c5043ffb5a91df18c2e109ced6fe4a71db": "0xad78ebc5ac6200000",
  	"0x143c639752caeecf6a997d39709fc8f19878c7e8": "0x6acb3df27e1f880000",
  	"0x143d536b8b1cb84f56a39e0bc81fd5442bcacce1": "0x56bc75e2d63100000",
  	"0x143f5f1658d9e578f4f3d95f80c0b1bd3933cbda": "0x50c5e761a444080000",
  	"0x14410fb310711be074a80883c635d0ef6afb2539": "0x6c6b935b8bbd400000",
  	"0x144b19f1f66cbe318347e48d84b14039466c5909": "0x6c6b935b8bbd400000",
  	"0x145250b06e4fa7cb2749422eb817bdda8b54de5f": "0xbdf3c4bb0328c0000",
  	"0x145e0600e2a927b2dd8d379356b45a2e7d51d3ae": "0x8a02ab400bb2cb8000",
  	"0x145e1de0147911ccd880875fbbea61f6a142d11d": "0xd8d726b7177a800000",
  	"0x1463a873555bc0397e575c2471cf77fa9db146e0": "0x21e19e0c9bab2400000",
  	"0x1479a9ec7480b74b5db8fc499be352da7f84ee9c": "0x3635c9adc5dea00000",
  	"0x147af46ae9ccd18bb35ca01b353b51990e49dce1": "0xd8d726b7177a800000",
  	"0x147f4210ab5804940a0b7db8c14c28396b62a6bf": "0x6c6b935b8bbd400000",
  	"0x14830704e99aaad5c55e1f502b27b22c12c91933": "0x219c3a7b1966300000",
  	"0x149b6dbde632c19f5af47cb493114bebd9b03c1f": "0x28a857425466f800000",
  	"0x149ba10f0da2725dc704733e87f5a524ca88515e": "0x1ab2cf7c9f87e200000",
  	"0x14a7352066364404db50f0d0d78d754a22198ef4": "0x65ea3db75546600000",
  	"0x14ab164b3b524c82d6abfbc0de831126ae8d1375": "0x6c6b935b8bbd400000",
  	"0x14b1603ec62b20022033eec4d6d6655ac24a015a": "0x2b5e3af16b1880000",
  	"0x14c63ba2dcb1dd4df33ddab11c4f0007fa96a62d": "0x34841b6057afab00000",
  	"0x14cdddbc8b09e6675a9e9e05091cb92238c39e1e": "0x11478b7c30abc300000",
  	"0x14d00aad39a0a7d19ca05350f7b03727f08dd82e": "0x1b1ae4d6e2ef500000",
  	"0x14eec09bf03e352bd6ff1b1e876be664ceffd0cf": "0x116dc3a8994b30000",
  	"0x14f221159518783bc4a706676fc4f3c5ee405829": "0xad78ebc5ac6200000",
  	"0x14fcd1391e7d732f41766cdacd84fa1deb9ffdd2": "0x6c6b935b8bbd400000",
  	"0x150e3dbcbcfc84ccf89b73427763a565c23e60d0": "0x22b1c8c1227a00000",
  	"0x1518627b88351fede796d3f3083364fbd4887b0c": "0x3635c9adc5dea000000",
  	"0x15224ad1c0face46f9f556e4774a3025ad06bd52": "0xb98bc829a6f90000",
  	"0x152f2bd229ddf3cb0fdaf455c183209c0e1e39a2": "0x6c6b935b8bbd400000",
  	"0x152f4e860ef3ee806a502777a1b8dbc91a907668": "0x2086ac351052600000",
  	"0x153c08aa8b96a611ef63c0253e2a4334829e579d": "0x155bd9307f9fe80000",
  	"0x153cf2842cb9de876c276fa64767d1a8ecf573bb": "0x6c6b935b8bbd400000",
  	"0x153ef58a1e2e7a3eb6b459a80ab2a547c94182a2": "0x14542ba12a337c000000",
  	"0x154459fa2f21318e3434449789d826cdc1570ce5": "0x6c6b935b8bbd400000",
  	"0x1547b9bf7ad66274f3413827231ba405ee8c88c1": "0x3a9d5baa4abf1d00000",
  	"0x1548b770a5118ede87dba2f690337f616de683ab": "0x1c995685e0bf870000",
  	"0x15528350e0d9670a2ea27f7b4a33b9c0f9621d21": "0xd8d8583fa2d52f0000",
  	"0x155b3779bb6d56342e2fda817b5b2d81c7f41327": "0x2b8aa3a076c9c0000",
  	"0x1565af837ef3b0bd4e2b23568d5023cd34b16498": "0x1551e9724ac4ba0000",
  	"0x15669180dee29598869b08a721c7d24c4c0ee63f": "0x3635c9adc5dea00000",
  	"0x1572cdfab72a01ce968e78f5b5448da29853fbdd": "0x112626c49060fa60000",
  	"0x157559adc55764cc6df79323092534e3d6645a66": "0x14542ba12a337c00000",
  	"0x1578bdbc371b4d243845330556fff2d5ef4dff67": "0x56bc75e2d63100000",
  	"0x157eb3d3113bd3b597714d3a954edd018982a5cb": "0x6c6b935b8bbd400000",
  	"0x1584a2c066b7a455dbd6ae2807a7334e83c35fa5": "0x70c1cc73b00c80000",
  	"0x15874686b6733d10d703c9f9bec6c52eb8628d67": "0x6c6b935b8bbd400000",
  	"0x158a0d619253bf4432b5cd02c7b862f7c2b75636": "0x75bac7c5b12188000",
  	"0x1598127982f2f8ad3b6b8fc3cf27bf617801ba2b": "0x960db77681e940000",
  	"0x159adce27aa10b47236429a34a5ac42cad5b6416": "0x6bf90a96edbfa718000",
  	"0x15a0aec37ff9ff3d5409f2a4f0c1212aaccb0296": "0x3635c9adc5dea00000",
  	"0x15aa530dc36958b4edb38eee6dd9e3c77d4c9145": "0x6c6b935b8bbd400000",
  	"0x15acb61568ec4af7ea2819386181b116a6c5ee70": "0x690836c0af5f5600000",
  	"0x15b96f30c23b8664e7490651066b00c4391fbf84": "0x1642e9df4876290000",
  	"0x15c7edb8118ee27b342285eb5926b47a855bc7a5": "0x1158e460913d00000",
  	"0x15d99468507aa0413fb60dca2adc7f569cb36b54": "0x6c6b935b8bbd400000",
  	"0x15dbb48c98309764f99ced3692dcca35ee306bac": "0x1fc3842bd1f071c00000",
  	"0x15dcafcc2bace7b55b54c01a1c514626bf61ebd8": "0x1fd933494aa5fe00000",
  	"0x15e3b584056b62c973cf5eb096f1733e54c15c91": "0x32c75a0223ddf30000",
  	"0x15ebd1c7cad2aff19275c657c4d808d010efa0f5": "0xadf30ba70c8970000",
  	"0x15ee0fc63ebf1b1fc49d7bb38f8863823a2e17d2": "0x678a932062e4180000",
  	"0x15f1b352110d68901d8f67aac46a6cfafe031477": "0xad78ebc5ac6200000",
  	"0x15f2b7b16432ee50a5f55b41232f6334ed58bdc0": "0x15af1d78b58c400000",
  	"0x16019a4dafab43f4d9bf4163fae0847d848afca2": "0x15bc70139f74a0000",
  	"0x160226efe7b53a8af462d117a0108089bdecc2d1": "0xadf30ba70c8970000",
  	"0x160ceb6f980e04315f53c4fc988b2bf69e284d7d": "0x10910d4cdc9f60000",
  	"0x161caf5a972ace8379a6d0a04ae6e163fe21df2b": "0x152d02c7e14af6800000",
  	"0x161d26ef6759ba5b9f20fdcd66f16132c352415e": "0x6c6b935b8bbd400000",
  	"0x162110f29eac5f7d02b543d8dcd5bb59a5e33b73": "0x6c6b935b8bbd400000",
  	"0x162ba503276214b509f97586bd842110d103d517": "0x1e7ffd8895c22680000",
  	"0x162d76c2e6514a3afb6fe3d3cb93a35c5ae783f1": "0x6c6b935b8bbd400000",
  	"0x163bad4a122b457d64e8150a413eae4d07023e6b": "0x104e70464b1580000",
  	"0x163cc8be227646cb09719159f28ed09c5dc0dce0": "0x487a9a304539440000",
  	"0x163dca73d7d6ea3f3e6062322a8734180c0b78ef": "0x9f742003cb7dfc0000",
  	"0x164d7aac3eecbaeca1ad5191b753f173fe12ec33": "0x285652b8a468690000",
  	"0x16526c9edf943efa4f6d0f0bae81e18b31c54079": "0x35659ef93f0fc40000",
  	"0x165305b787322e25dc6ad0cefe6c6f334678d569": "0x6c6b935b8bbd400000",
  	"0x1665ab1739d71119ee6132abbd926a279fe67948": "0x56bc75e2d63100000",
  	"0x166bf6dab22d841b486c38e7ba6ab33a1487ed8c": "0x43c33c1937564800000",
  	"0x167699f48a78c615512515739958993312574f07": "0x21d3bd55e803c0000",
  	"0x1678c5f2a522393225196361894f53cc752fe2f3": "0x68f365aea1e4400000",
  	"0x167ce7de65e84708595a525497a3eb5e5a665073": "0x1f314773666fc40000",
  	"0x167e3e3ae2003348459392f7dfce44af7c21ad59": "0x1b1ae4d6e2ef500000",
  	"0x1680cec5021ee93050f8ae127251839e74c1f1fd": "0x2c61461e5d743d68000",
  	"0x16816aac0ede0d2d3cd442da79e063880f0f1d67": "0x6c6b935b8bbd400000",
  	"0x168b5019b818691644835fe69bf229e17112d52c": "0x5ede20f01a459800000",
  	"0x168bdec818eafc6d2992e5ef54aa0e1601e3c561": "0x3637507a30abeb0000",
  	"0x168d30e53fa681092b52e9bae15a0dcb41a8c9bb": "0x56bc75e2d63100000",
  	"0x169bbefc41cfd7d7cbb8dfc63020e9fb06d49546": "0x6c6b935b8bbd400000",
  	"0x16a58e985dccd707a594d193e7cca78b5d027849": "0x49b9ca9a6943400000",
  	"0x16a9e9b73ae98b864d1728798b8766dbc6ea8d12": "0x33e7b44b0db5040000",
  	"0x16aa52cb0b554723e7060f21f327b0a68315fea3": "0xd8d726b7177a80000",
  	"0x16abb8b021a710bdc78ea53494b20614ff4eafe8": "0x890b0c2e14fb80000",
  	"0x16afa787fc9f94bdff6976b1a42f430a8bf6fb0f": "0x6c6b935b8bbd400000",
  	"0x16bae5d24eff91778cd98b4d3a1cc3162f44aa77": "0x15be6174e1912e0000",
  	"0x16bc40215abbd9ae5d280b95b8010b4514ff1292": "0xad78ebc5ac6200000",
  	"0x16be75e98a995a395222d00bd79ff4b6e638e191": "0x79f905c6fd34e800000",
  	"0x16c1bf5b7dc9c83c179efacbcf2eb174e3561cb3": "0x3635c9adc5dea00000",
  	"0x16c7b31e8c376282ac2271728c31c95e35d952c3": "0x6c6b935b8bbd400000",
  	"0x16f313cf8ad000914a0a176dc6a4342b79ec2538": "0x6c6b935b8bbd400000",
  	"0x16ffac84032940f0121a09668b858a7e79ffa3bb": "0xd24ada6e1087110000",
  	"0x1703b4b292b8a9deddede81bb25d89179f6446b6": "0x42b65a455e8b1680000",
  	"0x17049311101d817efb1d65910f663662a699c98c": "0x6c68ccd09b022c0000",
  	"0x1704cefcfb1331ec7a78388b29393e85c1af7916": "0x15af1d78b58c400000",
  	"0x170a88a8997f92d238370f1affdee6347050b013": "0xa2ac77351488300000",
  	"0x17108dab2c50f99de110e1b3b3b4cd82f5df28e7": "0x35203b67bccad00000",
  	"0x17125b59ac51cee029e4bd78d7f5947d1ea49bb2": "0x4a89f54ef0121c00000",
  	"0x171ad9a04bedc8b861e8ed4bddf5717813b1bb48": "0x15af1d78b58c400000",
  	"0x171ca02a8b6d62bf4ca47e906914079861972cb2": "0xad78ebc5ac6200000",
  	"0x1722c4cbe70a94b6559d425084caeed4d6e66e21": "0xd8d726b7177a800000",
  	"0x17580b766f7453525ca4c6a88b01b50570ea088c": "0x56bc75e2d63100000",
  	"0x17589a6c006a54cad70103123aae0a82135fdeb4": "0xd8d726b7177a800000",
  	"0x175a183a3a235ffbb03ba835675267229417a091": "0x3635c9adc5dea000000",
  	"0x175feeea2aa4e0efda12e1588d2f483290ede81a": "0xad78ebc5ac6200000",
  	"0x1765361c2ec2f83616ce8363aae21025f2566f40": "0x10f0cf064dd59200000",
  	"0x1767525c5f5a22ed80e9d4d7710f0362d29efa33": "0x15af1d78b58c400000",
  	"0x17762560e82a93b3f522e0e524adb8612c3a7470": "0x3635c9adc5dea00000",
  	"0x177dae78bc0113d8d39c4402f2a641ae2a105ab8": "0x6292425620b4480000",
  	"0x1784948bf99848c89e445638504dd698271b5924": "0x1474c410d87baee0000",
  	"0x1788da9b57fd05edc4ff99e7fef301519c8a0a1e": "0x6c6b935b8bbd400000",
  	"0x178eaf6b8554c45dfde16b78ce0c157f2ee31351": "0x1158e460913d000000",
  	"0x17961d633bcf20a7b029a7d94b7df4da2ec5427f": "0xc6ff070f1938b8000",
  	"0x1796bcc97b8abc717f4b4a7c6b1036ea2182639f": "0x1341f91cd8e3510000",
  	"0x17993d312aa1106957868f6a55a5e8f12f77c843": "0x1865e814f4142e8000",
  	"0x179a825e0f1f6e985309668465cffed436f6aea9": "0x1158e460913d00000",
  	"0x17b2d6cf65c6f4a347ddc6572655354d8a412b29": "0x6c6b935b8bbd400000",
  	"0x17b807afa3ddd647e723542e7b52fee39527f306": "0x15af40ffa7fc010000",
  	"0x17c0478657e1d3d17aaa331dd429cecf91f8ae5d": "0x3634fb9f1489a70000",
  	"0x17c0fef6986cfb2e4041f9979d9940b69dff3de2": "0xd8d726b7177a800000",
  	"0x17d4918dfac15d77c47f9ed400a850190d64f151": "0x6c6b935b8bbd400000",
  	"0x17d521a8d9779023f7164d233c3b6420ffd223ed": "0x1158e460913d00000",
  	"0x17d931d4c56294dcbe77c8655be4695f006d4a3c": "0x6c6b935b8bbd400000",
  	"0x17df49518d73b129f0da36b1c9b40cb66420fdc7": "0x21e19e0c9bab2400000",
  	"0x17e4a0e52bac3ee44efe0954e753d4b85d644e05": "0x6c6b935b8bbd400000",
  	"0x17e584e810e567702c61d55d434b34cdb5ee30f6": "0x10f0cf064dd59200000",
  	"0x17e82e7078dc4fd9e879fb8a50667f53a5c54591": "0xad78ebc5ac6200000",
  	"0x17e86f3b5b30c0ba59f2b2e858425ba89f0a10b0": "0x6c6b935b8bbd400000",
  	"0x17ee9f54d4ddc84d670eff11e54a659fd72f4455": "0x3635c9adc5dea000000",
  	"0x17ef4acc1bf147e326749d10e677dcffd76f9e06": "0x87751f4e0e1b5300000",
  	"0x17f14632a7e2820be6e8f6df823558283dadab2d": "0x6c6b935b8bbd400000",
  	"0x17f523f117bc9fe978aa481eb4f5561711371bc8": "0x6c69f73e29134e0000",
  	"0x17fd9b551a98cb61c2e07fbf41d3e8c9a530cba5": "0x1768c308193048000",
  	"0x180478a655d78d0f3b0c4f202b61485bc4002fd5": "0x6c6b935b8bbd400000",
  	"0x18136c9df167aa17b6f18e22a702c88f4bc28245": "0xd8d726b7177a800000",
  	"0x1815279dff9952da3be8f77249dbe22243377be7": "0x1017cb76e7b26640000",
  	"0x181fbba852a7f50178b1c7f03ed9e58d54162929": "0x241a9b4f617a280000",
  	"0x1827039f09570294088fddf047165c33e696a492": "0x205b4dfa1ee74780000",
  	"0x182db85293f606e88988c3704cb3f0c0bbbfca5a": "0x73f75d1a085ba0000",
  	"0x1848003c25bfd4aa90e7fcb5d7b16bcd0cffc0d8": "0x3635c9adc5dea00000",
  	"0x184a4f0beb71ffd558a6b6e8f228b78796c4cf3e": "0x28a857425466f800000",
  	"0x184d86f3466ae6683b19729982e7a7e1a48347b2": "0x21e19e0c9bab2400000",
  	"0x1851a063ccdb30549077f1d139e72de7971197d5": "0x6c6b935b8bbd400000",
  	"0x185546e8768d506873818ac9751c1f12116a3bef": "0xad78ebc5ac6200000",
  	"0x1858cf11aea79f5398ad2bb22267b5a3c952ea74": "0x215f835bc769da80000",
  	"0x185a7fc4ace368d233e620b2a45935661292bdf2": "0x43c33c1937564800000",
  	"0x1864a3c7b48155448c54c88c708f166709736d31": "0x73f75d1a085ba0000",
  	"0x186afdc085f2a3dce4615edffbadf71a11780f50": "0xad78ebc5ac6200000",
  	"0x186b95f8e5effddcc94f1a315bf0295d3b1ea588": "0x6c6acc67d7b1d40000",
  	"0x187d9f0c07f8eb74faaad15ebc7b80447417f782": "0x1158e460913d00000",
  	"0x1895a0eb4a4372722fcbc5afe6936f289c88a419": "0x3154c9729d05780000",
  	"0x1899f69f653b05a5a6e81f480711d09bbf97588c": "0x69fb133df750ac0000",
  	"0x18a6d2fc52be73084023c91802f05bc24a4be09f": "0x6c6b935b8bbd400000",
  	"0x18b0407cdad4ce52600623bd5e1f6a81ab61f026": "0x1151ccf0c654c68000",
  	"0x18b8bcf98321da61fb4e3eacc1ec5417272dc27e": "0x2fb474098f67c00000",
  	"0x18c6723a6753299cb914477d04a3bd218df8c775": "0x3635c9adc5dea00000",
  	"0x18e113d8177c691a61be785852fa5bb47aeebdaf": "0x487a9a304539440000",
  	"0x18e4ce47483b53040adbab35172c01ef64506e0c": "0x1e7e4171bf4d3a00000",
  	"0x18e53243981aabc8767da10c73449f1391560eaa": "0x14542ba12a337c00000",
  	"0x18fa8625c9dc843c78c7ab259ff87c9599e07f10": "0x3635c9adc5dea00000",
  	"0x18fb09188f27f1038e654031924f628a2106703d": "0x6c6b935b8bbd400000",
  	"0x18fccf62d2c3395453b7587b9e26f5cff9eb7482": "0x3635c9adc5dea00000",
  	"0x191313525238a21c767457a91374f02200c55448": "0x64f5fdf494f780000",
  	"0x1914f1eb95d1277e93b6e61b668b7d77f13a11a1": "0x34957444b840e80000",
  	"0x1923cfc68b13ea7e2055803645c1e320156bd88d": "0x487a9a304539440000",
  	"0x19336a236ded755872411f2e0491d83e3e00159e": "0x32f51edbaaa3300000",
  	"0x1933e334c40f3acbad0c0b851158206924beca3a": "0x1995eaf01b896188000",
  	"0x1937c5c515057553ccbd46d5866455ce66290284": "0xd3c21bcecceda1000000",
  	"0x193ac65183651800e23580f8f0ead3bb597eb8a4": "0x2b62abcfb910a0000",
  	"0x193d37ed347d1c2f4e35350d9a444bc57ca4db43": "0x340aad21b3b700000",
  	"0x1940dc9364a852165f47414e27f5002445a4f143": "0x24c2dff6a3c7c480000",
  	"0x1945fe377fe6d4b71e3e791f6f17db243c9b8b0f": "0x7679e7beb988360000",
  	"0x194a6bb302b8aba7a5b579df93e0df1574967625": "0x1b1ae4d6e2ef500000",
  	"0x194cebb4929882bf3b4bf9864c2b1b0f62c283f9": "0x1ef861531f74aa0000",
  	"0x194ff44aefc17bd20efd7a204c47d1620c86db5d": "0xa29909687f6aa40000",
  	"0x194ffe78bbf5d20dd18a1f01da552e00b7b11db1": "0x17b7883c06916600000",
  	"0x1953313e2ad746239cb2270f48af34d8bb9c4465": "0x6c6b935b8bbd400000",
  	"0x19571a2b8f81c6bcf66ab3a10083295617150003": "0x1ab2cf7c9f87e20000",
  	"0x19687daa39c368139b6e7be60dc1753a9f0cbea3": "0x1b1ae4d6e2ef5000000",
  	"0x196c02210a450ab0b36370655f717aa87bd1c004": "0xe10ace157dbc00000",
  	"0x196e85df7e732b4a8f0ed03623f4db9db0b8fa31": "0x125b92f5cef248000",
  	"0x19732bf973055dbd91a4533adaa2149a91d38380": "0x6c6b935b8bbd400000",
  	"0x197672fd39d6f246ce66a790d13aa922d70ea109": "0x3635c9adc5dea00000",
  	"0x19798cbda715ea9a9b9d6aab942c55121e98bf91": "0x410d586a20a4c00000",
  	"0x198bfcf1b07ae308fa2c02069ac9dafe7135fb47": "0x1158e460913d00000",
  	"0x198ef1ec325a96cc354c7266a038be8b5c558f67": "0x80d1e4373e7f21da0000",
  	"0x19918aa09e7d494e98ffa5db50350892f7156ac6": "0x21e19e0c9bab2400000",
  	"0x19b36b0c87ea664ed80318dc77b688dde87d95a5": "0x699f499802303d0000",
  	"0x19df9445a81c1b3d804aeaeb6f6e204e4236663f": "0x206d94e6a49878000",
  	"0x19e5dea3370a2c746aae34a37c531f41da264e83": "0xad78ebc5ac6200000",
  	"0x19e7f3eb7bf67f3599209ebe08b62ad3327f8cde": "0x6c6b935b8bbd400000",
  	"0x19e94e620050aad766b9e1bad931238312d4bf49": "0x81e32df972abf00000",
  	"0x19ecf2abf40c9e857b252fe1dbfd3d4c5d8f816e": "0x6c6b935b8bbd400000",
  	"0x19f5caf4c40e6908813c0745b0aea9586d9dd931": "0x23fed9e1fa2b600000",
  	"0x19f643e1a8fa04ae16006028138333a59a96de87": "0x1158e460913d00000",
  	"0x19f99f2c0b46ce8906875dc9f90ae104dae35594": "0xf4575a5d4d162a0000",
  	"0x19ff244fcfe3d4fa2f4fd99f87e55bb315b81eb6": "0xad78ebc5ac6200000",
  	"0x1a04cec420ad432215246d77fe178d339ed0b595": "0x11216185c29f700000",
  	"0x1a04d5389eb006f9ce880c30d15353f8d11c4b31": "0x39d84b2186dc9100000",
  	"0x1a0841b92a7f7075569dc4627e6b76cab05ade91": "0x52663ccab1e1c00000",
  	"0x1a085d43ec92414ea27b914fe767b6d46b1eef44": "0x641e8a13563d8f80000",
  	"0x1a09fdc2c7a20e23574b97c69e93deba67d37220": "0x6c4fd1ee246e780000",
  	"0x1a0a1ddfb031e5c8cc1d46cf05842d50fddc7130": "0x3635c9adc5dea00000",
  	"0x1a1c9a26e0e02418a5cf687da75a275c622c9440": "0x10f0cf064dd59200000",
  	"0x1a201b4327cea7f399046246a3c87e6e03a3cda8": "0x3635c9adc5dea00000",
  	"0x1a2434cc774422d48d53d59c5d562cce8407c94b": "0x1a055690d9db80000",
  	"0x1a25e1c5bc7e5f50ec16f8885f210ea1b938800e": "0xd8d726b7177a800000",
  	"0x1a2694ec07cf5e4d68ba40f3e7a14c53f3038c6e": "0x3636cd06e2db3a8000",
  	"0x1a3520453582c718a21c42375bc50773255253e1": "0x2ad373ce668e980000",
  	"0x1a376e1b2d2f590769bb858d4575320d4e149970": "0x106712576391d180000",
  	"0x1a3a330e4fcb69dbef5e6901783bf50fd1c15342": "0xe3aeb5737240a00000",
  	"0x1a4ec6a0ae7f5a9427d23db9724c0d0cffb2ab2f": "0x9b41fbf9e0aec0000",
  	"0x1a505e62a74e87e577473e4f3afa16bedd3cfa52": "0x1b1ae4d6e2ef500000",
  	"0x1a5ee533acbfb3a2d76d5b685277b796c56a052b": "0x6c6b935b8bbd400000",
  	"0x1a644a50cbc2aee823bd2bf243e825be4d47df02": "0x56be03ca3e47d8000",
  	"0x1a7044e2383f8708305b495bd1176b92e7ef043a": "0xad78ebc5ac6200000",
  	"0x1a79c7f4039c67a39d7513884cdc0e2c34222490": "0x1158e460913d00000",
  	"0x1a89899cbebdbb64bb26a195a63c08491fcd9eee": "0x6c6b935b8bbd400000",
  	"0x1a8a5ce414de9cd172937e37f2d59cff71ce57a0": "0x21e19e0c9bab2400000",
  	"0x1a95a8a8082e4652e4170df9271cb4bb4305f0b2": "0x2b5e3af16b1880000",
  	"0x1a95c9b7546b5d1786c3858fb1236446bc0ca4ce": "0x6acb3df27e1f880000",
  	"0x1a987e3f83de75a42f1bde7c997c19217b4a5f24": "0x6c6b935b8bbd400000",
  	"0x1a9e702f385dcd105e8b9fa428eea21c57ff528a": "0x4be4e7267b6ae00000",
  	"0x1aa1021f550af158c747668dd13b463160f95a40": "0x4fb0591b9b30380000",
  	"0x1aa27699cada8dc3a76f7933aa66c71919040e88": "0x15af1d78b58c400000",
  	"0x1aa40270d21e5cde86b6316d1ac3c533494b79ed": "0x1158e460913d00000",
  	"0x1ab53a11bcc63ddfaa40a02b9e186496cdbb8aff": "0x6c3f2aac800c000000",
  	"0x1abc4e253b080aeb437984ab05bca0979aa43e1c": "0x3635c9adc5dea00000",
  	"0x1ac089c3bc4d82f06a20051a9d732dc0e734cb61": "0x25f69d63a6ce0e0000",
  	"0x1ad4563ea5786be1159935abb0f1d5879c3e7372": "0x14542ba12a337c00000",
  	"0x1ad72d20a76e7fcc6b764058f48d417d496fa6cd": "0x6c6b935b8bbd400000",
  	"0x1adaf4abfa867db17f99af6abebf707a3cf55df6": "0x14542ba12a337c00000",
  	"0x1af60343360e0b2d75255210375720df21db5c7d": "0x3635c9adc5dea00000",
  	"0x1afcc585896cd0ede129ee2de5c19ea811540b64": "0xaf2aba0c8e5bef8000",
  	"0x1b05ea6a6ac8af7cb6a8b911a8cce8fe1a2acfc8": "0x6c6b935b8bbd400000",
  	"0x1b0b31afff4b6df3653a94d7c87978ae35f34aae": "0x133910453fa9840000",
  	"0x1b0d076817e8d68ee2df4e1da1c1142d198c4435": "0x54069233bf7f780000",
  	"0x1b130d6fa51d5c48ec8d1d52dc8a227be8735c8a": "0x6c6b935b8bbd400000",
  	"0x1b23cb8663554871fbbe0d9e60397efb6faedc3e": "0xad78ebc5ac6200000",
  	"0x1b2639588b55c344b023e8de5fd4087b1f040361": "0x5150ae84a8cdf00000",
  	"0x1b3920d001c43e72b24e7ca46f0fd6e0c20a5ff2": "0x6c6b935b8bbd400000",
  	"0x1b3cb81e51011b549d78bf720b0d924ac763a7c2": "0x7695a92c20d6fe000000",
  	"0x1b43232ccd4880d6f46fa751a96cd82473315841": "0x4563918244f400000",
  	"0x1b4bbcb18165211b265b280716cb3f1f212176e8": "0x199ad37d03d0608000",
  	"0x1b4d07acd38183a61bb2783d2b7b178dd502ac8d": "0xad78ebc5ac6200000",
  	"0x1b636b7a496f044d7359596e353a104616436f6b": "0x1388ea95c33f1d0000",
  	"0x1b6495891240e64e594493c2662171db5e30ce13": "0x95887d695ed580000",
  	"0x1b6610fb68bad6ed1cfaa0bbe33a24eb2e96fafb": "0x83d6c7aab63600000",
  	"0x1b799033ef6dc7127822f74542bb22dbfc09a308": "0x56bc75e2d63100000",
  	"0x1b7ed974b6e234ce81247498429a5bd4a0a2d139": "0x6c6b935b8bbd400000",
  	"0x1b826fb3c012b0d159e294ba5b8a499ff3c0e03c": "0x6c6b935b8bbd400000",
  	"0x1b8aa0160cd79f005f88510a714913d70ad3be33": "0xaeffb83079ad00000",
  	"0x1b8bd6d2eca20185a78e7d98e8e185678dac4830": "0x3894f0e6f9b9f700000",
  	"0x1b9b2dc2960e4cb9408f7405827c9b59071612fd": "0x3635c9adc5dea00000",
  	"0x1ba9228d388727f389150ea03b73c82de8eb2e09": "0x18974fbe177c9280000",
  	"0x1ba9f7997e5387b6b2aa0135ac2452fe36b4c20d": "0x2e141ea081ca080000",
  	"0x1bba03ff6b4ad5bf18184acb21b188a399e9eb4a": "0x61093d7c2c6d380000",
  	"0x1bbc199e586790be87afedc849c04726745c5d7b": "0xd8d726b7177a800000",
  	"0x1bbc60bcc80e5cdc35c5416a1f0a40a83dae867b": "0x6c6b935b8bbd400000",
  	"0x1bc44c8761231ba1f11f5faa40fa669a013e12ce": "0xb0952c45aeaad0000",
  	"0x1bcf3441a866bdbe963009ce33c81cbb0261b02c": "0x9ddc1e3b901180000",
  	"0x1bd28cd5c78aee51357c95c1ef9235e7c18bc854": "0x6c6b935b8bbd400000",
  	"0x1bd8ebaa7674bb18e19198db244f570313075f43": "0x821ab0d4414980000",
  	"0x1bd909ac0d4a1102ec98dcf2cca96a0adcd7a951": "0x11651ac3e7a758000",
  	"0x1be3542c3613687465f15a70aeeb81662b65cca8": "0x6c6b935b8bbd400000",
  	"0x1bea4df5122fafdeb3607eddda1ea4ffdb9abf2a": "0x12c1b6eed03d280000",
  	"0x1bec4d02ce85fc48feb62489841d85b170586a9b": "0x821ab0d44149800000",
  	"0x1bf974d9904f45ce81a845e11ef4cbcf27af719e": "0x56bc75e2d63100000",
  	"0x1c045649cd53dc23541f8ed4d341812808d5dd9c": "0x17b7883c06916600000",
  	"0x1c128bd6cda5fca27575e4b43b3253c8c4172afe": "0x6c6b935b8bbd400000",
  	"0x1c13d38637b9a47ce79d37a86f50fb409c060728": "0x487a9a304539440000",
  	"0x1c2010bd662df417f2a271879afb13ef4c88a3ae": "0xd8d726b7177a800000",
  	"0x1c257ad4a55105ea3b58ed374b198da266c85f63": "0x21e19e0c9bab2400000",
  	"0x1c2e3607e127caca0fbd5c5948adad7dd830b285": "0x42bf06b78ed3b500000",
  	"0x1c356cfdb95febb714633b28d5c132dd84a9b436": "0x15af1d78b58c40000",
  	"0x1c35aab688a0cd8ef82e76541ba7ac39527f743b": "0x1b1ae4d6e2ef500000",
  	"0x1c3ef05dae9dcbd489f3024408669de244c52a02": "0x43c33c1937564800000",
  	"0x1c4af0e863d2656c8635bc6ffec8dd9928908cb5": "0x6c6b935b8bbd400000",
  	"0x1c601993789207f965bb865cbb4cd657cce76fc0": "0x5541a7037503f0000",
  	"0x1c63fa9e2cbbf23c49fcdef1cbabfe6e0d1e14c1": "0x3635c9adc5dea00000",
  	"0x1c6702b3b05a5114bdbcaeca25531aeeb34835f4": "0x58556bead45dcae0000",
  	"0x1c68a66138783a63c98cc675a9ec77af4598d35e": "0x2b746f48f0f120000",
  	"0x1c73d00b6e25d8eb9c1ff4ad827b6b9e9cf6d20c": "0xad78ebc5ac6200000",
  	"0x1c751e7f24df9d94a637a5dedeffc58277b5db19": "0xae8e7a0bb575d00000",
  	"0x1c7cb2fe6bf3e09cbcdc187af38fa8f5053a70b6": "0x21c84f742d0cead8000",
  	"0x1c89060f987c518fa079ec2c0a5ebfa30f5d20f7": "0x80bfbefcb5f0bc00000",
  	"0x1c94d636e684eb155895ce6db4a2588fba1d001b": "0x6c6b935b8bbd400000",
  	"0x1c99fe9bb6c6d1066d912099547fd1f4809eacd9": "0x6c6b935b8bbd400000",
  	"0x1cb450920078aab2317c7db3b38af7dd298b2d41": "0x126e72a69a50d00000",
  	"0x1cb5f33b4d488936d13e3161da33a1da7df70d1b": "0xad78ebc5ac6200000",
  	"0x1cb6b2d7cfc559b7f41e6f56ab95c7c958cd0e4c": "0x487a9a304539440000",
  	"0x1cc1d3c14f0fb8640e36724dc43229d2ea7a1e48": "0x5c283d410394100000",
  	"0x1cc90876004109cd79a3dea866cb840ac364ba1b": "0x6c6b935b8bbd400000",
  	"0x1cd1f0a314cbb200de0a0cb1ef97e920709d97c2": "0x6c6b935b8bbd400000",
  	"0x1cda411bd5163baeca1e558563601ce720e24ee1": "0xfc936392801c0000",
  	"0x1ce81d31a7923022e125bf48a3e03693b98dc9dd": "0x6c6b935b8bbd400000",
  	"0x1cebf0985d7f680aaa915c44cc62edb49eab269e": "0x3635c9adc5dea00000",
  	"0x1ced6715f862b1ff86058201fcce5082b36e62b2": "0x16a5e60bee273b10000",
  	"0x1cf04cb14380059efd3f238b65d5beb86afa14d8": "0x1158e460913d00000",
  	"0x1cf105ab23023b554c583e86d7921179ee83169f": "0x6acb3df27e1f880000",
  	"0x1cf2eb7a8ccac2adeaef0ee87347d535d3b94058": "0x6c6b935b8bbd400000",
  	"0x1cfcf7517f0c08459720942b647ad192aa9c8828": "0x2b5e3af16b18800000",
  	"0x1d09ad2412691cc581c1ab36b6f9434cd4f08b54": "0x17b7883c06916600000",
  	"0x1d157c5876c5cad553c912caf6ce2d5277e05c73": "0x6c6b935b8bbd400000",
  	"0x1d2615f8b6ca5012b663bdd094b0c5137c778ddf": "0x21e19e0c9bab2400000",
  	"0x1d29c7aab42b2048d2b25225d498dba67a03fbb2": "0xad78ebc5ac6200000",
  	"0x1d341fa5a3a1bd051f7db807b6db2fc7ba4f9b45": "0xfc936392801c0000",
  	"0x1d344e962567cb27e44db9f2fac7b68df1c1e6f7": "0x692ae8897081d00000",
  	"0x1d36683063b7e9eb99462dabd569bddce71686f2": "0x3635c9adc5dea00000",
  	"0x1d37616b793f94911838ac8e19ee9449df921ec4": "0x5150ae84a8cdf00000",
  	"0x1d395b30adda1cf21f091a4f4a7b753371189441": "0x152d02c7e14af6800000",
  	"0x1d45586eb803ca2190650bf748a2b174312bb507": "0x4be4e7267b6ae00000",
  	"0x1d572edd2d87ca271a6714c15a3b37761dcca005": "0x6ebd52a8ddd390000",
  	"0x1d633097a85225a1ff4321b12988fdd55c2b3844": "0xd8d726b7177a800000",
  	"0x1d69c83d28ff0474ceebeacb3ad227a144ece7a3": "0x128cc03920a62d28000",
  	"0x1d96bcd58457bbf1d3c2a46ffaf16dbf7d836859": "0x9497209d8467e8000",
  	"0x1d9e6aaf8019a05f230e5def05af5d889bd4d0f2": "0x73f75d1a085ba0000",
  	"0x1dab172effa6fbee534c94b17e794edac54f55f8": "0x6acb3df27e1f880000",
  	"0x1db9ac9a9eaeec0a523757050c71f47278c72d50": "0x487a9a304539440000",
  	"0x1dbe8e1c2b8a009f85f1ad3ce80d2e05350ee39c": "0x7570d6e9ebbe40000",
  	"0x1dc7f7dad85df53f1271152403f4e1e4fdb3afa0": "0xad78ebc5ac6200000",
  	"0x1dcebcb7656df5dcaa3368a055d22f9ed6cdd940": "0x1b181e4bf2343c0000",
  	"0x1dd77441844afe9cc18f15d8c77bccfb655ee034": "0x106eb45579944880000",
  	"0x1ddefefd35ab8f658b2471e54790bc17af98dea4": "0x3635c9adc5dea00000",
  	"0x1deec01abe5c0d952de9106c3dc30639d85005d6": "0x6c6b935b8bbd400000",
  	"0x1df6911672679bb0ef3509038c0c27e394fdfe30": "0x1d460162f516f00000",
  	"0x1dfaee077212f1beaf0e6f2f1840537ae154ad86": "0x3635c9adc5dea00000",
  	"0x1e060dc6c5f1cb8cc7e1452e02ee167508b56542": "0x2b14f02c864c77e0000",
  	"0x1e13ec51142cebb7a26083412c3ce35144ba56a1": "0x10f0cf064dd59200000",
  	"0x1e1a4828119be309bd88236e4d482b504dc55711": "0xa030dcebbd2f4c0000",
  	"0x1e1aed85b86c6562cb8fa1eb6f8f3bc9dcae6e79": "0xf4d2dd84259b240000",
  	"0x1e1c6351776ac31091397ecf16002d979a1b2d51": "0x4be4e7267b6ae00000",
  	"0x1e1d7a5f2468b94ea826982dbf2125793c6e4a5a": "0x3634f48417401a0000",
  	"0x1e210e7047886daa52aaf70f4b991dac68e3025e": "0xad78ebc5ac6200000",
  	"0x1e2bf4ba8e5ef18d37de6d6ad636c4cae489d0cc": "0x6c6b935b8bbd400000",
  	"0x1e2fe4e4a77d141ff49a0c7fbc95b0a2b283eeeb": "0x6c6b935b8bbd400000",
  	"0x1e33d1c2fb5e084f2f1d54bc5267727fec3f985d": "0x1b1ae4d6e2ef500000",
  	"0x1e381adcf801a3bf9fd7bfac9ccc2b8482ad5e66": "0x208972c0010d740000",
  	"0x1e3badb1b6e1380e27039c576ae6222e963a5b53": "0x43c33c1937564800000",
  	"0x1e484d0621f0f5331b35d5408d9aae4eb1acf21e": "0x1158e460913d00000",
  	"0x1e5800227d4dcf75e30f5595c5bed3f72e341e3b": "0xd75dace73417e0000",
  	"0x1e596a81b357c6f24970cc313df6dbdaabd0d09e": "0x6c6b935b8bbd400000",
  	"0x1e6915ebd9a19c81b692ad99b1218a592c1ac7b1": "0xd8d726b7177a800000",
  	"0x1e6e0153fc161bc05e656bbb144c7187bf4fe84d": "0x6c6b935b8bbd400000",
  	"0x1e706655e284dcf0bb37fe075d613a18dc12ff4a": "0xed43bf1eee82ac0000",
  	"0x1e783e522ab7df0acaac9eeed3593039e5ac7579": "0x2b1446dd6aefe41c0000",
  	"0x1e7b5e4d1f572becf2c00fc90cb4767b4a6e33d4": "0x61fc6107593e10000",
  	"0x1e8e689b02917cdc29245d0c9c68b094b41a9ed6": "0x6c6b935b8bbd400000",
  	"0x1ea334b5750807ea74aac5ab8694ec5f28aa77cf": "0x1ab2cf7c9f87e20000",
  	"0x1ea4715504c6af107b0194f4f7b1cb6fcccd6f4b": "0x20043197e0b0270000",
  	"0x1ea492bce1ad107e337f4bd4a7ac9a7babcccdab": "0x56bc75e2d63100000",
  	"0x1ea6bf2f15ae9c1dbc64daa7f8ea4d0d81aad3eb": "0xe3aeb5737240a00000",
  	"0x1eb4bf73156a82a0a6822080c6edf49c469af8b9": "0x678a932062e4180000",
  	"0x1ebacb7844fdc322f805904fbf1962802db1537c": "0x21e19e0c9bab2400000",
  	"0x1ec4ec4b77bf19d091a868e6f49154180541f90e": "0x6c6b935b8bbd400000",
  	"0x1ed06ee51662a86c634588fb62dc43c8f27e7c17": "0xad78ebc5ac6200000",
  	"0x1ed8bb3f06778b039e9961d81cb71a73e6787c8e": "0x6c6b935b8bbd400000",
  	"0x1eda084e796500ba14c5121c0d90846f66e4be62": "0x1cfdd7468216e80000",
  	"0x1eee6cbee4fe96ad615a9cf5857a647940df8c78": "0x10d3aa536e2940000",
  	"0x1ef2dcbfe0a500411d956eb8c8939c3d6cfe669d": "0x2a1129d09367200000",
  	"0x1ef5c9c73650cfbbde5c885531d427c7c3fe5544": "0x14542ba12a337c00000",
  	"0x1f0412bfedcd964e837d092c71a5fcbaf30126e2": "0x1158e460913d00000",
  	"0x1f174f40a0447234e66653914d75bc003e5690dc": "0x8ac7230489e800000",
  	"0x1f2186ded23e0cf9521694e4e164593e690a9685": "0x1043561a8829300000",
  	"0x1f2afc0aed11bfc71e77a907657b36ea76e3fb99": "0xd8d726b7177a800000",
  	"0x1f3959fc291110e88232c36b7667fc78a379613f": "0xfc936392801c0000",
  	"0x1f3da68fe87eaf43a829ab6d7ec5a6e009b204fb": "0x1e1601758c2c7e0000",
  	"0x1f49b86d0d3945590698a6aaf1673c37755ca80d": "0x25f273933db5700000",
  	"0x1f5f3b34bd134b2781afe5a0424ac5846cdefd11": "0x55de6a779bbac0000",
  	"0x1f6f0030349752061c96072bc3d6eb3549208d6b": "0x14b8de1eb88db8000",
  	"0x1f7d8e86d6eeb02545aad90e91327bd369d7d2f3": "0x1158e460913d00000",
  	"0x1f8116bd0af5570eaf0c56c49c7ab5e37a580458": "0x6c6b935b8bbd400000",
  	"0x1f88f8a1338fc7c10976abcd3fb8d38554b5ec9c": "0xb9f65d00f63c0000",
  	"0x1f9c3268458da301a2be5ab08257f77bb5a98aa4": "0xad78ebc5ac6200000",
  	"0x1fa2319fed8c2d462adf2e17feec6a6f30516e95": "0x6cae30621d4720000",
  	"0x1fb463a0389983df7d593f7bdd6d78497fed8879": "0x1158e460913d00000",
  	"0x1fb7bd310d95f2a6d9baaf8a8a430a9a04453a8b": "0xa2a15d09519be00000",
  	"0x1fcc7ce6a8485895a3199e16481f72e1f762defe": "0x3635c9adc5dea00000",
  	"0x1fcfd1d57f872290560cb62d600e1defbefccc1c": "0x50c5e761a444080000",
  	"0x1fd296be03ad737c92f9c6869e8d80a71c5714aa": "0xb98bc829a6f90000",
  	"0x1fddd85fc98be9c4045961f40f93805ecc4549e5": "0x8e3f50b173c100000",
  	"0x2001bef77b66f51e1599b02fb110194a0099b78d": "0x6c6b935b8bbd400000",
  	"0x200264a09f8c68e3e6629795280f56254f8640d0": "0x1158e460913d00000",
  	"0x2003717907a72560f4307f1beecc5436f43d21e7": "0x1b1ae4d6e2ef500000",
  	"0x200dfc0b71e359b2b465440a36a6cdc352773007": "0x5150ae84a8cdf00000",
  	"0x20134cbff88bfadc466b52eceaa79857891d831e": "0x3635c9adc5dea00000",
  	"0x2014261f01089f53795630ba9dd24f9a34c2d942": "0x487a9a304539440000",
  	"0x2016895df32c8ed5478269468423aea7b7fbce50": "0x1158e460913d00000",
  	"0x20181c4b41f6f972b66958215f19f570c15ddff1": "0x56bc75e2d631000000",
  	"0x201864a8f784c2277b0b7c9ee734f7b377eab648": "0xf2281400d1d5ec0000",
  	"0x2020b81ae53926ace9f7d7415a050c031d585f20": "0x127f19e83eb3480000",
  	"0x203c6283f20df7bc86542fdfb4e763ecdbbbeef5": "0x54b40b1f852bda00000",
  	"0x204ac98867a7c9c7ed711cb82f28a878caf69b48": "0x14542ba12a337c00000",
  	"0x205237c4be146fba99478f3a7dad17b09138da95": "0x6c6b935b8bbd400000",
  	"0x2053ac97548a0c4e8b80bc72590cd6a098fe7516": "0xa2325753b460c0000",
  	"0x205f5166f12440d85762c967d3ae86184f8f4d98": "0x177224aa844c720000",
  	"0x205fc843e19a4913d1881eb69b69c0fa3be5c50b": "0x20dd68aaf3289100000",
  	"0x206482ee6f138a778fe1ad62b180ce856fbb23e6": "0x6c6b935b8bbd400000",
  	"0x2066774d822793ff25f1760909479cf62491bf88": "0xbae3ac685cb72e00000",
  	"0x206d55d5792a514ec108e090599f2a065e501185": "0xadf30ba70c8970000",
  	"0x20707e425d2a11d2c89f391b2b809f556c592421": "0x6c6b935b8bbd400000",
  	"0x207ef80b5d60b6fbffc51f3a64b8c72036a5abbd": "0x16a6502f15a1e540000",
  	"0x20824ba1dbebbef9846ef3d0f6c1b017e6912ec4": "0x184b26e4daf1d350000",
  	"0x2084fce505d97bebf1ad8c5ff6826fc645371fb2": "0x1a055690d9db80000",
  	"0x208c45732c0a378f17ac8324926d459ba8b658b4": "0xa030dcebbd2f4c0000",
  	"0x209377b6ad3fe101c9685b3576545c6b1684e73c": "0x62a992e53a0af00000",
  	"0x209e8e29d33beae8fb6baa783d133e1d9ec1bc0b": "0x2d43f3ebfafb2c0000",
  	"0x20a15256d50ce058bf0eac43aa533aa16ec9b380": "0x1158e460913d00000",
  	"0x20a29c5079e26b3f18318bb2e50e8e8b346e5be8": "0x1b1ab319f5ec750000",
  	"0x20a81680e465f88790f0074f60b4f35f5d1e6aa5": "0x456180278f0c778000",
  	"0x20b9a9e6bd8880d9994ae00dd0b9282a0beab816": "0x1b1ae4d6e2ef500000",
  	"0x20c284ba10a20830fc3d699ec97d2dfa27e1b95e": "0x6c6b935b8bbd400000",
  	"0x20d1417f99c569e3beb095856530fe12d0fceaaa": "0x4015f94b1183698000",
  	"0x20dd8fcbb46ea46fe381a68b8ca0ea5be21fe9a5": "0x6c6b935b8bbd400000",
  	"0x20ff3ede8cadb5c37b48cb14580fb65e23090a7b": "0x8e4d316827686400000",
  	"0x2100381d60a5b54adc09d19683a8f6d5bb4bfbcb": "0x21e19e0c9bab2400000",
  	"0x2118c116ab0cdf6fd11d54a4309307b477c3fc0f": "0x21e19e0c9bab2400000",
  	"0x211b29cefc79ae976744fdebcebd3cbb32c51303": "0x2f6f10780d22cc00000",
  	"0x21206ce22ea480e85940d31314e0d64f4e4d3a04": "0x3635c9adc5dea00000",
  	"0x2132c0516a2e17174ac547c43b7b0020d1eb4c59": "0x35659ef93f0fc40000",
  	"0x21408b4d7a2c0e6eca4143f2cacdbbccba121bd8": "0x43c33c1937564800000",
  	"0x214b743955a512de6e0d886a8cbd0282bee6d2a2": "0x6c6b935b8bbd400000",
  	"0x214c89c5bd8e7d22bc574bb35e48950211c6f776": "0x10654f258fd358000",
  	"0x21546914dfd3af2add41b0ff3e83ffda7414e1e0": "0x14395e7385a502e0000",
  	"0x21582e99e502cbf3d3c23bdffb76e901ac6d56b2": "0x56bc75e2d63100000",
  	"0x2159240813a73095a7ebf7c3b3743e8028ae5f09": "0x6c6b935b8bbd400000",
  	"0x2160b4c02cac0a81de9108de434590a8bfe68735": "0x6acb3df27e1f880000",
  	"0x216e41864ef98f060da08ecae19ad1166a17d036": "0x1369fb96128ac480000",
  	"0x21846f2fdf5a41ed8df36e5ed8544df75988ece3": "0x6c6acc67d7b1d40000",
  	"0x21a6db6527467bc6dad54bc16e9fe2953b6794ed": "0x2f6f10780d22cc00000",
  	"0x21a6feb6ab11c766fdd977f8df4121155f47a1c0": "0x319cf38f100580000",
  	"0x21b182f2da2b384493cf5f35f83d9d1ee14f2a21": "0x6c6b935b8bbd400000",
  	"0x21bfe1b45cacde6274fd8608d9a178bf3eeb6edc": "0x6cee06ddbe15ec0000",
  	"0x21c07380484f6cbc8724ad32bc864c3b5ad500b7": "0x3635c9adc5dea00000",
  	"0x21c3a8bba267c8cca27b1a9afabad86f607af708": "0x1e4a36c49d998300000",
  	"0x21ce6d5b9018cec04ad6967944bea39e8030b6b8": "0x1158e460913d00000",
  	"0x21d02705f3f64905d80ed9147913ea8c7307d695": "0x49edb1c09887360000",
  	"0x21d13f0c4024e967d9470791b50f22de3afecf1b": "0xf15ad35e2e31e50000",
  	"0x21dbdb817a0d8404c6bdd61504374e9c43c9210e": "0x21e18b9e9ab45e48000",
  	"0x21df1ec24b4e4bfe79b0c095cebae198f291fbd1": "0x43c33c1937564800000",
  	"0x21df2dcdaf74b2bf803404dd4de6a35eabec1bbd": "0x177224aa844c7200000",
  	"0x21e219c89ca8ac14ae4cba6130eeb77d9e6d3962": "0x2acd9faaa038ee0000",
  	"0x21e5d2bae995ccfd08a5c16bb524e1f630448f82": "0x97c9ce4cf6d5c00000",
  	"0x21e5d77320304c201c1e53b261a123d0a1063e81": "0x4b6fa9d33dd460000",
  	"0x21eae6feffa9fbf4cd874f4739ace530ccbe5937": "0x10f0cf064dd59200000",
  	"0x21ecb2dfa65779c7592d041cd2105a81f4fd4e46": "0x3635c9adc5dea00000",
  	"0x21efbca09b3580b98e73f5b2f7f4dc0bf02c529c": "0x6c6b935b8bbd400000",
  	"0x21fd0bade5f4ef7474d058b7f3d854cb1300524e": "0x1158e460913d00000",
  	"0x21fd47c5256012198fa5abf131c06d6aa1965f75": "0x1ab2cf7c9f87e200000",
  	"0x21fd6c5d97f9c600b76821ddd4e776350fce2be0": "0x6c6ad382d4fb610000",
  	"0x220dc68df019b6b0ccbffb784b5a5ab4b15d4060": "0xd5967be4fc3f100000",
  	"0x220e2b92c0f6c902b513d9f1e6fab6a8b0def3d7": "0x2b5e3af16b18800000",
  	"0x22561c5931143536309c17e832587b625c390b9a": "0xd8d726b7177a800000",
  	"0x2257fca16a6e5c2a647c3c29f36ce229ab93b17e": "0xd8d726b7177a800000",
  	"0x225d35faedb391c7bc2db7fa9071160405996d00": "0x91854fc1862630000",
  	"0x225f9eb3fb6ff3e9e3c8447e14a66e8d4f3779f6": "0x6c6b935b8bbd400000",
  	"0x2272186ef27dcbe2f5fc373050fdae7f2ace2316": "0x368c8623a8b4d100000",
  	"0x2273bad7bc4e487622d175ef7a66988b6a93c4ee": "0x1158e460913d00000",
  	"0x2276264bec8526c0c0f270677abaf4f0e441e167": "0x3635c9adc5dea00000",
  	"0x228242f8336eecd8242e1f000f41937e71dffbbf": "0x10f0cf064dd59200000",
  	"0x22842ab830da509913f81dd1f04f10af9edd1c55": "0x6c6b935b8bbd400000",
  	"0x22944fbca9b57963084eb84df7c85fb9bcdfb856": "0xfc118fef90ba388000",
  	"0x229cc4711b62755ea296445ac3b77fc633821cf2": "0x223e8b05219328000",
  	"0x229e430de2b74f442651ddcdb70176bc054cad54": "0xbbf981bc4aaa8000",
  	"0x229f4f1a2a4f540774505b4707a81de44410255b": "0x6c6b935b8bbd400000",
  	"0x229ff80bf5708009a9f739e0f8b560914016d5a6": "0x1211ecb56d13488000",
  	"0x22a25812ab56dcc423175ed1d8adacce33cd1810": "0x6449e84e47a8a80000",
  	"0x22b96ab2cad55db100b53001f9e4db378104c807": "0x21e19e0c9bab2400000",
  	"0x22bdffc240a88ff7431af3bff50e14da37d5183e": "0x3635c9adc5dea00000",
  	"0x22ce349159eeb144ef06ff2636588aef79f62832": "0xa31062beeed700000",
  	"0x22db559f2c3c1475a2e6ffe83a5979599196a7fa": "0x3635c9adc5dea00000",
  	"0x22e15158b5ee3e86eb0332e3e6a9ac6cd9b55ecd": "0x8ac7230489e800000",
  	"0x22e2488e2da26a49ae84c01bd54b21f2947891c6": "0x5dc892aa1131c80000",
  	"0x22e512149a18d369b73c71efa43e86c9edabaf1d": "0x4ee02e6714615c0000",
  	"0x22eb7db0ba56b0f8b816ccb206e615d929185b0d": "0x45d29737e22f20000",
  	"0x22eed327f8eb1d1338a3cb7b0f8a4baa5907cd95": "0x1455d5f4877088000",
  	"0x22f004df8de9e6ebf523ccace457accb26f97281": "0x21e19e0c9bab2400000",
  	"0x22f2dcff5ad78c3eb6850b5cb951127b659522e6": "0xbe202d6a0eda0000",
  	"0x22f3c779dd79023ea92a78b65c1a1780f62d5c4a": "0x6acb3df27e1f880000",
  	"0x22fe884d9037291b4d52e6285ae68dea0be9ffb5": "0x6c6b935b8bbd400000",
  	"0x2306df931a940d58c01665fa4d0800802c02edfe": "0x3635c9adc5dea00000",
  	"0x2309d34091445b3232590bd70f4f10025b2c9509": "0x21e19e0c9bab2400000",
  	"0x23120046f6832102a752a76656691c863e17e59c": "0x11e0e4f8a50bd40000",
  	"0x231a15acc199c89fa9cb22441cc70330bdcce617": "0x1b1ae4d6e2ef500000",
  	"0x231d94155dbcfe2a93a319b6171f63b20bd2b6fa": "0xcf147bb906e2f80000",
  	"0x232832cd5977e00a4c30d0163f2e24f088a6cb09": "0xa2a15d09519be00000",
  	"0x232c6d03b5b6e6711efff190e49c28eef36c82b0": "0x487a9a304539440000",
  	"0x232cb1cd49993c144a3f88b3611e233569a86bd6": "0x34c606c42d0ac600000",
  	"0x232ce782506225fd9860a2edc14a7a3047736da2": "0x1158e460913d00000",
  	"0x232f525d55859b7d4e608d20487faadb00293135": "0xd8d726b7177a800000",
  	"0x2334c590c7a48769103045c5b6534c8a3469f44a": "0x3b199073df72dc00000",
  	"0x23376ecabf746ce53321cf42c86649b92b67b2ff": "0x6c6b935b8bbd400000",
  	"0x23378f42926d0184b793b0c827a6dd3e3d334fcd": "0x30927f74c9de00000",
  	"0x233842b1d0692fd11140cf5acda4bf9630bae5f8": "0x6c6b935b8bbd400000",
  	"0x2339e9492870afea2537f389ac2f838302a33c06": "0x6c6b935b8bbd400000",
  	"0x233bdddd5da94852f4ade8d212885682d9076bc6": "0xd8d726b7177a800000",
  	"0x234f46bab73fe45d31bf87f0a1e0466199f2ebac": "0x1a4aba225c20740000",
  	"0x23551f56975fe92b31fa469c49ea66ee6662f41e": "0x678a932062e4180000",
  	"0x23569542c97d566018c907acfcf391d14067e87e": "0x6c6b935b8bbd400000",
  	"0x235fa66c025ef5540070ebcf0d372d8177c467ab": "0x7129e1cdf373ee00000",
  	"0x2372c4c1c9939f7aaf6cfac04090f00474840a09": "0x21e19e0c9bab2400000",
  	"0x23730c357a91026e44b1d0e2fc2a51d071d8d77b": "0xd8d726b7177a800000",
  	"0x2376ada90333b1d181084c97e645e810aa5b76f1": "0x28a857425466f80000",
  	"0x2378fd4382511e968ed192106737d324f454b535": "0x3635c9adc5dea00000",
  	"0x2382a9d48ec83ea3652890fd0ee79c907b5b2dc1": "0x73f75d1a085ba0000",
  	"0x2383c222e67e969190d3219ef14da37850e26c55": "0x6c6b935b8bbd400000",
  	"0x238a6b7635252f5244486c0af0a73a207385e039": "0x4a4491bd6dcd280000",
  	"0x239a733e6b855ac592d663156186a8a174d2449e": "0x58be3758b241f60000",
  	"0x23ab09e73f87aa0f3be0139df0c8eb6be5634f95": "0x1b1ae4d6e2ef5000000",
  	"0x23abd9e93e7957e5b636be6579051c15e5ce0b0e": "0x3a3c8f7cbf42c380000",
  	"0x23b1c4917fbd93ee3d48389306957384a5496cbf": "0xd8d8583fa2d52f0000",
  	"0x23ba3864da583dab56f420873c37679690e02f00": "0x21342520d5fec200000",
  	"0x23c55aeb5739876f0ac8d7ebea13be729685f000": "0x487a9a304539440000",
  	"0x23c99ba087448e19c9701df66e0cab52368331fa": "0x6c6b935b8bbd400000",
  	"0x23ccc3c6acd85c2e460c4ffdd82bc75dc849ea14": "0xd8d726b7177a800000",
  	"0x23cd2598a20e149ead2ad69379576ecedb60e38e": "0x6c6b935b8bbd400000",
  	"0x23df8f48ee009256ea797e1fa369beebcf6bc663": "0x7cd3fac26d19818000",
  	"0x23e2c6a8be8e0acfa5c4df5e36058bb7cbac5a81": "0x6c6b935b8bbd400000",
  	"0x23ea669e3564819a83b0c26c00a16d9e826f6c46": "0x4d8d6ca968ca130000",
  	"0x23eb6fd85671a9063ab7678ebe265a20f61a02b3": "0x6c6b935b8bbd400000",
  	"0x23f9ecf3e5dddca38815d3e59ed34b5b90b4a353": "0xb1781a3f0bb200000",
  	"0x23fa7eb51a48229598f97e762be0869652dffc66": "0x3635c9adc5dea00000",
  	"0x240305727313d01e73542c775ff59d11cd35f819": "0x141885666807f5c8000",
  	"0x24046b91da9b61b629cb8b8ec0c351a07e0703e4": "0x6c6b935b8bbd400000",
  	"0x240e559e274aaef0c258998c979f671d1173b88b": "0xd8d726b7177a800000",
  	"0x241361559feef80ef137302153bd9ed2f25db3ef": "0x43c33c1937564800000",
  	"0x243b3bca6a299359e886ce33a30341fafe4d573d": "0x43c33c1937564800000",
  	"0x243c84d12420570cc4ef3baba1c959c283249520": "0x7f1f6993a853040000",
  	"0x24434a3e32e54ecf272fe3470b5f6f512f675520": "0x14061b9d77a5e980000",
  	"0x2448596f91c09baa30bc96106a2d37b5705e5d28": "0x6c6b935b8bbd400000",
  	"0x24586ec5451735eeaaeb470dc8736aae752f82e5": "0xf43fc2c04ee00000",
  	"0x2458d6555ff98a129cce4037953d00206eff4287": "0xaadec983fcff40000",
  	"0x246291165b59332df5f18ce5c98856fae95897d6": "0x5c283d410394100000",
  	"0x2467c6a5c696ede9a1e542bf1ad06bcc4b06aca0": "0x100bd33fb98ba0000",
  	"0x2476b2bb751ce748e1a4c4ff7b230be0c15d2245": "0xd8d726b7177a800000",
  	"0x247a0a11c57f0383b949de540b66dee68604b0a1": "0x39fbae8d042dd00000",
  	"0x2487c3c4be86a2723d917c06b458550170c3edba": "0x3635c9adc5dea00000",
  	"0x2489ac126934d4d6a94df08743da7b7691e9798e": "0x3635c9adc5dea00000",
  	"0x249db29dbc19d1235da7298a04081c315742e9ac": "0x61acff81a78ad40000",
  	"0x24a4eb36a7e498c36f99975c1a8d729fd6b305d7": "0xdfc78210eb2c80000",
  	"0x24a750eae5874711116dd7d47b7186ce990d3103": "0xad78ebc5ac6200000",
  	"0x24aa1151bb765fa3a89ca50eb6e1b1c706417fd4": "0xa80d24677efef00000",
  	"0x24aca08d5be85ebb9f3132dfc1b620824edfedf9": "0xfc936392801c0000",
  	"0x24b2be118b16d8b2174769d17b4cf84f07ca946d": "0x6c6b935b8bbd400000",
  	"0x24b8b446debd1947955dd084f2c544933346d3ad": "0xea696d904039bd8000",
  	"0x24b95ebef79500baa0eda72e77f877415df75c33": "0x3154c9729d05780000",
  	"0x24b9e6644f6ba4cde126270d81f6ab60f286dff4": "0x73f75d1a085ba0000",
  	"0x24bd5904059091d2f9e12d6a26a010ca22ab14e8": "0x65ea3db75546600000",
  	"0x24c0c88b54a3544709828ab4ab06840559f6c5e2": "0x90f534608a72880000",
  	"0x24c117d1d2b3a97ab11a4679c99a774a9eade8d1": "0x3635c9adc5dea00000",
  	"0x24cff0e9336a9f80f9b1cb968caf6b1d1c4932a4": "0xada55474b81340000",
  	"0x24daaaddf7b06bbcea9b80590085a88567682b4e": "0x114b2015d2bbd00000",
  	"0x24dcc24bd9c7210ceacfb30da98ae04a4d7b8ab9": "0x3635c9adc5dea00000",
  	"0x24f7450ddbf18b020feb1a2032d9d54b633edf37": "0x2b5e3af16b1880000",
  	"0x24fc73d20793098e09ddab5798506224fa1e1850": "0xad78ebc5ac6200000",
  	"0x24fd9a6c874c2fab3ff36e9afbf8ce0d32c7de92": "0x487a9a304539440000",
  	"0x250a40cef3202397f240469548beb5626af4f23c": "0x503b203e9fba20000",
  	"0x250a69430776f6347703f9529783955a6197b682": "0x692ae8897081d00000",
  	"0x250eb7c66f869ddf49da85f3393e980c029aa434": "0xd8d726b7177a800000",
  	"0x25106ab6755df86d6b63a187703b0cfea0e594a0": "0x17c405ad41db40000",
  	"0x25185f325acf2d64500698f65c769ddf68301602": "0x10f0cf064dd59200000",
  	"0x251c12722c6879227992a304eb3576cd18434ea5": "0x6c6b935b8bbd400000",
  	"0x251e6838f7cec5b383c1d90146341274daf8e502": "0x7ff1ccb7561df0000",
  	"0x25259d975a21d83ae30e33f800f53f37dfa01938": "0x1158e460913d00000",
  	"0x25287b815f5c82380a73b0b13fbaf982be24c4d3": "0x22b1c8c1227a00000",
  	"0x252b6555afdc80f2d96d972d17db84ea5ad521ac": "0x1ab2cf7c9f87e200000",
  	"0x2538532936813c91e653284f017c80c3b8f8a36f": "0x6c8754c8f30c080000",
  	"0x253e32b74ea4490ab92606fda0aa257bf23dcb8b": "0x21e19e0c9bab2400000",
  	"0x253f1e742a2cec86b0d7b306e5eacb6ccb2f8554": "0x43e5ede1f878c200000",
  	"0x2541314a0b408e95a694444977712a50713591ab": "0x589e1a5df4d7b50000",
  	"0x254c1ecc630c2877de8095f0a8dba1e8bf1f550c": "0x5c283d410394100000",
  	"0x255abc8d08a096a88f3d6ab55fbc7352bddcb9ce": "0x4743682313ede8000",
  	"0x255bdd6474cc8262f26a22c38f45940e1ceea69b": "0xd8d726b7177a800000",
  	"0x2560b09b89a4ae6849ed5a3c9958426631714466": "0x5c283d410394100000",
  	"0x2561a138dcf83bd813e0e7f108642be3de3d6f05": "0x3634f48417401a0000",
  	"0x2561ec0f379218fe5ed4e028a3f744aa41754c72": "0xb98bc829a6f90000",
  	"0x256292a191bdda34c4da6b6bd69147bf75e2a9ab": "0xc2ff2e0dfb038000",
  	"0x25697ef20cccaa70d32d376f8272d9c1070c3d78": "0xad78ebc5ac6200000",
  	"0x256fa150cc87b5056a07d004efc84524739e62b5": "0xad78ebc5ac6200000",
  	"0x25721c87b0dc21377c7200e524b14a22f0af69fb": "0xd8d726b7177a800000",
  	"0x258939bbf00c9de9af5338f5d714abf6d0c1c671": "0x54069233bf7f780000",
  	"0x2590126870e0bde8a663ab040a72a5573d8d41c2": "0x10f0cf064dd59200000",
  	"0x259ec4d265f3ab536b7c70fa97aca142692c13fc": "0x11b1b5bea89f80000",
  	"0x25a500eeec7a662a841552b5168b707b0de21e9e": "0x21f2f6f0fc3c6100000",
  	"0x25a5a44d38a2f44c6a9db9cdbc6b1e2e97abb509": "0x39992648a23c8a00000",
  	"0x25a74c2ac75dc8baa8b31a9c7cb4b7829b2456da": "0x6c6b935b8bbd400000",
  	"0x25adb8f96f39492c9bb47c5edc88624e46075697": "0x5a9940bc56879500000",
  	"0x25aee68d09afb71d8817f3f184ec562f7897b734": "0x6c6b935b8bbd400000",
  	"0x25b0533b81d02a617b9229c7ec5d6f2f672e5b5a": "0x3635c9adc5dea00000",
  	"0x25b78c9fad85b43343f0bfcd0fac11c9949ca5eb": "0x6c6b935b8bbd400000",
  	"0x25bc49ef288cd165e525c661a812cf84fbec8f33": "0x125921aebda9d00000",
  	"0x25bdfa3ee26f3849617b230062588a97e3cae701": "0x3635e619bb04d40000",
  	"0x25c1a37ee5f08265a1e10d3d90d5472955f97806": "0x62a992e53a0af00000",
  	"0x25c6e74ff1d928df98137af4df8430df24f07cd7": "0x15245655b102580000",
  	"0x25cfc4e25c35c13b69f7e77dbfb08baf58756b8d": "0x878678326eac9000000",
  	"0x25dad495a11a86b9eeece1eeec805e57f157faff": "0x3635c9adc5dea000000",
  	"0x25e037f00a18270ba5ec3420229ddb0a2ce38fa2": "0x21e19e0c9bab2400000",
  	"0x25e661c939863acc044e6f17b5698cce379ec3cc": "0x4a4491bd6dcd280000",
  	"0x26048fe84d9b010a62e731627e49bc2eb73f408f": "0xd8d726b7177a800000",
  	"0x2606c3b3b4ca1b091498602cb1978bf3b95221c0": "0x15af1d78b58c400000",
  	"0x260a230e4465077e0b14ee4442a482d5b0c914bf": "0x5af606a06b5b118000",
  	"0x260df8943a8c9a5dba7945327fd7e0837c11ad07": "0xad78ebc5ac6200000",
  	"0x2614f42d5da844377578e6b448dc24305bef2b03": "0x6c6b935b8bbd400000",
  	"0x2615100ea7e25bba9bca746058afbbb4ffbe4244": "0x1b1ae4d6e2ef500000",
  	"0x261575e9cf59c8226fa7aaf91de86fb70f5ac3ae": "0x1043a4436a523f0000",
  	"0x261e0fa64c51137465eecf5b90f197f7937fdb05": "0x3cfc82e37e9a7400000",
  	"0x262a8bfd7d9dc5dd3ad78161b6bb560824373655": "0x3f6a8384072b760000",
  	"0x262aed4bc0f4a4b2c6fb35793e835a49189cdfec": "0x21e19e0c9bab2400000",
  	"0x262dc1364ccf6df85c43268ee182554dae692e29": "0x10b202fec74ced80000",
  	"0x263814309de4e635cf585e0d365477fc40e66cf7": "0x7ea28327577080000",
  	"0x2639eee9873ceec26fcc9454b548b9e7c54aa65c": "0x3635c9adc5dea00000",
  	"0x263e57dacbe0149f82fe65a2664898866ff5b463": "0x80bfbefcb5f0bc00000",
  	"0x26475419c06d5f147aa597248eb46cf7befa64a5": "0x58e7926ee858a00000",
  	"0x264cc8086a8710f91b21720905912cd7964ae868": "0x1731790534df20000",
  	"0x265383d68b52d034161bfab01ae1b047942fbc32": "0x47271dee20d745c0000",
  	"0x2659facb1e83436553b5b42989adb8075f9953ed": "0x1976576771a5e0000",
  	"0x266f2da7f0085ef3f3fa09baee232b93c744db2e": "0xcb49b44ba602d800000",
  	"0x267148fd72c54f620a592fb92799319cc4532b5c": "0x1639e49bba16280000",
  	"0x26784ade91c8a83a8e39658c8d8277413ccc9954": "0x14542ba12a337c00000",
  	"0x267a7e6e82e1b91d51deddb644f0e96dbb1f7f7e": "0x1158e460913d00000",
  	"0x2680713d40808e2a50ed013150a2a694b96a7f1d": "0x61093d7c2c6d380000",
  	"0x2697b339813b0c2d964b2471eb1c606f4ecb9616": "0x3e8ef795d890c80000",
  	"0x26a68eab905a8b3dce00e317308225dab1b9f6b8": "0x6b56051582a9700000",
  	"0x26b11d066588ce74a572a85a6328739212aa8b40": "0x6c6b935b8bbd400000",
  	"0x26babf42b267fdcf3861fdd4236a5e474848b358": "0x3635c9adc5dea00000",
  	"0x26c0054b700d3a7c2dcbe275689d4f4cad16a335": "0x6c6b935b8bbd400000",
  	"0x26c2ffc30efdc5273e76183a16c2698d6e531286": "0x2a1129d09367200000",
  	"0x26c99f8849c9802b83c861217fd07a9e84cdb79d": "0x1043561a8829300000",
  	"0x26cfffd052152bb3f957b478d5f98b233a7c2b92": "0xd8d726b7177a800000",
  	"0x26d4a16891f52922789217fcd886f7fce296d400": "0x6c6b935b8bbd400000",
  	"0x26d4ec17d5ceb2c894bdc59d0a6a695dad2b43cc": "0x9f1f78761d341a0000",
  	"0x26e801b62c827191dd68d31a011990947fd0ebe0": "0x1158e460913d00000",
  	"0x26e9e2ad729702626417ef25de0dc800f7a779b3": "0x3635c9adc5dea00000",
  	"0x26f9f7cefd7e394b9d3924412bf2c2831faf1f85": "0xd8d726b7177a800000",
  	"0x26fe174cbf526650e0cd009bd6126502ce8e684d": "0x277017338a30ae00000",
  	"0x26ff0a51e7cece8400276978dbd6236ef162c0e6": "0x152e185627540a500000",
  	"0x27101a0f56d39a88c5a84f9b324cdde33e5cb68c": "0x6c6b935b8bbd400000",
  	"0x27144ca9a7771a836ad50f803f64d869b2ae2b20": "0xd8d726b7177a800000",
  	"0x27146913563aa745e2588430d9348e86ea7c3510": "0x15af1d78b58c400000",
  	"0x271d3d481cb88e7671ad216949b6365e06303de0": "0xd8d726b7177a800000",
  	"0x2720f9ca426ef2f2cbd2fecd39920c4f1a89e16d": "0x6c6b935b8bbd400000",
  	"0x272a131a5a656a7a3aca35c8bd202222a7592258": "0x90f534608a72880000",
  	"0x2744ff67464121e35afc2922177164fa2fcb0267": "0x56bc75e2d63100000",
  	"0x274a3d771a3d709796fbc4d5f48fce2fe38c79d6": "0x1158e460913d00000",
  	"0x274d69170fe7141401882b886ac4618c6ae40edb": "0x33c5499031720c0000",
  	"0x27521deb3b6ef1416ea4c781a2e5d7b36ee81c61": "0x6c6b935b8bbd400000",
  	"0x275875ff4fbb0cf3a430213127487f7608d04cba": "0x1b1c010e766d580000",
  	"0x276a006e3028ecd44cdb62ba0a77ce94ebd9f10f": "0x6194049f30f7200000",
  	"0x276b0521b0e68b277df0bb32f3fd48326350bfb2": "0x2b5e3af16b1880000",
  	"0x276fd7d24f8f883f5a7a28295bf17151c7a84b03": "0x6c6b935b8bbd400000",
  	"0x2770f14efb165ddeba79c10bb0af31c31e59334c": "0xa2a15d09519be00000",
  	"0x277677aba1e52c3b53bfa2071d4e859a0af7e8e1": "0x3635c9adc5dea00000",
  	"0x27824666d278d70423f03dfe1dc7a3f02f43e2b5": "0x3636c25e66ece70000",
  	"0x27830c5f6023afaaf79745676c204a0faccda0ba": "0xd02ab486cedc00000",
  	"0x2784903f1d7c1b5cd901f8875d14a79b3cbe2a56": "0x4bda7e9d74ad5500000",
  	"0x278c0bde630ec393b1e7267fc9d7d97019e4145b": "0x6c6b935b8bbd400000",
  	"0x27987110221a880826adb2e7ab5eca78c6e31aec": "0xd8d726b7177a800000",
  	"0x27ac073be79ce657a93aa693ee43bf0fa41fef04": "0xa968163f0a57b400000",
  	"0x27b1694eafa165ebd7cc7bc99e74814a951419dc": "0x2b5e3af16b18800000",
  	"0x27b62816e1e3b8d19b79d1513d5dfa855b0c3a2a": "0x56af5c1fd69508000",
  	"0x27bf943c1633fe32f8bcccdb6302b407a5724e44": "0x32f84c6df408c08000",
  	"0x27bf9f44ba7d05c33540c3a53bb02cbbffe7c3c6": "0x6c6b935b8bbd400000",
  	"0x27c2d7ca504daa3d9066dc09137dc42f3aaab452": "0x2086ac351052600000",
  	"0x27d158ac3d3e1109ab6e570e90e85d3892cd7680": "0x56bc75e2d63100000",
  	"0x27e63989ca1e903bc620cf1b9c3f67b9e2ae6581": "0x487a9a304539440000",
  	"0x27f03cf1abc5e1b51dbc444b289e542c9ddfb0e6": "0x10f0cf064dd59200000",
  	"0x27fc85a49cff90dbcfdadc9ddd40d6b9a2210a6c": "0x56bc75e2d63100000",
  	"0x2805415e1d7fdec6dedfb89e521d10592d743c10": "0x56bc75e2d63100000",
  	"0x28073efc17d05cab3195c2db332b61984777a612": "0x3635c9adc5dea00000",
  	"0x281250a29121270a4ee5d78d24feafe82c70ba3a": "0x3635c9adc5dea00000",
  	"0x2813d263fc5ff2479e970595d6b6b560f8d6d6d1": "0x6c6b935b8bbd400000",
  	"0x282e80a554875a56799fa0a97f5510e795974c4e": "0x3635c9adc5dea00000",
  	"0x283396ce3cac398bcbe7227f323e78ff96d08767": "0x15af1d78b58c400000",
  	"0x28349f7ef974ea55fe36a1583b34cec3c45065f0": "0xcb633d49e65590000",
  	"0x2836123046b284e5ef102bfd22b1765e508116ad": "0x1653fbb5c427e40000",
  	"0x283c2314283c92d4b064f0aef9bb5246a7007f39": "0xad78ebc5ac6200000",
  	"0x283e11203749b1fa4f32febb71e49d135919382a": "0x3635c9adc5dea00000",
  	"0x283e6252b4efcf4654391acb75f903c59b78c5fb": "0x28a857425466f800000",
  	"0x28510e6eff1fc829b6576f4328bc3938ec7a6580": "0x21e19e0c9bab2400000",
  	"0x2858acacaf21ea81cab7598fdbd86b452e9e8e15": "0x241a9b4f617a280000",
  	"0x285ae51b9500c58d541365d97569f14bb2a3709b": "0x6c6b935b8bbd400000",
  	"0x2866b81decb02ee70ae250cee5cdc77b59d7b679": "0x6c6b935b8bbd400000",
  	"0x286906b6bd4972e3c71655e04baf36260c7cb153": "0x126e72a69a50d00000",
  	"0x286b186d61ea1fd78d9930fe12b06537b05c3d51": "0x3635c9adc5dea00000",
  	"0x2874f3e2985d5f7b406627e17baa772b01abcc9e": "0x146050410765f380000",
  	"0x287cf9d0902ef819a7a5f149445bf1775ee8c47c": "0x3635c9adc5dea000000",
  	"0x28818e18b610001321b31df6fe7d2815cdadc9f5": "0x3635c9adc5dea00000",
  	"0x28868324337e11ba106cb481da962f3a8453808d": "0x6c6b935b8bbd400000",
  	"0x28904bb7c4302943b709b14d7970e42b8324e1a1": "0x21f97846a072d7e0000",
  	"0x2895e80999d406ad592e2b262737d35f7db4b699": "0x692ae8897081d00000",
  	"0x28967280214e218a120c5dda37041b111ea36d74": "0xad78ebc5ac6200000",
  	"0x28a3da09a8194819ae199f2e6d9d1304817e28a5": "0x6c6b935b8bbd400000",
  	"0x28ab165ffb69eda0c549ae38e9826f5f7f92f853": "0x464df6d7c844590000",
  	"0x28b77585cb3d55a199ab291d3a18c68fe89a848a": "0x6a4076cf7995a00000",
  	"0x28d4ebf41e3d3c451e943bdd7e1f175fae932a3d": "0x14542ba12a337c00000",
  	"0x28d7e5866f1d85fd1ceb32bfbe1dfc36db434566": "0x1864231c610351c0000",
  	"0x28d8c35fb7eea622582135e3ad47a227c9a663bd": "0xfc936392801c0000",
  	"0x28e4af30cd93f686a122ad7bb19f8a8785eee342": "0x71e53b706cc7b40000",
  	"0x28eaea78cd4d95faecfb68836eafe83520f3bbb7": "0xad78ebc5ac6200000",
  	"0x28efae6356509edface89fc61a7fdcdb39eea8e5": "0x121ea68c114e5100000",
  	"0x28fa2580f9ebe420f3e5eefdd371638e3b7af499": "0x14542ba12a337c00000",
  	"0x2901f8077f34190bb47a8e227fa29b30ce113b31": "0x56bc75e2d63100000",
  	"0x2905b192e83ce659aa355b9d0c204e3e95f9bb9a": "0x75235c1d00393e8000",
  	"0x290a56d41f6e9efbdcea0342e0b7929a8cdfcb05": "0x12a5f58168ee600000",
  	"0x2915624bcb679137b8dae9ab57d11b4905eaee4b": "0x1158e460913d00000",
  	"0x291efe0081dce8c14799f7b2a43619c0c3b3fc1f": "0x410d586a20a4c00000",
  	"0x291f929ca59b54f8443e3d4d75d95dee243cef78": "0x1b1a089237073d0000",
  	"0x29298ccbdff689f87fe41aa6e98fdfb53deaf37a": "0x4315c32d71a9e600000",
  	"0x292f228b0a94748c8eec612d246f989363e08f08": "0xa076407d3f7440000",
  	"0x293384c42b6f8f2905ce52b7205c2274376c612b": "0x4be4e7267b6ae00000",
  	"0x2934c0df7bbc172b6c186b0b72547ace8bf75454": "0x340aad21b3b700000",
  	"0x293c2306df3604ae4fda0d207aba736f67de0792": "0xad78ebc5ac6200000",
  	"0x2949fd1def5c76a286b3872424809a07db3966f3": "0x11bd906daa0c9438000",
  	"0x294f494b3f2e143c2ffc9738cbfd9501850b874e": "0x796e3ea3f8ab000000",
  	"0x2955c357fd8f75d5159a3dfa69c5b87a359dea8c": "0x6c6b935b8bbd400000",
  	"0x2961fb391c61957cb5c9e407dda29338d3b92c80": "0x3634fb9f1489a70000",
  	"0x29681d9912ddd07eaabb88d05d90f766e862417d": "0x3635c9adc5dea00000",
  	"0x296b71c0015819c242a7861e6ff7eded8a5f71e3": "0x6c68ccd09b022c0000",
  	"0x296d66b521571a4e4103a7f562c511e6aa732d81": "0x243d4d18229ca20000",
  	"0x296f00de1dc3bb01d47a8ccd1e5d1dd9a1eb7791": "0x3635c9adc5dea00000",
  	"0x297385e88634465685c231a314a0d5dcd146af01": "0x54069233bf7f780000",
  	"0x29763dd6da9a7c161173888321eba6b63c8fb845": "0x11c7ea162e78200000",
  	"0x2979741174a8c1ea0b7f9edf658177859417f512": "0x1901966c8496838000",
  	"0x297a88921b5fca10e5bb9ded60025437ae221694": "0xad78ebc5ac6200000",
  	"0x297d5dbe222f2fb52531acbd0b013dc446ac7368": "0x43c33c1937564800000",
  	"0x29824e94cc4348bc963279dcdf47391715324cd3": "0x692ae8897081d00000",
  	"0x2982d76a15f847dd41f1922af368fe678d0e681e": "0x56bc75e2d63100000",
  	"0x298887bab57c5ba4f0615229d7525fa113b7ea89": "0x22b1c8c1227a00000",
  	"0x298ec76b440d8807b3f78b5f90979bee42ed43db": "0x65a4da25d3016c00000",
  	"0x299368609042a858d1ecdf1fc0ada5eaceca29cf": "0x6c6b935b8bbd400000",
  	"0x299e0bca55e069de8504e89aca6eca21d38a9a5d": "0x302379bf2ca2e0000",
  	"0x29ac2b458454a36c7e96c73a8667222a12242c71": "0xd8d726b7177a800000",
  	"0x29adcf83b6b20ac6a434abb1993cbd05c60ea2e4": "0x21e19e0c9bab2400000",
  	"0x29aef48de8c9fbad4b9e4ca970797a5533eb722d": "0x21e19e0c9bab2400000",
  	"0x29b3f561ee7a6e25941e98a5325b78adc79785f3": "0x56bc75e2d63100000",
  	"0x29bdc4f28de0180f433c2694eb74f5504ce94337": "0x6c6b935b8bbd400000",
  	"0x29cc804d922be91f5909f348b0aaa5d21b607830": "0xd8d726b7177a800000",
  	"0x29da3e35b23bb1f72f8e2258cf7f553359d24bac": "0x43c33c1937564800000",
  	"0x29e67990e1b6d52e1055ffe049c53195a81542cf": "0x43c33c1937564800000",
  	"0x29eaae82761762f4d2db53a9c68b0f6b0b6d4e66": "0x6c6b935b8bbd400000",
  	"0x29eb7eefdae9feb449c63ff5f279d67510eb1422": "0x10d3aa536e2940000",
  	"0x29f0edc60338e7112085a1d114da8c42ce8f55d6": "0xa05a7f0fd825780000",
  	"0x29f8fba4c30772b057edbbe62ae7420c390572e1": "0x3635c9adc5dea00000",
  	"0x29f9286c0e738d1721a691c6b95ab3d9a797ede8": "0x2a5a058fc295ed000000",
  	"0x2a085e25b64862f5e68d768e2b0f7a8529858eee": "0x6b883acd5766cd0000",
  	"0x2a2ab6b74c7af1d9476bb5bcb4524797bedc3552": "0x3635c9adc5dea00000",
  	"0x2a39190a4fde83dfb3ddcb4c5fbb83ac6c49755c": "0x3635c9adc5dea00000",
  	"0x2a400dff8594de7228b4fd15c32322b75bb87da8": "0x531a17f607a2d0000",
  	"0x2a44a7218fe44d65a1b4b7a7d9b1c2c52c8c3e34": "0xd2d06c305a1eb578000",
  	"0x2a46d353777176ff8e83ffa8001f4f70f9733aa5": "0x5bf0ba6634f680000",
  	"0x2a595f16eee4cb0c17d9a2d939b3c10f6c677243": "0x3ba1910bf341b00000",
  	"0x2a59e47ea5d8f0e7c028a3e8e093a49c1b50b9a3": "0x6c6b935b8bbd400000",
  	"0x2a5ba9e34cd58da54c9a2712663a3be274c8e47b": "0xaadec983fcff40000",
  	"0x2a5e3a40d2cd0325766de73a3d671896b362c73b": "0x152d02c7e14af6800000",
  	"0x2a63590efe9986c3fee09b0a0a338b15bed91f21": "0x15e1c4e05ee26d00000",
  	"0x2a67660a1368efcd626ef36b2b1b601980941c05": "0x73f75d1a085ba0000",
  	"0x2a742b8910941e0932830a1d9692cfd28494cf40": "0x1b1ab319f5ec750000",
  	"0x2a746cd44027af3ebd37c378c85ef7f754ab5f28": "0x155bd9307f9fe80000",
  	"0x2a81d27cb6d4770ff4f3c4a3ba18e5e57f07517c": "0x6c6b935b8bbd400000",
  	"0x2a91a9fed41b7d0e5cd2d83158d3e8a41a9a2d71": "0x692ae8897081d00000",
  	"0x2a9c57fe7b6b138a920d676f3c76b6c2a0eef699": "0x1fd933494aa5fe00000",
  	"0x2a9c96c19151ffcbe29a4616d0c52b3933b4659f": "0x3c1379b8765e18000",
  	"0x2aa192777ca5b978b6b2c2ff800ac1860f753f47": "0x12290f15180bdc0000",
  	"0x2aaa35274d742546670b7426264521032af4f4c3": "0x21e19e0c9bab2400000",
  	"0x2aaea1f1046f30f109faec1c63ef5c7594eb08da": "0xd8d726b7177a800000",
  	"0x2ab97e8d59eee648ab6caf8696f89937143864d6": "0xcf152640c5c8300000",
  	"0x2abce1808940cd4ef5b5e05285f82df7a9ab5e03": "0x21342520d5fec200000",
  	"0x2abdf1a637ef6c42a7e2fe217773d677e804ebdd": "0x10f0cf064dd59200000",
  	"0x2ac1f8d7bf721f3cfe74d20fea9b87a28aaa982c": "0x8ba52e6fc45e40000",
  	"0x2acc9c1a32240b4d5b2f777a2ea052b42fc1271c": "0x8d807ee14d836100000",
  	"0x2ad6c9d10c261819a1a0ca2c48d8c7b2a71728df": "0x3635c9adc5dea00000",
  	"0x2ae53866fc2d14d572ab73b4a065a1188267f527": "0x1b1ae4d6e2ef5000000",
  	"0x2ae73a79aea0278533accf21070922b1613f8f32": "0xa7e94bbeae701a8000",
  	"0x2ae82dab92a66389eea1abb901d1d57f5a7cca0b": "0x6c6b935b8bbd400000",
  	"0x2aec809df9325b9f483996e99f7331097f08aa0e": "0xd8d726b7177a800000",
  	"0x2aed2ce531c056b0097efc3c6de10c4762004ed9": "0x2356953ab7ddc380000",
  	"0x2afb058c3d31032b353bf24f09ae20d54de57dbe": "0x3ba1910bf341b00000",
  	"0x2b0362633614bfcb583569438ecc4ea57b1d337e": "0x43c33c1937564800000",
  	"0x2b101e822cd962962a06800a2c08d3b15d82b735": "0x83d6c7aab63600000",
  	"0x2b129c26b75dde127f8320bd0f63410c92a9f876": "0x77432217e683600000",
  	"0x2b241f037337eb4acc61849bd272ac133f7cdf4b": "0x500b6bca962ab8400000",
  	"0x2b3a68db6b0cae8a7c7a476bdfcfbd6205e10687": "0x821ab0d44149800000",
  	"0x2b3cf97311ff30f460945a9d8099f4a88e26d456": "0x6c6b935b8bbd400000",
  	"0x2b49fba29830360fcdb6da23bbfea5c0bbac5281": "0x1158e460913d00000",
  	"0x2b4f4507bb6b9817942ce433781b708fbcd166fd": "0xfc936392801c0000",
  	"0x2b5016e2457387956562587115aa8759d8695fdf": "0x2a5a058fc295ed000000",
  	"0x2b5c60e84535eeb4d580de127a12eb2677ccb392": "0x43c33c1937564800000",
  	"0x2b5ced9987c0765f900e49cf9da2d9f9c1138855": "0x15af1d78b58c400000",
  	"0x2b5f4b3f1e11707a227aa5e69fa49dded33fb321": "0x14542ba12a337c00000",
  	"0x2b68306ba7f8daaf73f4c644ef7d2743c0f26856": "0x2ee182ca17ddd00000",
  	"0x2b6ed29a95753c3ad948348e3e7b1a251080ffb9": "0x34f086f3b33b68400000",
  	"0x2b701d16c0d3cc1e4cd85445e6ad02eea4ac012d": "0x2086ac351052600000",
  	"0x2b717cd432a323a4659039848d3b87de26fc9546": "0x69e10de76676d0800000",
  	"0x2b74c373d04bfb0fd60a18a01a88fbe84770e58c": "0x22b1c8c1227a00000",
  	"0x2b77a4d88c0d56a3dbe3bae04a05f4fcd1b757e1": "0x1043561a8829300000",
  	"0x2b8488bd2d3c197a3d26151815b5a798d27168dc": "0x16a1f9f5fd7d9600000",
  	"0x2b8a0dee5cb0e1e97e15cfca6e19ad21f995efad": "0x1b55438d9a249b0000",
  	"0x2b8fe4166e23d11963c0932b8ade8e0145ea0770": "0x92896529baddc880000",
  	"0x2b99b42e4f42619ee36baa7e4af2d65eacfcba35": "0x878678326eac9000000",
  	"0x2bab0fbe28d58420b52036770a12f9952aea6911": "0xcf152640c5c8300000",
  	"0x2bade91d154517620fd4b439ac97157a4102a9f7": "0xd8d726b7177a800000",
  	"0x2baf8d6e221174124820ee492b9459ec4fadafbb": "0x6c6b935b8bbd400000",
  	"0x2bafbf9e9ed2c219f7f2791374e7d05cb06777e7": "0xbed1d0263d9f00000",
  	"0x2bb366b9edcb0da680f0e10b3b6e28748190d6c3": "0x13a62d7b57640640000",
  	"0x2bb6f578adfbe7b2a116b3554facf9969813c319": "0x19127a1391ea2a00000",
  	"0x2bbe62eac80ca7f4d6fdee7e7d8e28b63acf770e": "0x81e32df972abf00000",
  	"0x2bbe672a1857508f630f2a5edb563d9e9de92815": "0x6c6b935b8bbd400000",
  	"0x2bc429d618a66a4cf82dbb2d824e9356effa126a": "0x6c6acc67d7b1d40000",
  	"0x2bd252e0d732ff1d7c78f0a02e6cb25423cf1b1a": "0x90f534608a72880000",
  	"0x2bdd03bebbee273b6ca1059b34999a5bbd61bb79": "0x1158e460913d00000",
  	"0x2c04115c3e52961b0dc0b0bf31fba4546f5966fd": "0xad78ebc5ac6200000",
  	"0x2c06dd922b61514aafedd84488c0c28e6dcf0e99": "0x152d02c7e14af6800000",
  	"0x2c0cc3f951482cc8a2925815684eb9f94e060200": "0x14542ba12a337c00000",
  	"0x2c0ee134d8b36145b47beee7af8d2738dbda08e8": "0xae56f730e6d840000",
  	"0x2c0f5b9df43625798e7e03c1a5fd6a6d091af82b": "0x1b0fcaab200300000",
  	"0x2c128c95d957215101f043dd8fc582456d41016d": "0x2d43f3ebfafb2c0000",
  	"0x2c1800f35fa02d3eb6ff5b25285f5e4add13b38d": "0x3122d3adafde100000",
  	"0x2c1c19114e3d6de27851484b8d2715e50f8a1065": "0x56bc75e2d63100000",
  	"0x2c1cc6e18c152488ba11c2cc1bcefa2df306abd1": "0x5a87e7d7f5f6580000",
  	"0x2c1df8a76f48f6b54bcf9caf56f0ee1cf57ab33d": "0x2247f750089da580000",
  	"0x2c2147947ae33fb098b489a5c16bfff9abcd4e2a": "0xad78ebc5ac6200000",
  	"0x2c234f505ca8dcc77d9b7e01d257c318cc19396d": "0x56bc75e2d63100000",
  	"0x2c2428e4a66974edc822d5dbfb241b2728075158": "0x6c6b935b8bbd400000",
  	"0x2c2d15ff39561c1b72eda1cc027ffef23743a144": "0xd480ed9ef32b400000",
  	"0x2c2db28c3309375eea3c6d72cd6d0eec145afcc0": "0x6c6b935b8bbd400000",
  	"0x2c424ee47f583cdce07ae318b6fad462381d4d2b": "0xd8d726b7177a800000",
  	"0x2c4b470307a059854055d91ec3794d80b53d0f4a": "0x43c33c1937564800000",
  	"0x2c52c984102ee0cd3e31821b84d408930efa1ac7": "0x6c6b935b8bbd400000",
  	"0x2c5a2d0abda03bbe215781b4ff296c8c61bdbaf6": "0x1a8e56f48c0228000",
  	"0x2c5b7d7b195a371bf9abddb42fe04f2f1d9a9910": "0xad78ebc5ac6200000",
  	"0x2c5df866666a194b26cebb407e4a1fd73e208d5e": "0x3635c9adc5dea00000",
  	"0x2c603ff0fe93616c43573ef279bfea40888d6ae7": "0x100f4b6d66757900000",
  	"0x2c6846a1aa999a2246a287056000ba4dcba8e63d": "0x21f2f6f0fc3c6100000",
  	"0x2c6afcd4037c1ed14fa74ff6758e0945a185a8e8": "0xf43fc2c04ee00000",
  	"0x2c6b699d9ead349f067f45711a074a641db6a897": "0x1158e460913d00000",
  	"0x2c6f5c124cc789f8bb398e3f889751bc4b602d9e": "0x159f20bed00f00000",
  	"0x2c83aeb02fcf067d65a47082fd977833ab1cec91": "0x8273823258ac00000",
  	"0x2c89f5fdca3d155409b638b98a742e55eb4652b7": "0x14dbb2195ca228900000",
  	"0x2c964849b1f69cc7cea4442538ed87fdf16cfc8f": "0x6c6b935b8bbd400000",
  	"0x2c9fa72c95f37d08e9a36009e7a4b07f29bad41a": "0xdf6eb0b2d3ca0000",
  	"0x2caf6bf4ec7d5a19c5e0897a5eeb011dcece4210": "0x7934835a031160000",
  	"0x2cb4c3c16bb1c55e7c6b7a19b127a1ac9390cc09": "0xb82794a9244f0c8000",
  	"0x2cb5495a505336c2465410d1cae095b8e1ba5cdd": "0x43c33c1937564800000",
  	"0x2cb615073a40dcdb99faa848572e987b3b056efb": "0x2b58addb89a2580000",
  	"0x2cba6d5d0dc204ea8a25ada2e26f5675bd5f2fdc": "0x4823ef7ddb9af38000",
  	"0x2cbb0c73df91b91740b6693b774a7d05177e8e58": "0x6449e84e47a8a80000",
  	"0x2ccb66494d0af689abf9483d365d782444e7dead": "0x3635c9adc5dea00000",
  	"0x2ccc1f1cb5f4a8002e186b20885d9dbc030c0894": "0x6c6b935b8bbd400000",
  	"0x2ccf80e21898125eb4e807cd82e09b9d28592f6e": "0x6c6b935b8bbd400000",
  	"0x2cd19694d1926a0fa9189edebafc671cf1b2caa5": "0x3635c9adc5dea00000",
  	"0x2cd39334ac7eac797257abe3736195f5b4b5ce0f": "0x56b47785e37260000",
  	"0x2cd79eb52027b12c18828e3eaab2969bfcd287e9": "0x1158e460913d00000",
  	"0x2cd87866568dd81ad47d9d3ad0846e5a65507373": "0x15af1d78b58c400000",
  	"0x2cdb3944650616e47cb182e060322fa1487978ce": "0x62a992e53a0af00000",
  	"0x2ce11a92fad024ff2b3e87e3b542e6c60dcbd996": "0xd8d726b7177a800000",
  	"0x2d0326b23f0409c0c0e9236863a133075a94ba18": "0xb679be75be6ae0000",
  	"0x2d0dec51a6e87330a6a8fa2a0f65d88d4abcdf73": "0xa076407d3f7440000",
  	"0x2d23766b6f6b05737dad80a419c40eda4d77103e": "0xcf152640c5c8300000",
  	"0x2d2b032359b363964fc11a518263bfd05431e867": "0x81c1df7629e700000",
  	"0x2d3480bf0865074a72c7759ee5137b4d70c51ce9": "0xad78ebc5ac6200000",
  	"0x2d35a9df62757f7ffad1049afb06ca4afc464c51": "0x1158e460913d00000",
  	"0x2d40558b06f90a3923145592123b6774e46e31f4": "0x3635c9adc5dea00000",
  	"0x2d426912d059fad9740b2e390a2eeac0546ff01b": "0x4be4e7267b6ae00000",
  	"0x2d532df4c63911d1ce91f6d1fcbff7960f78a885": "0x5a85968a5878da8000",
  	"0x2d5391e938b34858cf965b840531d5efda410b09": "0x4be4e7267b6ae00000",
  	"0x2d5b42fc59ebda0dfd66ae914bc28c1b0a6ef83a": "0x2bc8b59fdcd836638000",
  	"0x2d5d7335acb0362b47dfa3a8a4d3f5949544d380": "0xad78ebc5ac6200000",
  	"0x2d61bfc56873923c2b00095dc3eaa0f590d8ae0f": "0x46566dff8ce55600000",
  	"0x2d6511fd7a3800b26854c7ec39c0dcb5f4c4e8e8": "0x15adddba2f9e770000",
  	"0x2d7d5c40ddafc450b04a74a4dabc2bb5d665002e": "0x6c6b935b8bbd400000",
  	"0x2d89a8006a4f137a20dc2bec46fe2eb312ea9654": "0xad78ebc5ac6200000",
  	"0x2d8c52329f38d2a2fa9cbaf5c583daf1490bb11c": "0x1158e460913d00000",
  	"0x2d8e061892a5dcce21966ae1bb0788fd3e8ba059": "0xd8e5ce617f2d50000",
  	"0x2d8e5bb8d3521695c77e7c834e0291bfacee7408": "0x6acb3df27e1f880000",
  	"0x2d90b415a38e2e19cdd02ff3ad81a97af7cbf672": "0x5f3c7f64131e40000",
  	"0x2d9bad6f1ee02a70f1f13def5cccb27a9a274031": "0x61093d7c2c6d380000",
  	"0x2d9c5fecd2b44fbb6a1ec732ea059f4f1f9d2b5c": "0x36ca32661d1aa70000",
  	"0x2da617695009cc57d26ad490b32a5dfbeb934e5e": "0x43c33c1937564800000",
  	"0x2da76b7c39b420e388ba2c1020b0856b0270648a": "0x6c6b935b8bbd400000",
  	"0x2dc79d6e7f55bce2e2d0c02ad07ceca8bb529354": "0x55a6e79ccd1d300000",
  	"0x2dca0e449ab646dbdfd393a96662960bcab5ae1e": "0x878678326eac9000000",
  	"0x2dd325fdffb97b19995284afa5abdb574a1df16a": "0x1b1ae4d6e2ef500000",
  	"0x2dd578f7407dfbd548d05e95ccc39c485429626a": "0xe3aeb5737240a00000",
  	"0x2dd8eeef87194abc2ce7585da1e35b7cea780cb7": "0x3635c6204739d98000",
  	"0x2ddf40905769bcc426cb2c2938ffe077e1e89d98": "0xa2a15d09519be00000",
  	"0x2de0964400c282bdd78a919c6bf77c6b5f796179": "0xad78ebc5ac6200000",
  	"0x2de31afd189a13a76ff6fe73ead9f74bb5c4a629": "0x14542ba12a337c00000",
  	"0x2dec98329d1f96c3a59caa7981755452d4da49d5": "0xad78ebc5ac6200000",
  	"0x2dee90a28f192d676a8773232b56f18f239e2fad": "0x3efa7e747b6d1ad0000",
  	"0x2e0880a34596230720f05ac8f065af8681dcb6c2": "0x152d02c7e14af6800000",
  	"0x2e0c57b47150f95aa6a7e16ab9b1cbf54328979a": "0x56bc75e2d63100000",
  	"0x2e10910ba6e0bc17e055556614cb87090f4d7e5b": "0xad78ebc5ac6200000",
  	"0x2e24b597873bb141bdb237ea8a5ab747799af02d": "0x43c33c1937564800000",
  	"0x2e2810dee44ae4dff3d86342ab126657d653c336": "0xad78ebc5ac6200000",
  	"0x2e2cbd7ad82547b4f5ff8b3ab56f942a6445a3b0": "0xad78ebc5ac6200000",
  	"0x2e2d7ea66b9f47d8cc52c01c52b6e191bc7d4786": "0xd8d4602c26bf6c0000",
  	"0x2e439348df8a4277b22a768457d1158e97c40904": "0x2a1e9ff26fbf410000",
  	"0x2e46fcee6a3bb145b594a243a3913fce5dad6fba": "0x21e19e0c9bab2400000",
  	"0x2e47f287f498233713850d3126823cc67dcee255": "0xca9d9ea558b40000",
  	"0x2e4ee1ae996aa0a1d92428d06652a6bea6d2d15d": "0x6c6b935b8bbd400000",
  	"0x2e52912bc10ea39d54e293f7aed6b99a0f4c73be": "0x15af1d78b58c400000",
  	"0x2e619f57abc1e987aa936ae3a2264962e7eb2d9a": "0x28fb9b8a8a53500000",
  	"0x2e64a8d71111a22f4c5de1e039b336f68d398a7c": "0x6c6b935b8bbd400000",
  	"0x2e6933543d4f2cc00b5350bd8068ba9243d6beb0": "0x6c6b935b8bbd400000",
  	"0x2e7e05e29edda7e4ae25c5173543efd71f6d3d80": "0x14542ba12a337c00000",
  	"0x2e7f465520ec35cc23d68e75651bb6689544a196": "0x38ec5b721a1a268000",
  	"0x2e8eb30a716e5fe15c74233e039bfb1106e81d12": "0x56bc75e2d63100000",
  	"0x2e9824b5c132111bca24ddfba7e575a5cd7296c1": "0x3a484516e6d7ffe0000",
  	"0x2ea5fee63f337a376e4b918ea82148f94d48a626": "0x650f8e0dd293c50000",
  	"0x2eaf4e2a46b789ccc288c8d1d9294e3fb0853896": "0x6c6b935b8bbd400000",
  	"0x2eaff9f8f8113064d3957ac6d6e11eee42c8195d": "0x6acb3df27e1f880000",
  	"0x2eba0c6ee5a1145c1c573984963a605d880a7a20": "0x1b1ae4d6e2ef500000",
  	"0x2ec95822eb887bc113b4712a4dfd7f13b097b5e7": "0x3635c9adc5dea00000",
  	"0x2eca6a3c5d9f449d0956bd43fa7b4d7be8435958": "0x6c6bda69709cc20000",
  	"0x2ecac504b233866eb5a4a99e7bd2901359e43b3d": "0x43c33c1937564800000",
  	"0x2eebf59432b52892f9380bd140aa99dcf8ad0c0f": "0x83d6c7aab63600000",
  	"0x2eeed50471a1a2bf53ee30b1232e6e9d80ef866d": "0x1158e460913d00000",
  	"0x2eef6b1417d7b10ecfc19b123a8a89e73e526c58": "0x2086ac351052600000",
  	"0x2ef869f0350b57d53478d701e3fee529bc911c75": "0x2b5e3af16b1880000",
  	"0x2ef9e465716acacfb8c8252fa8e7bc7969ebf6e4": "0x959eb1c0e4ae200000",
  	"0x2efc4c647dac6acac35577ad221758fef6616faa": "0x1b1ae4d6e2ef5000000",
  	"0x2f13657526b177cad547c3908c840eff647b45d9": "0x3f76849cf1ee2c8000",
  	"0x2f187d5a704d5a338c5b2876a090dce964284e29": "0xd8d726b7177a800000",
  	"0x2f2523cc834f0086052402626296675186a8e582": "0x3635c9adc5dea000000",
  	"0x2f282abbb6d4a3c3cd3b5ca812f7643e80305f06": "0x6449e84e47a8a80000",
  	"0x2f2bba1b1796821a766fce64b84f28ec68f15aea": "0x1158e460913d00000",
  	"0x2f315d9016e8ee5f536681202f9084b032544d4d": "0x383cd12b9e863c0000",
  	"0x2f4da753430fc09e73acbccdcde9da647f2b5d37": "0xad78ebc5ac6200000",
  	"0x2f5080b83f7e2dc0a1dd11b092ad042bff788f4c": "0xb4f8fb79231d2b8000",
  	"0x2f61efa5819d705f2b1e4ee754aeb8a819506a75": "0x4f2591f896a6500000",
  	"0x2f66bfbf2262efcc8d2bd0444fc5b0696298ff1e": "0x21ad935f79f76d00000",
  	"0x2f6dce1330c59ef921602154572d4d4bacbd048a": "0x3635c9adc5dea00000",
  	"0x2f7d3290851be5c6b4b43f7d4574329f61a792c3": "0x56bc75e2d63100000",
  	"0x2f853817afd3b8f3b86e9f60ee77b5d97773c0e3": "0x4eaeea44e368b90000",
  	"0x2fa491fb5920a6574ebd289f39c1b2430d2d9a6a": "0x6c6b935b8bbd400000",
  	"0x2fb566c94bbba4e3cb67cdda7d5fad7131539102": "0x6c6b935b8bbd400000",
  	"0x2fbb504a5dc527d3e3eb0085e2fc3c7dd538cb7a": "0x43c2b18aec3c0a8000",
  	"0x2fbc85798a583598b522166d6e9dda121d627dbc": "0xad78ebc5ac6200000",
  	"0x2fbcef3384d420e4bf61a0669990bc7054f1a5af": "0x6c6b935b8bbd400000",
  	"0x2fc82ef076932341264f617a0c80dd571e6ae939": "0x18424f5f0b1b4e00000",
  	"0x2fdd9b79df8df530ad63c20e62af431ae99216b8": "0x1236efcbcbb340000",
  	"0x2fe0023f5722650f3a8ac01009125e74e3f82e9b": "0xa2a15d09519be00000",
  	"0x2fe0cc424b53a31f0916be08ec81c50bf8eab0c1": "0x2086ac351052600000",
  	"0x2fe13a8d0785de8758a5e41876c36e916cf75074": "0xd8d726b7177a800000",
  	"0x2fea1b2f834f02fc54333f8a809f0438e5870aa9": "0x11854d0f9cee40000",
  	"0x2fee36a49ee50ecf716f1047915646779f8ba03f": "0x394222c4da86d70000",
  	"0x2fef81478a4b2e8098db5ff387ba2153f4e22b79": "0x3627e8f712373c0000",
  	"0x2ff160c44f72a299b5ec2d71e28ce5446d2fcbaf": "0x138400eca364a00000",
  	"0x2ff1ca55fd9cec1b1fe9f0a9abb74c513c1e2aaa": "0xa2a15d09519be00000",
  	"0x2ff5cab12c0d957fd333f382eeb75107a64cb8e8": "0x21e19e0c9bab2400000",
  	"0x2ff830cf55fb00d5a0e03514fecd44314bd6d9f1": "0x21e19e0c9bab2400000",
  	"0x2ffe93ec1a5636e9ee34af70dff52682e6ff7079": "0x6c6b935b8bbd400000",
  	"0x30037988702671acbe892c03fe5788aa98af287a": "0x97c9ce4cf6d5c00000",
  	"0x30248d58e414b20fed3a6c482b59d9d8f5a4b7e2": "0x340aad21b3b700000",
  	"0x303139bc596403d5d3931f774c66c4ba467454db": "0x5c25e14aea283f0000",
  	"0x30380087786965149e81423b15e313ba32c5c783": "0xfc936392801c0000",
  	"0x303a30ac4286ae17cf483dad7b870c6bd64d7b4a": "0x1b1ae4d6e2ef500000",
  	"0x303fbaebbe46b35b6e5b74946a5f99bc1585cae7": "0x2f9ac0695f5bba0000",
  	"0x3041445a33ba158741160d9c344eb88e5c306f94": "0x340aad21b3b700000",
  	"0x30480164bcd84974ebc0d90c9b9afab626cd1c73": "0x2b5e3af16b18800000",
  	"0x304ec69a74545721d7316aef4dcfb41ac59ee2f0": "0xad78ebc5ac6200000",
  	"0x30511832918d8034a7bee72ef2bfee440ecbbcf6": "0x368c8623a8b4d100000",
  	"0x30513fca9f36fd788cfea7a340e86df98294a244": "0x183b5f03b1479c0000",
  	"0x3055efd26029e0d11b930df4f53b162c8c3fd2ce": "0x1b1a089237073d0000",
  	"0x305d26c10bdc103f6b9c21272eb7cb2d9108c47e": "0x1b1ae4d6e2ef500000",
  	"0x305f78d618b990b4295bac8a2dfa262884f804ea": "0xd8d726b7177a800000",
  	"0x3064899a963c4779cbf613cd6980846af1e6ec65": "0x17b773ce6e5df0a0000",
  	"0x30730466b8eb6dc90d5496aa76a3472d7dbe0bbe": "0x6c68ccd09b022c0000",
  	"0x30742ccdf4abbcd005681f8159345c9e79054b1a": "0x243d4d18229ca20000",
  	"0x3083ef0ed4c4401196774a95cf4edc83edc1484f": "0x23ffb7ed6565d6400000",
  	"0x308dd21cebe755126704b48c0f0dc234c60ba9b1": "0xad78ebc5ac6200000",
  	"0x3090f8130ec44466afadb36ed3c926133963677b": "0xd8d726b7177a800000",
  	"0x309544b6232c3dd737f945a03193d19b5f3f65b9": "0x3af342f67ef6c80000",
  	"0x3096dca34108085bcf04ae72b94574a13e1a3e1d": "0xad78ebc5ac6200000",
  	"0x3098b65db93ecacaf7353c48808390a223d57684": "0x186484cf7bb6a48000",
  	"0x30a9da72574c51e7ee0904ba1f73a6b7b83b9b9d": "0x11854d0f9cee40000",
  	"0x30acd858875fa24eef0d572fc7d62aad0ebddc35": "0x15af1d78b58c400000",
  	"0x30b66150f1a63457023fdd45d0cc6cb54e0c0f06": "0x3635c9adc5dea00000",
  	"0x30bb4357cd6910c86d2238bf727cbe8156680e62": "0x56bf91b1a65eb0000",
  	"0x30bf61b2d877fe10635126326fa189e4b0b1c3b0": "0x37b48985a5d7e60000",
  	"0x30c01142907acb1565f70438b9980ae731818738": "0x6c6b935b8bbd400000",
  	"0x30c26a8e971baa1855d633ba703f028cc7873140": "0x21e19e0c9bab2400000",
  	"0x30db6b9b107e62102f434a9dd0960c2021f5ce4c": "0x2083179b6e42530000",
  	"0x30e33358fc21c85006e40f32357dc8895940aaf0": "0x678a932062e4180000",
  	"0x30e60900cacc7203f314dc604347255167fc2a0f": "0x6c6b935b8bbd400000",
  	"0x30e789b3d2465e946e6210fa5b35de4e8c93085f": "0x6c6b935b8bbd400000",
  	"0x30e9698cf1e08a9d048bd8d8048f28be7ed9409f": "0x16a6502f15a1e540000",
  	"0x30e9d5a0088f1ddb2fd380e2a049192266c51cbf": "0xaacacd9b9e22b0000",
  	"0x30eac740e4f02cb56eef0526e5d300322600d03e": "0x6acb3df27e1f880000",
  	"0x30ec9392244a2108c987bc5cdde0ed9f837a817b": "0x549925f6c9c5250000",
  	"0x30ed11b77bc17e5e6694c8bc5b6e4798f68d9ca7": "0x1e6fb3421fe0299e0000",
  	"0x30f7d025d16f7bee105580486f9f561c7bae3fef": "0x1b1ae4d6e2ef500000",
  	"0x30fbe5885f9fcce9ea5edb82ed4a1196dd259aed": "0x119e47f21381f400000",
  	"0x31047d703f63b93424fbbd6e2f1f9e74de13e709": "0x9a8166f7e6b2a78000",
  	"0x31313ffd635bf2f3324841a88c07ed146144ceeb": "0x6acb3df27e1f880000",
  	"0x3159e90c48a915904adfe292b22fa5fd5e72796b": "0x36afe98f2606100000",
  	"0x315db7439fa1d5b423afa7dd7198c1cf74c918bc": "0x2086ac351052600000",
  	"0x315ef2da620fd330d12ee55de5f329a696e0a968": "0x821ab0d4414980000",
  	"0x316e92a91bbda68b9e2f98b3c048934e3cc0b416": "0x6c6b935b8bbd400000",
  	"0x316eb4e47df71b42e16d6fe46825b7327baf3124": "0xd8d726b7177a800000",
  	"0x3171877e9d820cc618fc0919b29efd333fda4934": "0x3635c9adc5dea00000",
  	"0x317cf4a23cb191cdc56312c29d15e210b3b9b784": "0x7ce66c50e28400000",
  	"0x318b2ea5f0aaa879c4d5e548ac9d92a0c67487b7": "0xad78ebc5ac6200000",
  	"0x318c76ecfd8af68d70555352e1f601e35988042d": "0x1b31192e68c7f00000",
  	"0x318f1f8bd220b0558b95fb33100ffdbb640d7ca6": "0xd8d726b7177a800000",
  	"0x31aa3b1ebe8c4dbcb6a708b1d74831e60e497660": "0x15af1d78b58c400000",
  	"0x31ab088966ecc7229258f6098fce68cf39b38485": "0x3635c9adc5dea00000",
  	"0x31ad4d9946ef09d8e988d946b1227f9141901736": "0x4d853c8f89089800000",
  	"0x31b43b015d0081643c6cda46a7073a6dfdbca825": "0xa97916520cd18e80000",
  	"0x31ccc616b3118268e75d9ab8996c8858ebd7f3c3": "0x15ae0f771ca1520000",
  	"0x31d81d526c195e3f10b5c6db52b5e59afbe0a995": "0xe4fbc69449f200000",
  	"0x31e9c00f0c206a4e4e7e0522170dc81e88f3eb70": "0x918ddc3a42a3d40000",
  	"0x31ea12d49a35a740780ddeeaece84c0835b26270": "0xad78ebc5ac6200000",
  	"0x31ea6eab19d00764e9a95e183f2b1b22fc7dc40f": "0x1158e460913d00000",
  	"0x31eb123c95c82bf685ace7a75a1881a289efca10": "0x31e009607371bd0000",
  	"0x31ed858788bda4d5270992221cc04206ec62610d": "0x3fc0474948f3600000",
  	"0x31f006f3494ed6c16eb92aaf9044fa8abb5fd5a3": "0x1b1ae4d6e2ef500000",
  	"0x3201259caf734ad7581c561051ba0bca7fd6946b": "0x261dd1ce2f2088800000",
  	"0x32034e8581d9484e8af42a28df190132ec29c466": "0xbb9125542263900000",
  	"0x322021022678a0166d204b3aaa7ad4ec4b88b7d0": "0x15af1d78b58c400000",
  	"0x3225c1ca5f2a9c88156bb7d9cdc44a326653c214": "0x15af1d78b58c400000",
  	"0x322788b5e29bf4f5f55ae1ddb32085fda91b8ebe": "0xad78ebc5ac6200000",
  	"0x322d6f9a140d213f4c80cd051afe25c620bf4c7d": "0x1158e460913d00000",
  	"0x322e5c43b0f524389655a9b3ff24f2d4db3da10f": "0xfc13b69b3e7e680000",
  	"0x323486ca64b375474fb2b759a9e7a135859bd9f6": "0x15af1d78b58c400000",
  	"0x323749a3b971959e46c8b4822dcafaf7aaf9bd6e": "0x11671a5b245700000",
  	"0x323aad41df4b6fc8fece8c93958aa901fa680843": "0x34957444b840e80000",
  	"0x323b3cfe3ee62bbde2a261e53cb3ecc05810f2c6": "0x2eb8eb1a172dcb80000",
  	"0x323fca5ed77f699f9d9930f5ceeff8e56f59f03c": "0x487a9a304539440000",
  	"0x32485c818728c197fea487fbb6e829159eba8370": "0x3921b413bc4ec08000",
  	"0x3250e3e858c26adeccadf36a5663c22aa84c4170": "0x10f0cf064dd59200000",
  	"0x3259bd2fddfbbc6fbad3b6e874f0bbc02cda18b5": "0x2846056495b0d188000",
  	"0x3275496fd4dd8931fd69fb0a0b04c4d1ff879ef5": "0x182d7e4cfda0380000",
  	"0x327bb49e754f6fb4f733c6e06f3989b4f65d4bee": "0x1158e460913d00000",
  	"0x3282791d6fd713f1e94f4bfd565eaa78b3a0599d": "0x487a9a304539440000",
  	"0x3283eb7f9137dd39bed55ffe6b8dc845f3e1a079": "0x3970ae92155780000",
  	"0x32860997d730b2d83b73241a25d3667d51c908ef": "0x1b1a089237073d0000",
  	"0x3286d1bc657a312c8847d93cb3cb7950f2b0c6e3": "0x43c33c1937564800000",
  	"0x32a20d028e2c6218b9d95b445c771524636a22ef": "0x202fefbf2d7c2f00000",
  	"0x32a70691255c9fc9791a4f75c8b81f388e0a2503": "0x35659ef93f0fc40000",
  	"0x32b7feebc5c59bf65e861c4c0be42a7611a5541a": "0x77e9aaa8525c100000",
  	"0x32ba9a7d0423e03a525fe2ebeb661d2085778bd8": "0x43c33c1937564800000",
  	"0x32bb2e9693e4e085344d2f0dbd46a283e3a087fd": "0x15af1d78b58c400000",
  	"0x32c2fde2b6aabb80e5aea2b949a217f3cb092283": "0x1306160afdf20378000",
  	"0x32d950d5e93ea1d5b48db4714f867b0320b31c0f": "0x3708baed3d68900000",
  	"0x32dbb6716c54e83165829a4abb36757849b6e47d": "0x3635c9adc5dea00000",
  	"0x32eb64be1b5dede408c6bdefbe6e405c16b7ed02": "0x6acb3df27e1f880000",
  	"0x32ef5cdc671df5562a901aee5db716b9be76dcf6": "0x6c6b935b8bbd400000",
  	"0x32f29e8727a74c6b4301e3ffff0687c1b870dae9": "0x3635c9adc5dea00000",
  	"0x32fa0e86cd087dd68d693190f32d93310909ed53": "0xd8d726b7177a800000",
  	"0x32fbeed6f626fcdfd51acafb730b9eeff612f564": "0x6c6b935b8bbd400000",
  	"0x3300fb149aded65bcba6c04e9cd6b7a03b893bb1": "0xfc936392801c0000",
  	"0x3301d9ca2f3bfe026279cd6819f79a293d98156e": "0xa968163f0a57b400000",
  	"0x3308b03466c27a17dfe1aafceb81e16d2934566f": "0x39992648a23c8a00000",
  	"0x331a1c26cc6994cdd3c14bece276ffff4b9df77c": "0xfa7aeddf4f068000",
  	"0x3326b88de806184454c40b27f309d9dd6dcfb978": "0x3ca5c66d9bc44300000",
  	"0x3329eb3baf4345d600ced40e6e9975656f113742": "0x10f08eda8e555098000",
  	"0x33320dd90f2baa110dd334872a998f148426453c": "0x36356633ebd8ea0000",
  	"0x3336c3ef6e8b50ee90e037b164b7a8ea5faac65d": "0xec8a3a71c22540000",
  	"0x33380c6fff5acd2651309629db9a71bf3f20c5ba": "0x368c8623a8b4d100000",
  	"0x333ad1596401e05aea2d36ca47318ef4cd2cb3df": "0x9dc05cce28c2b80000",
  	"0x334340ee4b9cdc81f850a75116d50ee9b69825bf": "0x6c6b935b8bbd400000",
  	"0x33481e856ebed48ea708a27426ef28e867f57cd1": "0xad78ebc5ac6200000",
  	"0x33565ba9da2c03e778ce12294f081dfe81064d24": "0x3635c9adc5dea000000",
  	"0x33581cee233088c0860d944e0cf1ceabb8261c2e": "0xb98bc829a6f90000",
  	"0x335858f749f169cabcfe52b796e3c11ec47ea3c2": "0xad78ebc5ac6200000",
  	"0x335e22025b7a77c3a074c78b8e3dfe071341946e": "0x227ca730ab3f6ac0000",
  	"0x33629bd52f0e107bc071176c64df108f64777d49": "0x1cfdd7468216e8000",
  	"0x337b3bdf86d713dbd07b5dbfcc022b7a7b1946ae": "0xd7c198710e66b00000",
  	"0x337cfe1157a5c6912010dd561533791769c2b6a6": "0x3635c9adc5dea00000",
  	"0x33b336f5ba5edb7b1ccc7eb1a0d984c1231d0edc": "0x6c6b935b8bbd400000",
  	"0x33c407133b84b3ca4c3ded1f4658900c38101624": "0x97c9ce4cf6d5c00000",
  	"0x33d172ab075c51db1cd40a8ca8dbff0d93b843bb": "0x136780510d12de38000",
  	"0x33e9b71823952e1f66958c278fc28b1196a6c5a4": "0x56bc75e2d63100000",
  	"0x33ea6b7855e05b07ab80dab1e14de9b649e99b6c": "0x1cd6fbad57dbd00000",
  	"0x33f15223310d44de8b6636685f3a4c3d9c5655a5": "0xd9462c6cb4b5a0000",
  	"0x33f4a6471eb1bca6a9f85b3b4872e10755c82be1": "0x6c6b935b8bbd400000",
  	"0x33fb577a4d214fe010d32cca7c3eeda63f87ceef": "0x3635c9adc5dea00000",
  	"0x33fd718f0b91b5cec88a5dc15eecf0ecefa4ef3d": "0x177224aa844c720000",
  	"0x341480cc8cb476f8d01ff30812e7c70e05afaf5d": "0x6c6b935b8bbd400000",
  	"0x34272d5e7574315dcae9abbd317bac90289d4765": "0x62a992e53a0af00000",
  	"0x3430a16381f869f6ea5423915855e800883525a9": "0x3ca5c66d9bc44300000",
  	"0x34318625818ec13f11835ae97353ce377d6f590a": "0x52663ccab1e1c00000",
  	"0x34393c5d91b9de597203e75bac4309b5fa3d28c3": "0xa844a7424d9c80000",
  	"0x3439998b247cb4bf8bc80a6d2b3527f1dfe9a6d2": "0x796e3ea3f8ab00000",
  	"0x34437d1465640b136cb5841c3f934f9ba0b7097d": "0x960db77681e940000",
  	"0x344a8db086faed4efc37131b3a22b0782dad7095": "0x1b1ae4d6e2ef500000",
  	"0x34664d220fa7f37958024a3332d684bcc6d4c8bd": "0x21e19e0c9bab2400000",
  	"0x3466f67e39636c01f43b3a21a0e8529325c08624": "0x2db1167650acd80000",
  	"0x3485361ee6bf06ef6508ccd23d94641f814d3e2f": "0x6c6b935b8bbd400000",
  	"0x3485f621256433b98a4200dad857efe55937ec98": "0x6c6b935b8bbd400000",
  	"0x34958a46d30e30b273ecc6e5d358a212e5307e8c": "0x6c6b935b8bbd400000",
  	"0x3497dd66fd118071a78c2cb36e40b6651cc82598": "0x5f1016b5076d00000",
  	"0x349a816b17ab3d27bbc0ae0051f6a070be1ff29d": "0x21e19e0c9bab2400000",
  	"0x349d2c918fd09e2807318e66ce432909176bd50b": "0x3cb71f51fc55800000",
  	"0x34a0431fff5ead927f3c69649616dc6e97945f6f": "0x15af1d78b58c400000",
  	"0x34a85d6d243fb1dfb7d1d2d44f536e947a4cee9e": "0x43c33c1937564800000",
  	"0x34a901a69f036bcf9f7843c0ba01b426e8c3dc2b": "0xd8d726b7177a800000",
  	"0x34b454416e9fb4274e6addf853428a0198d62ee1": "0x161042779f1ffc0000",
  	"0x34c8e5f1330fcb4b14ca75cb2580a4b93d204e36": "0x6c6b935b8bbd400000",
  	"0x34e2849bea583ab0cc37975190f322b395055582": "0x1a5c5e857fdf2b20000",
  	"0x34fa7792bad8bbd7ff64056214a33eb6600c1ea8": "0x2b5e3af16b1880000",
  	"0x34ff26eb60a8d1a95a489fae136ee91d4e58084c": "0x2086ac351052600000",
  	"0x34ff582952ff24458f7b13d51f0b4f987022c1fe": "0x9806de3da6e9780000",
  	"0x35106ba94e8563d4b3cb3c5c692c10e604b7ced8": "0x6c6b935b8bbd400000",
  	"0x35145f620397c69cb8e00962961f0f4886643989": "0x14542ba12a337c00000",
  	"0x35147430c3106500e79fa2f502462e94703c23b1": "0x6c6acc67d7b1d40000",
  	"0x351787843505f8e4eff46566cce6a59f4d1c5fe7": "0x1f5718987664b480000",
  	"0x351f16e5e0735af56751b0e225b2421171394090": "0x2d4ca05e2b43ca80000",
  	"0x3524a000234ebaaf0789a134a2a417383ce5282a": "0x1317955947d8e2c0000",
  	"0x3526eece1a6bdc3ee7b400fe935b48463f31bed7": "0x477879b6d14300000",
  	"0x352a785f4a921632504ce5d015f83c49aa838d6d": "0xe9e7e0fb35b7780000",
  	"0x352d29a26e8a41818181746467f582e6e84012e0": "0x14542ba12a337c00000",
  	"0x352e77c861696ef96ad54934f894aa8ea35151dd": "0x3635c9adc5dea00000",
  	"0x352f25babf4a690673e35195efa8f79d05848aad": "0xe253c39be6e7dc00000",
  	"0x3536453322c1466cb905af5c335ca8db74bff1e6": "0x183b5f03b1479c0000",
  	"0x353dbec42f92b50f975129b93c4c997375f09073": "0x6c5db2a4d815dc0000",
  	"0x3540c7bd7a8442d5bee21a2180a1c4edff1649e0": "0x432eac4c6f05b98000",
  	"0x3549bd40bbbc2b30095cac8be2c07a0588e0aed6": "0x1158e460913d00000",
  	"0x3552a496eba67f12be6eedab360cd13661dc7480": "0x1043561a8829300000",
  	"0x3554947b7b947b0040da52ca180925c6d3b88ffe": "0x39fbae8d042dd0000",
  	"0x355c0c39f5d5700b41d375b3f17851dcd52401f9": "0xd7b3b7ba5abf4c0000",
  	"0x355ccfe0e77d557b971be1a558bc02df9eee0594": "0x5f5cb1afc865280000",
  	"0x3571cf7ad304ecaee595792f4bbfa484418549d6": "0x13bcd0d892d9e160000",
  	"0x3575c770668a9d179f1ef768c293f80166e2aa3d": "0x19b21248a3ef280000",
  	"0x357a02c0a9dfe287de447fb67a70ec5b62366647": "0x1731790534df20000",
  	"0x35855ec641ab9e081ed0c2a6dcd81354d0244a87": "0x4127abe993a7aa8000",
  	"0x3588895ac9fbafec012092dc05c0c302d90740fa": "0xa2a15d09519be00000",
  	"0x3599493ce65772cf93e98af1195ec0955dc98002": "0x5151590c67b3280000",
  	"0x35a08081799173e001cc5bd46a02406dc95d1787": "0x21e19e0c9bab2400000",
  	"0x35a549e8fd6c368d6dcca6d2e7d18e4db95f5284": "0x1b1a089237073d0000",
  	"0x35a6885083c899dabbf530ed6c12f4dd3a204cf5": "0xad78ebc5ac6200000",
  	"0x35aaa0465d1c260c420fa30e2629869fb6559207": "0x263781e0e087c80000",
  	"0x35ac1d3ed7464fa3db14e7729213ceaa378c095e": "0x52663ccab1e1c00000",
  	"0x35af040a0cc2337a76af288154c7561e1a233349": "0x3635c9adc5dea00000",
  	"0x35b03ea4245736f57b85d2eb79628f036ddcd705": "0xd8d726b7177a800000",
  	"0x35bd246865fab490ac087ac1f1d4f2c10d0cda03": "0x15af1d78b58c400000",
  	"0x35bf6688522f35467a7f75302314c02ba176800e": "0x3af418202d954e00000",
  	"0x35c8adc11125432b3b77acd64625fe58ebee9d66": "0x6c6b935b8bbd400000",
  	"0x35d2970f49dcc81ea9ee707e9c8a0ab2a8bb7463": "0x4e1003b28d92800000",
  	"0x35e096120deaa5c1ecb1645e2ccb8b4edbd9299a": "0x1b1ae4d6e2ef500000",
  	"0x35ea2163a38cdf9a123f82a5ec00258dae0bc767": "0xd8d726b7177a800000",
  	"0x35f1da127b83376f1b88c82a3359f67a5e67dd50": "0x678a932062e4180000",
  	"0x35f2949cf78bc219bb4f01907cf3b4b3d3865482": "0xfb5c86c92e4340000",
  	"0x35f5860149e4bbc04b8ac5b272be55ad1aca58e0": "0xad78ebc5ac6200000",
  	"0x3602458da86f6d6a9d9eb03daf97fe5619d442fa": "0x6c6b935b8bbd400000",
  	"0x3605372d93a9010988018f9f315d032ed1880fa1": "0x1b1bcf51896a7d0000",
  	"0x3616d448985f5d32aefa8b93a993e094bd854986": "0xb227f63be813c0000",
  	"0x3616fb46c81578c9c8eb4d3bf880451a88379d7d": "0xad78ebc5ac6200000",
  	"0x361c75931696bc3d427d93e76c77fd13b241f6f4": "0x1dc5d8fc266dd60000",
  	"0x361d9ed80b5bd27cf9f1226f26753258ee5f9b3f": "0xbf6914ba7d72c20000",
  	"0x361f3ba9ed956b770f257d3672fe1ff9f7b0240c": "0x2086ac351052600000",
  	"0x36227cdfa0fd3b9d7e6a744685f5be9aa366a7f0": "0xac2730ee9c6c18000",
  	"0x362fbcb10662370a068fc2652602a2577937cce6": "0xad78ebc5ac6200000",
  	"0x3630c5e565ceaa8a0f0ffe32875eae2a6ce63c19": "0x937722b3774d00000",
  	"0x36339f84a5c2b44ce53dfdb6d4f97df78212a7df": "0x116f18b81715a00000",
  	"0x36343aeca07b6ed58a0e62fa4ecb498a124fc971": "0x1043561a8829300000",
  	"0x366175403481e0ab15bb514615cbb989ebc68f82": "0x6c6b935b8bbd400000",
  	"0x36726f3b885a24f92996da81625ec8ad16d8cbe6": "0x53af75d18148578000",
  	"0x3673954399f6dfbe671818259bb278e2e92ee315": "0x2a5a058fc295ed000000",
  	"0x36758e049cd98bcea12277a676f9297362890023": "0xd8d726b7177a800000",
  	"0x367f59cc82795329384e41e1283115e791f26a01": "0x6c6b935b8bbd400000",
  	"0x36810ff9d213a271eda2b8aa798be654fa4bbe06": "0x6c6b935b8bbd400000",
  	"0x368c5414b56b8455171fbf076220c1cba4b5ca31": "0x1e3ef911e83d720000",
  	"0x3690246ba3c80679e22eac4412a1aefce6d7cd82": "0x43c33c1937564800000",
  	"0x36928b55bc861509d51c8cf1d546bfec6e3e90af": "0x6acb3df27e1f880000",
  	"0x369822f5578b40dd1f4471706b22cd971352da6b": "0x12c1b6eed03d280000",
  	"0x369ef761195f3a373e24ece6cd22520fe0b9e86e": "0x1cffafc94db2088000",
  	"0x36a08fd6fd1ac17ce15ed57eefb12a2be28188bf": "0x487a9a304539440000",
  	"0x36a0e61e1be47fa87e30d32888ee0330901ca991": "0x1158e460913d00000",
  	"0x36b2c85e3aeeebb70d63c4a4730ce2e8e88a3624": "0x21e19e0c9bab2400000",
  	"0x36bf43ff35df90908824336c9b31ce33067e2f50": "0x49721510c1c1e9480000",
  	"0x36bfe1fa3b7b70c172eb042f6819a8972595413e": "0x3635c9adc5dea00000",
  	"0x36c510bf8d6e569bf2f37d47265dbcb502ff2bce": "0x65a4da25d3016c00000",
  	"0x36d85dc3683156e63bf880a9fab7788cf8143a27": "0x43c33c1937564800000",
  	"0x36df8f883c1273ec8a171f7a33cfd649b1fe6075": "0xc52484ac416890000",
  	"0x36e156610cd8ff64e780d89d0054385ca76755aa": "0x2f6f10780d22cc00000",
  	"0x36fec62c2c425e219b18448ad757009d8c54026f": "0x15af1d78b58c400000",
  	"0x3700e3027424d939dbde5d42fb78f6c4dbec1a8f": "0x22b1c8c1227a00000",
  	"0x3702e704cc21617439ad4ea27a5714f2fda1e932": "0x3635c9adc5dea00000",
  	"0x3703350c4d6fe337342cddc65bf1e2386bf3f9b2": "0x6d8121a194d1100000",
  	"0x3708e59de6b4055088782902e0579c7201a8bf50": "0x2a5a058fc295ed000000",
  	"0x3712367e5e55a96d5a19168f6eb2bc7e9971f869": "0x3635c9adc5dea00000",
  	"0x37195a635dcc62f56a718049d47e8f9f96832891": "0x6acb3df27e1f880000",
  	"0x3727341f26c12001e378405ee38b2d8464ec7140": "0x6c6b935b8bbd400000",
  	"0x372e453a6b629f27678cc8aeb5e57ce85ec0aef9": "0xad78ebc5ac6200000",
  	"0x3734cb187491ede713ae5b3b2d12284af46b8101": "0xa2a15d09519be00000",
  	"0x3737216ee91f177732fb58fa4097267207e2cf55": "0x52663ccab1e1c00000",
  	"0x373c547e0cb5ce632e1c5ad66155720c01c40995": "0xfe54dcdce6c55a0000",
  	"0x376cd7577383e902951b60a2017ba7ea29e33576": "0x6c6b935b8bbd400000",
  	"0x378ea1dc8edc19bae82638029ea8752ce98bcfcd": "0x6c6b935b8bbd400000",
  	"0x378f37243f3ff0bef5e1dc85eb4308d9340c29f9": "0x6c6e59e67c78540000",
  	"0x37959c20b7e9931d72f5a8ae869dafddad3b6d5c": "0xad78ebc5ac6200000",
  	"0x379a7f755a81a17edb7daaa28afc665dfa6be63a": "0x15af1d78b58c40000",
  	"0x379c7166849bc24a02d6535e2def13daeef8aa8d": "0x56bc75e2d63100000",
  	"0x37a05aceb9395c8635a39a7c5d266ae610d10bf2": "0x65a4da25d3016c00000",
  	"0x37a10451f36166cf643dd2de6c1cbba8a011cfa3": "0x14998f32ac78700000",
  	"0x37a7a6ff4ea3d60ec307ca516a48d3053bb79cbb": "0x6c6b935b8bbd400000",
  	"0x37ab66083a4fa23848b886f9e66d79cdc150cc70": "0x12be22ffb5ec00380000",
  	"0x37ac29bda93f497bc4aeaab935452c431510341e": "0x35659ef93f0fc40000",
  	"0x37b8beac7b1ca38829d61ab552c766f48a10c32f": "0x15af1d78b58c400000",
  	"0x37bbc47212d82fcb5ee08f5225ecc2041ad2da7d": "0xb1cf24ddd0b1400000",
  	"0x37cb868d2c3f95b257611eb34a4188d58b749802": "0x6c6b935b8bbd400000",
  	"0x37d980a12ee3bf23cc5cdb63b4ae45691f74c837": "0x6c6b935b8bbd400000",
  	"0x37e169a93808d8035698f815c7235613c1e659f2": "0x3635c9adc5dea00000",
  	"0x37eada93c475ded2f7e15e7787d400470fa52062": "0xad78ebc5ac6200000",
  	"0x37fac1e6bc122e936dfb84de0c4bef6e0d60c2d7": "0x6c6b935b8bbd400000",
  	"0x3807eff43aa97c76910a19752dd715ee0182d94e": "0xd90156f6fc2fb0000",
  	"0x3815b0743f94fc8cc8654fd9d597ed7d8b77c57e": "0x2809d429d896750000",
  	"0x381db4c8465df446a4ce15bf81d47e2f17c980bf": "0x6c6b935b8bbd4000000",
  	"0x38202c5cd7078d4f887673ab07109ad8ada89720": "0x3635c9adc5dea00000",
  	"0x3821862493242c0aeb84b90de05d250c1e50c074": "0x11776c58e946dc0000",
  	"0x382591e7217b435e8e884cdbf415fe377a6fe29e": "0x1b2df9d219f57980000",
  	"0x382ba76db41b75606dd48a48f0137e9174e031b6": "0x1158e460913d00000",
  	"0x3831757eae7557cb8a37a4b10644b63e4d3b3c75": "0xad78ebc5ac6200000",
  	"0x383304dd7a5720b29c1a10f60342219f48032f80": "0x12f939c99edab800000",
  	"0x383a7c899ee18bc214969870bc7482f6d8f3570e": "0x21e19e0c9bab2400000",
  	"0x38430e931d93be01b4c3ef0dc535f1e0a9610063": "0x21e19e0c9bab2400000",
  	"0x38439aaa24e3636f3a18e020ea1da7e145160d86": "0x8cf23f909c0fa00000",
  	"0x38458e0685573cb4d28f53098829904570179266": "0x22b1c8c1227a00000",
  	"0x3847667038f33b01c1cc795d8daf5475eff5a0d4": "0x277b9bf4246c410000",
  	"0x38643babea6011316cc797d9b093c897a17bdae7": "0x1220bb7445daa00000",
  	"0x38695fc7e1367ceb163ebb053751f9f68ddb07a0": "0x6c6b935b8bbd400000",
  	"0x3872f48dc5e3f817bc6b2ad2d030fc5e0471193d": "0xd8d726b7177a800000",
  	"0x387eeafd6b4009deaf8bd5b85a72983a8dcc3487": "0xd8d726b7177a800000",
  	"0x3881defae1c07b3ce04c78abe26b0cdc8d73f010": "0xad78ebc5ac6200000",
  	"0x3883becc08b9be68ad3b0836aac3b620dc0017ef": "0x6c6b935b8bbd400000",
  	"0x3885fee67107dc3a3c741ee290c98918c9b99397": "0x1158e460913d00000",
  	"0x3887192c7f705006b630091276b39ac680448d6b": "0x340aad21b3b700000",
  	"0x38898bbb4553e00bbfd0cf268b2fc464d154add5": "0x1158e460913d000000",
  	"0x388bdcdae794fc44082e667501344118ea96cd96": "0x5a87e7d7f5f6580000",
  	"0x388c85a9b9207d8146033fe38143f6d34b595c47": "0xad78ebc5ac6200000",
  	"0x3896ad743579d38e2302454d1fb6e2ab69e01bfd": "0x65ea3db75546600000",
  	"0x38a3dccf2fcfe0c91a2624bd0cbf88ee4a076c33": "0x6c6b935b8bbd400000",
  	"0x38a744efa6d5c2137defef8ef9187b649eee1c78": "0xd8d726b7177a800000",
  	"0x38ac664ee8e0795e4275cb852bcba6a479ad9c8d": "0x1158e460913d00000",
  	"0x38b2197106123387a0d4de368431a8bacdda30e2": "0x1158e460913d00000",
  	"0x38b3965c21fa893931079beacfffaf153678b6eb": "0x93c6a0a51e2670000",
  	"0x38b403fb1fb7c14559a2d6f6564a5552bca39aff": "0x6c6b935b8bbd400000",
  	"0x38b50146e71916a5448de12a4d742135dcf39833": "0x6d190c475169a200000",
  	"0x38bf2a1f7a69de0e2546adb808b36335645da9ff": "0x6c700439d9b5600000",
  	"0x38c10b90c859cbb7815692f99dae520ab5febf5e": "0x2c9e4966fa5cf240000",
  	"0x38c7851f5ffd4cee98df30f3b25597af8a6ca263": "0x8ead3a2f7d7e180000",
  	"0x38d2e9154964b41c8d50a7487d391e7ee2c3d3c2": "0xbdbc41e0348b300000",
  	"0x38da1ba2de9e2c954b092dd9d81204fd016ba016": "0x2268ed01f34b3300000",
  	"0x38df0c4abe7ded5fe068eadf154ac691774324a4": "0x61093d7c2c6d380000",
  	"0x38e2af73393ea98a1d993a74df5cd754b98d529a": "0x61093d7c2c6d380000",
  	"0x38e46de4453c38e941e7930f43304f94bb7b2be8": "0x6cb7e74867d5e60000",
  	"0x38e7dba8fd4f1f850dbc2649d8e84f0952e3eb3c": "0x2b5e3af16b1880000",
  	"0x38e8a31af2d265e31a9fff2d8f46286d1245a467": "0x1158e460913d00000",
  	"0x38ea6f5b5a7b88417551b4123dc127dfe9342da6": "0x15af1d78b58c400000",
  	"0x38eec6e217f4d41aa920e424b9525197041cd4c6": "0xf00d25eb922e670000",
  	"0x38f387e1a4ed4a73106ef2b462e474e2e3143ad0": "0x14542ba12a337c00000",
  	"0x391161b0e43c302066e8a68d2ce7e199ecdb1d57": "0xd8d726b7177a800000",
  	"0x3915eab5ab2e5977d075dec47d96b68b4b5cf515": "0xd07018185120f400000",
  	"0x391a77405c09a72b5e8436237aaaf95d68da1709": "0x2a9264af3d1b90000",
  	"0x391f20176d12360d724d51470a90703675594a4d": "0x56bc75e2d631000000",
  	"0x392433d2ce83d3fb4a7602cca3faca4ec140a4b0": "0x2c3c465ca58ec0000",
  	"0x393f783b5cdb86221bf0294fb714959c7b45899c": "0x14061b9d77a5e980000",
  	"0x393ff4255e5c658f2e7f10ecbd292572671bc2d2": "0x6c6b935b8bbd400000",
  	"0x394132600f4155e07f4d45bc3eb8d9fb72dcd784": "0x9f6e92edea07d40000",
  	"0x3951e48e3c869e6b72a143b6a45068cdb9d466d0": "0x1158e460913d00000",
  	"0x3954bdfe0bf587c695a305d9244c3d5bdddac9bb": "0x410278327f985608000",
  	"0x395d6d255520a8db29abc47d83a5db8a1a7df087": "0x56bc75e2d63100000",
  	"0x39636b25811b176abfcfeeca64bc87452f1fdff4": "0x15af1d78b58c400000",
  	"0x3969b4f71bb8751ede43c016363a7a614f76118e": "0x6c6b935b8bbd400000",
  	"0x39782ffe06ac78822a3c3a8afe305e50a56188ce": "0x21e19e0c9bab2400000",
  	"0x397a6ef8763a18f00fac217e055c0d3094101011": "0x6c6b935b8bbd400000",
  	"0x397cdb8c80c67950b18d654229610e93bfa6ee1a": "0x3f95c8e08215210000",
  	"0x39824f8bced176fd3ea22ec6a493d0ccc33fc147": "0xd8d726b7177a800000",
  	"0x39936c2719450b9420cc2522cf91db01f227c1c1": "0x1b1ae4d6e2ef500000",
  	"0x3995e096b08a5a726800fcd17d9c64c64e088d2b": "0xad78ebc5ac6200000",
  	"0x399aa6f5d078cb0970882bc9992006f8fbdf3471": "0x3635c9adc5dea00000",
  	"0x39aa05e56d7d32385421cf9336e90d3d15a9f859": "0x168d28e3f00280000",
  	"0x39aaf0854db6eb39bc7b2e43846a76171c0445de": "0x6449e84e47a8a80000",
  	"0x39b1c471ae94e12164452e811fbbe2b3cd7275ac": "0x6c6b935b8bbd400000",
  	"0x39b299327490d72f9a9edff11b83afd0e9d3c450": "0xad78ebc5ac6200000",
  	"0x39bac68d947859f59e9226089c96d62e9fbe3cde": "0x22b1c8c1227a00000",
  	"0x39bfd978689bec048fc776aa15247f5e1d7c39a2": "0x43c33c1937564800000",
  	"0x39c773367c8825d3596c686f42bf0d14319e3f84": "0x73f75d1a085ba0000",
  	"0x39d4a931402c0c79c457186f24df8729cf957031": "0xd8d726b7177a800000",
  	"0x39d6caca22bccd6a72f87ee7d6b59e0bde21d719": "0x6c8754c8f30c080000",
  	"0x39e0db4d60568c800b8c5500026c2594f5768960": "0x3635c9adc5dea00000",
  	"0x39ee4fe00fbced647068d4f57c01cb22a80bccd1": "0x14542ba12a337c00000",
  	"0x39f198331e4b21c1b760a3155f4ab2fe00a74619": "0x6c6b935b8bbd400000",
  	"0x39f44663d92561091b82a70dcf593d754005973a": "0xad78b2edc21598000",
  	"0x3a035594c747476d42d1ee966c36224cdd224993": "0x134af74569f9c50000",
  	"0x3a04572847d31e81f7765ca5bfc9d557159f3683": "0x7362d0dabeafd8000",
  	"0x3a06e3bb1edcfd0c44c3074de0bb606b049894a2": "0x21e19e0c9bab2400000",
  	"0x3a10888b7e149cae272c01302c327d0af01a0b24": "0xebec21ee1da40000",
  	"0x3a3108c1e680a33b336c21131334409d97e5adec": "0x1158e460913d00000",
  	"0x3a368efe4ad786e26395ec9fc6ad698cae29fe01": "0x2245899675f9f40000",
  	"0x3a3dd104cd7eb04f21932fd433ea7affd39369f5": "0x13614f23e242260000",
  	"0x3a4297da3c555e46c073669d0478fce75f2f790e": "0x6ac5c62d9486070000",
  	"0x3a476bd2c9e664c63ab266aa4c6e4a4825f516c3": "0xad78ebc5ac6200000",
  	"0x3a48e0a7098b06a905802b87545731118e89f439": "0x6c6b935b8bbd400000",
  	"0x3a4da78dce05aeb87de9aead9185726da1926798": "0xad78ebc5ac6200000",
  	"0x3a59a08246a8206f8d58f70bb1f0d35c5bcc71bd": "0xa076407d3f7440000",
  	"0x3a72d635aadeee4382349db98a1813a4cfeb3df1": "0x2a5a058fc295ed000000",
  	"0x3a7db224acae17de7798797d82cdf8253017dfa8": "0x10f0cf064dd59200000",
  	"0x3a805fa0f7387f73055b7858ca8519edd93d634f": "0x6449e84e47a8a80000",
  	"0x3a84e950ed410e51b7e8801049ab2634b285fea1": "0x3f52fdaa822d2c80000",
  	"0x3a86ee94862b743dd34f410969d94e2c5652d4ad": "0xaede69ad30e810000",
  	"0x3a9132b7093d3ec42e1e4fb8cb31ecdd43ae773c": "0x6c6b935b8bbd400000",
  	"0x3a9960266df6492063538a99f487c950a3a5ec9e": "0x5150ae84a8cdf000000",
  	"0x3a9b111029ce1f20c9109c7a74eeeef34f4f2eb2": "0xd8d726b7177a800000",
  	"0x3a9e5441d44b243be55b75027a1ceb9eacf50df2": "0x3635c9adc5dea00000",
  	"0x3aa07a34a1afc8967d3d1383b96b62cf96d5fa90": "0x43c33c1937564800000",
  	"0x3aa42c21b9b31c3e27ccd17e099af679cdf56907": "0x1b1ae4d6e2ef5000000",
  	"0x3aa948ea02397755effb2f9dc9392df1058f7e33": "0x2e141ea081ca080000",
  	"0x3aadf98b61e5c896e7d100a3391d3250225d61df": "0xcaf67003701680000",
  	"0x3aae4872fd9093cbcad1406f1e8078bab50359e2": "0x222c8eb3ff6640000",
  	"0x3abb8adfc604f48d5984811d7f1d52fef6758270": "0xf29719b66f110c0000",
  	"0x3ac2f0ff1612e4a1c346d53382abf6d8a25baa53": "0x6c6b935b8bbd400000",
  	"0x3ac9dc7a436ae98fd01c7a9621aa8e9d0b8b531d": "0x61093d7c2c6d380000",
  	"0x3ad06149b21c55ff867cc3fb9740d2bcc7101231": "0x29b76432b94451200000",
  	"0x3ad70243d88bf0400f57c8c1fd57811848af162a": "0x2e9ee5c38653f00000",
  	"0x3ad915d550b723415620f5a9b5b88a85f382f035": "0x3635c9adc5dea00000",
  	"0x3ae160e3cd60ae31b9d6742d68e14e76bd96c517": "0x1a055690d9db80000",
  	"0x3ae62bd271a760637fad79c31c94ff62b4cd12f7": "0x6c6b935b8bbd400000",
  	"0x3aea4e82d2400248f99871a41ca257060d3a221b": "0x3635c9adc5dea00000",
  	"0x3af65b3e28895a4a001153391d1e69c31fb9db39": "0xd5967be4fc3f100000",
  	"0x3b07db5a357f5af2484cbc9d77d73b1fd0519fc7": "0x1b1ae4d6e2ef500000",
  	"0x3b0accaf4b607cfe61d17334c214b75cdefdbd89": "0x6c6b935b8bbd400000",
  	"0x3b13631a1b89cb566548899a1d60915cdcc4205b": "0x6c6b935b8bbd400000",
  	"0x3b159099075207c6807663b1f0f7eda54ac8cce3": "0x6ac4e65b69f92d8000",
  	"0x3b1937d5e793b89b63fb8eb5f1b1c9ca6ba0fa8e": "0x6c6b935b8bbd400000",
  	"0x3b22da2a0271c8efe102532773636a69b1c17e09": "0x1b36a6444a3e180000",
  	"0x3b22dea3c25f1b59c7bd27bb91d3a3eaecef3984": "0x56bc75e2d63100000",
  	"0x3b2367f8494b5fe18d683c055d89999c9f3d1b34": "0x21e19e0c9bab2400000",
  	"0x3b2c45990e21474451cf4f59f01955b331c7d7c9": "0x6c6b935b8bbd400000",
  	"0x3b4100e30a73b0c734b18ffa8426d19b19312f1a": "0xbb5d1aa700afd900000",
  	"0x3b42a66d979f582834747a8b60428e9b4eeccd23": "0x21a1c790fadc580000",
  	"0x3b4768fd71e2db2cbe7fa050483c27b4eb931df3": "0x6c6b935b8bbd400000",
  	"0x3b566a8afad19682dc2ce8679a3ce444a5b0fd4f": "0x6c6b935b8bbd400000",
  	"0x3b5c251d7fd7893ba209fe541cecd0ce253a990d": "0x65a4da25d3016c00000",
  	"0x3b5e8b3c77f792decb7a8985df916efb490aac23": "0x6c6b935b8bbd400000",
  	"0x3b6e814f770748a7c3997806347605480a3fd509": "0x6c6b935b8bbd400000",
  	"0x3b7b4f53c45655f3dc5f017edc23b16f9bc536fa": "0x56bc75e2d63100000",
  	"0x3b7b8e27de33d3ce7961b98d19a52fe79f6c25be": "0x152d02c7e14af6800000",
  	"0x3b7c77dbe95dc2602ce3269a9545d04965fefdbd": "0x6c6b935b8bbd400000",
  	"0x3b8098533f7d9bdcd307dbb23e1777ca18418936": "0x6c6b935b8bbd400000",
  	"0x3b93b16136f11eaf10996c95990d3b2739ccea5f": "0x21e19e0c9bab2400000",
  	"0x3bab4b01a7c84ba13feea9b0bb191b77a3aadca3": "0xad78ebc5ac6200000",
  	"0x3bb53598cc20e2055dc553b049404ac9b7dd1e83": "0x21571df77c00be0000",
  	"0x3bbc13d04accc0707aebdcaef087d0b87e0b5ee3": "0xbed1d0263d9f000000",
  	"0x3bc6e3ee7a56ce8f14a37532590f63716b9966e8": "0x6c6b935b8bbd400000",
  	"0x3bc85d6c735b9cda4bba5f48b24b13e70630307b": "0x6acb3df27e1f880000",
  	"0x3bd624b548cb659736907ed8aa3c0c705e24b575": "0x6c6b935b8bbd400000",
  	"0x3bd9a06d1bd36c4edd27fc0d1f5b088ddae3c72a": "0x1b1a7a420ba00d0000",
  	"0x3bddbc8134f77d55597fc97c26d26698090604eb": "0xbe202d6a0eda0000",
  	"0x3bf86ed8a3153ec933786a02ac090301855e576b": "0x5f4a8c8375d155400000",
  	"0x3bfbd3847c17a61cf3f17b52f8eba1b960b3f39f": "0xa2a15d09519be00000",
  	"0x3c03bbc023e1e93fa3a3a6e428cf0cd8f95e1ec6": "0x52663ccab1e1c00000",
  	"0x3c0c3defac9cea7acc319a96c30b8e1fedab4574": "0x692ae8897081d00000",
  	"0x3c15b3511df6f0342e7348cc89af39a168b7730f": "0x3635c9adc5dea00000",
  	"0x3c1f91f301f4b565bca24751aa1f761322709ddd": "0x61093d7c2c6d380000",
  	"0x3c286cfb30146e5fd790c2c8541552578de334d8": "0x2291b11aa306e8c0000",
  	"0x3c322e611fdb820d47c6f8fc64b6fad74ca95f5e": "0xd258ece1b13150000",
  	"0x3c5a241459c6abbf630239c98a30d20b8b3ac561": "0x88b23acffd9900000",
  	"0x3c79c863c3d372b3ff0c6f452734a7f97042d706": "0x98a7d9b8314c00000",
  	"0x3c83c1701db0388b68210d00f5717cd9bd322c6a": "0x65a4da25d3016c00000",
  	"0x3c860e2e663f46db53427b29fe3ea5e5bf62bbcc": "0x556f64c1fe7fa0000",
  	"0x3c869c09696523ced824a070414605bb76231ff2": "0x3635c9adc5dea00000",
  	"0x3c925619c9b33144463f0537d896358706c520b0": "0x6c6b935b8bbd400000",
  	"0x3c98594bf68b57351e8814ae9e6dfd2d254aa06f": "0x1043561a8829300000",
  	"0x3cadeb3d3eed3f62311d52553e70df4afce56f23": "0xd8d726b7177a800000",
  	"0x3caedb5319fe806543c56e5021d372f71be9062e": "0x878678326eac9000000",
  	"0x3cafaf5e62505615068af8eb22a13ad8a9e55070": "0x6c660645aa47180000",
  	"0x3cb179cb4801a99b95c3b0c324a2bdc101a65360": "0x168d28e3f00280000",
  	"0x3cb561ce86424b359891e364ec925ffeff277df7": "0xad78ebc5ac6200000",
  	"0x3ccb71aa6880cb0b84012d90e60740ec06acd78f": "0x6c6b935b8bbd400000",
  	"0x3ccef88679573947e94997798a1e327e08603a65": "0x2bc916d69f3b020000",
  	"0x3cd1d9731bd548c1dd6fcea61beb75d91754f7d3": "0x1161d01b215cae48000",
  	"0x3cd3a6e93579c56d494171fc533e7a90e6f59464": "0x6c6b935b8bbd400000",
  	"0x3cd6b7593cbee77830a8b19d0801958fcd4bc57a": "0x1b1ae4d6e2ef500000",
  	"0x3cd7f7c7c2353780cde081eeec45822b25f2860c": "0xad78ebc5ac6200000",
  	"0x3ce1dc97fcd7b7c4d3a18a49d6f2a5c1b1a906d7": "0xad78ebc5ac6200000",
  	"0x3cea302a472a940379dd398a24eafdbadf88ad79": "0xa2a15d09519be00000",
  	"0x3ceca96bb1cdc214029cbc5e181d398ab94d3d41": "0x10f0cf064dd592000000",
  	"0x3cf484524fbdfadae26dc185e32b2b630fd2e726": "0x185452cb2a91c30000",
  	"0x3cf9a1d465e78b7039e3694478e2627b36fcd141": "0x4a60532ad51bf00000",
  	"0x3cfbf066565970639e130df2a7d16b0e14d6091c": "0x5c283d410394100000",
  	"0x3d09688d93ad07f3abe68c722723cd680990435e": "0x65a4ce99f769e6e0000",
  	"0x3d31587b5fd5869845788725a663290a49d3678c": "0x1b1ae4d6e2ef500000",
  	"0x3d3fad49c9e5d2759c8e8e5a7a4d60a0dd135692": "0x1158e460913d00000",
  	"0x3d574fcf00fae1d98cc8bf9ddfa1b3953b9741bc": "0x6acb3df27e1f880000",
  	"0x3d5a8b2b80be8b35d8ecf789b5ed7a0775c5076c": "0x1158e460913d00000",
  	"0x3d66cd4bd64d5c8c1b5eea281e106d1c5aad2373": "0x69c4f3a8a110a60000",
  	"0x3d6ae053fcbc318d6fd0fbc353b8bf542e680d27": "0xc673ce3c40160000",
  	"0x3d6ff82c9377059fb30d9215723f60c775c891fe": "0xd8e5ce617f2d50000",
  	"0x3d79a853d71be0621b44e29759656ca075fdf409": "0x6c6b935b8bbd400000",
  	"0x3d7ea5bf03528100ed8af8aed2653e921b6e6725": "0x3635c9adc5dea00000",
  	"0x3d813ff2b6ed57b937dabf2b381d148a411fa085": "0x56bc75e2d63100000",
  	"0x3d881433f04a7d0d27f84944e08a512da3555287": "0x410d586a20a4c00000",
  	"0x3d89e505cb46e211a53f32f167a877bec87f4b0a": "0x15b3557f1937f8000",
  	"0x3d8d0723721e73a6c0d860aa0557abd14c1ee362": "0x10f0cf064dd59200000",
  	"0x3d8f39881b9edfe91227c33fa4cdd91e678544b0": "0x4ab07ba43ada98000",
  	"0x3d9d6be57ff83e065985664f12564483f2e600b2": "0x6eace43f23bd800000",
  	"0x3da39ce3ef4a7a3966b32ee7ea4ebc2335a8f11f": "0x6c6b935b8bbd400000",
  	"0x3daa01ceb70eaf9591fa521ba4a27ea9fb8ede4a": "0x5a63d2c9bc76540000",
  	"0x3db5fe6a68bd3612ac15a99a61e555928eeceaf3": "0x55a6e79ccd1d300000",
  	"0x3db9ed7f024c7e26372feacf2b050803445e3810": "0x45b148b4996a300000",
  	"0x3dbf0dbfd77890800533f09dea8301b9f025d2a6": "0x3635c9adc5dea00000",
  	"0x3dcef19c868b15d34eda426ec7e04b18b6017002": "0x6c68ccd09b022c0000",
  	"0x3dd12e556a603736feba4a6fa8bd4ac45d662a04": "0x23757b9183e078280000",
  	"0x3dde8b15b3ccbaa5780112c3d674f313bba68026": "0x601d515a3e4f940000",
  	"0x3ddedbe48923fbf9e536bf9ffb0747c9cdd39eef": "0x368c8623a8b4d100000",
  	"0x3deae43327913f62808faa1b6276a2bd6368ead9": "0x6c6b935b8bbd400000",
  	"0x3df762049eda8ac6927d904c7af42f94e5519601": "0x6c6b935b8bbd400000",
  	"0x3e040d40cb80ba0125f3b15fdefcc83f3005da1b": "0x384524cc70b7780000",
  	"0x3e0b8ed86ed669e12723af7572fbacfe829b1e16": "0x514de7f9b812dc0000",
  	"0x3e0cbe6a6dcb61f110c45ba2aa361d7fcad3da73": "0x1b2df9d219f57980000",
  	"0x3e194b4ecef8bb711ea2ff24fec4e87bd032f7d1": "0x8b9dc1bc1a036a8000",
  	"0x3e1b2230afbbd310b4926a4c776d5ae7819c661d": "0x65a4da25d3016c00000",
  	"0x3e1c53300e4c168912163c7e99b95da268ad280a": "0x3662325cd18fe00000",
  	"0x3e1c962063e0d5295941f210dca3ab531eec8809": "0xa2a15d09519be00000",
  	"0x3e2ca0d234baf607ad466a1b85f4a6488ef00ae7": "0x4da21a3483d568000",
  	"0x3e2f26235e137a7324e4dc154b5df5af46ea1a49": "0x137aad8032db90000",
  	"0x3e3161f1ea2fbf126e79da1801da9512b37988c9": "0xa6dd90cae5114480000",
  	"0x3e36c17253c11cf38974ed0db1b759160da63783": "0x17b7883c06916600000",
  	"0x3e3cd3bec06591d6346f254b621eb41c89008d31": "0x35dfbeda9f37340000",
  	"0x3e45bd55db9060eced923bb9cb733cb3573fb531": "0x58e7926ee858a00000",
  	"0x3e4d13c55a84e46ed7e9cb90fd355e8ad991e38f": "0x3635c9adc5dea00000",
  	"0x3e4e9265223c9738324cf20bd06006d0073edb8c": "0x73f75d1a085ba0000",
  	"0x3e4fbd661015f6461ed6735cefef01f31445de3a": "0x36e342998b8b0200000",
  	"0x3e53ff2107a8debe3328493a92a586a7e1f49758": "0x4e69c2a71a405ab0000",
  	"0x3e5a39fdda70df1126ab0dc49a7378311a537a1f": "0x821ab0d44149800000",
  	"0x3e5abd09ce5af7ba8487c359e0f2a93a986b0b18": "0x21e19e0c9bab2400000",
  	"0x3e5cb8928c417825c03a3bfcc52183e5c91e42d7": "0xe731d9c52c962f0000",
  	"0x3e5e93fb4c9c9d1246f8f247358e22c3c5d17b6a": "0x821ab0d4414980000",
  	"0x3e618350fa01657ab0ef3ebac8e37012f8fc2b6f": "0x9806de3da6e9780000",
  	"0x3e63ce3b24ca2865b4c5a687b7aea3597ef6e548": "0x6c6b935b8bbd400000",
  	"0x3e66b84769566ab67945d5fa81373556bcc3a1fa": "0x83d6c7aab63600000",
  	"0x3e76a62db187aa74f63817533b306cead0e8cebe": "0x69b5afac750bb800000",
  	"0x3e7a966b5dc357ffb07e9fe067c45791fd8e3049": "0x3342d60dff1960000",
  	"0x3e81772175237eb4cbe0fe2dcafdadffeb6a1999": "0x1dd0c885f9a0d800000",
  	"0x3e8349b67f5745449f659367d9ad4712db5b895a": "0x62a992e53a0af00000",
  	"0x3e83544f0082552572c782bee5d218f1ef064a9d": "0x56cd55fc64dfe0000",
  	"0x3e84b35c5b2265507061d30b6f12da033fe6f8b9": "0x61093d7c2c6d380000",
  	"0x3e8641d43c42003f0a33c929f711079deb2b9e46": "0x1b1ae4d6e2ef500000",
  	"0x3e8745ba322f5fd6cb50124ec46688c7a69a7fae": "0x10afc1ade3b4ed40000",
  	"0x3e914e3018ac00449341c49da71d04dfeeed6221": "0xd8d726b7177a800000",
  	"0x3e9410d3b9a87ed5e451a6b91bb8923fe90fb2b5": "0xad78ebc5ac6200000",
  	"0x3e94df5313fa520570ef232bc3311d5f622ff183": "0x6c6b935b8bbd400000",
  	"0x3e9b34a57f3375ae59c0a75e19c4b641228d9700": "0xf8699329677e0000",
  	"0x3eada8c92f56067e1bb73ce378da56dc2cdfd365": "0x77cde93aeb0d480000",
  	"0x3eaf0879b5b6db159b589f84578b6a74f6c10357": "0x18938b671fa65a28000",
  	"0x3eaf316b87615d88f7adc77c58e712ed4d77966b": "0x56dbc4cee24648000",
  	"0x3eb8b33b21d23cda86d8288884ab470e164691b5": "0x1b1ae4d6e2ef500000",
  	"0x3eb9ef06d0c259040319947e8c7a6812aa0253d8": "0x90d972f32323c0000",
  	"0x3ecc8e1668dde995dc570fe414f44211c534a615": "0x6c6b935b8bbd400000",
  	"0x3ecdb532e397579662b2a46141e78f8235936a5f": "0x39fbae8d042dd0000",
  	"0x3eee6f1e96360b7689b3069adaf9af8eb60ce481": "0x3635c9adc5dea00000",
  	"0x3f08d9ad894f813e8e2148c160d24b353a8e74b0": "0xcb49b44ba602d800000",
  	"0x3f0c83aac5717962734e5ceaeaecd39b28ad06be": "0x6c6b935b8bbd400000",
  	"0x3f10800282d1b7ddc78fa92d8230074e1bf6aeae": "0x10afc1ade3b4ed40000",
  	"0x3f1233714f204de9de4ee96d073b368d8197989f": "0x217c41074e6bb0000",
  	"0x3f173aa6edf469d185e59bd26ae4236b92b4d8e1": "0x1158e460913d000000",
  	"0x3f1bc420c53c002c9e90037c44fe6a8ef4ddc962": "0x960db77681e940000",
  	"0x3f236108eec72289bac3a65cd283f95e041d144c": "0x3634bf39ab98788000",
  	"0x3f2da093bb16eb064f8bfa9e30b929d15f8e1c4c": "0x6c6b935b8bbd400000",
  	"0x3f2dd55db7eab0ebee65b33ed8202c1e992e958b": "0x2c73c937742c500000",
  	"0x3f2f381491797cc5c0d48296c14fd0cd00cdfa2d": "0x2b95bdcc39b6100000",
  	"0x3f30d3bc9f602232bc724288ca46cd0b0788f715": "0xd8d726b7177a800000",
  	"0x3f3c8e61e5604cef0605d436dd22accd862217fc": "0x487a9a304539440000",
  	"0x3f3f46b75cabe37bfacc8760281f4341ca7f463d": "0x20ac448235fae88000",
  	"0x3f472963197883bbda5a9b7dfcb22db11440ad31": "0x1a19643cb1eff08000",
  	"0x3f4cd1399f8a34eddb9a17a471fc922b5870aafc": "0xad78ebc5ac6200000",
  	"0x3f551ba93cd54693c183fb9ad60d65e1609673c9": "0x6c6b935b8bbd400000",
  	"0x3f627a769e6a950eb87017a7cd9ca20871136831": "0x2eb8eb1a172dcb80000",
  	"0x3f6dd3650ee428dcb7759553b017a96a94286ac9": "0x487a9a304539440000",
  	"0x3f747237806fed3f828a6852eb0867f79027af89": "0x5150ae84a8cdf00000",
  	"0x3f75ae61cc1d8042653b5baec4443e051c5e7abd": "0x52d542804f1ce0000",
  	"0x3fb7d197b3ba4fe045efc23d50a14585f558d9b2": "0x1158e460913d00000",
  	"0x3fbc1e4518d73400c6d046359439fb68ea1a49f4": "0x3790bb8551376400000",
  	"0x3fbed6e7e0ca9c84fbe9ebcf9d4ef9bb49428165": "0x6c6b935b8bbd400000",
  	"0x3fd0bb47798cf44cdfbe4d333de637df4a00e45c": "0x56c5579f722140000",
  	"0x3fe40fbd919aad2818df01ee4df46c46842ac539": "0x14542ba12a337c00000",
  	"0x3fe801e61335c5140dc7eda2ef5204460a501230": "0x6c6b935b8bbd400000",
  	"0x3ff836b6f57b901b440c30e4dbd065cf37d3d48c": "0xad78ebc5ac6200000",
  	"0x3ffcb870d4023d255d5167d8a507cefc366b68ba": "0x23343c4354d2ac0000",
  	"0x401354a297952fa972ad383ca07a0a2811d74a71": "0xc249fdd327780000",
  	"0x4030a925706b2c101c8c5cb9bd05fbb4f6759b18": "0xd8d726b7177a800000",
  	"0x403145cb4ae7489fcc90cd985c6dc782b3cc4e44": "0x1453ff387b27cac0000",
  	"0x403220600a36f73f24e190d1edb2d61be3f41354": "0x107ad8f556c6c00000",
  	"0x4039bd50a2bde15ffe37191f410390962a2b8886": "0xad78ebc5ac6200000",
  	"0x403c64896a75cad816a9105e18d8aa5bf80f238e": "0x35659ef93f0fc40000",
  	"0x403d53cf620f0922b417848dee96c190b5bc8271": "0x215f835bc769da80000",
  	"0x404100db4c5d0eec557823b58343758bcc2c8083": "0x1158e460913d00000",
  	"0x4041374b0feef4792e4b33691fb86897a4ff560c": "0x13c9647e25a9940000",
  	"0x40467d80e74c35407b7db51789234615fea66818": "0x150894e849b3900000",
  	"0x40585200683a403901372912a89834aadcb55fdb": "0x6c6b935b8bbd400000",
  	"0x4058808816fdaa3a5fc98ed47cfae6c18315422e": "0xad4c8316a0b0c0000",
  	"0x405f596b94b947344c033ce2dcbff12e25b79784": "0x6c6b935b8bbd400000",
  	"0x40630024bd2c58d248edd8465617b2bf1647da0e": "0x3635c9adc5dea00000",
  	"0x40652360d6716dc55cf9aab21f3482f816cc2cbd": "0x21e19e0c9bab2400000",
  	"0x407295ebd94b48269c2d569c9b9af9aa05e83e5e": "0x21e19e0c9bab2400000",
  	"0x4073fa49b87117cb908cf1ab512da754a932d477": "0x6acb3df27e1f880000",
  	"0x408a69a40715e1b313e1354e600800a1e6dc02a5": "0x1e7b891cc92540000",
  	"0x409bd75085821c1de70cdc3b11ffc3d923c74010": "0xd8d726b7177a800000",
  	"0x409d5a962edeeebea178018c0f38b9cdb213f289": "0x1158e460913d00000",
  	"0x40a331195b977325c2aa28fa2f42cb25ec3c253c": "0x6c6b935b8bbd400000",
  	"0x40a7f72867a7dc86770b162b7557a434ed50cce9": "0x3635c9adc5dea00000",
  	"0x40ab0a3e83d0c8ac9366910520eab1772bac3b1a": "0x34f10c2dc05e7c0000",
  	"0x40ab66fe213ea56c3afb12c75be33f8e32fd085d": "0xd8d726b7177a800000",
  	"0x40ad74bc0bce2a45e52f36c3debb1b3ada1b7619": "0x170162de109c6580000",
  	"0x40cf890591eae4a18f812a2954cb295f633327e6": "0x29bf736fc591a0000",
  	"0x40cf90ef5b768c5da585002ccbe6617650d8e837": "0x36330322d5238c0000",
  	"0x40d45d9d7625d15156c932b771ca7b0527130958": "0x152d02c7e14af6800000",
  	"0x40db1ba585ce34531edec5494849391381e6ccd3": "0x61093d7c2c6d380000",
  	"0x40df495ecf3f8b4cef2a6c189957248fe884bc2b": "0x28a857425466f800000",
  	"0x40e0dbf3efef9084ea1cd7e503f40b3b4a8443f6": "0xd8d726b7177a800000",
  	"0x40e2440ae142c880366a12c6d4102f4b8434b62a": "0x3635c9adc5dea00000",
  	"0x40e3c283f7e24de0410c121bee60a5607f3e29a6": "0x3635c9adc5dea00000",
  	"0x40ea5044b204b23076b1a5803bf1d30c0f88871a": "0x2f6f10780d22cc00000",
  	"0x40eddb448d690ed72e05c225d34fc8350fa1e4c5": "0x17b7883c06916600000",
  	"0x40f4f4c06c732cd35b119b893b127e7d9d0771e4": "0x21e19e0c9bab2400000",
  	"0x41010fc8baf8437d17a04369809a168a17ca56fb": "0x56bc75e2d63100000",
  	"0x4103299671d46763978fa4aa19ee34b1fc952784": "0xad78ebc5ac6200000",
  	"0x41033c1b6d05e1ca89b0948fc64453fbe87ab25e": "0x487a9a304539440000",
  	"0x41098a81452317c19e3eef0bd123bbe178e9e9ca": "0x97c9ce4cf6d5c00000",
  	"0x411610b178d5617dfab934d293f512a93e5c10e1": "0x93739534d28680000",
  	"0x411c831cc6f44f1965ec5757ab4e5b3ca4cffd1f": "0x170a0f5040e5040000",
  	"0x412a68f6c645559cc977fc4964047a201d1bb0e2": "0xa968163f0a57b400000",
  	"0x413f4b02669ccff6806bc826fcb7deca3b0ea9bc": "0x1158e460913d00000",
  	"0x414599092e879ae25372a84d735af5c4e510cd6d": "0x15af1d78b58c400000",
  	"0x41485612d03446ec4c05e5244e563f1cbae0f197": "0x34957444b840e80000",
  	"0x415d096ab06293183f3c033d25f6cf7178ac3bc7": "0x22b1c8c1227a00000",
  	"0x4166fc08ca85f766fde831460e9dc93c0e21aa6c": "0x3635c9adc5dea00000",
  	"0x416784af609630b070d49a8bcd12235c6428a408": "0x43c33c1937564800000",
  	"0x4167cd48e733418e8f99ffd134121c4a4ab278c4": "0xc55325ca7415e00000",
  	"0x416c86b72083d1f8907d84efd2d2d783dffa3efb": "0x6c6acc67d7b1d40000",
  	"0x4173419d5c9f6329551dc4d3d0ceac1b701b869e": "0x4c53ecdc18a600000",
  	"0x4174fa1bc12a3b7183cbabb77a0b59557ba5f1db": "0x6c6b935b8bbd400000",
  	"0x41786a10d447f484d33244ccb7facd8b427b5b8c": "0x3635c9adc5dea00000",
  	"0x417a3cd19496530a6d4204c3b5a17ce0f207b1a5": "0x1b1ae4d6e2ef5000000",
  	"0x417e4e2688b1fd66d821529e46ed4f42f8b3db3d": "0x6c6b935b8bbd400000",
  	"0x419a71a36c11d105e0f2aef5a3e598078e85c80b": "0x10f0cf064dd59200000",
  	"0x419bde7316cc1ed295c885ace342c79bf7ee33ea": "0x14542ba12a337c00000",
  	"0x41a2f2e6ecb86394ec0e338c0fc97e9c5583ded2": "0x6cee06ddbe15ec0000",
  	"0x41a8c2830081b102df6e0131657c07ab635b54ce": "0x6c6acc67d7b1d40000",
  	"0x41a8e236a30e6d63c1ff644d132aa25c89537e01": "0x1158e460913d00000",
  	"0x41a9a404fc9f5bfee48ec265b12523338e29a8bf": "0x150894e849b3900000",
  	"0x41ad369f758fef38a19aa3149379832c818ef2a0": "0x36369ed7747d260000",
  	"0x41b2d34fde0b1029262b4172c81c1590405b03ae": "0x3635c9adc5dea00000",
  	"0x41b2dbd79dda9b864f6a7030275419c39d3efd3b": "0xad78ebc5ac62000000",
  	"0x41c3c2367534d13ba2b33f185cdbe6ac43c2fa31": "0xd8d726b7177a800000",
  	"0x41cb9896445f70a10a14215296daf614e32cf4d5": "0x678a932062e4180000",
  	"0x41ce79950935cff55bf78e4ccec2fe631785db95": "0x6c6b935b8bbd400000",
  	"0x41d3b731a326e76858baa5f4bd89b57b36932343": "0x155bd9307f9fe80000",
  	"0x41e4a20275e39bdcefeb655c0322744b765140c2": "0x21e19e0c9bab2400000",
  	"0x41ed2d8e7081482c919fc23d8f0091b3c82c4685": "0x463a1e765bd78a0000",
  	"0x41f27e744bd29de2b0598f02a0bb9f98e681eaa4": "0x1a4aba225c207400000",
  	"0x41f489a1ec747bc29c3e5f9d8db97877d4d1b4e9": "0x73f75d1a085ba0000",
  	"0x420fb86e7d2b51401fc5e8c72015decb4ef8fc2e": "0x3635c9adc5dea00000",
  	"0x421684baa9c0b4b5f55338e6f6e7c8e146d41cb7": "0x5150ae84a8cdf00000",
  	"0x42399659aca6a5a863ea2245c933fe9a35b7880e": "0x6ece32c26c82700000",
  	"0x423bca47abc00c7057e3ad34fca63e375fbd8b4a": "0x3cfc82e37e9a7400000",
  	"0x423c3107f4bace414e499c64390a51f74615ca5e": "0x6c6b935b8bbd400000",
  	"0x423cc4594cf4abb6368de59fd2b1230734612143": "0x6c6b935b8bbd400000",
  	"0x4244f1331158b9ce26bbe0b9236b9203ca351434": "0x21e19e0c9bab2400000",
  	"0x425177eb74ad0a9d9a5752228147ee6d6356a6e6": "0xb98bc829a6f90000",
  	"0x425725c0f08f0811f5f006eec91c5c5c126b12ae": "0x821ab0d4414980000",
  	"0x4258fd662fc4ce3295f0d4ed8f7bb1449600a0a9": "0x16c452ed6088ad80000",
  	"0x425c1816868f7777cc2ba6c6d28c9e1e796c52b3": "0x21e19e0c9bab2400000",
  	"0x425c338a1325e3a1578efa299e57d986eb474f81": "0x6c6b935b8bbd400000",
  	"0x426259b0a756701a8b663528522156c0288f0f24": "0x218ae196b8d4f300000",
  	"0x426d15f407a01135b13a6b72f8f2520b3531e302": "0x1158e460913d00000",
  	"0x426f78f70db259ac8534145b2934f4ef1098b5d8": "0x138400eca364a00000",
  	"0x42732d8ef49ffda04b19780fd3c18469fb374106": "0x170b00e5e4a9be0000",
  	"0x427417bd16b1b3d22dbb902d8f9657016f24a61c": "0x6c6b935b8bbd400000",
  	"0x42746aeea14f27beff0c0da64253f1e7971890a0": "0x54069233bf7f780000",
  	"0x427b462ab84e5091f48a46eb0cdc92ddcb26e078": "0x6c6b935b8bbd400000",
  	"0x427e4751c3babe78cff8830886febc10f9908d74": "0x6acb3df27e1f880000",
  	"0x427ec668ac9404e895cc861511d1620a4912be98": "0x878678326eac9000000",
  	"0x4280a58f8bb10b9440de94f42b4f592120820191": "0x6c6b935b8bbd400000",
  	"0x428a1ee0ed331d7952ccbe1c7974b2852bd1938a": "0x77b74a4e8de5650000",
  	"0x429c06b487e8546abdfc958a25a3f0fba53f6f00": "0xbb644af542198000",
  	"0x42a98bf16027ce589c4ed2c95831e2724205064e": "0x21e19e0c9bab2400000",
  	"0x42c6edc515d35557808d13cd44dcc4400b2504e4": "0xaba14c59ba7320000",
  	"0x42cecfd2921079c2d7df3f08b07aa3beee5e219a": "0x3635c9adc5dea00000",
  	"0x42d1a6399b3016a8597f8b640927b8afbce4b215": "0xa18bcec34888100000",
  	"0x42d34940edd2e7005d46e2188e4cfece8311d74d": "0x890b0c2e14fb80000",
  	"0x42d3a5a901f2f6bd9356f112a70180e5a1550b60": "0x3224f42723d4540000",
  	"0x42d6b263d9e9f4116c411424fc9955783c763030": "0x6c6b935b8bbd400000",
  	"0x42db0b902559e04087dd5c441bc7611934184b89": "0x6d33b17d253a620000",
  	"0x42ddd014dc52bfbcc555325a40b516f4866a1dd3": "0x6c6b935b8bbd400000",
  	"0x4319263f75402c0b5325f263be4a5080651087f0": "0x354b0f14631bab0000",
  	"0x431f2c19e316b044a4b3e61a0c6ff8c104a1a12f": "0x3635c9adc5dea00000",
  	"0x43227d65334e691cf231b4a4e1d339b95d598afb": "0x21e19e0c9bab2400000",
  	"0x432809a2390f07c665921ff37d547d12f1c9966a": "0x65a4da25d3016c00000",
  	"0x4329fc0931cbeb033880fe4c9398ca45b0e2d11a": "0x6c7120716d33680000",
  	"0x432d884bd69db1acc0d89c64ade4cb4fc3a88b7a": "0x869a8c10808eec0000",
  	"0x4331ab3747d35720a9d8ca25165cd285acd4bda8": "0x6c6b935b8bbd400000",
  	"0x433a3b68e56b0df1862b90586bbd39c840ff1936": "0x6c6b935b8bbd400000",
  	"0x433e3ba1c51b810fc467d5ba4dea42f7a9885e69": "0x878678326eac9000000",
  	"0x433eb94a339086ed12d9bde9cd1d458603c97dd6": "0x152d02c7e14af6800000",
  	"0x4349225a62f70aea480a029915a01e5379e64fa5": "0x8cd67e2334c0d80000",
  	"0x4354221e62dc09e6406436163a185ef06d114a81": "0x6c6b935b8bbd400000",
  	"0x435443b81dfdb9bd8c6787bc2518e2d47e57c15f": "0x1438d9397881ef20000",
  	"0x4361d4846fafb377b6c0ee49a596a78ddf3516a3": "0xc2127af858da700000",
  	"0x4364309a9fa07095600f79edc65120cdcd23dc64": "0x21e19e0c9bab2400000",
  	"0x4367ae4b0ce964f4a54afd4b5c368496db169e9a": "0x6c6b935b8bbd400000",
  	"0x43748928e8c3ec4436a1d092fbe43ac749be1251": "0x15af1d78b58c400000",
  	"0x43767bf7fd2af95b72e9312da9443cb1688e4343": "0x1043561a8829300000",
  	"0x437983388ab59a4ffc215f8e8269461029c3f1c1": "0x43c33c1937564800000",
  	"0x43898c49a34d509bfed4f76041ee91caf3aa6aa5": "0x1043561a8829300000",
  	"0x438c2f54ff8e629bab36b1442b760b12a88f02ae": "0x6c6b935b8bbd400000",
  	"0x4398628ea6632d393e929cbd928464c568aa4a0c": "0x4be4e7267b6ae00000",
  	"0x439d2f2f5110a4d58b1757935015408740fec7f8": "0xcfa5c5150f4c888000",
  	"0x439dee3f7679ff1030733f9340c096686b49390b": "0x6c6b935b8bbd400000",
  	"0x43b079baf0727999e66bf743d5bcbf776c3b0922": "0x6c6b935b8bbd400000",
  	"0x43bc2d4ddcd6583be2c7bc094b28fb72e62ba83b": "0x6c6b935b8bbd400000",
  	"0x43c7ebc5b3e7af16f47dc5617ab10e0f39b4afbb": "0x678a932062e4180000",
  	"0x43cb9652818c6f4d6796b0e89409306c79db6349": "0x6c6b935b8bbd400000",
  	"0x43cc08d0732aa58adef7619bed46558ad7774173": "0xf0e7dcb0122a8f0000",
  	"0x43d5a71ce8b8f8ae02b2eaf8eaf2ca2840b93fb6": "0x14542ba12a337c00000",
  	"0x43db7ff95a086d28ebbfb82fb8fb5f230a5ebccd": "0xdf6eb0b2d3ca0000",
  	"0x43e7ec846358d7d0f937ad1c350ba069d7bf72bf": "0x670ae629214680000",
  	"0x43f16f1e75c3c06a9478e8c597a40a3cb0bf04cc": "0x9df7dfa8f760480000",
  	"0x43f470ed659e2991c375957e5ddec5bd1d382231": "0x56bc75e2d63100000",
  	"0x43f7e86e381ec51ec4906d1476cba97a3db584e4": "0x3635c9adc5dea00000",
  	"0x43ff38743ed0cd43308c066509cc8e7e72c862aa": "0x692ae8897081d00000",
  	"0x43ff8853e98ed8406b95000ada848362d6a0392a": "0x4ae0b1c4d2e84d00000",
  	"0x44098866a69b68c0b6bc168229b9603587058967": "0xa31062beeed700000",
  	"0x4419ac618d5dea7cdc6077206fb07dbdd71c1702": "0xd8d726b7177a800000",
  	"0x441a52001661fac718b2d7b351b7c6fb521a7afd": "0x15af1d78b58c400000",
  	"0x441aca82631324acbfa2468bda325bbd78477bbf": "0x14542ba12a337c00000",
  	"0x441f37e8a029fd02482f289c49b5d06d00e408a4": "0x1211ecb56d13488000",
  	"0x4420aa35465be617ad2498f370de0a3cc4d230af": "0x6c6b935b8bbd400000",
  	"0x44232ff66ddad1fd841266380036afd7cf7d7f42": "0xad78ebc5ac6200000",
  	"0x44250d476e062484e9080a3967bf3a4a732ad73f": "0x1158e460913d00000",
  	"0x4429a29fee198450672c0c1d073162250bec6474": "0x362aaf8202f2500000",
  	"0x44355253b27748e3f34fe9cae1fb718c8f249529": "0xad78ebc5ac6200000",
  	"0x4438e880cb2766b0c1ceaec9d2418fceb952a044": "0x73fa073903f080000",
  	"0x444caf79b71338ee9aa7c733b02acaa7dc025948": "0x22b1c8c1227a00000",
  	"0x445cb8de5e3df520b499efc980f52bff40f55c76": "0x6c6b935b8bbd400000",
  	"0x446a8039cecf9dce4879cbcaf3493bf545a88610": "0x17b7883c06916600000",
  	"0x4474299d0ee090dc90789a1486489c3d0d645e6d": "0x3635c9adc5dea00000",
  	"0x448bf410ad9bbc2fecc4508d87a7fc2e4b8561ad": "0xad6eedd17cf3b8000",
  	"0x44901e0d0e08ac3d5e95b8ec9d5e0ff5f12e0393": "0x16a1f9f5fd7d960000",
  	"0x4493123c021ece3b33b1a452c9268de14007f9d3": "0x16a6502f15a1e540000",
  	"0x449ac4fbe383e36738855e364a57f471b2bfa131": "0x29b76432b94451200000",
  	"0x44a01fb04ac0db2cce5dbe281e1c46e28b39d878": "0x6c6acc67d7b1d40000",
  	"0x44a63d18424587b9b307bfc3c364ae10cd04c713": "0x1158e460913d00000",
  	"0x44a8989e32308121f72466978db395d1f76c3a4b": "0x18850299f42b06a0000",
  	"0x44c1110b18870ec81178d93d215838c551d48e64": "0xad6f98593bd8f0000",
  	"0x44c14765127cde11fab46c5d2cf4d4b2890023fd": "0x6c6b935b8bbd400000",
  	"0x44c54eaa8ac940f9e80f1e74e82fc14f1676856a": "0x1ab2cf7c9f87e200000",
  	"0x44cd77535a893fa7c4d5eb3a240e79d099a72d2d": "0x2c73c937742c500000",
  	"0x44dfba50b829becc5f4f14d1b04aab3320a295e5": "0x3635c9adc5dea00000",
  	"0x44e2fdc679e6bee01e93ef4a3ab1bcce012abc7c": "0x163d194900c5458000",
  	"0x44f62f2aaabc29ad3a6b04e1ff6f9ce452d1c140": "0x39992648a23c8a00000",
  	"0x44fff37be01a3888d3b8b8e18880a7ddefeeead3": "0xe0c5bfc7dae9a8000",
  	"0x4506fe19fa4b006baa3984529d8516db2b2b50ab": "0x6c6b935b8bbd400000",
  	"0x451b3699475bed5d7905f8905aa3456f1ed788fc": "0x8ac7230489e8000000",
  	"0x451b7070259bdba27100e36e23428a53dfe304e9": "0xb98bc829a6f90000",
  	"0x45272b8f62e9f9fa8ce04420e1aea3eba9686eac": "0xd8d726b7177a800000",
  	"0x452b64db8ef7d6df87c788639c2290be8482d575": "0x1b1ae4d6e2ef5000000",
  	"0x453e359a3397944c5a275ab1a2f70a5e5a3f6989": "0xd02ab486cedc00000",
  	"0x4549b15979255f7e65e99b0d5604db98dfcac8bf": "0xd8d726b7177a800000",
  	"0x454b61b344c0ef965179238155f277c3829d0b38": "0x6c6b935b8bbd400000",
  	"0x454f0141d721d33cbdc41018bd01119aa4784818": "0x14542ba12a337c00000",
  	"0x45533390e340fe0de3b3cf5fb9fc8ea552e29e62": "0x4f2591f896a6500000",
  	"0x455396a4bbd9bae8af9fb7c4d64d471db9c24505": "0x8ba52e6fc45e40000",
  	"0x455b9296921a74d1fc41617f43b8303e6f3ed76c": "0xe3aeb5737240a00000",
  	"0x455cb8ee39ffbc752331e5aefc588ef0ee593454": "0x3635463a780def8000",
  	"0x456ae0aca48ebcfae166060250525f63965e760f": "0x1043561a8829300000",
  	"0x456f8d746682b224679349064d1b368c7c05b176": "0xc893d09c8f51500000",
  	"0x457029c469c4548d168cec3e65872e4428d42b67": "0x6c6b935b8bbd400000",
  	"0x4571de672b9904bad8743692c21c4fdcea4c2e01": "0xd8d726b7177a800000",
  	"0x45781bbe7714a1c8f73b1c747921df4f84278b70": "0x6c6b935b8bbd400000",
  	"0x457bcef37dd3d60b2dd019e3fe61d46b3f1e7252": "0x1158e460913d00000",
  	"0x458e3cc99e947844a18e6a42918fef7e7f5f5eb3": "0x7b53f79e888dac00000",
  	"0x459393d63a063ef3721e16bd9fde45ee9dbd77fb": "0x6abad6a3c153050000",
  	"0x45a570dcc2090c86a6b3ea29a60863dde41f13b5": "0xc9a95ee2986520000",
  	"0x45a820a0672f17dc74a08112bc643fd1167736c3": "0xad6c43b2815ed8000",
  	"0x45b47105fe42c4712dce6e2a21c05bffd5ea47a9": "0x6c6b935b8bbd400000",
  	"0x45bb829652d8bfb58b8527f0ecb621c29e212ec3": "0x6c6b935b8bbd400000",
  	"0x45c0d19f0b8e054f9e893836d5ecae7901af2812": "0x10f0cf064dd59200000",
  	"0x45c4ecb4ee891ea984a7c5cefd8dfb00310b2850": "0x6b56051582a9700000",
  	"0x45ca8d956608f9e00a2f9974028640888465668f": "0x6c6b935b8bbd400000",
  	"0x45ca9862003b4e40a3171fb5cafa9028cac8de19": "0x2eb8eb1a172dcb80000",
  	"0x45d1c9eedf7cab41a779057b79395f5428d80528": "0x6c6b935b8bbd400000",
  	"0x45d4b54d37a8cf599821235f062fa9d170ede8a4": "0x1190673b5fda900000",
  	"0x45db03bccfd6a5f4d0266b82a22a368792c77d83": "0x1b1ae4d6e2ef5000000",
  	"0x45e3a93e72144ada860cbc56ff85145ada38c6da": "0x57473d05dabae80000",
  	"0x45e68db8dbbaba5fc2cb337c62bcd0d61b059189": "0x6c6b935b8bbd400000",
  	"0x45e68db94c7d0ab7ac41857a71d67147870f4e71": "0x54b40b1f852bda000000",
  	"0x45f4fc60f08eaca10598f0336329801e3c92cb46": "0xad78ebc5ac6200000",
  	"0x460d5355b2ceeb6e62107d81e51270b26bf45620": "0x6cb7e74867d5e60000",
  	"0x46224f32f4ece5c8867090d4409d55e50b18432d": "0x14542ba12a337c00000",
  	"0x4627c606842671abde8295ee5dd94c7f549534f4": "0xf895fbd8732f40000",
  	"0x462b678b51b584f3ed7ada070b5cd99c0bf7b87f": "0x56bc75e2d63100000",
  	"0x464d9c89cce484df000277198ed8075fa63572d1": "0x1158e460913d00000",
  	"0x46504e6a215ac83bccf956befc82ab5a679371c8": "0x1c212805c2b4a50000",
  	"0x4651dc420e08c3293b27d2497890eb50223ae2f4": "0x43c33c1937564800000",
  	"0x46531e8b1bde097fdf849d6d119885608a008df7": "0xad78ebc5ac6200000",
  	"0x466292f0e80d43a78774277590a9eb45961214f4": "0x34957444b840e80000",
  	"0x4662a1765ee921842ddc88898d1dc8627597bd7e": "0x21e19e0c9bab2400000",
  	"0x4665e47396c7db97eb2a03d90863d5d4ba319a94": "0x2086ac351052600000",
  	"0x466fda6b9b58c5532750306a10a2a8c768103b07": "0xad6eedd17cf3b8000",
  	"0x467124ae7f452f26b3d574f6088894fa5d1cfb3b": "0x925e06eec972b00000",
  	"0x46722a36a01e841d03f780935e917d85d5a67abd": "0xcec76f0e71520000",
  	"0x46779a5656ff00d73eac3ad0c38b6c853094fb40": "0xc8253c96c6af00000",
  	"0x4677b04e0343a32131fd6abb39b1b6156bba3d5b": "0xad78ebc5ac6200000",
  	"0x467d5988249a68614716659840ed0ae6f6f457bc": "0x1501a48cefdfde0000",
  	"0x467e0ed54f3b76ae0636176e07420815a021736e": "0x6c6b935b8bbd400000",
  	"0x467ea10445827ef1e502daf76b928a209e0d4032": "0x6c6b935b8bbd400000",
  	"0x467fbf41441600757fe15830c8cd5f4ffbbbd560": "0x21e19e0c9bab2400000",
  	"0x469358709332c82b887e20bcddd0220f8edba7d0": "0x3a9d5baa4abf1d00000",
  	"0x4697baaf9ccb603fd30430689d435445e9c98bf5": "0xad201a6794ff80000",
  	"0x46a30b8a808931217445c3f5a93e882c0345b426": "0xd8db5ebd7b2638000",
  	"0x46a430a2d4a894a0d8aa3feac615361415c3f81f": "0x6c6b935b8bbd400000",
  	"0x46aa501870677e7f0a504876b4e8801a0ad01c46": "0x2b5e3af16b18800000",
  	"0x46bfc5b207eb2013e2e60f775fecd71810c5990c": "0x54069233bf7f780000",
  	"0x46c1aa2244b9c8a957ca8fac431b0595a3b86824": "0xd8d726b7177a800000",
  	"0x46d80631284203f6288ecd4e5758bb9d41d05dbe": "0x6c6b935b8bbd400000",
  	"0x470ac5d1f3efe28f3802af925b571e63868b397d": "0x6c6b935b8bbd400000",
  	"0x471010da492f4018833b088d9872901e06129174": "0x1b1ae4d6e2ef500000",
  	"0x4712540265cbeec3847022c59f1b318d43400a9e": "0xbdbc41e0348b300000",
  	"0x4714cfa4f46bd6bd70737d75878197e08f88e631": "0x27f3edfb34e6e400000",
  	"0x472048cc609aeb242165eaaa8705850cf3125de0": "0x3635c9adc5dea00000",
  	"0x47219229e8cd56659a65c2a943e2dd9a8f4bfd89": "0x52663ccab1e1c00000",
  	"0x4737d042dc6ae73ec73ae2517acea2fdd96487c5": "0x3635c9adc5dea00000",
  	"0x474158a1a9dc693c133f65e47b5c3ae2f773a86f": "0xada55474b81340000",
  	"0x4745ab181a36aa8cbf2289d0c45165bc7ebe2381": "0x222c8eb3ff6640000",
  	"0x475066f9ad26655196d5535327bbeb9b7929cb04": "0xa4cc799563c3800000",
  	"0x4752218e54de423f86c0501933917aea08c8fed5": "0x43c33c1937564800000",
  	"0x475a6193572d4a4e59d7be09cb960ddd8c530e2f": "0x242cf78cdf07ff8000",
  	"0x47648bed01f3cd3249084e635d14daa9e7ec3c8a": "0xa844a7424d9c80000",
  	"0x47688410ff25d654d72eb2bc06e4ad24f833b094": "0x8b28d61f3d3ac0000",
  	"0x476b5599089a3fb6f29c6c72e49b2e4740ea808d": "0x97c9ce4cf6d5c00000",
  	"0x47730f5f8ebf89ac72ef80e46c12195038ecdc49": "0xab4dcf399a3a600000",
  	"0x477b24eee8839e4fd19d1250bd0b6645794a61ca": "0x1b1ae4d6e2ef5000000",
  	"0x4781a10a4df5eebc82f4cfe107ba1d8a7640bd66": "0x61093d7c2c6d380000",
  	"0x47885ababedf4d928e1c3c71d7ca40d563ed595f": "0x62a992e53a0af00000",
  	"0x478dc09a1311377c093f9cc8ae74111f65f82f39": "0xd8d726b7177a800000",
  	"0x478e524ef2a381d70c82588a93ca7a5fa9d51cbf": "0x35fa97226f8899700000",
  	"0x479298a9de147e63a1c7d6d2fce089c7e64083bd": "0x21e19dd3c3c0d798000",
  	"0x479abf2da4d58716fd973a0d13a75f530150260a": "0x1158e460913d00000",
  	"0x47a281dff64167197855bf6e705eb9f2cef632ea": "0x3636c9796436740000",
  	"0x47beb20f759100542aa93d41118b3211d664920e": "0x6c6b935b8bbd400000",
  	"0x47c247f53b9fbeb17bba0703a00c009fdb0f6eae": "0x43c33c1937564800000",
  	"0x47c7e5efb48b3aed4b7c6e824b435f357df4c723": "0xfc936392801c0000",
  	"0x47cf9cdaf92fc999cc5efbb7203c61e4f1cdd4c3": "0x71f8a93d01e540000",
  	"0x47d20e6ae4cad3f829eac07e5ac97b66fdd56cf5": "0x3635c9adc5dea00000",
  	"0x47d792a756779aedf1343e8883a6619c6c281184": "0x6c6b935b8bbd400000",
  	"0x47e25df8822538a8596b28c637896b4d143c351d": "0x110be9eb24b881500000",
  	"0x47f4696bd462b20da09fb83ed2039818d77625b3": "0x813ca56906d340000",
  	"0x47fef58584465248a0810d60463ee93e5a6ee8d3": "0xf58cd3e1269160000",
  	"0x47ff6feb43212060bb1503d7a397fc08f4e70352": "0x6c6b935b8bbd400000",
  	"0x47fff42c678551d141eb75a6ee398117df3e4a8d": "0x56beae51fd2d10000",
  	"0x48010ef3b8e95e3f308f30a8cb7f4eb4bf60d965": "0x6c6b935b8bbd400000",
  	"0x480af52076009ca73781b70e43b95916a62203ab": "0x321972f4083d878000",
  	"0x480f31b989311e4124c6a7465f5a44094d36f9d0": "0x3790bb855137640000",
  	"0x481115296ab7db52492ff7b647d63329fb5cbc6b": "0x368c8623a8b4d100000",
  	"0x481e3a91bfdc2f1c8428a0119d03a41601417e1c": "0x3635c9adc5dea00000",
  	"0x4828e4cbe34e1510afb72c2beeac8a4513eaebd9": "0xd5967be4fc3f100000",
  	"0x482982ac1f1c6d1721feecd9b9c96cd949805055": "0x21e19e0c9bab2400000",
  	"0x48302c311ef8e5dc664158dd583c81194d6e0d58": "0xb6676ce0bccb5c0000",
  	"0x483ba99034e900e3aedf61499d3b2bce39beb7aa": "0x35659ef93f0fc40000",
  	"0x48548b4ba62bcb2f0d34a88dc69a680e539cf046": "0x56cf1cbbb74320000",
  	"0x4863849739265a63b0a2bf236a5913e6f959ce15": "0x52663ccab1e1c00000",
  	"0x48659d8f8c9a2fd44f68daa55d23a608fbe500dc": "0x6c6b935b8bbd400000",
  	"0x48669eb5a801d8b75fb6aa58c3451b7058c243bf": "0x68d42c138dab9f00000",
  	"0x486a6c8583a84484e3df43a123837f8c7e2317d0": "0x1187c571ab80450000",
  	"0x487adf7d70a6740f8d51cbdd68bb3f91c4a5ce68": "0x39fbae8d042dd0000",
  	"0x487e108502b0b189ef9c8c6da4d0db6261eec6c0": "0x678a932062e4180000",
  	"0x4888fb25cd50dbb9e048f41ca47d78b78a27c7d9": "0x3a9d5baa4abf1d00000",
  	"0x489334c2b695c8ee0794bd864217fb9fd8f8b135": "0xfc936392801c0000",
  	"0x48a30de1c919d3fd3180e97d5f2b2a9dbd964d2d": "0x2629f66e0c5300000",
  	"0x48bf14d7b1fc84ebf3c96be12f7bce01aa69b03e": "0x68155a43676e00000",
  	"0x48c2ee91a50756d8ce9abeeb7589d22c6fee5dfb": "0xae8e7a0bb575d00000",
  	"0x48c5c6970b9161bb1c7b7adfed9cdede8a1ba864": "0xd8d726b7177a800000",
  	"0x48d2434b7a7dbbff08223b6387b05da2e5093126": "0x3cfc82e37e9a7400000",
  	"0x48d4f2468f963fd79a006198bb67895d2d5aa4d3": "0x4be4e7267b6ae00000",
  	"0x48e0cbd67f18acdb7a6291e1254db32e0972737f": "0x56be03ca3e47d8000",
  	"0x48f60a35484fe7792bcc8a7b6393d0dda1f6b717": "0xc328093e61ee400000",
  	"0x48f883e567b436a27bb5a3124dbc84dec775a800": "0x29d76e869dcd800000",
  	"0x490145afa8b54522bb21f352f06da5a788fa8f1d": "0x1f46c62901a03fb0000",
  	"0x4909b31998ead414b8fb0e846bd5cbde393935be": "0xd8d726b7177a800000",
  	"0x4912d902931676ff39fc34fe3c3cc8fb2182fa7a": "0x1158e460913d00000",
  	"0x49136fe6e28b7453fcb16b6bbbe9aaacba8337fd": "0x6c6b935b8bbd400000",
  	"0x491561db8b6fafb9007e62d050c282e92c4b6bc8": "0x65a4da25d3016c00000",
  	"0x49185dd7c23632f46c759473ebae966008cd3598": "0xdc55fdb17647b0000",
  	"0x492cb5f861b187f9df21cd4485bed90b50ffe22d": "0x1b19e50b44977c0000",
  	"0x492de46aaf8f1d708d59d79af1d03ad2cb60902f": "0x6c6b935b8bbd400000",
  	"0x492e70f04d18408cb41e25603730506b35a2876b": "0x222c8eb3ff6640000",
  	"0x493a67fe23decc63b10dda75f3287695a81bd5ab": "0x2fb474098f67c00000",
  	"0x493d48bda015a9bfcf1603936eab68024ce551e0": "0x138a388a43c000000",
  	"0x494256e99b0f9cd6e5ebca3899863252900165c8": "0x2f6f10780d22cc00000",
  	"0x494dec4d5ee88a2771a815f1ee7264942fb58b28": "0x6c6b935b8bbd400000",
  	"0x495b641b1cdea362c3b4cbbd0f5cc50b1e176b9c": "0x3635c9adc5dea00000",
  	"0x4968a2cedb457555a139295aea28776e54003c87": "0x2231aefc9a6628f0000",
  	"0x496d365534530a5fc1577c0a5241cb88c4da7072": "0x61093d7c2c6d380000",
  	"0x496e319592b341eaccd778dda7c8196d54cac775": "0x1f5718987664b480000",
  	"0x496f5843f6d24cd98d255e4c23d1e1f023227545": "0x5f179fd4a6ee098000",
  	"0x4970d3acf72b5b1f32a7003cf102c64ee0547941": "0x1da56a4b0835bf800000",
  	"0x4977a7939d0939689455ce2639d0ee5a4cd910ed": "0x62a992e53a0af00000",
  	"0x4979194ec9e97db9bee8343b7c77d9d7f3f1dc9f": "0x1158e460913d00000",
  	"0x49793463e1681083d6abd6e725d5bba745dccde8": "0x1d98e94c4e471f0000",
  	"0x4981c5ff66cc4e9680251fc4cd2ff907cb327865": "0x28a857425466f80000",
  	"0x49897fe932bbb3154c95d3bce6d93b6d732904dd": "0xd8d726b7177a800000",
  	"0x4989e1ab5e7cd00746b3938ef0f0d064a2025ba5": "0x6c6b935b8bbd400000",
  	"0x498abdeb14c26b7b7234d70fceaef361a76dff72": "0xa2a15d09519be00000",
  	"0x49a645e0667dfd7b32d075cc2467dd8c680907c4": "0x70601958fcb9c0000",
  	"0x49b74e169265f01a89ec4c9072c5a4cd72e4e835": "0x368c8623a8b4d100000",
  	"0x49bdbc7ba5abebb6389e91a3285220d3451bd253": "0x3635c9adc5dea00000",
  	"0x49c941e0e5018726b7290fc473b471d41dae80d1": "0x1b1ae4d6e2ef500000",
  	"0x49c9771fca19d5b9d245c891f8158fe49f47a062": "0x21e19e0c9bab2400000",
  	"0x49cf1e54be363106b920729d2d0ba46f0867989a": "0xe873f44133cb00000",
  	"0x49d2c28ee9bc545eaaf7fd14c27c4073b4bb5f1a": "0x4fe9b806b40daf0000",
  	"0x49ddee902e1d0c99d1b11af3cc8a96f78e4dcf1a": "0xacea5e4c18c530000",
  	"0x49f028395b5a86c9e07f7778630e4c2e3d373a77": "0x6a74a5038db918000",
  	"0x4a192035e2619b24b0709d56590e9183ccf2c1d9": "0x21e19e0c9bab2400000",
  	"0x4a4053b31d0ee5dbafb1d06bd7ac7ff3222c47d6": "0x4be4e7267b6ae00000",
  	"0x4a430170152de5172633dd8262d107a0afd96a0f": "0xab4dcf399a3a600000",
  	"0x4a47fc3e177f567a1e3893e000e36bba23520ab8": "0x6c6b935b8bbd400000",
  	"0x4a52bad20357228faa1e996bed790c93674ba7d0": "0x487a9a304539440000",
  	"0x4a53dcdb56ce4cdce9f82ec0eb13d67352e7c88b": "0xe3aeb5737240a00000",
  	"0x4a5fae3b0372c230c125d6d470140337ab915656": "0x56bc75e2d631000000",
  	"0x4a719061f5285495b37b9d7ef8a51b07d6e6acac": "0xad4c8316a0b0c0000",
  	"0x4a73389298031b8816cca946421c199e18b343d6": "0x223868b879146f0000",
  	"0x4a735d224792376d331367c093d31c8794341582": "0x66ffcbfd5e5a300000",
  	"0x4a7494cce44855cc80582842be958a0d1c0072ee": "0x821ab0d44149800000",
  	"0x4a75c3d4fa6fccbd5dd5a703c15379a1e783e9b7": "0x62a992e53a0af00000",
  	"0x4a81abe4984c7c6bef63d69820e55743c61f201c": "0x36401004e9aa3470000",
  	"0x4a82694fa29d9e213202a1a209285df6e745c209": "0xd8d726b7177a800000",
  	"0x4a835c25824c47ecbfc79439bf3f5c3481aa75cd": "0x4be4e7267b6ae00000",
  	"0x4a918032439159bb315b6725b6830dc83697739f": "0x12a32ef678334c0000",
  	"0x4a97e8fcf4635ea7fc5e96ee51752ec388716b60": "0x1d9945ab2b03480000",
  	"0x4a9a26fd0a8ba10f977da4f77c31908dab4a8016": "0x61093d7c2c6d380000",
  	"0x4aa148c2c33401e66a2b586e6577c4b292d3f240": "0xbb860b285f7740000",
  	"0x4aa693b122f314482a47b11cc77c68a497876162": "0x6acb3df27e1f880000",
  	"0x4ab2d34f04834fbf7479649cab923d2c4725c553": "0xbed1d0263d9f000000",
  	"0x4ac07673e42f64c1a25ec2fa2d86e5aa2b34e039": "0x6c6b935b8bbd400000",
  	"0x4ac5acad000b8877214cb1ae00eac9a37d59a0fd": "0xd8d726b7177a800000",
  	"0x4ac9905a4cb6ab1cfd62546ee5917300b87c4fde": "0x3708baed3d68900000",
  	"0x4acfa9d94eda6625c9dfa5f9f4f5d107c4031fdf": "0x222c8eb3ff6640000",
  	"0x4ad047fae67ef162fe68fedbc27d3b65caf10c36": "0x6acb3df27e1f880000",
  	"0x4ad95d188d6464709add2555fb4d97fe1ebf311f": "0x12c1b6eed03d280000",
  	"0x4adbf4aae0e3ef44f7dd4d8985cfaf096ec48e98": "0x821ab0d4414980000",
  	"0x4ae2a04d3909ef454e544ccfd614bfefa71089ae": "0x1801159df1eef80000",
  	"0x4ae93082e45187c26160e66792f57fad3551c73a": "0x4961520daff82280000",
  	"0x4af0db077bb9ba5e443e21e148e59f379105c592": "0x2086ac351052600000",
  	"0x4b0619d9d8aa313a9531ac7dbe04ca0d6a5ad1b6": "0x6c6b935b8bbd400000",
  	"0x4b0bd8acfcbc53a6010b40d4d08ddd2d9d69622d": "0x243d4d18229ca20000",
  	"0x4b19eb0c354bc1393960eb06063b83926f0d67b2": "0x19274b259f6540000",
  	"0x4b29437c97b4a844be71cca3b648d4ca0fdd9ba4": "0x824719834cfac0000",
  	"0x4b31bf41abc75c9ae2cd8f7f35163b6e2b745054": "0x14b550a013c7380000",
  	"0x4b3a7cc3a7d7b00ed5282221a60259f25bf6538a": "0x3635c9adc5dea00000",
  	"0x4b3aab335ebbfaa870cc4d605e7d2e74c668369f": "0xcb49b44ba602d800000",
  	"0x4b3c7388cc76da3d62d40067dabccd7ef0433d23": "0x56cd55fc64dfe0000",
  	"0x4b3dfbdb454be5279a3b8addfd0ed1cd37a9420d": "0x6c6b935b8bbd400000",
  	"0x4b470f7ba030bc7cfcf338d4bf0432a91e2ea5ff": "0x6c6b935b8bbd400000",
  	"0x4b53ae59c784b6b5c43616b9a0809558e684e10c": "0x410d586a20a4c00000",
  	"0x4b58101f44f7e389e12d471d1635b71614fdd605": "0x8ac7230489e800000",
  	"0x4b5cdb1e428c91dd7cb54a6aed4571da054bfe52": "0x4c53ecdc18a600000",
  	"0x4b60a3e253bf38c8d5662010bb93a473c965c3e5": "0x50c5e761a444080000",
  	"0x4b74f5e58e2edf76daf70151964a0b8f1de0663c": "0x1190ae4944ba120000",
  	"0x4b762166dd1118e84369f804c75f9cd657bf730c": "0x1b1ae4d6e2ef500000",
  	"0x4b792e29683eb586e394bb33526c6001b397999e": "0x2086ac351052600000",
  	"0x4b904e934bd0cc8b20705f879e905b93ea0ccc30": "0x6c6b935b8bbd400000",
  	"0x4b9206ba6b549a1a7f969e1d5dba867539d1fa67": "0x1ab2cf7c9f87e200000",
  	"0x4b984ef26c576e815a2eaed2f5177f07dbb1c476": "0x54915956c409600000",
  	"0x4b9e068fc4680976e61504912985fd5ce94bab0d": "0x243d4d18229ca20000",
  	"0x4ba0d9e89601772b496847a2bb4340186787d265": "0x3635c9adc5dea00000",
  	"0x4ba53ab549e2016dfa223c9ed5a38fad91288d07": "0x4be4e7267b6ae00000",
  	"0x4ba8e0117fc0b6a3e56b24a3a58fe6cef442ff98": "0x131beb925ffd3200000",
  	"0x4bac846af4169f1d95431b341d8800b22180af1a": "0x1158e460913d00000",
  	"0x4bb6d86b8314c22d8d37ea516d0019f156aae12d": "0x3635c9adc5dea00000",
  	"0x4bb9655cfb2a36ea7c637a7b859b4a3154e26ebe": "0x3635c9adc5dea000000",
  	"0x4bbcbf38b3c90163a84b1cd2a93b58b2a3348d87": "0x1b1ae4d6e2ef5000000",
  	"0x4bd6dd0cff23400e1730ba7b894504577d14e74a": "0x2ba0ccddd0df73b00000",
  	"0x4be8628a8154874e048d80c142181022b180bcc1": "0x340aad21b3b700000",
  	"0x4be90d412129d5a4d0424361d6649d4e47a62316": "0x3708baed3d68900000",
  	"0x4bea288eea42c4955eb9faad2a9faf4783cbddac": "0x618be1663c4af490000",
  	"0x4bf4479799ef82eea20943374f56a1bf54001e5e": "0xd5967be4fc3f100000",
  	"0x4bf8bf1d35a231315764fc8001809a949294fc49": "0x39fbae8d042dd0000",
  	"0x4bf8e26f4c2790da6533a2ac9abac3c69a199433": "0xad78ebc5ac6200000",
  	"0x4c0aca508b3caf5ee028bc707dd1e800b838f453": "0xfc936392801c0000",
  	"0x4c0b1515dfced7a13e13ee12c0f523ae504f032b": "0xa968163f0a57b400000",
  	"0x4c13980c32dcf3920b78a4a7903312907c1b123f": "0x3410015faae0c0000",
  	"0x4c1579af3312e4f88ae93c68e9449c2e9a68d9c4": "0x6c6b935b8bbd400000",
  	"0x4c23b370fc992bb67cec06e26715b62f0b3a4ac3": "0x21e19e0c9bab2400000",
  	"0x4c24b78baf2bafc7fcc69016426be973e20a50b2": "0xa2a15d09519be00000",
  	"0x4c2f1afef7c5868c44832fc77cb03b55f89e6d6e": "0x43c33c1937564800000",
  	"0x4c377bb03ab52c4cb79befa1dd114982924c4ae9": "0x631603ccd38dd70000",
  	"0x4c3e95cc3957d252ce0bf0c87d5b4f2234672e70": "0x878678326eac900000",
  	"0x4c423c76930d07f93c47a5cc4f615745c45a9d72": "0x56bc75e2d63100000",
  	"0x4c45d4c9a725d11112bfcbca00bf31186ccaadb7": "0x15af1d78b58c400000",
  	"0x4c4e6f13fb5e3f70c3760262a03e317982691d10": "0x56bc75e2d63100000",
  	"0x4c5afe40f18ffc48d3a1aec41fc29de179f4d297": "0x6c6b935b8bbd400000",
  	"0x4c5b3dc0e2b9360f91289b1fe13ce12c0fbda3e1": "0x6c6b935b8bbd400000",
  	"0x4c666b86f1c5ee8ca41285f5bde4f79052081406": "0x1b1ae4d6e2ef500000",
  	"0x4c696be99f3a690440c3436a59a7d7e937d6ba0d": "0xbb9125542263900000",
  	"0x4c6a248fc97d705def495ca20759169ef0d36471": "0x29331e6558f0e00000",
  	"0x4c6a9dc2cab10abb2e7c137006f08fecb5b779e1": "0x1b0d04202f47ec0000",
  	"0x4c6b93a3bec16349540cbfcae96c9621d6645010": "0x6c6b935b8bbd400000",
  	"0x4c759813ad1386bed27ffae9e4815e3630cca312": "0x6c6b935b8bbd400000",
  	"0x4c760cd9e195ee4f2d6bce2500ff96da7c43ee91": "0xcb49b44ba602d800000",
  	"0x4c767b65fd91161f4fbdcc6a69e2f6ad711bb918": "0x270801d946c9400000",
  	"0x4c7e2e2b77ad0cd6f44acb2861f0fb8b28750ef9": "0x1158e460913d00000",
  	"0x4c85ed362f24f6b9f04cdfccd022ae535147cbb9": "0x5150ae84a8cdf00000",
  	"0x4c935bb250778b3c4c7f7e07fc251fa630314aab": "0x5150ae84a8cdf00000",
  	"0x4c997992036c5b433ac33d25a8ea1dc3d4e4e6d8": "0x1953b3d4ab1680000",
  	"0x4c99dae96481e807c1f99f8b7fbde29b7547c5bf": "0x821ab0d4414980000",
  	"0x4c9a862ad115d6c8274ed0b944bdd6a5500510a7": "0x56bc75e2d63100000",
  	"0x4ca783b556e5bf53aa13c8116613d65782c9b642": "0x5561840b4ad83c00000",
  	"0x4ca7b717d9bc8793b04e051a8d23e1640f5ba5e3": "0x43b514549ecf620000",
  	"0x4ca8db4a5efefc80f4cd9bbcccb03265931332b6": "0xad78ebc5ac6200000",
  	"0x4cac91fb83a147d2f76c3267984b910a79933348": "0x75792a8abdef7c0000",
  	"0x4cadf573ce4ceec78b8e1b21b0ed78eb113b2c0e": "0x6c6b935b8bbd400000",
  	"0x4cb5c6cd713ca447b848ae2f56b761ca14d7ad57": "0xe7eeba3410b740000",
  	"0x4cc22c9bc9ad05d875a397dbe847ed221c920c67": "0x6c6b935b8bbd400000",
  	"0x4cd0b0a6436362595ceade052ebc9b929fb6c6c0": "0x6c6b935b8bbd400000",
  	"0x4cda41dd533991290794e22ae324143e309b3d3d": "0x821ab0d44149800000",
  	"0x4cee901b4ac8b156c5e2f8a6f1bef572a7dceb7e": "0x3635c9adc5dea00000",
  	"0x4cefbe2398e47d52e78db4334c8b697675f193ae": "0xd96fce90cfabcc0000",
  	"0x4cf5537b85842f89cfee359eae500fc449d2118f": "0x3635c9adc5dea00000",
  	"0x4d08471d68007aff2ae279bc5e3fe4156fbbe3de": "0x878678326eac9000000",
  	"0x4d200110124008d56f76981256420c946a6ff45c": "0xad6eedd17cf3b8000",
  	"0x4d24b7ac47d2f27de90974ba3de5ead203544bcd": "0x56bc75e2d63100000",
  	"0x4d29fc523a2c1629532121da9998e9b5ab9d1b45": "0xdb44e049bb2c0000",
  	"0x4d38d90f83f4515c03cc78326a154d358bd882b7": "0xa076407d3f7440000",
  	"0x4d4cf5807429615e30cdface1e5aae4dad3055e6": "0x2086ac351052600000",
  	"0x4d57e716876c0c95ef5eaebd35c8f41b069b6bfe": "0x6c6b935b8bbd400000",
  	"0x4d67f2ab8599fef5fc413999aa01fd7fce70b43d": "0x21e19e0c9bab2400000",
  	"0x4d6e8fe109ccd2158e4db114132fe75fecc8be5b": "0x15b3557f1937f8000",
  	"0x4d71a6eb3d7f327e1834278e280b039eddd31c2f": "0x14542ba12a337c00000",
  	"0x4d7cfaa84cb33106800a8c802fb8aa463896c599": "0x61093d7c2c6d380000",
  	"0x4d801093c19ca9b8f342e33cc9c77bbd4c8312cf": "0x12b3e7fb95cda48000",
  	"0x4d828894752f6f25175daf2177094487954b6f9f": "0x4f212bc2c49c838000",
  	"0x4d82d7700c123bb919419bbaf046799c6b0e2c66": "0x43c33c1937564800000",
  	"0x4d836d9d3b0e2cbd4de050596faa490cffb60d5d": "0x1043561a8829300000",
  	"0x4d8697af0fbf2ca36e8768f4af22133570685a60": "0x1158e460913d00000",
  	"0x4d9279962029a8bd45639737e98b511eff074c21": "0x487a9a304539440000",
  	"0x4d93696fa24859f5d2939aebfa54b4b51ae1dccc": "0x10910d4cdc9f60000",
  	"0x4d9c77d0750c5e6fbc247f2fd79274686cb353d6": "0x1158e460913d00000",
  	"0x4da5edc688b0cb62e1403d1700d9dcb99ffe3fd3": "0x6c6b935b8bbd400000",
  	"0x4da8030769844bc34186b85cd4c7348849ff49e9": "0x21e19e0c9bab2400000",
  	"0x4db1c43a0f834d7d0478b8960767ec1ac44c9aeb": "0x2f5181305627370000",
  	"0x4db21284bcd4f787a7556500d6d7d8f36623cf35": "0x6928374f77a3630000",
  	"0x4dc3da13b2b4afd44f5d0d3189f444d4ddf91b1b": "0x6c6b935b8bbd400000",
  	"0x4dc4bf5e7589c47b28378d7503cf96488061dbbd": "0x5f68e8131ecf800000",
  	"0x4dc9d5bb4b19cecd94f19ec25d200ea72f25d7ed": "0x6c6b935b8bbd400000",
  	"0x4dcd11815818ae29b85d01367349a8a7fb12d06b": "0x1ac4286100191f00000",
  	"0x4dcf62a3de3f061db91498fd61060f1f6398ff73": "0x6c6acc67d7b1d40000",
  	"0x4dd131c74a068a37c90aded4f309c2409f6478d3": "0x15af39e4aab2740000",
  	"0x4ddda7586b2237b053a7f3289cf460dc57d37a09": "0x21e19e0c9bab2400000",
  	"0x4de3fe34a6fbf634c051997f47cc7f48791f5824": "0x6c5db2a4d815dc0000",
  	"0x4df140ba796585dd5489315bca4bba680adbb818": "0x90f534608a72880000",
  	"0x4e020779b5ddd3df228a00cb48c2fc979da6ae38": "0x6c6b935b8bbd400000",
  	"0x4e0bd32473c4c51bf25654def69f797c6b29a232": "0x56c95de8e8ca1d0000",
  	"0x4e2225a1bb59bc88a2316674d333b9b0afca6655": "0x8670e9ec6598c0000",
  	"0x4e2310191ead8d3bc6489873a5f0c2ec6b87e1be": "0x3635c9adc5dea00000",
  	"0x4e232d53b3e6be8f895361d31c34d4762b12c82e": "0x5f68e8131ecf800000",
  	"0x4e2bfa4a466f82671b800eee426ad00c071ba170": "0xd8d726b7177a800000",
  	"0x4e3edad4864dab64cae4c5417a76774053dc6432": "0x2008fb478cbfa98000",
  	"0x4e4318f5e13e824a54edfe30a7ed4f26cd3da504": "0x6c6b935b8bbd400000",
  	"0x4e5b77f9066159e615933f2dda7477fa4e47d648": "0xad78ebc5ac6200000",
  	"0x4e6600806289454acda330a2a3556010dfacade6": "0x14542ba12a337c00000",
  	"0x4e73cf2379f124860f73d6d91bf59acc5cfc845b": "0x22ca3587cf4eb0000",
  	"0x4e7aa67e12183ef9d7468ea28ad239c2eef71b76": "0x10afc1ade3b4ed40000",
  	"0x4e7b54474d01fefd388dfcd53b9f662624418a05": "0x1b1ae4d6e2ef5000000",
  	"0x4e892e8081bf36e488fddb3b2630f3f1e8da30d2": "0x28aba30752451fc0000",
  	"0x4e8a6d63489ccc10a57f885f96eb04ecbb546024": "0x3eae3130ecc96900000",
  	"0x4e8e47ae3b1ef50c9d54a38e14208c1abd3603c2": "0x7928db1276660c0000",
  	"0x4e90ccb13258acaa9f4febc0a34292f95991e230": "0xdb44e049bb2c0000",
  	"0x4ea56e1112641c038d0565a9c296c463afefc17e": "0x9ddc1e3b901180000",
  	"0x4ea70f04313fae65c3ff224a055c3d2dab28dddf": "0x43c30fb0884a96c0000",
  	"0x4eb1454b573805c8aca37edec7149a41f61202f4": "0x1043561a8829300000",
  	"0x4eb87ba8788eba0df87e5b9bd50a8e45368091c1": "0x1158e460913d00000",
  	"0x4ebc5629f9a6a66b2cf3363ac4895c0348e8bf87": "0x3637096c4bcc690000",
  	"0x4ec768295eeabafc42958415e22be216cde77618": "0x33b1dbc39c5480000",
  	"0x4ecc19948dd9cd87b4c7201ab48e758f28e7cc76": "0x1b1dab61d3aa640000",
  	"0x4ed14d81b60b23fb25054d8925dfa573dcae6168": "0x126e72a69a50d00000",
  	"0x4ee13c0d41200b46d19dee5c4bcec71d82bb8e38": "0x1abee13ccbeefaf8000",
  	"0x4eead40aad8c73ef08fc84bc0a92c9092f6a36bf": "0x1731790534df20000",
  	"0x4eebe80cb6f3ae5904f6f4b28d907f907189fcab": "0x6c6acc67d7b1d40000",
  	"0x4eebf1205d0cc20cee6c7f8ff3115f56d48fba26": "0x10d3aa536e2940000",
  	"0x4ef1c214633ad9c0703b4e2374a2e33e3e429291": "0x487a9a304539440000",
  	"0x4efcd9c79fb4334ca6247b0a33bd9cc33208e272": "0x487a9a304539440000",
  	"0x4f06246b8d4bd29661f43e93762201d286935ab1": "0x105394ffc4636110000",
  	"0x4f152b2fb8659d43776ebb1e81673aa84169be96": "0x6c6b935b8bbd400000",
  	"0x4f177f9d56953ded71a5611f393322c30279895c": "0xd55ef90a2da180000",
  	"0x4f1a2da54a4c6da19d142412e56e815741db2325": "0x56bc75e2d63100000",
  	"0x4f23b6b817ffa5c664acdad79bb7b726d30af0f9": "0x5f68e8131ecf800000",
  	"0x4f26690c992b7a312ab12e1385d94acd58288e7b": "0x2f6f10780d22cc00000",
  	"0x4f2b47e2775a1fa7178dad92985a5bbe493ba6d6": "0xad78ebc5ac6200000",
  	"0x4f3a4854911145ea01c644044bdb2e5a960a982f": "0xd8d726b7177a800000",
  	"0x4f3f2c673069ac97c2023607152981f5cd6063a0": "0x2086ac351052600000",
  	"0x4f4a9be10cd5d3fb5de48c17be296f895690645b": "0x878678326eac9000000",
  	"0x4f52ad6170d25b2a2e850eadbb52413ff2303e7f": "0xa4cc799563c3800000",
  	"0x4f5801b1eb30b712d8a0575a9a71ff965d4f34eb": "0x1043561a8829300000",
  	"0x4f5df5b94357de948604c51b7893cddf6076baad": "0xcbd47b6eaa8cc00000",
  	"0x4f64a85e8e9a40498c0c75fceb0337fb49083e5e": "0x3635c9adc5dea00000",
  	"0x4f67396d2553f998785f704e07a639197dd1948d": "0x104472521ba7380000",
  	"0x4f6d4737d7a940382487264886697cf7637f8015": "0x5a87e7d7f5f6580000",
  	"0x4f7330096f79ed264ee0127f5d30d2f73c52b3d8": "0x1b1a7a420ba00d0000",
  	"0x4f767bc8794aef9a0a38fea5c81f14694ff21a13": "0x1bc433f23f83140000",
  	"0x4f85bc1fc5cbc9c001e8f1372e07505370d8c71f": "0x32f51edbaaa3300000",
  	"0x4f88dfd01091a45a9e2676021e64286cd36b8d34": "0x3635c9adc5dea00000",
  	"0x4f8972838f70c903c9b6c6c46162e99d6216d451": "0xf9e89a0f2c56c80000",
  	"0x4f8ae80238e60008557075ab6afe0a7f2e74d729": "0x56bc75e2d63100000",
  	"0x4f8e8d274fb22a3fd36a47fe72980471544b3434": "0xad78ebc5ac6200000",
  	"0x4f9ce2af9b8c5e42c6808a3870ec576f313545d1": "0x21e19e0c9bab2400000",
  	"0x4fa3f32ef4086448b344d5f0a9890d1ce4d617c3": "0x5150ae84a8cdf00000",
  	"0x4fa554ab955c249217386a4d3263bbf72895434e": "0x1154e53217ddb0000",
  	"0x4fa983bb5e3073a8edb557effeb4f9fb1d60ef86": "0x56b9af57e575ec0000",
  	"0x4faf90b76ecfb9631bf9022176032d8b2c207009": "0x36363b5d9a77700000",
  	"0x4fc46c396e674869ad9481638f0013630c87caac": "0x3635c9adc5dea00000",
  	"0x4fcc19ea9f4c57dcbce893193cfb166aa914edc5": "0x17b8baa7f19546a0000",
  	"0x4fce8429ba49caa0369d1e494db57e89eab2ad39": "0x2a5a058fc295ed000000",
  	"0x4fdac1aa517007e0089430b3316a1badd12c01c7": "0x1b1ae4d6e2ef500000",
  	"0x4fe56ab3bae1b0a44433458333c4b05a248f8241": "0x762d93d1dd6f900000",
  	"0x4feb846be43041fd6b34202897943e3f21cb7f04": "0x482fe260cbca90000",
  	"0x4fee50c5f988206b09a573469fb1d0b42ebb6dce": "0x6cee06ddbe15ec0000",
  	"0x4ff676e27f681a982d8fd9d20e648b3dce05e945": "0x97c9ce4cf6d5c00000",
  	"0x4ff67fb87f6efba9279930cfbd1b7a343c79fade": "0x15af1d78b58c400000",
  	"0x5006fe4c22173980f00c74342b39cd231c653129": "0x6c6b935b8bbd400000",
  	"0x500c16352e901d48ba8d04e2c767121772790b02": "0x1a3a6824973098000",
  	"0x500c902958f6421594d1b6ded712490d52ed6c44": "0x6acb3df27e1f880000",
  	"0x500e34cde5bd9e2b71bb92d7cf55eee188d5fa0c": "0x121ea68c114e5100000",
  	"0x5032e4bcf7932b49fdba377b6f1499636513cfc3": "0x56bc75e2d63100000",
  	"0x50378af7ef54043f892ab7ce97d647793511b108": "0x11164759ffb320000",
  	"0x503bdbd8bc421c32a443032deb2e3e4cd5ba8b4e": "0x6c6b935b8bbd400000",
  	"0x504666ce8931175e11a5ed11c1dcaa06e57f4e66": "0x27f3edfb34e6e400000",
  	"0x50584d9206a46ce15c301117ee28f15c30e60e75": "0xb9f65d00f63c0000",
  	"0x505a33a18634dd4800693c67f48a1d693d4833f8": "0x18921b79941dcd00000",
  	"0x505e4f7c275588c533a20ebd2ac13b409bbdea3c": "0xf43fc2c04ee00000",
  	"0x5062e5134c612f12694dbd0e131d4ce197d1b6a4": "0x3635c9adc5dea00000",
  	"0x506411fd79003480f6f2b6aac26b7ba792f094b2": "0x1b1ae4d6e2ef500000",
  	"0x5067f4549afbfe884c59cbc12b96934923d45db0": "0x3635c9adc5dea00000",
  	"0x50763add868fd7361178342fc055eaa2b95f6846": "0x39f9046e0898f0000",
  	"0x508cf19119db70aa86454253da764a2cb1b2be1a": "0x3635c9adc5dea00000",
  	"0x509982f56237ee458951047e0a2230f804e2e895": "0x3b4ad496106b7f00000",
  	"0x509a20bc48e72be1cdaf9569c711e8648d957334": "0x6c6b935b8bbd400000",
  	"0x509c8668036d143fb8ae70b11995631f3dfcad87": "0x3635c9adc5dea00000",
  	"0x50ad187ab21167c2b6e78be0153f44504a07945e": "0x56cd55fc64dfe0000",
  	"0x50b9fef0a1329b02d16506255f5a2db71ec92d1f": "0x47da821564085c0000",
  	"0x50bb67c8b8d8bd0f63c4760904f2d333f400aace": "0x6c6b935b8bbd400000",
  	"0x50bef2756248f9a7a380f91b051ba3be28a649ed": "0x6c69f73e29134e0000",
  	"0x50ca86b5eb1d01874df8e5f34945d49c6c1ab848": "0x3635c9adc5dea00000",
  	"0x50cd97e9378b5cf18f173963236c9951ef7438a5": "0x4be4e7267b6ae00000",
  	"0x50dcbc27bcad984093a212a9b4178eabe9017561": "0x7e362790b5ca40000",
  	"0x50e13023bd9ca96ad4c53fdfd410cb6b1f420bdf": "0xad78ebc5ac6200000",
  	"0x50e1c8ec98415bef442618708799437b86e6c205": "0x14542ba12a337c00000",
  	"0x50f8fa4bb9e2677c990a4ee8ce70dd1523251e4f": "0x1693d23164f6b0000",
  	"0x50fb36c27107ee2ca9a3236e2746cca19ace6b49": "0x6c6b935b8bbd400000",
  	"0x50fef296955588caae74c62ec32a23a454e09ab8": "0x411dffabc507380000",
  	"0x5102a4a42077e11c58df4773e3ac944623a66d9f": "0x6c7015fd52ed408000",
  	"0x51039377eed0c573f986c5e8a95fb99a59e9330f": "0x6acb3df27e1f880000",
  	"0x5103bc09933e9921fd53dc536f11f05d0d47107d": "0xd8d726b7177a800000",
  	"0x5104ecc0e330dd1f81b58ac9dbb1a9fbf88a3c85": "0x152d02c7e14af6800000",
  	"0x510d8159cc945768c7450790ba073ec0d9f89e30": "0x8ac7230489e8000000",
  	"0x510eda5601499a0d5e1a006bfffd833672f2e267": "0x6c6b935b8bbd400000",
  	"0x51126446ab3d8032557e8eba65597d75fadc815c": "0x1174a5cdf88bc80000",
  	"0x5118557d600d05c2fcbf3806ffbd93d02025d730": "0x267d3ab6423f5800000",
  	"0x511e0efb04ac4e3ff2e6550e498295bfcd56ffd5": "0x243d4d18229ca20000",
  	"0x512116817ba9aaf843d1507c65a5ea640a7b9eec": "0x2b5e3af16b1880000",
  	"0x5126460d692c71c9af6f05574d93998368a23799": "0x2d1a51c7e00500000",
  	"0x51277fe7c81eebd252a03df69a6b9f326e272207": "0x3402e79cab44c8000",
  	"0x51296f5044270d17707646129c86aad1645eadc1": "0x487c72b310d4648000",
  	"0x512b91bbfaa9e581ef683fc90d9db22a8f49f48b": "0x41a522386d9b95c00000",
  	"0x5135fb8757600cf474546252f74dc0746d06262c": "0x6c6b935b8bbd400000",
  	"0x514632efbd642c04de6ca342315d40dd90a2dba6": "0x90f534608a72880000",
  	"0x514b7512c9ae5ea63cbf11715b63f21e18d296c1": "0x6c6acc67d7b1d40000",
  	"0x5153a0c3c8912881bf1c3501bf64b45649e48222": "0xd8d726b7177a800000",
  	"0x515651d6db4faf9ecd103a921bbbbe6ae970fdd4": "0x43c33c1937564800000",
  	"0x515f30bc90cdf4577ee47d65d785fbe2e837c6bc": "0x2271b5e018ba0580000",
  	"0x5160ed612e1b48e73f3fc15bc4321b8f23b8a24b": "0x1e826b422865d80000",
  	"0x5161fd49e847f67455f1c8bb7abb36e985260d03": "0x410d586a20a4c00000",
  	"0x516954025fca2608f47da81c215eedfd844a09ff": "0x14b550a013c7380000",
  	"0x5169c60aee4ceed1849ab36d664cff97061e8ea8": "0xa2a15d09519be00000",
  	"0x517c75430de401c341032686112790f46d4d369e": "0x150894e849b3900000",
  	"0x517cd7608e5d0d83a26b717f3603dac2277dc3a4": "0x6c6b935b8bbd400000",
  	"0x51865db148881951f51251710e82b9be0d7eadb2": "0x6c6b935b8bbd400000",
  	"0x51891b2ccdd2f5a44b2a8bc49a5d9bca6477251c": "0x10ce1d3d8cb3180000",
  	"0x518cef27b10582b6d14f69483ddaa0dd3c87bb5c": "0x2086ac351052600000",
  	"0x51a6d627f66a8923d88d6094c4715380d3057cb6": "0x3e73d27a35941e0000",
  	"0x51a8c2163602a32ee24cf4aa97fd9ea414516941": "0x368f7e6b8672c0000",
  	"0x51b4758e9e1450e7af4268c3c7b1e7bd6f5c7550": "0x3635c9adc5dea00000",
  	"0x51ca8bd4dc644fac47af675563d5804a0da21eeb": "0x2ab7b260ff3fd00000",
  	"0x51d24bc3736f88dd63b7222026886630b6eb878d": "0x6c6b935b8bbd400000",
  	"0x51d78b178d707e396e8710965c4f41b1a1d9179d": "0x5fee222041e340000",
  	"0x51e32f14f4ca5e287cdac057a7795ea9e0439953": "0x1b1ae4d6e2ef500000",
  	"0x51e43fe0d25c782860af81ea89dd793c13f0cbb1": "0x340aad21b3b700000",
  	"0x51e7b55c2f9820eed73884361b5066a59b6f45c6": "0x6c6b935b8bbd400000",
  	"0x51ea1c0934e3d04022ed9c95a087a150ef705e81": "0x1547081e7224d200000",
  	"0x51ee0cca3bcb10cd3e983722ced8493d926c0866": "0x36356633ebd8ea0000",
  	"0x51f4663ab44ff79345f427a0f6f8a6c8a53ff234": "0x43c33c1937564800000",
  	"0x51f55ef47e6456a418ab32b9221ed27dba6608ee": "0xe3aeb5737240a00000",
  	"0x51f9c432a4e59ac86282d6adab4c2eb8919160eb": "0x703b5b89c3a6e7400000",
  	"0x520f66a0e2657ff0ac4195f2f064cf2fa4b24250": "0x22b1c8c1227a00000",
  	"0x52102354a6aca95d8a2e86d5debda6de69346076": "0x6c6b935b8bbd400000",
  	"0x5213f459e078ad3ab95a0920239fcf1633dc04ca": "0x8cf2187c2afb188000",
  	"0x5215183b8f80a9bc03d26ce91207832a0d39e620": "0x3635c9adc5dea00000",
  	"0x52214378b54004056a7cc08c891327798ac6b248": "0x337fe5feaf2d1800000",
  	"0x522323aad71dbc96d85af90f084b99c3f09decb7": "0x14542ba12a337c00000",
  	"0x523e140dc811b186dee5d6c88bf68e90b8e096fd": "0x6c6b935b8bbd400000",
  	"0x523f6d64690fdacd942853591bb0ff20d3656d95": "0x62a992e53a0af00000",
  	"0x524fb210522c5e23bb67dfbf8c26aa616da49955": "0x363562a66d34238000",
  	"0x5255dc69155a45b970c604d30047e2f530690e7f": "0x1158e460913d00000",
  	"0x5260dc51ee07bddaababb9ee744b393c7f4793a6": "0x1d8665fa5fa4c0000",
  	"0x5267f4d41292f370863c90d793296903843625c7": "0x4be4e7267b6ae00000",
  	"0x526bb533b76e20c8ee1ebf123f1e9ff4148e40be": "0xaadec983fcff40000",
  	"0x526cb09ce3ada3672eec1deb46205be89a4b563e": "0x85ca615bf9c0100000",
  	"0x52738c90d860e04cb12f498d96fdb5bf36fc340e": "0x1a055690d9db80000",
  	"0x527a8ca1268633a6c939c5de1b929aee92aeac8d": "0x30ca024f987b900000",
  	"0x528101ce46b720a2214dcdae6618a53177ffa377": "0x1b9612b9dc01ae0000",
  	"0x5281733473e00d87f11e9955e589b59f4ac28e7a": "0x8bd62ff4eec559200000",
  	"0x5298ab182a19359ffcecafd7d1b5fa212dede6dd": "0x1158e460913d00000",
  	"0x529aa002c6962a3a8545027fd8b05f22b5bf9564": "0x5a87e7d7f5f6580000",
  	"0x529e824fa072582b4032683ac7eecc1c04b4cac1": "0x6c6b935b8bbd400000",
  	"0x52a5e4de4393eeccf0581ac11b52c683c76ea15d": "0x43c30fb0884a96c0000",
  	"0x52b4257cf41b6e28878d50d57b99914ffa89873a": "0xd50dc9aa2c41770000",
  	"0x52b8a9592634f7300b7c5c59a3345b835f01b95c": "0x6c6b935b8bbd400000",
  	"0x52bdd9af5978850bc24110718b3723759b437e59": "0x5dc892aa1131c80000",
  	"0x52cd20403ba7eda6bc307a3d63b5911b817c1263": "0x1158e460913d00000",
  	"0x52d380511df19d5ec2807bbcb676581b67fd37a3": "0xb9f65d00f63c0000",
  	"0x52e1731350f983cc2c4189842fde0613fad50ce1": "0x277017338a30ae00000",
  	"0x52e46783329a769301b175009d346768f4c87ee4": "0x6c6b935b8bbd400000",
  	"0x52f058d46147e9006d29bf2c09304ad1cddd6e15": "0x5150ae84a8cdf00000",
  	"0x52f15423323c24f19ae2ab673717229d3f747d9b": "0x37a034cbe8e3f38000",
  	"0x52f8b509fee1a874ab6f9d87367fbeaf15ac137f": "0x3635c9adc5dea00000",
  	"0x52fb46ac5d00c3518b2c3a1c177d442f8165555f": "0x5150ae84a8cdf00000",
  	"0x530077c9f7b907ff9cec0c77a41a70e9029add4a": "0x6c6b935b8bbd400000",
  	"0x530319db0a8f93e5bb7d4dbf4816314fbed8361b": "0x6c6b935b8bbd400000",
  	"0x53047dc8ac9083d90672e8b3473c100ccd278323": "0x22b1c8c1227a00000",
  	"0x530b61e42f39426d2408d40852b9e34ab5ebebc5": "0xe7eeba3410b740000",
  	"0x530ffac3bc3412e2ec0ea47b7981c770f5bb2f35": "0x73f75d1a085ba0000",
  	"0x5317ecb023052ca7f5652be2fa854cfe4563df4d": "0x1b1ab319f5ec750000",
  	"0x53194d8afa3e883502767edbc30586af33b114d3": "0x6c6b935b8bbd400000",
  	"0x532a7da0a5ad7407468d3be8e07e69c7dd64e861": "0x1b1ae4d6e2ef500000",
  	"0x532d32b00f305bcc24dcef56817d622f34fb2c24": "0x6194049f30f7200000",
  	"0x533444584082eba654e1ad30e149735c6f7ba922": "0x5dc892aa1131c80000",
  	"0x5338ef70eac9dd9af5a0503b5efad1039e67e725": "0x90f534608a72880000",
  	"0x53396f4a26c2b4604496306c5442e7fcba272e36": "0x43f2f08d40e5afc0000",
  	"0x533a73a4a2228eee05c4ffd718bbf3f9c1b129a7": "0x14542ba12a337c00000",
  	"0x533c06928f19d0a956cc28866bf6c8d8f4191a94": "0xfd8c14338e6300000",
  	"0x534065361cb854fac42bfb5c9fcde0604ac919da": "0x6c6b935b8bbd400000",
  	"0x53437fecf34ab9d435f4deb8ca181519e2592035": "0xa31062beeed700000",
  	"0x535201a0a1d73422801f55ded4dfaee4fbaa6e3b": "0x226211f7915428000",
  	"0x53608105ce4b9e11f86bf497ffca3b78967b5f96": "0x43c33c1937564800000",
  	"0x536e4d8029b73f5579dca33e70b24eba89e11d7e": "0x6acb3df27e1f880000",
  	"0x53700d53254d430f22781a4a76a463933b5d6b08": "0x6acb3df27e1f880000",
  	"0x537f9d4d31ef70839d84b0d9cdb72b9afedbdf35": "0xed2b525841adfc00000",
  	"0x5381448503c0c702542b1de7cc5fb5f6ab1cf6a5": "0x1b1ae4d6e2ef5000000",
  	"0x53942e7949d6788bb780a7e8a0792781b1614b84": "0x35deb46684f10c80000",
  	"0x5395a4455d95d178b4532aa4725b193ffe512961": "0x3635c9adc5dea00000",
  	"0x53989ed330563fd57dfec9bd343c3760b0799390": "0x150894e849b39000000",
  	"0x53a244672895480f4a2b1cdf7da5e5a242ec4dbc": "0x3635c9adc5dea00000",
  	"0x53a714f99fa00fef758e23a2e746326dad247ca7": "0x50c5e761a444080000",
  	"0x53af32c22fef99803f178cf90b802fb571c61cb9": "0xd255d112e103a00000",
  	"0x53c0bb7fc88ea422d2ef7e540e2d8f28b1bb8183": "0x1158e460913d00000",
  	"0x53c5fe0119e1e848640cee30adea96940f2a5d8b": "0x49ada5fa8c10c880000",
  	"0x53c9eca40973f63bb5927be0bc6a8a8be1951f74": "0x6c6b935b8bbd400000",
  	"0x53ce88e66c5af2f29bbd8f592a56a3d15f206c32": "0x7a28c31cc36040000",
  	"0x53cec6c88092f756efe56f7db11228a2db45b122": "0xd8d726b7177a800000",
  	"0x53e35b12231f19c3fd774c88fec8cbeedf1408b2": "0x1bc16d674ec8000000",
  	"0x53e4d9696dcb3f4d7b3f70dcaa4eecb71782ff5c": "0xad78ebc5ac6200000",
  	"0x53faf165be031ec18330d9fce5bd1281a1af08db": "0x796e3ea3f8ab00000",
  	"0x540a1819bd7c35861e791804e5fbb3bc97c9abb1": "0x4ed7dac64230200000",
  	"0x540c072802014ef0d561345aec481e8e11cb3570": "0x1b1ae4d6e2ef5000000",
  	"0x540cf23dd95c4d558a279d778d2b3735b3164191": "0x21e19e0c9bab2400000",
  	"0x541060fc58c750c40512f83369c0a63340c122b6": "0x6acb3df27e1f880000",
  	"0x5413c97ffa4a6e2a7bba8961dc9fce8530a787d7": "0x3635c9adc5dea00000",
  	"0x541db20a80cf3b17f1621f1b3ff79b882f50def3": "0x3635c9adc5dea00000",
  	"0x542e8096bafb88162606002e8c8a3ed19814aeac": "0x6c6b935b8bbd400000",
  	"0x54310b3aa88703a725dfa57de6e646935164802c": "0x678a932062e4180000",
  	"0x5431b1d18751b98fc9e2888ac7759f1535a2db47": "0x6c6b935b8bbd400000",
  	"0x5431ca427e6165a644bae326bd09750a178c650d": "0x6c6b935b8bbd400000",
  	"0x5435c6c1793317d32ce13bba4c4ffeb973b78adc": "0xd8e6b1c1285ef0000",
  	"0x543629c95cdef428ad37d453ca9538a9f90900ac": "0x92896529baddc880000",
  	"0x54391b4d176d476cea164e5fb535c69700cb2535": "0x56cd55fc64dfe0000",
  	"0x543a8c0efb8bcd15c543e2a6a4f807597631adef": "0x13f80e7e14f2d440000",
  	"0x543f8c674e2462d8d5daa0e80195a8708e11a29e": "0x37758833b3a7a0000",
  	"0x544b5b351d1bc82e9297439948cf4861dac9ae11": "0x4a89f54ef0121c00000",
  	"0x544dda421dc1eb73bb24e3e56a248013b87c0f44": "0x6acb3df27e1f880000",
  	"0x54575c3114751e3c631971da6a2a02fd3ffbfcc8": "0x692ae8897081d00000",
  	"0x545bb070e781172eb1608af7fc2895d6cb87197e": "0x79a5c17ec748900000",
  	"0x5475d7f174bdb1f789017c7c1705989646079d49": "0x1fd933494aa5fe00000",
  	"0x548558d08cfcb101181dac1eb6094b4e1a896fa6": "0x6c6acc67d7b1d40000",
  	"0x54939ff08921b467cf2946751d856378296c63ed": "0x3635c9adc5dea00000",
  	"0x549b47649cfad993e4064d2636a4baa0623305cc": "0x209d922f5259c50000",
  	"0x549d51af29f724c967f59423b85b2681e7b15136": "0xcbd47b6eaa8cc00000",
  	"0x54a1370116fe22099e015d07cd2669dd291cc9d1": "0x1158e460913d00000",
  	"0x54a62bf9233e146ffec3876e45f20ee8414adeba": "0x21e19e0c9bab2400000",
  	"0x54b4429b182f0377be7e626939c5db6440f75d7a": "0x6acb3df27e1f880000",
  	"0x54bcb8e7f73cda3d73f4d38b2d0847e600ba0df8": "0x3a70415882df180000",
  	"0x54c93e03a9b2e8e4c3672835a9ee76f9615bc14e": "0x10d3aa536e2940000",
  	"0x54ce88275956def5f9458e3b95decacd484021a0": "0x6c6b935b8bbd400000",
  	"0x54db5e06b4815d31cb56a8719ba33af2d73e7252": "0x24521e2a3017b80000",
  	"0x54e01283cc8b384538dd646770b357c960d6cacd": "0x10f0cf064dd59200000",
  	"0x54ec7300b81ac84333ed1b033cd5d7a33972e234": "0xad78ebc5ac6200000",
  	"0x54febcce20fe7a9098a755bd90988602a48c089e": "0x22b1c8c1227a000000",
  	"0x550aadae1221b07afea39fba2ed62e05e5b7b5f9": "0x1158e460913d00000",
  	"0x550c306f81ef5d9580c06cb1ab201b95c748a691": "0x2417d4c470bf140000",
  	"0x551999ddd205563327b9b530785acff9bc73a4ba": "0x14542ba12a337c00000",
  	"0x551e7784778ef8e048e495df49f2614f84a4f1dc": "0x2086ac351052600000",
  	"0x5529830a61c1f13c197e550beddfd6bd195c9d02": "0x21e19e0c9bab2400000",
  	"0x552987f0651b915b2e1e5328c121960d4bdd6af4": "0x61093d7c2c6d380000",
  	"0x553b6b1c57050e88cf0c31067b8d4cd1ff80cb09": "0x15af1d78b58c400000",
  	"0x553f37d92466550e9fd775ae74362df030179132": "0x6c6b935b8bbd400000",
  	"0x554336ee4ea155f9f24f87bca9ca72e253e12cd2": "0x56bc75e2d63100000",
  	"0x5543dd6d169eec8a213bbf7a8af9ffd15d4ff759": "0xfc936392801c0000",
  	"0x5547fdb4ae11953e01292b7807fa9223d0e4606a": "0x55d117dcb1d260000",
  	"0x5552f4b3ed3e1da79a2f78bb13e8ae5a68a9df3b": "0x3635c9adc5dea00000",
  	"0x555ca9f05cc134ab54ae9bea1c3ff87aa85198ca": "0x56bc75e2d63100000",
  	"0x555d8d3ce1798aca902754f164b8be2a02329c6c": "0x21e19e0c9bab2400000",
  	"0x555df19390c16d01298772bae8bc3a1152199cbd": "0xad78ebc5ac6200000",
  	"0x555ebe84daa42ba256ea789105cec4b693f12f18": "0x56bc75e2d63100000",
  	"0x557f5e65e0da33998219ad4e99570545b2a9d511": "0x2559cbb985842400000",
  	"0x558360206883dd1b6d4a59639e5629d0f0c675d0": "0x6c6b935b8bbd400000",
  	"0x5584423050e3c2051f0bbd8f44bd6dbc27ecb62c": "0xa2a15d09519be00000",
  	"0x55852943492970f8d629a15366cdda06a94f4513": "0x6c6b935b8bbd400000",
  	"0x55866486ec168f79dbe0e1abb18864d98991ae2c": "0xdf6eb0b2d3ca0000",
  	"0x558c54649a8a6e94722bd6d21d14714f71780534": "0x6c6b935b8bbd400000",
  	"0x559194304f14b1b93afe444f0624e053c23a0009": "0x15af1d78b58c400000",
  	"0x5593c9d4b664730fd93ca60151c25c2eaed93c3b": "0xad78ebc5ac6200000",
  	"0x559706c332d20779c45f8a6d046a699159b74921": "0x149b442e85a3cf8000",
  	"0x5598b3a79a48f32b1f5fc915b87b645d805d1afe": "0x1b1ae4d6e2ef500000",
  	"0x55a3df57b7aaec16a162fd5316f35bec082821cf": "0x6acb3df27e1f880000",
  	"0x55a4cac0cb8b582d9fef38c5c9fff9bd53093d1f": "0x6acb3df27e1f880000",
  	"0x55a61b109480b5b2c4fcfdef92d90584160c0d35": "0x26c564d2b53f60000",
  	"0x55aa5d313ebb084da0e7801091e29e92c5dec3aa": "0x6c6b935b8bbd400000",
  	"0x55ab99b0e0e55d7bb874b7cfe834de631c97ec23": "0x37e98ce36899e40000",
  	"0x55af092f94ba6a79918b0cf939eab3f01b3f51c7": "0x820d5e39576120000",
  	"0x55c564664166a1edf3913e0169f1cd451fdb5d0c": "0x8217ea49508e6c0000",
  	"0x55ca6abe79ea2497f46fdbb830346010fe469cbe": "0x1369fb96128ac480000",
  	"0x55caff4bba04d220c9a5d2018672ec85e31ef83e": "0x6c6b935b8bbd400000",
  	"0x55d057bcc04bd0f4af9642513aa5090bb3ff93fe": "0x3bfe452c8edd4c0000",
  	"0x55d42eb495bf46a634997b5f2ea362814918e2b0": "0x5c0d265b5b2a80000",
  	"0x55da9dcdca61cbfe1f133c7bcefc867b9c8122f9": "0x2fb474098f67c00000",
  	"0x55e220876262c218af4f56784798c7e55da09e91": "0x73d99c15645d30000",
  	"0x55fd08d18064bd202c0ec3d2cce0ce0b9d169c4d": "0x6acb3df27e1f880000",
  	"0x5600730a55f6b20ebd24811faa3de96d1662abab": "0x65ea3db75546600000",
  	"0x5603241eb8f08f721e348c9d9ad92f48e390aa24": "0xad78ebc5ac6200000",
  	"0x560536794a9e2b0049d10233c41adc5f418a264a": "0x3635c9adc5dea00000",
  	"0x5607590059a9fec1881149a44b36949aef85d560": "0x6c6b935b8bbd400000",
  	"0x560becdf52b71f3d8827d927610f1a980f33716f": "0x17474d705f56d08000",
  	"0x560da37e956d862f81a75fd580a7135c1b246352": "0x21e19e0c9bab2400000",
  	"0x560fc08d079f047ed8d7df75551aa53501f57013": "0x19bff2ff57968c00000",
  	"0x561be9299b3e6b3e63b79b09169d1a948ae6db01": "0x1b1ae4d6e2ef500000",
  	"0x562020e3ed792d2f1835fe5f55417d5111460c6a": "0x43c33c1937564800000",
  	"0x5620f46d1451c2353d6243a5d4b427130be2d407": "0x340aad21b3b700000",
  	"0x562105e82b099735de49f62692cc87cd38a8edcd": "0x14542ba12a337c00000",
  	"0x562a8dcbbeeef7b360685d27303bd69e094accf6": "0x21e19e0c9bab2400000",
  	"0x562bced38ab2ab6c080f3b0541b8456e70824b3f": "0x22ca3587cf4eb00000",
  	"0x562be95aba17c5371fe2ba828799b1f55d2177d6": "0x816d37e87b9d1e00000",
  	"0x562f16d79abfcec3943e34b20f05f97bdfcda605": "0xd8d726b7177a800000",
  	"0x56373daab46316fd7e1576c61e6affcb6559ddd7": "0xbac715d146c9e0000",
  	"0x56397638bb3cebf1f62062794b5eb942f916171d": "0x6c6b935b8bbd400000",
  	"0x563a03ab9c56b600f6d25b660c21e16335517a75": "0x3635c9adc5dea00000",
  	"0x563cb8803c1d32a25b27b64114852bd04d9c20cd": "0xb149ead0ad9d80000",
  	"0x56586391040c57eec6f5affd8cd4abde10b50acc": "0xd8d726b7177a800000",
  	"0x566c10d638e8b88b47d6e6a414497afdd00600d4": "0x56b394263a40c0000",
  	"0x566c28e34c3808d9766fe8421ebf4f2b1c4f7d77": "0x6acb3df27e1f880000",
  	"0x568df31856699bb5acfc1fe1d680df9960ca4359": "0x4acf5552f3b2498000",
  	"0x5691dd2f6745f20e22d2e1d1b955aa2903d65656": "0x6ac5c62d9486070000",
  	"0x56a1d60d40f57f308eebf087dee3b37f1e7c2cba": "0x3edcaec82d06f80000",
  	"0x56ac20d63bd803595cec036da7ed1dc66e0a9e07": "0x3772a53ccdc658000",
  	"0x56b6c23dd2ec90b4728f3bb2e764c3c50c85f144": "0x3635c9adc5dea00000",
  	"0x56df05bad46c3f00ae476ecf017bb8c877383ff1": "0xab15daaef70400000",
  	"0x56ee197f4bbf9f1b0662e41c2bbd9aa1f799e846": "0x3635c9adc5dea00000",
  	"0x56f493a3d108aaa2d18d98922f8efe1662cfb73d": "0x6d8121a194d1100000",
  	"0x56fc1a7bad4047237ce116146296238e078f93ad": "0x9a63f08ea63880000",
  	"0x56febf9e1003af15b1bd4907ec089a4a1b91d268": "0xad78ebc5ac6200000",
  	"0x5717cc9301511d4a81b9f583148beed3d3cc8309": "0x8cf23f909c0fa00000",
  	"0x5717f2d8f18ffcc0e5fe247d3a4219037c3a649c": "0xd8bb6549b02bb80000",
  	"0x571950ea2c90c1427d939d61b4f2de4cf1cfbfb0": "0x1158e460913d00000",
  	"0x5719f49b720da68856f4b9e708f25645bdbc4b41": "0x22b1c8c1227a000000",
  	"0x572ac1aba0de23ae41a7cae1dc0842d8abfc103b": "0x678a932062e4180000",
  	"0x572dd8cd3fe399d1d0ec281231b7cefc20b9e4bb": "0x233c8fe42703e800000",
  	"0x574921838cc77d6c98b17d903a3ae0ee0da95bd0": "0xb5328178ad0f2a00000",
  	"0x574ad9355390e4889ef42acd138b2a27e78c00ae": "0x5467b732a913340000",
  	"0x574de1b3f38d915846ae3718564a5ada20c2f3ed": "0xd8d726b7177a800000",
  	"0x575c00c2818210c28555a0ff29010289d3f82309": "0x21e19e0c9bab2400000",
  	"0x5773b6026721a1dd04b7828cd62b591bfb34534c": "0x5b7ac4553de7ae00000",
  	"0x5777441c83e03f0be8dd340bde636850847c620b": "0x21e19e0c9bab2400000",
  	"0x5778ffdc9b94c5a59e224eb965b6de90f222d170": "0x122d7ff36603fc0000",
  	"0x577aeee8d4bc08fc97ab156ed57fb970925366be": "0x120df1147258bf0000",
  	"0x577b2d073c590c50306f5b1195a4b2ba9ecda625": "0x1440bdd49515f00000",
  	"0x577bfe64e3a1e3800e94db1c6c184d8dc8aafc66": "0x5134ed17417f280000",
  	"0x57825aeb09076caa477887fbc9ae37e8b27cc962": "0x56bc75e2d63100000",
  	"0x57883010b4ac857fedac03eab2551723a8447ffb": "0x3635c9adc5dea00000",
  	"0x5789d01db12c816ac268e9af19dc0dd6d99f15df": "0xad78ebc5ac6200000",
  	"0x5792814f59a33a1843faa01baa089eb02ffb5cf1": "0x1b1ab319f5ec750000",
  	"0x5793abe6f1533311fd51536891783b3f9625ef1c": "0x2cd8a656f23fda0000",
  	"0x5797b60fd2894ab3c2f4aede86daf2e788d745ad": "0x14542ba12a337c00000",
  	"0x57a852fdb9b1405bf53ccf9508f83299d3206c52": "0x6c6b935b8bbd400000",
  	"0x57b23d6a1adc06c652a779c6a7fb6b95b9fead66": "0xad78ebc5ac6200000",
  	"0x57bc20e2d62b3d19663cdb4c309d5b4f2fc2db8f": "0x56bc75e2d63100000",
  	"0x57bddf078834009c89d88e6282759dc45335b470": "0x74717cfb6883100000",
  	"0x57beea716cbd81700a73d67f9ff039529c2d9025": "0xad78ebc5ac6200000",
  	"0x57d032a43d164e71aa2ef3ffd8491b0a4ef1ea5b": "0x6c6b935b8bbd400000",
  	"0x57d3df804f2beee6ef53ab94cb3ee9cf524a18d3": "0x1556616b9606670000",
  	"0x57d5fd0e3d3049330ffcdcd020456917657ba2da": "0x6bf20195f554d40000",
  	"0x57dd9471cbfa262709f5f486bcb774c5f527b8f8": "0xaadec983fcff40000",
  	"0x57df23bebdc65eb75feb9cb2fad1c073692b2baf": "0xd8d726b7177a800000",
  	"0x5800cd8130839e94495d2d8415a8ea2c90e0c5cb": "0xad78ebc5ac6200000",
  	"0x5803e68b34da121aef08b602badbafb4d12481ca": "0x3cfc82e37e9a7400000",
  	"0x5816c2687777b6d7d2a2432d59a41fa059e3a406": "0x1c4fe43adb0a5e900000",
  	"0x581a3af297efa4436a29af0072929abf9826f58b": "0x6c6b935b8bbd400000",
  	"0x581b9fd6eae372f3501f42eb9619eec820b78a84": "0x42be2c00ca53b8d8000",
  	"0x581bdf1bb276dbdd86aedcdb397a01efc0e00c5b": "0x3635c9adc5dea00000",
  	"0x581f34b523e5b41c09c87c298e299cbc0e29d066": "0x3d5833aafd39758000",
  	"0x5824a7e22838277134308c5f4b50dab65e43bb31": "0x14542ba12a337c00000",
  	"0x582b70669c97aab7d68148d8d4e90411e2810d56": "0x36356633ebd8ea0000",
  	"0x582e7cc46f1d7b4e6e9d95868bfd370573178f4c": "0x6c6b935b8bbd400000",
  	"0x583e83ba55e67e13e0e76f8392d873cd21fbf798": "0x1158e460913d00000",
  	"0x5869fb867d71f1387f863b698d09fdfb87c49b5c": "0xc6bbf858b316080000",
  	"0x587d6849b168f6c3332b7abae7eb6c42c37f48bf": "0x2fb474098f67c00000",
  	"0x5887dc6a33dfed5ac1edefe35ef91a216231ac96": "0xd8d726b7177a80000",
  	"0x588ed990a2aff44a94105d58c305257735c868ac": "0x368c8623a8b4d100000",
  	"0x58ae2ddc5f4c8ada97e06c0086171767c423f5d7": "0x57473d05dabae80000",
  	"0x58aed6674affd9f64233272a578dd9386b99c263": "0xb8507a820728200000",
  	"0x58b808a65b51e6338969afb95ec70735e451d526": "0x8784bc1b9837a380000",
  	"0x58b8ae8f63ef35ed0762f0b6233d4ac14e64b64d": "0x6c6b935b8bbd400000",
  	"0x58ba1569650e5bbbb21d35d3e175c0d6b0c651a9": "0x1b1ae4d6e2ef500000",
  	"0x58c555bc293cdb16c6362ed97ae9550b92ea180e": "0x1158e460913d00000",
  	"0x58c650ced40bb65641b8e8a924a039def46854df": "0x100bd33fb98ba0000",
  	"0x58c90754d2f20a1cb1dd330625e04b45fa619d5c": "0x6c6b935b8bbd400000",
  	"0x58e2f11223fc8237f69d99c6289c148c0604f742": "0x5150ae84a8cdf000000",
  	"0x58e554af3d87629620da61d538c7f5b4b54c4afe": "0x46509d694534728000",
  	"0x58e5c9e344c806650dacfc904d33edba5107b0de": "0x10910d4cdc9f60000",
  	"0x58e661d0ba73d6cf24099a5562b808f7b3673b68": "0x6c6b935b8bbd400000",
  	"0x58f05b262560503ca761c61890a4035f4c737280": "0x1b1ae4d6e2ef5000000",
  	"0x58fb947364e7695765361ebb1e801ffb8b95e6d0": "0xad78ebc5ac6200000",
  	"0x590181d445007bd0875aaf061c8d51153900836a": "0x6c6b935b8bbd400000",
  	"0x5902e44af769a87246a21e079c08bf36b06efeb3": "0x3635c9adc5dea00000",
  	"0x590acbda37290c0d3ec84fc2000d7697f9a4b15d": "0x1b1ae4d6e2ef500000",
  	"0x590ccb5911cf78f6f622f535c474375f4a12cfcf": "0x43c33c1937564800000",
  	"0x5910106debd291a1cd80b0fbbb8d8d9e93a7cc1e": "0x6c6b935b8bbd400000",
  	"0x59161749fedcf1c721f2202d13ade2abcf460b3d": "0x6c6b935b8bbd400000",
  	"0x591bef3171d1c5957717a4e98d17eb142c214e56": "0x43c33c1937564800000",
  	"0x59203cc37599b648312a7cc9e06dacb589a9ae6a": "0x80f7971b6400e8000",
  	"0x59268171b833e0aa13c54b52ccc0422e4fa03aeb": "0xa2a15d09519be00000",
  	"0x592777261e3bd852c48eca95b3a44c5b7f2d422c": "0x43c33c1937564800000",
  	"0x593044670faeff00a55b5ae051eb7be870b11694": "0x73f75d1a085ba0000",
  	"0x593b45a1864ac5c7e8f0caaeba0d873cd5d113b2": "0x14542ba12a337c00000",
  	"0x593c48935beaff0fde19b04d309cd530a28e52ce": "0xd8d726b7177a800000",
  	"0x59473cd300fffae240f5785626c65dfec792b9af": "0x1158e460913d00000",
  	"0x5948bc3650ed519bf891a572679fd992f8780c57": "0xaadec983fcff40000",
  	"0x594a76f06935388dde5e234696a0668bc20d2ddc": "0x97c9ce4cf6d5c00000",
  	"0x59569a21d28fba4bda37753405a081f2063da150": "0xd8d726b7177a800000",
  	"0x5956b28ec7890b76fc061a1feb52d82ae81fb635": "0x6c6b935b8bbd400000",
  	"0x595e23d788a2d4bb85a15df7136d264a635511b3": "0xd5967be4fc3f100000",
  	"0x597038ff91a0900cbbab488af483c790e6ec00a0": "0x21e19e0c9bab2400000",
  	"0x5970fb1b144dd751e4ce2eca7caa20e363dc4da3": "0x21e19e0c9bab2400000",
  	"0x5975b9528f23af1f0e2ec08ac8ebaa786a2cb8e0": "0x12bf50503ae3038000",
  	"0x5975d78d974ee5bb9e4d4ca2ae77c84b9c3b4b82": "0x4a4491bd6dcd280000",
  	"0x5985c59a449dfc5da787d8244e746c6d70caa55f": "0x56bc75e2d63100000",
  	"0x598aaabae9ed833d7bc222e91fcaa0647b77580b": "0x6194049f30f7200000",
  	"0x5992624c54cdec60a5ae938033af8be0c50cbb0a": "0xc454e0f8870f2b0000",
  	"0x599728a78618d1a17b9e34e0fed8e857d5c40622": "0x2f6f10780d22cc00000",
  	"0x5997ffefb3c1d9d10f1ae2ac8ac3c8e2d2292783": "0x3635c9adc5dea00000",
  	"0x59a087b9351ca42f58f36e021927a22988284f38": "0x100bd33fb98ba0000",
  	"0x59a12df2e3ef857aceff9306b309f6a500f70134": "0x3635c9adc5dea00000",
  	"0x59b96deb8784885d8d3b4a166143cc435d2555a1": "0x487a9a304539440000",
  	"0x59b9e733cba4be00429b4bd9dfa64732053a7d55": "0x1158e460913d00000",
  	"0x59c5d06b170ee4d26eb0a0eb46cb7d90c1c91019": "0x21e19e0c9bab2400000",
  	"0x59c7f785c93160e5807ed34e5e534bc6188647a7": "0x22b1c8c1227a000000",
  	"0x59d139e2e40c7b97239d23dfaca33858f602d22b": "0x6c6b935b8bbd400000",
  	"0x59f6247b0d582aaa25e5114765e4bf3c774f43c2": "0x2b5e3af16b1880000",
  	"0x59fe00696dbd87b7976b29d1156c8842a2e17914": "0x6c6b935b8bbd400000",
  	"0x5a0d609aae2332b137ab3b2f26615a808f37e433": "0x21e19e0c9bab24000000",
  	"0x5a192b964afd80773e5f5eda6a56f14e25e0c6f3": "0x1b1ae4d6e2ef500000",
  	"0x5a1a336962d6e0c63031cc83c6a5c6a6f4478ecb": "0x3635c9adc5dea00000",
  	"0x5a1d2d2d1d520304b6208849570437eb3091bb9f": "0x6acb3df27e1f880000",
  	"0x5a267331facb262daaecd9dd63a9700c5f5259df": "0x56bc75e2d63100000",
  	"0x5a285755391e914e58025faa48cc685f4fd4f5b8": "0x581767ba6189c400000",
  	"0x5a2916b8d2e8cc12e207ab464d433e2370d823d9": "0x6c6b935b8bbd400000",
  	"0x5a2b1c853aeb28c45539af76a00ac2d8a8242896": "0x15af1d78b58c40000",
  	"0x5a2daab25c31a61a92a4c82c9925a1d2ef58585e": "0xc380da9c7950c0000",
  	"0x5a30feac37ac9f72d7b4af0f2bc73952c74fd5c3": "0x6c6b935b8bbd400000",
  	"0x5a5468fa5ca226c7532ecf06e1bc1c45225d7ec9": "0x678a932062e4180000",
  	"0x5a565285374a49eedd504c957d510874d00455bc": "0x56bc75e2d63100000",
  	"0x5a5ee8e9bb0e8ab2fecb4b33d29478be50bbd44b": "0x2a1129d09367200000",
  	"0x5a5f8508da0ebebb90be9033bd4d9e274105ae00": "0x16a6502f15a1e540000",
  	"0x5a6071bcebfcba4ab57f4db96fc7a68bece2ba5b": "0x6c6b935b8bbd400000",
  	"0x5a60c924162873fc7ea4da7f972e350167376031": "0x487f277a885798000",
  	"0x5a6686b0f17e07edfc59b759c77d5bef164d3879": "0x50c5e761a444080000",
  	"0x5a70106f20d63f875265e48e0d35f00e17d02bc9": "0x1158e460913d00000",
  	"0x5a74ba62e7c81a3474e27d894fed33dd24ad95fe": "0xfc936392801c0000",
  	"0x5a7735007d70b06844da9901cdfadb11a2582c2f": "0x14542ba12a337c00000",
  	"0x5a82f96cd4b7e2d93d10f3185dc8f43d4b75aa69": "0x6c633fbab98c040000",
  	"0x5a87f034e6f68f4e74ffe60c64819436036cf7d7": "0x1158e460913d00000",
  	"0x5a891155f50e42074374c739baadf7df2651153a": "0x102da6fd0f73a3c0000",
  	"0x5a9c8b69fc614d69564999b00dcb42db67f97e90": "0xb9e615abad3a778000",
  	"0x5aaf1c31254a6e005fba7f5ab0ec79d7fc2b630e": "0x14061b9d77a5e980000",
  	"0x5ab1a5615348001c7c775dc75748669b8be4de14": "0x256a72fb29e69c0000",
  	"0x5abfec25f74cd88437631a7731906932776356f9": "0x9d83cc0dfa11177ff8000",
  	"0x5ac2908b0f398c0df5bac2cb13ca7314fba8fa3d": "0xad4c8316a0b0c0000",
  	"0x5ac99ad7816ae9020ff8adf79fa9869b7cea6601": "0x472698b413b43200000",
  	"0x5ad12c5ed4fa827e2150cfa0d68c0aa37b1769b8": "0x2b5e3af16b18800000",
  	"0x5ad5e420755613886f35aa56ac403eebdfe4b0d0": "0x10f0cf064dd592000000",
  	"0x5ade77fd81c25c0af713b10702768c1eb2f975e7": "0x1158e460913d00000",
  	"0x5ae64e853ba0a51282cb8db52e41615e7c9f733f": "0x6c6b935b8bbd400000",
  	"0x5aed0e6cfe95f9d680c76472a81a2b680a7f93e2": "0xaadec983fcff40000",
  	"0x5aef16a226dd68071f2483e1da42598319f69b2c": "0x6c6b935b8bbd400000",
  	"0x5af46a25ac09cb73616b53b14fb42ff0a51cddb2": "0xd8d726b7177a800000",
  	"0x5af7c072b2c5acd71c76addcce535cf7f8f93585": "0x1158e460913d00000",
  	"0x5afda9405c8e9736514574da928de67456010918": "0x145b8b0239a46920000",
  	"0x5b06d1e6930c1054692b79e3dbe6ecce53966420": "0xb227f63be813c0000",
  	"0x5b25cae86dcafa2a60e7723631fc5fa49c1ad87d": "0x870c58510e85200000",
  	"0x5b287c7e734299e727626f93fb1187a60d5057fe": "0x57cd934a914cb0000",
  	"0x5b290c01967c812e4dc4c90b174c1b4015bae71e": "0x820eb348d52b90000",
  	"0x5b2b64e9c058e382a8b299224eecaa16e09c8d92": "0x8ba52e6fc45e40000",
  	"0x5b2e2f1618552eab0db98add55637c2951f1fb19": "0x28a857425466f800000",
  	"0x5b30608c678e1ac464a8994c3b33e5cdf3497112": "0x15af1d78b58c400000",
  	"0x5b333696e04cca1692e71986579c920d6b2916f9": "0x1b1ae4d6e2ef500000",
  	"0x5b430d779696a3653fc60e74fbcbacf6b9c2baf1": "0x2f6f10780d22cc00000",
  	"0x5b437365ae3a9a2ff97c68e6f90a7620188c7d19": "0x6c8754c8f30c080000",
  	"0x5b49afcd75447838f6e7ceda8d21777d4fc1c3c0": "0xd8d726b7177a800000",
  	"0x5b4c0c60f10ed2894bdb42d9dd1d210587810a0d": "0x1b1ae4d6e2ef500000",
  	"0x5b4ea16db6809b0352d4b6e81c3913f76a51bb32": "0x15af1d78b58c400000",
  	"0x5b5be0d8c67276baabd8edb30d48ea75640b8b29": "0x2cb1f55fb7be100000",
  	"0x5b5d517029321562111b43086d0b043591109a70": "0x8cf23f909c0fa00000",
  	"0x5b5d8c8eed6c85ac215661de026676823faa0a0c": "0x43c33c1937564800000",
  	"0x5b6d55f6712967405c659129f4b1de09acf2cb7b": "0xe7eeba3410b740000",
  	"0x5b70c49cc98b3df3fbe2b1597f5c1b6347a388b7": "0x34957444b840e80000",
  	"0x5b736eb18353629bde9676dadd165034ce5ecc68": "0x6acb3df27e1f880000",
  	"0x5b759fa110a31c88469f54d44ba303d57dd3e10f": "0x5b46dd2f0ea3b80000",
  	"0x5b7784caea01799ca30227827667ce207c5cbc76": "0x6c6b935b8bbd400000",
  	"0x5b78eca27fbdea6f26befba8972b295e7814364b": "0x6c6b935b8bbd400000",
  	"0x5b800bfd1b3ed4a57d875aed26d42f1a7708d72a": "0x15a82d1d5bb88e00000",
  	"0x5b85e60e2af0544f2f01c64e2032900ebd38a3c7": "0x6c6b935b8bbd400000",
  	"0x5ba2c6c35dfaec296826591904d544464aeabd5e": "0x1158e460913d00000",
  	"0x5baf6d749620803e8348af3710e5c4fbf20fc894": "0x10f4002615dfe900000",
  	"0x5bc1f95507b1018642e45cd9c0e22733b9b1a326": "0x56bc75e2d63100000",
  	"0x5bd23547477f6d09d7b2a005c5ee650c510c56d7": "0x21e19e0c9bab2400000",
  	"0x5bd24aac3612b20c609eb46779bf95698407c57c": "0x6acb3df27e1f880000",
  	"0x5bd6862d517d4de4559d4eec0a06cad05e2f946e": "0xad78ebc5ac6200000",
  	"0x5be045512a026e3f1cebfd5a7ec0cfc36f2dc16b": "0x68155a43676e00000",
  	"0x5bf9f2226e5aeacf1d80ae0a59c6e38038bc8db5": "0x14542ba12a337c00000",
  	"0x5bfafe97b1dd1d712be86d41df79895345875a87": "0x1b1ae4d6e2ef500000",
  	"0x5c0f2e51378f6b0d7bab617331580b6e39ad3ca5": "0x2086ac3510526000000",
  	"0x5c29f9e9a523c1f8669448b55c48cbd47c25e610": "0x3446a0dad04cb00000",
  	"0x5c308bac4857d33baea074f3956d3621d9fa28e1": "0x10f08eda8e555098000",
  	"0x5c312a56c784b122099b764d059c21ece95e84ca": "0x52663ccab1e1c0000",
  	"0x5c31996dcac015f9be985b611f468730ef244d90": "0xad78ebc5ac6200000",
  	"0x5c323457e187761a8276e359b7b7af3f3b6e3df6": "0x21e19e0c9bab2400000",
  	"0x5c3c1c645b917543113b3e6c1c054da1fe742b9a": "0x2b5e3af16b18800000",
  	"0x5c3d19441d196cb443662020fcad7fbb79b29e78": "0xc673ce3c40160000",
  	"0x5c3f567faff7bad1b5120022e8cbcaa82b4917b3": "0x6c6b935b8bbd400000",
  	"0x5c4368918ace6409c79eca80cdaae4391d2b624e": "0xd8d726b7177a800000",
  	"0x5c464197791c8a3da3c925436f277ab13bf2faa2": "0x1b1ae4d6e2ef5000000",
  	"0x5c4881165cb42bb82e97396c8ef44adbf173fb99": "0x5fee222041e340000",
  	"0x5c4892907a0720df6fd3413e63ff767d6b398023": "0x2cb009fd3b5790f8000",
  	"0x5c4f24e994ed8f850ea7818f471c8fac3bcf0452": "0x5d80688d9e31c00000",
  	"0x5c5419565c3aad4e714e0739328e3521c98f05cc": "0x1c9f78d2893e400000",
  	"0x5c6136e218de0a61a137b2b3962d2a6112b809d7": "0xff3dbb65ff4868000",
  	"0x5c61ab79b408dd3229f662593705d72f1e147bb8": "0x4d0243d3498cd840000",
  	"0x5c6d041da7af4487b9dc48e8e1f60766d0a56dbc": "0x4f070a003e9c740000",
  	"0x5c6f36af90ab1a656c6ec8c7d521512762bba3e1": "0x6c68ccd09b022c0000",
  	"0x5c7b9ec7a2438d1e3c7698b545b9c3fd77b7cd55": "0x3635c9adc5dea00000",
  	"0x5c936f3b9d22c403db5e730ff177d74eef42dbbf": "0x410d586a20a4c0000",
  	"0x5cb731160d2e8965670bde925d9de5510935347d": "0x22b1c8c1227a00000",
  	"0x5cb953a0e42f5030812226217fffc3ce230457e4": "0x56bc75e2d63100000",
  	"0x5cbd8daf27ddf704cdd0d909a789ba36ed4f37b2": "0xb9f65d00f63c0000",
  	"0x5cc4cba621f220637742057f6055b80dffd77e13": "0x878477b7d253b660000",
  	"0x5cc7d3066d45d27621f78bb4b339473e442a860f": "0x21e1899f0377aea0000",
  	"0x5cccf1508bfd35c20530aa642500c10dee65eaed": "0x2e141ea081ca080000",
  	"0x5cce72d068c7c3f55b1d2819545e77317cae8240": "0x692ae8897081d00000",
  	"0x5cd0e475b54421bdfc0c12ea8e082bd7a5af0a6a": "0x332ca1b67940c0000",
  	"0x5cd588a14ec648ccf64729f9167aa7bf8be6eb3d": "0x3635c9adc5dea00000",
  	"0x5cd8af60de65f24dc3ce5730ba92653022dc5963": "0x61093d7c2c6d380000",
  	"0x5cdc4708f14f40dcc15a795f7dc8cb0b7faa9e6e": "0x1d1c5f3eda20c40000",
  	"0x5ce0b6862cce9162e87e0849e387cb5df4f9118c": "0x5a87e7d7f5f6580000",
  	"0x5ce2e7ceaaa18af0f8aafa7fbad74cc89e3cd436": "0x43c33c1937564800000",
  	"0x5ce44068b8f4a3fe799e6a8311dbfdeda29dee0e": "0x6c6b935b8bbd400000",
  	"0x5cebe30b2a95f4aefda665651dc0cf7ef5758199": "0xfc936392801c0000",
  	"0x5cf18fa7c8a7c0a2b3d5efd1990f64ddc569242c": "0x3635c9adc5dea00000",
  	"0x5cf44e10540d65716423b1bcb542d21ff83a94cd": "0x21e19e0c9bab2400000",
  	"0x5cf8c03eb3e872e50f7cfd0c2f8d3b3f2cb5183a": "0xad78ebc5ac6200000",
  	"0x5cfa8d568575658ca4c1a593ac4c5d0e44c60745": "0xfc66fae3746ac0000",
  	"0x5cfa9877f719c79d9e494a08d1e41cf103fc87c9": "0xad78ebc5ac6200000",
  	"0x5d1dc3387b47b8451e55106c0cc67d6dc72b7f0b": "0x6c6b935b8bbd400000",
  	"0x5d231a70c1dfeb360abd97f616e2d10d39f3cab5": "0x15af1d78b58c400000",
  	"0x5d24bdbc1c47f0eb83d128cae48ac33c4817e91f": "0x3635c9adc5dea00000",
  	"0x5d2819e8d57821922ee445650ccaec7d40544a8d": "0xad78ebc5ac6200000",
  	"0x5d2f7f0b04ba4be161e19cb6f112ce7a5e7d7fe4": "0x1e87f85809dc00000",
  	"0x5d32f6f86e787ff78e63d78b0ef95fe6071852b8": "0x15be6174e1912e0000",
  	"0x5d39ef9ea6bdfff15d11fe91f561a6f9e31f5da5": "0x6c6b935b8bbd400000",
  	"0x5d3f3b1f7130b0bb21a0fd32396239179a25657f": "0xd3ab8ea5e8fd9e80000",
  	"0x5d5751819b4f3d26ed0c1ac571552735271dbefa": "0x3635c9adc5dea00000",
  	"0x5d5c2c1099bbeefb267e74b58880b444d94449e0": "0xdbf0bd181e2e70000",
  	"0x5d5cdbe25b2a044b7b9be383bcaa5807b06d3c6b": "0x6c6b935b8bbd400000",
  	"0x5d5d6e821c6eef96810c83c491468560ef70bfb5": "0x6c6b935b8bbd400000",
  	"0x5d68324bcb776d3ffd0bf9fea91d9f037fd6ab0f": "0x6c6b935b8bbd400000",
  	"0x5d6ae8cbd6b3393c22d16254100d0238e808147c": "0x2707e56d51a30c0000",
  	"0x5d6c5c720d66a6abca8397142e63d26818eaab54": "0x22b1c8c1227a00000",
  	"0x5d6ccf806738091042ad97a6e095fe8c36aa79c5": "0xa31062beeed700000",
  	"0x5d71799c8df3bccb7ee446df50b8312bc4eb71c5": "0xad78ebc5ac6200000",
  	"0x5d822d9b3ef4b502627407da272f67814a6becd4": "0x1158e460913d00000",
  	"0x5d83b21bd2712360436b67a597ee3378db3e7ae4": "0x6c6b935b8bbd400000",
  	"0x5d872b122e994ef27c71d7deb457bf65429eca6c": "0x1b1aded81d394108000",
  	"0x5d8d31faa864e22159cd6f5175ccecc53fa54d72": "0x5b696b70dd567100000",
  	"0x5d958a9bd189c2985f86c58a8c69a7a78806e8da": "0x228f16f861578600000",
  	"0x5da2a9a4c2c0a4a924cbe0a53ab9d0c627a1cfa0": "0x27bf38c6544df50000",
  	"0x5da4ca88935c27f55c311048840e589e04a8a049": "0x4563918244f400000",
  	"0x5da54785c9bd30575c89deb59d2041d20a39e17b": "0x6aa209f0b91d658000",
  	"0x5db69fe93e6fb6fbd450966b97238b110ad8279a": "0x878678326eac9000000",
  	"0x5db7bba1f9573f24115d8c8c62e9ce8895068e9f": "0x2b5aad72c65200000",
  	"0x5db84400570069a9573cab04b4e6b69535e202b8": "0x20dd68aaf3289100000",
  	"0x5dc36de5359450a1ec09cb0c44cf2bb42b3ae435": "0x3c946d893b33060000",
  	"0x5dc6f45fef26b06e3302313f884daf48e2746fb9": "0x1b1ae4d6e2ef500000",
  	"0x5dcdb6b87a503c6d8a3c65c2cf9a9aa883479a1e": "0x1f2bba5d84f99c00000",
  	"0x5dd112f368c0e6ceff77a9df02a5481651a02fb7": "0x93472c85c6d540000",
  	"0x5dd53ae897526b167d39f1744ef7c3da5b37a293": "0x1b1ae4d6e2ef5000000",
  	"0x5dded049a6e1f329dc4b971e722c9c1f2ade83f0": "0x3635c9adc5dea00000",
  	"0x5de598aba344378cab4431555b4f79992dc290c6": "0x487a9a304539440000",
  	"0x5de9e7d5d1b667d095dd34099c85b0421a0bc681": "0x1158e460913d00000",
  	"0x5df3277ca85936c7a0d2c0795605ad25095e7159": "0x6c6b935b8bbd400000",
  	"0x5dff811dad819ece3ba602c383fb5dc64c0a3a48": "0xa1544be879ea80000",
  	"0x5e031b0a724471d476f3bcd2eb078338bf67fbef": "0xfc936392801c0000",
  	"0x5e0785532c7723e4c0af9357d5274b73bdddddde": "0x54b41ea9bdb61dc0000",
  	"0x5e11ecf69d551d7f4f84df128046b3a13240a328": "0x1158e460913d00000",
  	"0x5e1fbd4e58e2312b3c78d7aaaafa10bf9c3189e3": "0x878678326eac9000000",
  	"0x5e32c72191b8392c55f510d8e3326e3a60501d62": "0x9513ea9de0243800000",
  	"0x5e51b8a3bb09d303ea7c86051582fd600fb3dc1a": "0x1158e460913d00000",
  	"0x5e58e255fc19870a04305ff2a04631f2ff294bb1": "0xf43fc2c04ee00000",
  	"0x5e5a441974a83d74c687ebdc633fb1a49e7b1ad7": "0xa2a15d09519be00000",
  	"0x5e65458be964ae449f71773704979766f8898761": "0x1ca7cc735b6f7c0000",
  	"0x5e67df8969101adabd91accd6bb1991274af8df2": "0x1b1ae4d6e2ef500000",
  	"0x5e6e9747e162f8b45c656e0f6cae7a84bac80e4e": "0x6c6b935b8bbd400000",
  	"0x5e731b55ced452bb3f3fe871ddc3ed7ee6510a8f": "0xa2a15d09519be00000",
  	"0x5e74ed80e9655788e1bb269752319667fe754e5a": "0x30927f74c9de00000",
  	"0x5e772e27f28800c50dda973bb33e10762e6eea20": "0x61093d7c2c6d380000",
  	"0x5e7b8c54dc57b0402062719dee7ef5e37ea35d62": "0x9bf9810fd05c840000",
  	"0x5e7f70378775589fc66a81d3f653e954f55560eb": "0x83f289181d84c80000",
  	"0x5e806e845730f8073e6cc9018ee90f5c05f909a3": "0x201e96dacceaf200000",
  	"0x5e8e4df18cf0af770978a8df8dac90931510a679": "0x6c6b935b8bbd400000",
  	"0x5e90c85877198756b0366c0e17b28e52b446505a": "0x144a4a18efeb680000",
  	"0x5e95fe5ffcf998f9f9ac0e9a81dab83ead77003d": "0x1d42c20d32797f0000",
  	"0x5ead29037a12896478b1296ab714e9cb95428c81": "0x3e043072d406e0000",
  	"0x5eb371c407406c427b3b7de271ad3c1e04269579": "0xa2a15d09519be00000",
  	"0x5ecdbaeab9106ffe5d7b519696609a05baeb85ad": "0x1158e460913d00000",
  	"0x5ed0d6338559ef44dc7a61edeb893fa5d83fa1b5": "0xbed1d0263d9f00000",
  	"0x5ed3bbc05240e0d399eb6ddfe60f62de4d9509af": "0x2914c02475f9d6d30000",
  	"0x5ed3f1ebe2ae6756b5d8dc19cad02c419aa5778b": "0x0",
  	"0x5ed56115bd6505a88273df5c56839470d24a2db7": "0x38e6591ee56668000",
  	"0x5ef8c96186b37984cbfe04c598406e3b0ac3171f": "0x1fd933494aa5fe00000",
  	"0x5efbdfe5389999633c26605a5bfc2c1bb5959393": "0x3c057c95cd9080000",
  	"0x5f13154631466dcb1353c890932a7c97e0878e90": "0x14542ba12a337c00000",
  	"0x5f167aa242bc4c189adecb3ac4a7c452cf192fcf": "0x6c6b4c4da6ddbe0000",
  	"0x5f1c8a04c90d735b8a152909aeae636fb0ce1665": "0x17b7827618c5a370000",
  	"0x5f23ba1f37a96c45bc490259538a54c28ba3b0d5": "0x410d586a20a4c00000",
  	"0x5f26cf34599bc36ea67b9e7a9f9b4330c9d542a3": "0x3635c9adc5dea00000",
  	"0x5f29c9de765dde25852af07d33f2ce468fd20982": "0x6c6b935b8bbd400000",
  	"0x5f2f07d2d697e8c567fcfdfe020f49f360be2139": "0x6c6b935b8bbd400000",
  	"0x5f321b3daaa296cadf29439f9dab062a4bffedd6": "0x47025903ea7ae0000",
  	"0x5f333a3b2310765a0d1832b9be4c0a03704c1c09": "0x3635c9adc5dea00000",
  	"0x5f344b01c7191a32d0762ac188f0ec2dd460911d": "0x3635c9adc5dea00000",
  	"0x5f363e0ab747e02d1b3b66abb69ea53c7baf523a": "0x277017338a30ae00000",
  	"0x5f375b86600c40cca8b2676b7a1a1d1644c5f52c": "0x44618d74c623f0000",
  	"0x5f3e1e6739b0c62200e00a003691d9efb238d89f": "0xa2a15d09519be00000",
  	"0x5f483ffb8f680aedf2a38f7833afdcde59b61e4b": "0x6c6b935b8bbd400000",
  	"0x5f4ace4c1cc13391e01f00b198e1f20b5f91cbf5": "0x10f0fa8b9d3811a0000",
  	"0x5f521282e9b278dc8c034c72af53ee29e5443d78": "0x161732d2f8f3ae00000",
  	"0x5f68a24c7eb4117667737b33393fb3c2148a53b6": "0x2cede918d453c0000",
  	"0x5f708eaf39d823946c51b3a3e9b7b3c003e26341": "0x62a992e53a0af00000",
  	"0x5f742e487e3ab81af2f94afdbe1b9b8f5ccc81bc": "0x75c445d41163e60000",
  	"0x5f74ed0e24ff80d9b2c4a44baa9975428cd6b935": "0xa18bcec34888100000",
  	"0x5f76f0a306269c78306b3d650dc3e9c37084db61": "0x821ab0d44149800000",
  	"0x5f77a107ab1226b3f95f10ee83aefc6c5dff3edc": "0x1b1ae4d6e2ef500000",
  	"0x5f7b3bbac16dab831a4a0fc53b0c549dc36c31ca": "0x692ae8897081d00000",
  	"0x5f93ff832774db5114c55bb4bf44ccf3b58f903f": "0x28a9c91a263458290000",
  	"0x5f9616c47b4a67f406b95a14fe6fc268396f1721": "0xad78ebc5ac6200000",
  	"0x5f981039fcf50225e2adf762752112d1cc26b6e3": "0x1b1a416a2153a50000",
  	"0x5f99dc8e49e61d57daef606acdd91b4d7007326a": "0xa2a15d09519be00000",
  	"0x5fa61f152de6123516c751242979285f796ac791": "0xb0f11972963b00000",
  	"0x5fa7bfe043886127d4011d8356a47e947963aca8": "0x62a992e53a0af00000",
  	"0x5fa8a54e68176c4fe2c01cf671c515bfbdd528a8": "0x45e155fa0110fa400000",
  	"0x5fad960f6b2c84569c9f4d47bf1985fcb2c65da6": "0x36356633ebd8ea0000",
  	"0x5fc6c11426b4a1eae7e51dd512ad1090c6f1a85b": "0x93fe5c57d710680000",
  	"0x5fcd84546896dd081db1a320bd4d8c1dd1528c4c": "0x1158e460913d00000",
  	"0x5fcda847aaf8d7fa8bca08029ca2849166aa15a3": "0x21cab81259a3bf0000",
  	"0x5fd1c3e31778276cb42ea740f5eae9c641dbc701": "0xa844a7424d9c80000",
  	"0x5fd3d6777ec2620ae83a05528ed425072d3ca8fd": "0x6c6b935b8bbd400000",
  	"0x5fd973af366aa5157c54659bcfb27cbfa5ac15d6": "0xd8d726b7177a800000",
  	"0x5fe77703808f823e6c399352108bdb2c527cb87c": "0x6a4076cf7995a00000",
  	"0x5fec49c665e64ee89dd441ee74056e1f01e92870": "0x1569b9e733474c00000",
  	"0x5ff326cd60fd136b245e29e9087a6ad3a6527f0d": "0x65ea3db75546600000",
  	"0x5ff93de6ee054cad459b2d5eb0f6870389dfcb74": "0xbed1d0263d9f00000",
  	"0x6006e36d929bf45d8f16231b126a011ae283d925": "0x98a7d9b8314c00000",
  	"0x6021e85a8814fce1e82a41abd1d3b2dad2faefe0": "0x6c6b935b8bbd400000",
  	"0x6038740ae28d66ba93b0be08482b3205a0f7a07b": "0x11216185c29f700000",
  	"0x603f2fab7afb6e017b94766069a4b43b38964923": "0x59d2db2414da990000",
  	"0x6042276df2983fe2bc4759dc1943e18fdbc34f77": "0x6acb3df27e1f880000",
  	"0x6042c644bae2b96f25f94d31f678c90dc96690db": "0x6c6b935b8bbd400000",
  	"0x604cdf18628dbfa8329194d478dd5201eecc4be7": "0x13f306a2409fc0000",
  	"0x604e9477ebf4727c745bcabbedcb6ccf29994022": "0x36369ed7747d260000",
  	"0x60676d1fa21fca052297e24bf96389c5b12a70d7": "0xd177c5a7a68d60000",
  	"0x60676e92d18b000509c61de540e6c5ddb676d509": "0x410d586a20a4c00000",
  	"0x606f177121f7855c21a5062330c8762264a97b31": "0xd8d726b7177a800000",
  	"0x60864236930d04d8402b5dcbeb807f3caf611ea2": "0xd8d726b7177a800000",
  	"0x60ab71cd26ea6d6e59a7a0f627ee079c885ebbf6": "0x1731790534df20000",
  	"0x60af0ee118443c9b37d2fead77f5e521debe1573": "0x678a932062e4180000",
  	"0x60b358cb3dbefa37f47df2d7365840da8e3bc98c": "0x1158e460913d00000",
  	"0x60b8d6b73b79534fb08bb8cbcefac7f393c57bfe": "0x5f68e8131ecf800000",
  	"0x60be6f953f2a4d25b6256ffd2423ac1438252e4e": "0x821ab0d4414980000",
  	"0x60c3714fdddb634659e4a2b1ea42c4728cc7b8ba": "0xb98bc829a6f90000",
  	"0x60cc3d445ebdf76a7d7ae571c6971dff68cc8585": "0x3635c9adc5dea00000",
  	"0x60d5667140d12614b21c8e5e8a33082e32dfcf23": "0x43c33c1937564800000",
  	"0x60de22a1507432a47b01cc68c52a0bf8a2e0d098": "0x10910d4cdc9f60000",
  	"0x60e0bdd0a259bb9cb09d3f37e5cd8b9daceabf8a": "0x4a4491bd6dcd280000",
  	"0x60e3cc43bcdb026aad759c7066f555bbf2ac66f5": "0x6c6b935b8bbd400000",
  	"0x61042b80fd6095d1b87be2f00f109fabafd157a6": "0x56bc75e2d63100000",
  	"0x6107d71dd6d0eefb11d4c916404cb98c753e117d": "0x6c6b935b8bbd400000",
  	"0x610fd6ee4eebab10a8c55d0b4bd2e7d6ef817156": "0x1159561065d5d0000",
  	"0x6114b0eae5576903f80bfb98842d24ed92237f1e": "0x56bc75e2d63100000",
  	"0x6121af398a5b2da69f65c6381aec88ce9cc6441f": "0x22b1c8c1227a000000",
  	"0x612667f172135b950b2cd1de10afdece6857b873": "0x3635c9adc5dea00000",
  	"0x612ced8dc0dc9e899ee46f7962333315f3f55e44": "0x125e35f9cd3d9b0000",
  	"0x6134d942f037f2cc3d424a230c603d67abd3edf7": "0x6c6b935b8bbd400000",
  	"0x613ac53be565d46536b820715b9b8d3ae68a4b95": "0xcbd47b6eaa8cc00000",
  	"0x613fab44b16bbe554d44afd178ab1d02f37aeaa5": "0x6c6b935b8bbd400000",
  	"0x614e8bef3dd2c59b59a4145674401018351884ea": "0x1158e460913d00000",
  	"0x61518464fdd8b73c1bb6ac6db600654938dbf17a": "0xad78ebc5ac6200000",
  	"0x61547d376e5369bcf978fc162c3c56ae453547e8": "0xad78ebc5ac6200000",
  	"0x6158e107c5eb54cb7604e0cd8dc1e07500d91c3c": "0x2b5e3af16b1880000",
  	"0x615a6f36777f40d6617eb5819896186983fd3731": "0x14061b9d77a5e980000",
  	"0x615f82365c5101f071e7d2cb6af14f7aad2c16c6": "0x1158e460913d00000",
  	"0x6170dd0687bd55ca88b87adef51cfdc55c4dd458": "0x6cb32f5c34fe440000",
  	"0x61733947fab820dbd351efd67855ea0e881373a0": "0x1158e460913d00000",
  	"0x6179979907fe7f037e4c38029d60bcbab832b3d6": "0x57473d05dabae80000",
  	"0x617f20894fa70e94a86a49cd74e03238f64d3cd9": "0x10f0dbae61009528000",
  	"0x617ff2cc803e31c9082233b825d025be3f7b1056": "0x6acb3df27e1f880000",
  	"0x6191ddc9b64a8e0890b4323709d7a07c48b92a64": "0x2a034919dfbfbc0000",
  	"0x6196c3d3c0908d254366b7bca55745222d9d4db1": "0xd8d726b7177a800000",
  	"0x619f171445d42b02e2e07004ad8afe694fa53d6a": "0x1158e460913d00000",
  	"0x61adf5929a5e2981684ea243baa01f7d1f5e148a": "0x5fabf6c984f230000",
  	"0x61b1b8c012cd4c78f698e470f90256e6a30f48dd": "0xad78ebc5ac6200000",
  	"0x61b3df2e9e9fd968131f1e88f0a0eb5bd765464d": "0xd8d726b7177a800000",
  	"0x61b902c5a673885826820d1fe14549e4865fbdc2": "0x1224efed2ae1918000",
  	"0x61b905de663fc17386523b3a28e2f7d037a655cd": "0x1b1ae4d6e2ef500000",
  	"0x61ba87c77e9b596de7ba0e326fddfeec2163ef66": "0xad78ebc5ac6200000",
  	"0x61bf84d5ab026f58c873f86ff0dfca82b55733ae": "0x6c6b935b8bbd400000",
  	"0x61c4ee7c864c4d6b5e37ea1331c203739e826b2f": "0x1a1353b382a918000",
  	"0x61c830f1654718f075ccaba316faacb85b7d120b": "0x15af1d78b58c400000",
  	"0x61c8f1fa43bf846999ecf47b2b324dfb6b63fe3a": "0x2b5e3af16b18800000",
  	"0x61c9dce8b2981cb40e98b0402bc3eb28348f03ac": "0xaacacd9b9e22b0000",
  	"0x61cea71fa464d62a07063f920b0cc917539733d8": "0x5a87e7d7f5f6580000",
  	"0x61d101a033ee0e2ebb3100ede766df1ad0244954": "0x1b1ae4d6e2ef500000",
  	"0x61ed5596c697207f3d55b2a51aa7d50f07fa09e8": "0x6c6b935b8bbd400000",
  	"0x61ff8e67b34d9ee6f78eb36ffea1b9f7c15787af": "0x58e7926ee858a00000",
  	"0x6205c2d5647470848a3840f3887e9b015d34755c": "0x6194049f30f7200000",
  	"0x6228ade95e8bb17d1ae23bfb0518414d497e0eb8": "0x15af1d78b58c400000",
  	"0x6229dcc203b1edccfdf06e87910c452a1f4d7a72": "0x6e1d41a8f9ec3500000",
  	"0x622be4b45495fcd93143efc412d699d6cdc23dc5": "0xf015f25736420000",
  	"0x62331df2a3cbee3520e911dea9f73e905f892505": "0x6c6b935b8bbd400000",
  	"0x625644c95a873ef8c06cdb9e9f6d8d7680043d62": "0x6194049f30f7200000",
  	"0x6265b2e7730f36b776b52d0c9d02ada55d8e3cb6": "0x3635c9adc5dea00000",
  	"0x62680a15f8ccb8bdc02f7360c25ad8cfb57b8ccd": "0x3635c9adc5dea00000",
  	"0x6294eae6e420a3d5600a39c4141f838ff8e7cc48": "0xa030dcebbd2f4c0000",
  	"0x62971bf2634cee0be3c9890f51a56099dbb9519b": "0x238fd42c5cf0400000",
  	"0x629be7ab126a5398edd6da9f18447e78c692a4fd": "0x6c6b935b8bbd400000",
  	"0x62b4a9226e61683c72c183254690daf511b4117a": "0xe18398e7601900000",
  	"0x62b9081e7710345e38e02e16449ace1b85bcfc4e": "0x3154c9729d05780000",
  	"0x62c37c52b97f4b040b1aa391d6dec152893c4707": "0x3635c9adc5dea00000",
  	"0x62c9b271ffd5b770a5eee4edc9787b5cdc709714": "0x6c6b935b8bbd400000",
  	"0x62d5cc7117e18500ac2f9e3c26c86b0a94b0de15": "0x5b12aefafa8040000",
  	"0x62dc72729024375fc37cbb9c7c2393d10233330f": "0x6c6b935b8bbd400000",
  	"0x62e6b2f5eb94fa7a43831fc87e254a3fe3bf8f89": "0xd8d726b7177a80000",
  	"0x62f2e5ccecd52cc4b95e0597df27cc079715608c": "0x7c0860e5a80dc0000",
  	"0x62fb8bd1f0e66b90533e071e6cbe6111fef0bc63": "0x3ba1910bf341b000000",
  	"0x630a913a9031c9492abd4c41dbb15054cfec4416": "0x13458db67af35e00000",
  	"0x630c5273126d517ce67101811cab16b8534cf9a8": "0x1feccc62573bbd38000",
  	"0x631030a5b27b07288a45696f189e1114f12a81c0": "0x1b1a7a420ba00d0000",
  	"0x6310b020fd98044957995092090f17f04e52cdfd": "0x55a6e79ccd1d300000",
  	"0x632b9149d70178a7333634275e82d5953f27967b": "0x25f273933db5700000",
  	"0x632cecb10cfcf38ec986b43b8770adece9200221": "0x1158e460913d00000",
  	"0x6331028cbb5a21485bc51b565142993bdb2582a9": "0x1cfdd7468216e80000",
  	"0x63334fcf1745840e4b094a3bb40bb76f9604c04c": "0xd7a5d703a717e80000",
  	"0x63340a57716bfa63eb6cd133721202575bf796f0": "0xb61e0a20c12718000",
  	"0x634efc24371107b4cbf03f79a93dfd93e431d5fd": "0x423582e08edc5c8000",
  	"0x635c00fdf035bca15fa3610df3384e0fb79068b1": "0x1e7e4171bf4d3a00000",
  	"0x63612e7862c27b587cfb6daf9912cb051f030a9f": "0x25b19d4bfe8ed0000",
  	"0x63666755bd41b5986997783c13043008242b3cb5": "0x1b1ae4d6e2ef500000",
  	"0x637be71b3aa815ff453d5642f73074450b64c82a": "0x6c6b935b8bbd400000",
  	"0x637d67d87f586f0a5a479e20ee13ea310a10b647": "0xa3a5926afa1e7300000",
  	"0x637f5869d6e4695f0eb9e27311c4878aff333380": "0x6ac04e68aaec860000",
  	"0x63977cad7d0dcdc52b9ac9f2ffa136e8642882b8": "0x410d586a20a4c0000",
  	"0x63a61dc30a8e3b30a763c4213c801cbf98738178": "0x3635c9adc5dea00000",
  	"0x63ac545c991243fa18aec41d4f6f598e555015dc": "0x2086ac351052600000",
  	"0x63b9754d75d12d384039ec69063c0be210d5e0e3": "0x920b860cc8ecfd8000",
  	"0x63bb664f9117037628594da7e3c5089fd618b5b5": "0x1158e460913d00000",
  	"0x63c2a3d235e5eeabd0d4a6afdb89d94627396495": "0x434ef05b9d84820000",
  	"0x63c8dfde0b8e01dadc2e748c824cc0369df090b3": "0xd255d112e103a00000",
  	"0x63d55ad99b9137fd1b20cc2b4f03d42cbaddf334": "0x15af1d78b58c400000",
  	"0x63d80048877596e0c28489e650cd4ac180096a49": "0xf2dc7d47f15600000",
  	"0x63e414603e80d4e5a0f5c18774204642258208e4": "0x10f0cf064dd59200000",
  	"0x63e88e2e539ffb450386b4e46789b223f5476c45": "0x155170a778e25d00000",
  	"0x63ef2fbc3daf5edaf4a295629ccf31bcdf4038e5": "0x4f2591f896a6500000",
  	"0x63f0e5a752f79f67124eed633ad3fd2705a397d4": "0xd5967be4fc3f100000",
  	"0x63f5b53d79bf2e411489526530223845fac6f601": "0x65a4da25d3016c00000",
  	"0x63fc93001305adfbc9b85d29d9291a05f8f1410b": "0x3635c9adc5dea00000",
  	"0x63fe6bcc4b8a9850abbe75803730c932251f145b": "0xfc936392801c0000",
  	"0x6403d062549690c8e8b63eae41d6c109476e2588": "0x6c6b935b8bbd400000",
  	"0x64042ba68b12d4c151651ca2813b7352bd56f08e": "0x2086ac351052600000",
  	"0x6405dd13e93abcff377e700e3c1a0086eca27d29": "0xfc936392801c0000",
  	"0x640aba6de984d94517377803705eaea7095f4a11": "0x21e19e0c9bab2400000",
  	"0x640bf87415e0cf407301e5599a68366da09bbac8": "0x1abc9f416098158000",
  	"0x6420f8bcc8164a6152a99d6b99693005ccf7e053": "0x36356633ebd8ea0000",
  	"0x64241a7844290e0ab855f1d4aa75b55345032224": "0x56bc75e2d631000000",
  	"0x64264aedd52dcae918a012fbcd0c030ee6f71821": "0x3635c9adc5dea00000",
  	"0x64370e87202645125a35b207af1231fb6072f9a7": "0xad78ebc5ac6200000",
  	"0x643d9aeed4b180947ed2b9207cce4c3ddc55e1f7": "0xad78ebc5ac6200000",
  	"0x6443b8ae639de91cf73c5ae763eeeed3ddbb9253": "0x6c6b935b8bbd400000",
  	"0x64457fa33b0832506c4f7d1180dce48f46f3e0ff": "0x6c6b935b8bbd400000",
  	"0x64464a6805b462412a901d2db8174b06c22deea6": "0x19c846a029c7c80000",
  	"0x644ba6c61082e989109f5c11d4b40e991660d403": "0xd8d726b7177a800000",
  	"0x64628c6fb8ec743adbd87ce5e018d531d9210437": "0x1731790534df20000",
  	"0x6463f715d594a1a4ace4bb9c3b288a74decf294d": "0x6acb3df27e1f880000",
  	"0x646628a53c2c4193da88359ce718dadd92b7a48d": "0xad8006c2f5ef00000",
  	"0x64672da3ab052821a0243d1ce4b6e0a36517b8eb": "0xad78ebc5ac6200000",
  	"0x646afba71d849e80c0ed59cac519b278e7f7abe4": "0x3635c9adc5dea00000",
  	"0x646e043d0597a664948fbb0dc15475a3a4f3a6ed": "0x1158e460913d00000",
  	"0x6470a4f92ec6b0fccd01234fa59023e9ff1f3aac": "0xa2a15d09519be00000",
  	"0x647b85044df2cf0b4ed4882e88819fe22ae5f793": "0x36363b5d9a77700000",
  	"0x6485470e61db110aebdbafd536769e3c599cc908": "0x2086ac351052600000",
  	"0x648f5bd2a2ae8902db37847d1cb0db9390b06248": "0x1a535ecf0760a048000",
  	"0x649a2b9879cd8fb736e6703b0c7747849796f10f": "0x18ee22da01ad34f0000",
  	"0x649a85b93653075fa6562c409a565d087ba3e1ba": "0x6c6b935b8bbd400000",
  	"0x64adcceec53dd9d9dd15c8cc1a9e736de4241d2c": "0x30927f74c9de00000",
  	"0x64cf0935bf19d2cebbecd8780d27d2e2b2c34166": "0x6acb3df27e1f880000",
  	"0x64d80c3b8ba68282290b75e65d8978a15a87782c": "0x6acb3df27e1f880000",
  	"0x64dba2d6615b8bd7571836dc75bc79d314f5ecee": "0x21e19e0c9bab2400000",
  	"0x64e0217a5b38aa40583625967fa9883690388b6f": "0xad78ebc5ac6200000",
  	"0x64e02abb016cc23a2934f6bcddb681905021d563": "0x3635c9adc5dea00000",
  	"0x64e03ef070a54703b7184e48276c5c0077ef4b34": "0x1158e460913d000000",
  	"0x64e2de21200b1899c3a0c0653b5040136d0dc842": "0x43c33c1937564800000",
  	"0x64ec8a5b743f3479e707dae9ee20ddaa4f40f1d9": "0xad78ebc5ac6200000",
  	"0x6503860b191008c15583bfc88158099301762828": "0x3635c9adc5dea00000",
  	"0x65053191319e067a25e6361d47f37f6318f83419": "0x155bd9307f9fe80000",
  	"0x65093b239bbfba23c7775ca7da5a8648a9f54cf7": "0x15af1d78b58c400000",
  	"0x6509eeb1347e842ffb413e37155e2cbc738273fd": "0x6c6b935b8bbd400000",
  	"0x650b425555e4e4c51718146836a2c1ee77a5b421": "0x43c33c1937564800000",
  	"0x650cf67db060cce17568d5f2a423687c49647609": "0x56bc75e2d63100000",
  	"0x6510df42a599bcb0a519cca961b488759a6f6777": "0x6c6b935b8bbd400000",
  	"0x653675b842d7d8b461f722b4117cb81dac8e639d": "0x1ae361fc1451c0000",
  	"0x654b7e808799a83d7287c67706f2abf49a496404": "0x6acb3df27e1f880000",
  	"0x654f524847b3a6acc0d3d5f1f362b603edf65f96": "0x1b1ae4d6e2ef5000000",
  	"0x655934da8e744eaa3de34dbbc0894c4eda0b61f2": "0xad78ebc5ac6200000",
  	"0x655d5cd7489629e2413c2105b5a172d933c27af8": "0xdb03186cd840a60000",
  	"0x656018584130db83ab0591a8128d9381666a8d0e": "0x3779f912019fc0000",
  	"0x6560941328ff587cbc56c38c78238a7bb5f442f6": "0x2861906b59c47a0000",
  	"0x656579daedd29370d9b737ee3f5cd9d84bc2b342": "0x4d853c8f8908980000",
  	"0x657473774f63ac3d6279fd0743d5790c4f161503": "0xad78ebc5ac6200000",
  	"0x6580b1bc94390f04b397bd73e95d96ef11eaf3a8": "0x1158e460913d00000",
  	"0x65849be1af20100eb8a3ba5a5be4d3ae8db5a70e": "0x15af1d78b58c400000",
  	"0x659c0a72c767a3a65ced0e1ca885a4c51fd9b779": "0x6c6b935b8bbd400000",
  	"0x65a52141f56bef98991724c6e7053381da8b5925": "0x3429c335d57fe0000",
  	"0x65a9dad42e1632ba3e4e49623fab62a17e4d3611": "0x50c4cb2a10c600000",
  	"0x65af8d8b5b1d1eedfa77bcbc96c1b133f83306df": "0x55005f0c614480000",
  	"0x65af9087e05167715497c9a5a749189489004def": "0x2d43f3ebfafb2c0000",
  	"0x65b42faecc1edfb14283ca979af545f63b30e60c": "0xfc936392801c0000",
  	"0x65d33eb39cda6453b19e61c1fe4db93170ef9d34": "0xb98bc829a6f90000",
  	"0x65d8dd4e251cbc021f05b010f2d5dc520c3872e0": "0x2d43579a36a90e0000",
  	"0x65ea26eabbe2f64ccccfe06829c25d4637520225": "0x25f273933db5700000",
  	"0x65ea67ad3fb56ad5fb94387dd38eb383001d7c68": "0x56bc75e2d63100000",
  	"0x65ebaed27edb9dcc1957aee5f452ac2105a65c0e": "0x937dfadae25e29b8000",
  	"0x65ee20b06d9ad589a7e7ce04b9f5f795f402aece": "0x6c6b935b8bbd400000",
  	"0x65f534346d2ffb787fa9cf185d745ba42986bd6e": "0x1b1ae4d6e2ef500000",
  	"0x65f5870f26bce089677dfc23b5001ee492483428": "0x112b1f155aa32a30000",
  	"0x65fd02d704a12a4dace9471b0645f962a89671c8": "0x18d1ce6e427cd8000",
  	"0x65ff874fafce4da318d6c93d57e2c38a0d73e820": "0x3638021cecdab00000",
  	"0x660557bb43f4be3a1b8b85e7df7b3c5bcd548057": "0x14542ba12a337c00000",
  	"0x66082c75a8de31a53913bbd44de3a0374f7faa41": "0x4f2591f896a6500000",
  	"0x6611ce59a98b072ae959dc49ad511daaaaa19d6b": "0xad78ebc5ac6200000",
  	"0x66201bd227ae6dc6bdfed5fbde811fecfe5e9dd9": "0x203e9e8492788c0000",
  	"0x662334814724935b7931ddca6100e00d467727cd": "0x2288269d0783d40000",
  	"0x66274fea82cd30b6c29b23350e4f4f3d310a5899": "0x70370550ab82980000",
  	"0x662cfa038fab37a01745a364e1b98127c503746d": "0xd5967be4fc3f100000",
  	"0x6635b46f711d2da6f0e16370cd8ee43efb2c2d52": "0x6c6b935b8bbd400000",
  	"0x663604b0503046e624cd26a8b6fb4742dce02a6f": "0x38b9b797ef68c0000",
  	"0x6636d7ac637a48f61d38b14cfd4865d36d142805": "0x1b1ae4d6e2ef500000",
  	"0x6640ccf053555c130ae2b656647ea6e31637b9ab": "0x6acb3df27e1f880000",
  	"0x66424bd8785b8cb461102a900283c35dfa07ef6a": "0x22e2db26666fc8000",
  	"0x664cd67dccc9ac8228b45c55db8d76550b659cdc": "0x155bd9307f9fe80000",
  	"0x664e43119870af107a448db1278b044838ffcdaf": "0x15af1d78b58c400000",
  	"0x6651736fb59b91fee9c93aa0bd6ea2f7b2506180": "0x1b1ae4d6e2ef500000",
  	"0x665b000f0b772750cc3c217a5ef429a92bf1ccbb": "0xd8d726b7177a800000",
  	"0x66662006015c1f8e3ccfcaebc8ee6807ee196303": "0x1b1b3a1ac261ec0000",
  	"0x666746fb93d1935c5a3c684e725010c4fad0b1d8": "0x1158e460913d00000",
  	"0x666b4f37d55d63b7d056b615bb74c96b3b01991a": "0xd8d726b7177a800000",
  	"0x66719c0682b2ac7f9e27abebec7edf8decf0ae0d": "0x1158e460913d00000",
  	"0x6671b182c9f741a0cd3c356c73c23126d4f9e6f4": "0xad78ebc5ac6200000",
  	"0x6679aeecd87a57a73f3356811d2cf49d0c4d96dc": "0x2086ac351052600000",
  	"0x667b61c03bb937a9f5d0fc5a09f1ea3363c77035": "0xe664992288f2280000",
  	"0x6685fd2e2544702c360b8bb9ee78f130dad16da5": "0x6c6b935b8bbd400000",
  	"0x668b6ba8ab08eace39c502ef672bd5ccb6a67a20": "0x697d95d4201333c0000",
  	"0x66925de3e43f4b41bf9dadde27d5488ef569ea0d": "0x222c8eb3ff6640000",
  	"0x66b0c100c49149935d14c0dc202cce907cea1a3d": "0x6acb3df27e1f880000",
  	"0x66b1a63da4dcd9f81fe54f5e3fcb4055ef7ec54f": "0xaeb272adf9cfa0000",
  	"0x66b39837cb3cac8a802afe3f12a258bbca62dacd": "0x15af1d78b58c400000",
  	"0x66c8331efe7198e98b2d32b938688e3241d0e24f": "0x2098051970e39d00000",
  	"0x66cc8ab23c00d1b82acd7d73f38c99e0d05a4fa6": "0x56bc75e2d63100000",
  	"0x66dcc5fb4ee7fee046e141819aa968799d644491": "0x487a9a304539440000",
  	"0x66e09427c1e63deed7e12b8c55a6a19320ef4b6a": "0x93739534d28680000",
  	"0x66ec16ee9caab411c55a6629e318de6ee216491d": "0x2ee449550898e40000",
  	"0x66f50406eb1b11a946cab45927cca37470e5a208": "0x6c6b935b8bbd400000",
  	"0x66fdc9fee351fa1538eb0d87d819fcf09e7c106a": "0x14627b5d93781b20000",
  	"0x67048f3a12a4dd1f626c64264cb1d7971de2ca38": "0x9c2007651b2500000",
  	"0x6704f169e0d0b36b57bbc39f3c45437b5ee3d28d": "0x155bd9307f9fe80000",
  	"0x671015b97670b10d5e583f3d62a61c1c79c5143f": "0x15af1d78b58c400000",
  	"0x6710c2c03c65992b2e774be52d3ab4a6ba217ef7": "0x274d656ac90e3400000",
  	"0x671110d96aaff11523cc546bf9940eedffb2faf7": "0xd8d726b7177a800000",
  	"0x6715c14035fb57bb3d667f7b707498c41074b855": "0x25f273933db5700000",
  	"0x671bbca099ff899bab07ea1cf86965c3054c8960": "0x2b5e3af16b1880000",
  	"0x6727daf5b9d68efcab489fedec96d7f7325dd423": "0x6c6b935b8bbd400000",
  	"0x672cbca8440a8577097b19aff593a2ad9d28a756": "0x4563918244f400000",
  	"0x672ec42faa8cd69aaa71b32cc7b404881d52ff91": "0x21e19e0c9bab2400000",
  	"0x672fa0a019088db3166f6119438d07a99f8ba224": "0x2d4ca05e2b43ca80000",
  	"0x673144f0ec142e770f4834fee0ee311832f3087b": "0x1b1b6bd7af64c70000",
  	"0x67350b5331926f5e28f3c1e986f96443809c8b8c": "0x1314fb370629800000",
  	"0x673706b1b0e4dc7a949a7a796258a5b83bb5aa83": "0x368c8623a8b4d100000",
  	"0x6742a2cfce8d79a2c4a51b77747498912245cd6a": "0xdfd5b80b7e4680000",
  	"0x674adb21df4c98c7a347ac4c3c24266757dd7039": "0x6c6b935b8bbd400000",
  	"0x67518e5d02b205180f0463a32004471f753c523e": "0x6b918aac494b168000",
  	"0x675d5caa609bf70a18aca580465d8fb7310d1bbb": "0x43c33c1937564800000",
  	"0x67632046dcb25a54936928a96f423f3320cbed92": "0x6c6b935b8bbd400000",
  	"0x6765df25280e8e4f38d4b1cf446fc5d7eb659e34": "0x56bc75e2d63100000",
  	"0x6776e133d9dc354c12a951087b639650f539a433": "0x68155a43676e00000",
  	"0x6785513cf732e47e87670770b5419be10cd1fc74": "0x6c6b935b8bbd400000",
  	"0x679437eacf437878dc293d48a39c87b7421a216c": "0x37f81821db2680000",
  	"0x679b9a109930517e8999099ccf2a914c4c8dd934": "0x340aad21b3b700000",
  	"0x67a80e0190721f94390d6802729dd12c31a895ad": "0x6c6b1375bc91560000",
  	"0x67b8a6e90fdf0a1cac441793301e8750a9fa7957": "0x30849ebe16369c0000",
  	"0x67bc85e87dc34c4e80aafa066ba8d29dbb8e438e": "0x15d1cf4176aeba0000",
  	"0x67c926093e9b8927933810d98222d62e2b8206bb": "0x678a932062e4180000",
  	"0x67cfda6e70bf7657d39059b59790e5145afdbe61": "0x23050d095866580000",
  	"0x67d682a282ef73fb8d6e9071e2614f47ab1d0f5e": "0x3635c9adc5dea00000",
  	"0x67d6a8aa1bf8d6eaf7384e993dfdf10f0af68a61": "0xabcbb5718974b8000",
  	"0x67da922effa472a6b124e84ea8f86b24e0f515aa": "0x1158e460913d00000",
  	"0x67df242d240dd4b8071d72f8fcf35bb3809d71e8": "0xd8d726b7177a800000",
  	"0x67ee406ea4a7ae6a3a381eb4edd2f09f174b4928": "0x3829635f0968b00000",
  	"0x67f2bb78b8d3e11f7c458a10b5c8e0a1d374467d": "0x61093d7c2c6d380000",
  	"0x67fc527dce1785f0fb8bc7e518b1c669f7ecdfb5": "0xd02ab486cedc00000",
  	"0x68027d19558ed7339a08aee8de3559be063ec2ea": "0x6c6b935b8bbd400000",
  	"0x680640838bd07a447b168d6d923b90cf6c43cdca": "0x5dc892aa1131c80000",
  	"0x6807ddc88db489b033e6b2f9a81553571ab3c805": "0x19f8e7559924c0000",
  	"0x680d5911ed8dd9eec45c060c223f89a7f620bbd5": "0x43c33c1937564800000",
  	"0x6811b54cd19663b11b94da1de2448285cd9f68d9": "0x3ba1910bf341b00000",
  	"0x68190ca885da4231874c1cfb42b1580a21737f38": "0xcf152640c5c8300000",
  	"0x682897bc4f8e89029120fcffb787c01a93e64184": "0x21e19e0c9bab2400000",
  	"0x68295e8ea5afd9093fc0a465d157922b5d2ae234": "0x1154e53217ddb0000",
  	"0x682e96276f518d31d7e56e30dfb009c1218201bd": "0x1158e460913d00000",
  	"0x6835c8e8b74a2ca2ae3f4a8d0f6b954a3e2a8392": "0x3429c335d57fe0000",
  	"0x683633010a88686bea5a98ea53e87997cbf73e69": "0x56b394263a40c0000",
  	"0x683dba36f7e94f40ea6aea0d79b8f521de55076e": "0x796e3ea3f8ab00000",
  	"0x68419c6dd2d3ce6fcbb3c73e2fa079f06051bde6": "0x6acb3df27e1f880000",
  	"0x68473b7a7d965904bedba556dfbc17136cd5d434": "0x56bc75e2d63100000",
  	"0x6847825bdee8240e28042c83cad642f286a3bddc": "0x5150ae84a8cdf00000",
  	"0x684a44c069339d08e19a75668bdba303be855332": "0xed2b525841adfc00000",
  	"0x68531f4dda808f5320767a03113428ca0ce2f389": "0x10d3aa536e2940000",
  	"0x687927e3048bb5162ae7c15cf76bd124f9497b9e": "0x6c6b935b8bbd400000",
  	"0x68809af5d532a11c1a4d6e32aac75c4c52b08ead": "0x21e19e0c9bab2400000",
  	"0x6886ada7bbb0617bda842191c68c922ea3a8ac82": "0x3ee23bde0e7d200000",
  	"0x68883e152e5660fee59626e7e3b4f05110e6222f": "0xb94633be975a62a0000",
  	"0x688a569e965524eb1d0ac3d3733eab909fb3d61e": "0x478eae0e571ba00000",
  	"0x688eb3853bbcc50ecfee0fa87f0ab693cabdef02": "0x6b10a18400647c00000",
  	"0x68a7425fe09eb28cf86eb1793e41b211e57bd68d": "0x243d4d18229ca20000",
  	"0x68a86c402388fddc59028fec7021e98cbf830eac": "0x10910d4cdc9f60000",
  	"0x68acdaa9fb17d3c309911a77b05f5391fa034ee9": "0x1e52e336cde22180000",
  	"0x68addf019d6b9cab70acb13f0b3117999f062e12": "0x2b51212e6b7c88000",
  	"0x68b31836a30a016ada157b638ac15da73f18cfde": "0x168d28e3f00280000",
  	"0x68b6854788a7c6496cdbf5f84b9ec5ef392b78bb": "0x42bf06b78ed3b500000",
  	"0x68c08490c89bf0d6b6f320b1aca95c8312c00608": "0xd8d726b7177a800000",
  	"0x68c7d1711b011a33f16f1f55b5c902cce970bdd7": "0x83d6c7aab63600000",
  	"0x68c8791dc342c373769ea61fb7b510f251d32088": "0x3635c9adc5dea00000",
  	"0x68df947c495bebaeb8e889b3f953d533874bf106": "0x1d9945ab2b03480000",
  	"0x68e8022740f4af29eb48db32bcecddfd148d3de3": "0x3635c9adc5dea00000",
  	"0x68ec79d5be7155716c40941c79d78d17de9ef803": "0x1b233877b5208c0000",
  	"0x68eec1e288ac31b6eaba7e1fbd4f04ad579a6b5d": "0x6c6b935b8bbd400000",
  	"0x68f525921dc11c329b754fbf3e529fc723c834cd": "0x57473d05dabae80000",
  	"0x68f719ae342bd7fef18a05cbb02f705ad38ed5b2": "0x38ebad5cdc90280000",
  	"0x68f7573cd457e14c03fea43e302d30347c10705c": "0x10f0cf064dd59200000",
  	"0x68f8f45155e98c5029a4ebc5b527a92e9fa83120": "0xf07b44b40793208000",
  	"0x68fe1357218d095849cd579842c4aa02ff888d93": "0x6c6b935b8bbd400000",
  	"0x690228e4bb12a8d4b5e0a797b0c5cf2a7509131e": "0x65ea3db75546600000",
  	"0x690594d306613cd3e2fd24bca9994ad98a3d73f8": "0x6c6b935b8bbd400000",
  	"0x69073269729e6414b26ec8dc0fd935c73b579f1e": "0x65a4da25d3016c00000",
  	"0x6919dd5e5dfb1afa404703b9faea8cee35d00d70": "0x14061b9d77a5e980000",
  	"0x693492a5c51396a482881669ccf6d8d779f00951": "0x12bf50503ae3038000",
  	"0x693d83be09459ef8390b2e30d7f7c28de4b4284e": "0x6c6b935b8bbd400000",
  	"0x69517083e303d4fbb6c2114514215d69bc46a299": "0x56bc75e2d63100000",
  	"0x695550656cbf90b75d92ad9122d90d23ca68ca4d": "0x3635c9adc5dea00000",
  	"0x6958f83bb2fdfb27ce0409cd03f9c5edbf4cbedd": "0x43c33c1937564800000",
  	"0x695b0f5242753701b264a67071a2dc880836b8db": "0xe398811bec680000",
  	"0x695b4cce085856d9e1f9ff3e79942023359e5fbc": "0x10f0cf064dd59200000",
  	"0x6966063aa5de1db5c671f3dd699d5abe213ee902": "0x1b1ae4d6e2ef5000000",
  	"0x6974c8a414ceaefd3c2e4dfdbef430568d9a960b": "0x121ea68c114e510000",
  	"0x6978696d5150a9a263513f8f74c696f8b1397cab": "0x167f482d3c5b1c00000",
  	"0x69797bfb12c9bed682b91fbc593591d5e4023728": "0x21e19e0c9bab2400000",
  	"0x697f55536bf85ada51841f0287623a9f0ed09a17": "0x21e19e0c9bab2400000",
  	"0x6982fe8a867e93eb4a0bd051589399f2ec9a5292": "0x6c6b935b8bbd400000",
  	"0x698a8a6f01f9ab682f637c7969be885f6c5302bf": "0x10d3aa536e2940000",
  	"0x698ab9a2f33381e07c0c47433d0d21d6f336b127": "0x1158e460913d00000",
  	"0x6994fb3231d7e41d491a9d68d1fa4cae2cc15960": "0xd8d726b7177a800000",
  	"0x699c9ee47195511f35f862ca4c22fd35ae8ffbf4": "0x4563918244f400000",
  	"0x699fc6d68a4775573c1dcdaec830fefd50397c4e": "0x340aad21b3b700000",
  	"0x69af28b0746cac0da17084b9398c5e36bb3a0df2": "0x3677036edf0af60000",
  	"0x69b80ed90f84834afa3ff82eb964703b560977d6": "0x1731790534df20000",
  	"0x69b81d5981141ec7a7141060dfcf8f3599ffc63e": "0x10f0cf064dd59200000",
  	"0x69bcfc1d43b4ba19de7b274bdffb35139412d3d7": "0x35659ef93f0fc40000",
  	"0x69bd25ade1a3346c59c4e930db2a9d715ef0a27a": "0xd8d726b7177a800000",
  	"0x69c08d744754de709ce96e15ae0d1d395b3a2263": "0x3635c9adc5dea00000",
  	"0x69c2d835f13ee90580408e6a3283c8cca6a434a2": "0x238fd42c5cf0400000",
  	"0x69c94e07c4a9be3384d95dfa3cb9290051873b7b": "0x3cb71f51fc5580000",
  	"0x69cb3e2153998d86e5ee20c1fcd1a6baeeb2863f": "0xd8d726b7177a800000",
  	"0x69d39d510889e552a396135bfcdb06e37e387633": "0xd8d726b7177a800000",
  	"0x69d98f38a3ba3dbc01fa5c2c1427d862832f2f70": "0x152d02c7e14af6800000",
  	"0x69e2e2e704307ccc5b5ca3f164fece2ea7b2e512": "0x17b7883c06916600000",
  	"0x69ff429074cb9b6c63bc914284bce5f0c8fbf7d0": "0x1b1ae4d6e2ef500000",
  	"0x69ff8901b541763f817c5f2998f02dcfc1df2997": "0x22b1c8c1227a00000",
  	"0x6a023af57d584d845e698736f130db9db40dfa9a": "0x55b201c8900980000",
  	"0x6a04f5d53fc0f515be942b8f12a9cb7ab0f39778": "0xa9aab3459be1940000",
  	"0x6a05b21c4f17f9d73f5fb2b0cb89ff5356a6cc7e": "0x5150ae84a8cdf00000",
  	"0x6a0f056066c2d56628850273d7ecb7f8e6e9129e": "0x10f0d293cc7a5880000",
  	"0x6a13d5e32c1fd26d7e91ff6e053160a89b2c8aad": "0x2e62f20a69be40000",
  	"0x6a2e86469a5bf37cee82e88b4c3863895d28fcaf": "0x1c229266385bbc0000",
  	"0x6a3694424c7cc6b8bcd9bccaba540cc1f5df18d7": "0x6c6b935b8bbd400000",
  	"0x6a42ca971c6578d5ade295c3e7f4ad331dd3424e": "0x14542ba12a337c00000",
  	"0x6a44af96b3f032ae641beb67f4b6c83342d37c5d": "0x19274b259f6540000",
  	"0x6a4c8907b600248057b1e46354b19bdc859c991a": "0x1158e460913d00000",
  	"0x6a514e6242f6b68c137e97fea1e78eb555a7e5f7": "0x1158e460913d00000",
  	"0x6a53d41ae4a752b21abed5374649953a513de5e5": "0x6c6b935b8bbd400000",
  	"0x6a6159074ab573e0ee581f0f3df2d6a594629b74": "0x10ce1d3d8cb3180000",
  	"0x6a6337833f8f6a6bf10ca7ec21aa810ed444f4cb": "0x37bd24345ce8a40000",
  	"0x6a6353b971589f18f2955cba28abe8acce6a5761": "0xa2a15d09519be00000",
  	"0x6a63fc89abc7f36e282d80787b7b04afd6553e71": "0x8ac7230489e800000",
  	"0x6a679e378fdce6bfd97fe62f043c6f6405d79e99": "0xd8d726b7177a800000",
  	"0x6a686bf220b593deb9b7324615fb9144ded3f39d": "0x4f2591f896a6500000",
  	"0x6a6b18a45a76467e2e5d5a2ef911c3e12929857b": "0x115d3a99a9614f400000",
  	"0x6a74844d8e9cb5581c45079a2e94462a6cee8821": "0x3ab53a552dd4c90000",
  	"0x6a7b2e0d88867ff15d207c222bebf94fa6ce8397": "0xcb49b44ba602d800000",
  	"0x6a7c252042e7468a3ff773d6450bba85efa26391": "0x1b1ae4d6e2ef500000",
  	"0x6a8a4317c45faa0554ccdb482548183e295a24b9": "0x3635c9adc5dea00000",
  	"0x6a8cea2de84a8df997fd3f84e3083d93de57cda9": "0x56be03ca3e47d8000",
  	"0x6a9758743b603eea3aa0524b42889723c4153948": "0x22385a827e815500000",
  	"0x6aa5732f3b86fb8c81efbe6b5b47b563730b06c8": "0x3635c9adc5dea00000",
  	"0x6ab323ae5056ed0a453072c5abe2e42fcf5d7139": "0x2fb474098f67c00000",
  	"0x6ab5b4c41cddb829690c2fda7f20c85e629dd5d5": "0x64d4af714c32900000",
  	"0x6ac40f532dfee5118117d2ad352da77d4f6da2c8": "0x15af1d78b58c400000",
  	"0x6ac4d4be2db0d99da3faaaf7525af282051d6a90": "0x458ca58a962b28000",
  	"0x6acddca3cd2b4990e25cd65c24149d0912099e79": "0xa2a1e07c9f6c908000",
  	"0x6ad90be252d9cd464d998125fab693060ba8e429": "0xd8d726b7177a800000",
  	"0x6add932193cd38494aa3f03aeccc4b7ab7fabca2": "0x4db73254763000000",
  	"0x6ae57f27917c562a132a4d1bf7ec0ac785832926": "0x14542ba12a337c00000",
  	"0x6aeb9f74742ea491813dbbf0d6fcde1a131d4db3": "0x17e554308aa0300000",
  	"0x6af235d2bbe050e6291615b71ca5829658810142": "0xa2a15d09519be00000",
  	"0x6af6c7ee99df271ba15bf384c0b764adcb4da182": "0x36356633ebd8ea0000",
  	"0x6af8e55969682c715f48ad4fc0fbb67eb59795a3": "0x6c6b935b8bbd400000",
  	"0x6af940f63ec9b8d876272aca96fef65cdacecdea": "0xa2a15d09519be00000",
  	"0x6af9f0dfeeaebb5f64bf91ab771669bf05295553": "0x15af1d78b58c400000",
  	"0x6aff1466c2623675e3cb0e75e423d37a25e442eb": "0x5dc892aa1131c80000",
  	"0x6b0da25af267d7836c226bcae8d872d2ce52c941": "0x14542ba12a337c00000",
  	"0x6b10f8f8b3e3b60de90aa12d155f9ff5ffb22c50": "0x6c6b935b8bbd400000",
  	"0x6b17598a8ef54f797ae515ccb6517d1859bf8011": "0x56bc75e2d63100000",
  	"0x6b20c080606a79c73bd8e75b11717a4e8db3f1c3": "0x103f735803f0140000",
  	"0x6b2284440221ce16a8382de5ff0229472269deec": "0x3635c9adc5dea00000",
  	"0x6b30f1823910b86d3acb5a6afc9defb6f3a30bf8": "0xe3aeb5737240a00000",
  	"0x6b38de841fad7f53fe02da115bd86aaf662466bd": "0x5dc892aa1131c80000",
  	"0x6b4b99cb3fa9f7b74ce3a48317b1cd13090a1a7a": "0x31b327e695de20000",
  	"0x6b5ae7bf78ec75e90cb503c778ccd3b24b4f1aaf": "0x2b5e3af16b18800000",
  	"0x6b63a2dfb2bcd0caec0022b88be30c1451ea56aa": "0x2bdb6bf91f7f4c8000",
  	"0x6b6577f3909a4d6de0f411522d4570386400345c": "0x65ea3db75546600000",
  	"0x6b72a8f061cfe6996ad447d3c72c28c0c08ab3a7": "0xe78c6ac79912620000",
  	"0x6b760d4877e6a627c1c967bee451a8507ddddbab": "0x3154c9729d05780000",
  	"0x6b83bae7b565244558555bcf4ba8da2011891c17": "0x6c6b935b8bbd400000",
  	"0x6b925dd5d8ed6132ab6d0860b82c44e1a51f1fee": "0x503b203e9fba200000",
  	"0x6b94615db750656ac38c7e1cf29a9d13677f4e15": "0x28a857425466f800000",
  	"0x6b951a43274eeafc8a0903b0af2ec92bf1efc839": "0x56bc75e2d63100000",
  	"0x6b992521ec852370848ad697cc2df64e63cc06ff": "0x3635c9adc5dea00000",
  	"0x6ba8f7e25fc2d871618e24e40184199137f9f6aa": "0x15af64869a6bc20000",
  	"0x6ba9b21b35106be159d1c1c2657ac56cd29ffd44": "0xf2dc7d47f156000000",
  	"0x6baf7a2a02ae78801e8904ad7ac05108fc56cff6": "0x3635c9adc5dea00000",
  	"0x6bb2aca23fa1626d18efd6777fb97db02d8e0ae4": "0x878678326eac9000000",
  	"0x6bb4a661a33a71d424d49bb5df28622ed4dffcf4": "0x222c8eb3ff66400000",
  	"0x6bb50813146a9add42ee22038c9f1f7469d47f47": "0xada55474b81340000",
  	"0x6bbc3f358a668dd1a11f0380f3f73108426abd4a": "0xd8d726b7177a800000",
  	"0x6bbd1e719390e6b91043f8b6b9df898ea8001b34": "0x6c6c4fa6c3da588000",
  	"0x6bc85acd5928722ef5095331ee88f484b8cf8357": "0x9c2007651b2500000",
  	"0x6bd3e59f239fafe4776bb9bddd6bee83ba5d9d9f": "0x3635c9adc5dea00000",
  	"0x6bd457ade051795df3f2465c3839aed3c5dee978": "0x3634bf39ab98788000",
  	"0x6be16313643ebc91ff9bb1a2e116b854ea933a45": "0x1b1ae4d6e2ef500000",
  	"0x6be7595ea0f068489a2701ec4649158ddc43e178": "0x6c6b935b8bbd400000",
  	"0x6be9030ee6e2fbc491aca3de4022d301772b7b7d": "0x1731790534df20000",
  	"0x6bec311ad05008b4af353c958c40bd06739a3ff3": "0x377f62a0f0a62700000",
  	"0x6bf7b3c065f2c1e7c6eb092ba0d15066f393d1b8": "0x15af1d78b58c400000",
  	"0x6bf86f1e2f2b8032a95c4d7738a109d3d0ed8104": "0x62a992e53a0af00000",
  	"0x6c05e34e5ef2f42ed09deff1026cd66bcb6960bb": "0x6c6b935b8bbd400000",
  	"0x6c08a6dc0173c7342955d1d3f2c065d62f83aec7": "0x1158e460913d00000",
  	"0x6c0ae9f043c834d44271f13406593dfe094f389f": "0x52442ae133b62a8000",
  	"0x6c0cc917cbee7d7c099763f14e64df7d34e2bf09": "0xd8d726b7177a80000",
  	"0x6c0e712f405c59725fe829e9774bf4df7f4dd965": "0xc2868889ca68a440000",
  	"0x6c101205b323d77544d6dc52af37aca3cec6f7f1": "0x21e19e0c9bab2400000",
  	"0x6c15ec3520bf8ebbc820bd0ff19778375494cf9d": "0x6cb7e74867d5e60000",
  	"0x6c1ddd33c81966dc8621776071a4129482f2c65f": "0x878678326eac9000000",
  	"0x6c25327f8dcbb2f45e561e86e35d8850e53ab059": "0x3bcdf9bafef2f00000",
  	"0x6c2e9be6d4ab450fd12531f33f028c614674f197": "0xc2127af858da700000",
  	"0x6c359e58a13d4578a9338e335c67e7639f5fb4d7": "0xbd15b94fc8b280000",
  	"0x6c3d18704126aa99ee3342ce60f5d4c85f1867cd": "0x2b5e3af16b1880000",
  	"0x6c474bc66a54780066aa4f512eefa773abf919c7": "0x5188315f776b80000",
  	"0x6c4e426e8dc005dfa3516cb8a680b02eea95ae8e": "0x487a9a304539440000",
  	"0x6c52cf0895bb35e656161e4dc46ae0e96dd3e62c": "0xd8d8583fa2d52f0000",
  	"0x6c5422fb4b14e6d98b6091fdec71f1f08640419d": "0x15af1d78b58c400000",
  	"0x6c5c3a54cda7c2f118edba434ed81e6ebb11dd7a": "0xad78ebc5ac6200000",
  	"0x6c63f84556d290bfcd99e434ee9997bfd779577a": "0x6c6b935b8bbd400000",
  	"0x6c63fc85029a2654d79b2bea4de349e4524577c5": "0x23c757072b8dd00000",
  	"0x6c6564e5c9c24eaaa744c9c7c968c9e2c9f1fbae": "0x499b42a21139640000",
  	"0x6c67d6db1d03516c128b8ff234bf3d49b26d2941": "0x152d02c7e14af6800000",
  	"0x6c67e0d7b62e2a08506945a5dfe38263339f1f22": "0x6acb3df27e1f880000",
  	"0x6c6aa0d30b64721990b9504a863fa0bfb5e57da7": "0x925e06eec972b00000",
  	"0x6c714a58fff6e97d14b8a5e305eb244065688bbd": "0xd8d726b7177a800000",
  	"0x6c800d4b49ba07250460f993b8cbe00b266a2553": "0x1ab2cf7c9f87e20000",
  	"0x6c808cabb8ff5fbb6312d9c8e84af8cf12ef0875": "0xd8d8583fa2d52f0000",
  	"0x6c822029218ac8e98a260c1e064029348839875b": "0x10f97b787e1e3080000",
  	"0x6c84cba77c6db4f7f90ef13d5ee21e8cfc7f8314": "0x6c6b935b8bbd400000",
  	"0x6c8687e3417710bb8a93559021a1469e6a86bc77": "0x25b2da278d96b7b8000",
  	"0x6c882c27732cef5c7c13a686f0a2ea77555ac289": "0x152d02c7e14af6800000",
  	"0x6ca5de00817de0cedce5fd000128dede12648b3c": "0x1158e460913d00000",
  	"0x6ca6a132ce1cd288bee30ec7cfeffb85c1f50a54": "0x6c6b935b8bbd400000",
  	"0x6cb11ecb32d3ce829601310636f5a10cf7cf9b5f": "0x43fe8949c3801f50000",
  	"0x6cc1c878fa6cde8a9a0b8311247e741e4642fe6d": "0x35659ef93f0fc40000",
  	"0x6ccb03acf7f53ce87aadcc21a9932de915f89804": "0x1b1ae4d6e2ef5000000",
  	"0x6cd212aee04e013f3d2abad2a023606bfb5c6ac7": "0x6c6acc67d7b1d40000",
  	"0x6cd228dc712169307fe27ceb7477b48cfc8272e5": "0x434ea94db8a500000",
  	"0x6ce1b0f6adc47051e8ab38b39edb4186b03babcc": "0x41799794cd24cc0000",
  	"0x6ceae3733d8fa43d6cd80c1a96e8eb93109c83b7": "0x102794ad20da680000",
  	"0x6d0569e5558fc7df2766f2ba15dc8aeffc5beb75": "0xd8e6001e6c302b0000",
  	"0x6d120f0caae44fd94bcafe55e2e279ef96ba5c7a": "0xd8d726b7177a800000",
  	"0x6d1456fff0104ee844a3314737843338d24cd66c": "0x7b06ce87fdd680000",
  	"0x6d20ef9704670a500bb269b5832e859802049f01": "0x70c1cc73b00c80000",
  	"0x6d2f976734b9d0070d1883cf7acab8b3e4920fc1": "0x21e19e0c9bab2400000",
  	"0x6d39a9e98f81f769d73aad2cead276ac1387babe": "0x155bd9307f9fe80000",
  	"0x6d3b7836a2b9d899721a4d237b522385dce8dfcd": "0x3636c25e66ece70000",
  	"0x6d3f2ba856ccbb0237fa7661156b14b013f21240": "0x3635c9adc5dea00000",
  	"0x6d4008b4a888a826f248ee6a0b0dfde9f93210b9": "0x127fcb8afae20d00000",
  	"0x6d40ca27826d97731b3e86effcd7b92a4161fe89": "0x6c6b935b8bbd400000",
  	"0x6d44974a31d187eda16ddd47b9c7ec5002d61fbe": "0x32f51edbaaa3300000",
  	"0x6d4b5c05d06a20957e1748ab6df206f343f92f01": "0x21f360699bf825f8000",
  	"0x6d4cbf3d8284833ae99344303e08b4d614bfda3b": "0x28a857425466f800000",
  	"0x6d59b21cd0e2748804d9abe064eac2bef0c95f27": "0x6c6b935b8bbd400000",
  	"0x6d63d38ee8b90e0e6ed8f192eda051b2d6a58bfd": "0x1a055690d9db80000",
  	"0x6d6634b5b8a40195d949027af4828802092ceeb6": "0xa2a15d09519be00000",
  	"0x6d7d1c949511f88303808c60c5ea0640fcc02683": "0x21e19e0c9bab2400000",
  	"0x6d846dc12657e91af25008519c3e857f51707dd6": "0xf8d30bc92342f80000",
  	"0x6d9193996b194617211106d1635eb26cc4b66c6c": "0x15aa1e7e9dd51c0000",
  	"0x6d9997509882027ea947231424bedede2965d0ba": "0x6c81c7b31195e00000",
  	"0x6da0ed8f1d69339f059f2a0e02471cb44fb8c3bb": "0x32bc38bb63a8160000",
  	"0x6db72bfd43fef465ca5632b45aab7261404e13bf": "0x6c6b935b8bbd400000",
  	"0x6dbe8abfa1742806263981371bf3d35590806b6e": "0x43c33c1937564800000",
  	"0x6dc3f92baa1d21dab7382b893261a0356fa7c187": "0x5dc892aa1131c80000",
  	"0x6dc7053a718616cfc78bee6382ee51add0c70330": "0x6c6b935b8bbd400000",
  	"0x6dcc7e64fcafcbc2dc6c0e5e662cb347bffcd702": "0x43c33c1937564800000",
  	"0x6dda5f788a6c688ddf921fa3852eb6d6c6c62966": "0x22b1c8c1227a00000",
  	"0x6ddb6092779d5842ead378e21e8120fd4c6bc132": "0x6c6b935b8bbd400000",
  	"0x6ddfef639155daab0a5cb4953aa8c5afaa880453": "0x62a992e53a0af00000",
  	"0x6de02f2dd67efdb7393402fa9eaacbcf589d2e56": "0x40138b917edfb80000",
  	"0x6de4b581385cf7fc9fe8c77d131fe2ee7724c76a": "0x7d2997733dcce40000",
  	"0x6de4d15219182faf3aa2c5d4d2595ff23091a727": "0x55a6e79ccd1d300000",
  	"0x6dedf62e743f4d2c2a4b87a787f5424a7aeb393c": "0x9c2007651b2500000",
  	"0x6df24f6685a62f791ba337bf3ff67e91f3d4bc3a": "0x756b49d40a48180000",
  	"0x6df5c84f7b909aab3e61fe0ecb1b3bf260222ad2": "0xd8d726b7177a800000",
  	"0x6dff90e6dc359d2590882b1483edbcf887c0e423": "0x3635c9adc5dea00000",
  	"0x6e01e4ad569c95d007ada30d5e2db12888492294": "0xd8d726b7177a800000",
  	"0x6e073b66d1b8c66744d88096a8dd99ec7e0228da": "0xd8d726b7177a800000",
  	"0x6e0ee70612c976287d499ddfa6c0dcc12c06deea": "0x70bd5b95621460000",
  	"0x6e12b51e225b4a4372e59ad7a2a1a13ea3d3a137": "0x30046c8cc775f040000",
  	"0x6e1a046caf5b4a57f4fd4bc173622126b4e2fd86": "0x61093d7c2c6d380000",
  	"0x6e1ea4b183e252c9bb7767a006d4b43696cb8ae9": "0xff3783c85eed08000",
  	"0x6e255b700ae7138a4bacf22888a9e2c00a285eec": "0xd8d726b7177a800000",
  	"0x6e270ad529f1f0b8d9cb6d2427ec1b7e2dc64a74": "0xad78ebc5ac6200000",
  	"0x6e2eab85dc89fe29dc0aa1853247dab43a523d56": "0x4563918244f400000",
  	"0x6e3a51db743d334d2fe88224b5fe7c008e80e624": "0x5bf0ba6634f680000",
  	"0x6e4c2ab7db026939dbd3bc68384af660a61816b2": "0x90d972f32323c0000",
  	"0x6e4d2e39c8836629e5b487b1918a669aebdd9536": "0x3635c9adc5dea00000",
  	"0x6e5c2d9b1c546a86eefd5d0a5120c9e4e730190e": "0xad201a6794ff80000",
  	"0x6e60aee1a78f8eda8b424c73e353354ae67c3042": "0xbd35a48d9919e60000",
  	"0x6e64e6129f224e378c0e6e736a7e7a06c211e9ec": "0x3635c9adc5dea00000",
  	"0x6e6d5bbbb9053b89d744a27316c2a7b8c09b547d": "0x3152710a023e6d8000",
  	"0x6e72b2a1186a8e2916543b1cb36a68870ea5d197": "0xa1544be879ea80000",
  	"0x6e761eaa0f345f777b5441b73a0fa5b56b85f22d": "0x6c6b935b8bbd400000",
  	"0x6e79edd4845b076e4cd88d188b6e432dd93f35aa": "0x33c5499031720c0000",
  	"0x6e8212b722afd408a7a73ed3e2395ee6454a0330": "0x89e917994f71c0000",
  	"0x6e84876dbb95c40b6656e42ba9aea08a993b54dc": "0x3bbc60e3b6cbbe0000",
  	"0x6e84c2fd18d8095714a96817189ca21cca62bab1": "0x127b6c702621cd8000",
  	"0x6e866d032d405abdd65cf651411d803796c22311": "0x6c6b935b8bbd400000",
  	"0x6e899e59a9b41ab7ea41df7517860f2acb59f4fd": "0x43c33c1937564800000",
  	"0x6e89c51ea6de13e06cdc748b67c4410fe9bcab03": "0xd8d726b7177a800000",
  	"0x6e8a26689f7a2fdefd009cbaaa5310253450daba": "0x6f213717bad8d30000",
  	"0x6e96faeda3054302c45f58f161324c99a3eebb62": "0x1158e460913d00000",
  	"0x6eb0a5a9ae96d22cf01d8fd6483b9f38f08c2c8b": "0xd8d726b7177a800000",
  	"0x6eb3819617404058268f0c3cff3596bfe9148c1c": "0x5a87e7d7f5f6580000",
  	"0x6eb5578a6bb7c32153195b0d8020a6914852c059": "0x8bc2abf40221f4800000",
  	"0x6ebb5e6957aa821ef659b6018a393a504cae4450": "0x6c6b935b8bbd400000",
  	"0x6ebcf9957f5fc5e985add475223b04b8c14a7aed": "0x5dc892aa1131c80000",
  	"0x6ec3659571b11f889dd439bcd4d67510a25be57e": "0x6aaf7c8516d0c0000",
  	"0x6ec89b39f9f5276a553e8da30e6ec17aa47eefc7": "0x18424f5f0b1b4e0000",
  	"0x6ec96d13bdb24dc7a557293f029e02dd74b97a55": "0xd8d726b7177a800000",
  	"0x6ecaefa6fc3ee534626db02c6f85a0c395571e77": "0x2086ac351052600000",
  	"0x6ed2a12b02f8c688c7b5d3a6ea14d63687dab3b6": "0x6c6b935b8bbd400000",
  	"0x6ed884459f809dfa1016e770edaf3e9fef46fa30": "0xb852d6782093f10000",
  	"0x6edf7f5283725c953ee64317f66188af1184b033": "0x1b464311d45a6880000",
  	"0x6ee8aad7e0a065d8852d7c3b9a6e5fdc4bf50c00": "0x1158e460913d00000",
  	"0x6eefdc850e87b715c72791773c0316c3559b58a4": "0xd8d726b7177a800000",
  	"0x6ef9e8c9b6217d56769af97dbb1c8e1b8be799d2": "0x9ddc1e3b901180000",
  	"0x6efba8fb2ac5b6730729a972ec224426a287c3ad": "0xf5985fbcbe1680000",
  	"0x6efd90b535e00bbd889fda7e9c3184f879a151db": "0x22385a827e815500000",
  	"0x6f051666cb4f7bd2b1907221b829b555d7a3db74": "0x5f68e8131ecf800000",
  	"0x6f0edd23bcd85f6015f9289c28841fe04c83efeb": "0x10910d4cdc9f60000",
  	"0x6f137a71a6f197df2cbbf010dcbd3c444ef5c925": "0x6c6b935b8bbd400000",
  	"0x6f176065e88e3c6fe626267d18a088aaa4db80bc": "0xbed1d0263d9f000000",
  	"0x6f18ec767e320508195f1374500e3f2e125689ff": "0x3635c9adc5dea00000",
  	"0x6f1f4907b8f61f0c51568d692806b382f50324f5": "0x6c6b935b8bbd400000",
  	"0x6f24c9af2b763480515d1b0951bb77a540f1e3f9": "0x6acb3df27e1f880000",
  	"0x6f2576da4de283bbe8e3ee69ddd66e5e711db3f5": "0x44591d67fecc800000",
  	"0x6f29bb375be5ed34ed999bb830ee2957dde76d16": "0x6c6b935b8bbd400000",
  	"0x6f2a31900e240395b19f159c1d00dfe4d898ebdf": "0x6c660645aa47180000",
  	"0x6f2a42e6e033d01061131929f7a6ee1538021e52": "0x6c6b935b8bbd400000",
  	"0x6f39cc37caaa2ddc9b610f6131e0619fae772a3c": "0x1b1ae4d6e2ef500000",
  	"0x6f44ca09f0c6a8294cbd519cdc594ad42c67579f": "0x2b5e3af16b1880000",
  	"0x6f50929777824c291a49c46dc854f379a6bea080": "0x138400eca364a00000",
  	"0x6f6cf20649a9e973177ac67dbadee4ebe5c7bdda": "0x11363297d01a8600000",
  	"0x6f791d359bc3536a315d6382b88311af8ed6da47": "0x4fcc1a89027f00000",
  	"0x6f794dbdf623daa6e0d00774ad6962737c921ea4": "0x6c6b935b8bbd400000",
  	"0x6f7ac681d45e418fce8b3a1db5bc3be6f06c9849": "0x6c6b935b8bbd400000",
  	"0x6f81f3abb1f933b1df396b8e9cc723a89b7c9806": "0xf2dc7d47f15600000",
  	"0x6f8f0d15cc96fb7fe94f1065bc6940f8d12957b2": "0x3635c9adc5dea00000",
  	"0x6f92d6e4548c78996509ee684b2ee29ba3c532b4": "0x3635c9adc5dea00000",
  	"0x6fa60df818a5446418b1bbd62826e0b9825e1318": "0x2cb92cc8f6714400000",
  	"0x6fa6388d402b30afe59934c3b9e13d1186476018": "0x24521e2a3017b80000",
  	"0x6fa72015fa78696efd9a86174f7f1f21019286b1": "0x487a9a304539440000",
  	"0x6fc25e7e00ca4f60a9fe6f28d1fde3542e2d1079": "0x2aef353bcddd600000",
  	"0x6fc53662371dca587b59850de78606e2359df383": "0x9c2007651b2500000",
  	"0x6fcc2c732bdd934af6ccd16846fb26ef89b2aa9b": "0x21e2b1d42261d490000",
  	"0x6fd4e0f3f32bee6d3767fdbc9d353a6d3aab7899": "0x25b064a875ea940000",
  	"0x6fd947d5a73b175008ae6ee8228163da289b167d": "0x65a4da25d3016c00000",
  	"0x6fd98e563d12ce0fd60f4f1f850ae396a9823c02": "0x445be3f2ef87940000",
  	"0x6fddbd9bca66e28765c2162c8433548c1052ed11": "0x1184429b82a818800000",
  	"0x6ff5d361b52ad0b68b1588607ec304ae5665fc98": "0x692ae8897081d00000",
  	"0x6ff6cc90d649de4e96cffee1077a5b302a848dcb": "0x18ce79c78802c0000",
  	"0x6ffe5cf82cc9ea5e36cad7c2974ce7249f3749e6": "0x692ae8897081d00000",
  	"0x7005a772282b1f62afda63f89b5dc6ab64c84cb9": "0x3cfc82e37e9a7400000",
  	"0x700711e311bb947355f755b579250ca7fd765a3e": "0x61093d7c2c6d380000",
  	"0x7010be2df57bd0ab9ae8196cd50ab0c521aba9f9": "0x6acb3df27e1f880000",
  	"0x7023c70956e04a92d70025aad297b539af355869": "0x6c6b935b8bbd400000",
  	"0x7025965d2b88da197d4459be3dc9386344cc1f31": "0x6cb7e74867d5e60000",
  	"0x702802f36d00250fab53adbcd696f0176f638a49": "0x6c6b935b8bbd400000",
  	"0x704819d2e44d6ed1da25bfce84c49fcca25613e5": "0x15af1d78b58c400000",
  	"0x704a6eb41ba34f13addde7d2db7df04915c7a221": "0x62a992e53a0af00000",
  	"0x704ab1150d5e10f5e3499508f0bf70650f028d4b": "0xd8d726b7177a800000",
  	"0x704ae21d762d6e1dde28c235d13104597236db1a": "0x6c6b935b8bbd400000",
  	"0x704d243c2978e46c2c86adbecd246e3b295ff633": "0x6d121bebf795f00000",
  	"0x704d5de4846d39b53cd21d1c49f096db5c19ba29": "0x83d6c7aab63600000",
  	"0x705ddd38355482b8c7d3b515bda1500dd7d7a817": "0x15af1d78b58c400000",
  	"0x70616e2892fa269705b2046b8fe3e72fa55816d3": "0x43c33c1937564800000",
  	"0x70670fbb05d33014444b8d1e8e7700258b8caa6d": "0x6c6b935b8bbd400000",
  	"0x7081fa6baad6cfb7f51b2cca16fb8970991a64ba": "0xcaec005f6c0f68000",
  	"0x7085ae7e7e4d932197b5c7858c00a3674626b7a5": "0x14542ba12a337c00000",
  	"0x7086b4bde3e35d4aeb24b825f1a215f99d85f745": "0x6c68ccd09b022c0000",
  	"0x708a2af425ceb01e87ffc1be54c0f532b20eacd6": "0x745d483b1f5a18000",
  	"0x708ea707bae4357f1ebea959c3a250acd6aa21b3": "0x1b1ae4d6e2ef500000",
  	"0x708fa11fe33d85ad1befcbae3818acb71f6a7d7e": "0xfc936392801c0000",
  	"0x7091303116d5f2389b23238b4d656a8596d984d3": "0x3b4e7e80aa58330000",
  	"0x7099d12f6ec656899b049a7657065d62996892c8": "0x15af1d78b58c400000",
  	"0x709fe9d2c1f1ce42207c9585044a60899f35942f": "0x6c6b935b8bbd400000",
  	"0x70a03549aa6168e97e88a508330a5a0bea74711a": "0x487a9a304539440000",
  	"0x70a4067d448cc25dc8e70e651cea7cf84e92109e": "0x98a7d9b8314c00000",
  	"0x70ab34bc17b66f9c3b63f151274f2a727c539263": "0x6c6b935b8bbd400000",
  	"0x70c213488a020c3cfb39014ef5ba6404724bcaa3": "0x692ae8897081d00000",
  	"0x70d25ed2c8ada59c088cf70dd22bf2db93acc18a": "0x39474545e4adbc0000",
  	"0x70e5e9da735ff077249dcb9aaf3db2a48d9498c0": "0x3635c9adc5dea00000",
  	"0x70fee08b00c6c2c04a3c625c1ff77caf1c32df01": "0xad78ebc5ac6200000",
  	"0x7101bd799e411cde14bdfac25b067ac890eab8e8": "0x4e9b8aae48de470000",
  	"0x7109dd011d15f3122d9d3a27588c10d77744508b": "0x6c6b935b8bbd400000",
  	"0x710b0274d712c77e08a5707d6f3e70c0ce3d92cf": "0x15af1d78b58c4000000",
  	"0x710be8fd5e2918468be2aabea80d828435d79612": "0xf43fc2c04ee00000",
  	"0x71135d8f05963c905a4a07922909235a896a52ea": "0xa2a15d09519be00000",
  	"0x711ecf77d71b3d0ea95ce4758afecdb9c131079d": "0x29331e6558f0e00000",
  	"0x71213fca313404204ecba87197741aa9dfe96338": "0x340aad21b3b700000",
  	"0x712b76510214dc620f6c3a1dd29aa22bf6d214fb": "0x14542ba12a337c00000",
  	"0x712ff7370a13ed360973fedc9ff5d2c93a505e9e": "0xd5967be4fc3f100000",
  	"0x7133843a78d939c69d4486e10ebc7b602a349ff7": "0x11d5cacce21f840000",
  	"0x7148aef33261d8031fac3f7182ff35928daf54d9": "0xde42ee1544dd900000",
  	"0x7163758cbb6c4c525e0414a40a049dcccce919bb": "0xad78ebc5ac6200000",
  	"0x7168b3bb8c167321d9bdb023a6e9fd11afc9afd9": "0x61093d7c2c6d380000",
  	"0x7169724ee72271c534cad6420fb04ee644cb86fe": "0x163c2b40dba5520000",
  	"0x716ad3c33a9b9a0a18967357969b94ee7d2abc10": "0x1a2117fe412a480000",
  	"0x716ba01ead2a91270635f95f25bfaf2dd610ca23": "0x979e7012056aa780000",
  	"0x716d50cca01e938500e6421cc070c3507c67d387": "0x6c6b935b8bbd400000",
  	"0x71762c63678c18d1c6378ce068e666381315147e": "0x6c6b935b8bbd400000",
  	"0x71784c105117c1f68935797fe159abc74e43d16a": "0x6c81c7b31195e00000",
  	"0x7179726f5c71ae1b6d16a68428174e6b34b23646": "0x18ea250097cbaf60000",
  	"0x717cf9beab3638308ded7e195e0c86132d163fed": "0x3326ee6f865f4220000",
  	"0x7180b83ee5574317f21c8072b191d895d46153c3": "0x18efc84ad0c7b00000",
  	"0x71946b7117fc915ed107385f42d99ddac63249c2": "0x6c6b935b8bbd400000",
  	"0x719e891fbcc0a33e19c12dc0f02039ca05b801df": "0x14f5538463a1b540000",
  	"0x71c7230a1d35bdd6819ed4b9a88e94a0eb0786dd": "0xeca08b353d24140000",
  	"0x71d2cc6d02578c65f73c575e76ce8fbcfadcf356": "0x3ecc078688a480000",
  	"0x71d9494e50c5dd59c599dba3810ba1755e6537f0": "0xd8d726b7177a800000",
  	"0x71e38ff545f30fe14ca863d4f5297fd48c73a5ce": "0xc2127af858da700000",
  	"0x71ea5b11ad8d29b1a4cb67bf58ca6c9f9c338c16": "0x56bc75e2d631000000",
  	"0x71ec3aec3f8f9221f9149fede06903a0f9a232f2": "0xad78ebc5ac6200000",
  	"0x71f2cdd1b046e2da2fbb5a26723422b8325e25a3": "0x56b394263a40c0000",
  	"0x71fa22cc6d33206b7d701a163a0dab31ae4d31d6": "0x57473d05dabae80000",
  	"0x7201d1c06920cd397ae8ad869bcda6e47ffb1b5a": "0x1158e460913d00000",
  	"0x72072a0ef1cff3d567cdd260e708ddc11cbc9a31": "0x56bc75e2d63100000",
  	"0x72094f3951ffc9771dced23ada080bcaf9c7cca7": "0x14542ba12a337c00000",
  	"0x720994dbe56a3a95929774e20e1fe525cf3704e4": "0x1b1ae4d6e2ef5000000",
  	"0x720e6b22bf430966fa32b6acb9a506eebf662c61": "0x83d6c7aab63600000",
  	"0x721158be5762b119cc9b2035e88ee4ee78f29b82": "0x21e19e0c9bab2400000",
  	"0x721f9d17e5a0e74205947aeb9bc6a7938961038f": "0x2d041d705a2c60000",
  	"0x7222fec7711781d26eaa4e8485f7aa3fac442483": "0x18b84570022a200000",
  	"0x72393d37b451effb9e1ff3b8552712e2a970d8c2": "0x35659ef93f0fc40000",
  	"0x723d8baa2551d2addc43c21b45e8af4ca2bfb2c2": "0x5f68e8131ecf800000",
  	"0x72402300e81d146c2e644e2bbda1da163ca3fb56": "0x17b7883c06916600000",
  	"0x72480bede81ad96423f2228b5c61be44fb523100": "0x15af1d78b58c4000000",
  	"0x724ce858857ec5481c86bd906e83a04882e5821d": "0xa2a15d09519be00000",
  	"0x726a14c90e3f84144c765cffacba3e0df11b48be": "0x21e19e0c9bab2400000",
  	"0x7283cd4675da58c496556151dafd80c7f995d318": "0x29331e6558f0e00000",
  	"0x7286e89cd9de8f7a8a00c86ffdb53992dd9251d1": "0x692ae8897081d00000",
  	"0x728f9ab080157db3073156dbca1a169ef3179407": "0x1b1ae4d6e2ef500000",
  	"0x7294c918b1aefb4d25927ef9d799e71f93a28e85": "0xaadec983fcff40000",
  	"0x7294ec9da310bc6b4bbdf543b0ef45abfc3e1b4d": "0x4a89f54ef0121c00000",
  	"0x729aad4627744e53f5d66309aa74448b3acdf46f": "0x6c6b935b8bbd400000",
  	"0x72a2fc8675feb972fa41b50dffdbbae7fa2adfb7": "0x9ab4fc67b528c80000",
  	"0x72a8260826294726a75bf39cd9aa9e07a3ea14cd": "0x6c6b935b8bbd400000",
  	"0x72b05962fb2ad589d65ad16a22559eba1458f387": "0x73f75d1a085ba0000",
  	"0x72b5633fe477fe542e742facfd690c137854f216": "0x5a87e7d7f5f6580000",
  	"0x72b7a03dda14ca9c661a1d469fd33736f673c8e8": "0x6c6b935b8bbd400000",
  	"0x72b904440e90e720d6ac1c2ad79c321dcc1c1a86": "0x54069233bf7f780000",
  	"0x72b90a4dc097239492c5b9777dcd1e52ba2be2c2": "0x14542ba12a337c00000",
  	"0x72bb27cb99f3e2c2cf90a98f707d30e4a201a071": "0x58e7926ee858a00000",
  	"0x72c083beadbdc227c5fb43881597e32e83c26056": "0x43c33c1937564800000",
  	"0x72cd048a110574482983492dfb1bd27942a696ba": "0x6c6b935b8bbd400000",
  	"0x72d03d4dfab3500cf89b86866f15d4528e14a195": "0xf34b82fd8e91200000",
  	"0x72dabb5b6eed9e99be915888f6568056381608f8": "0xb4c96c52cb4fe8000",
  	"0x72fb49c29d23a18950c4b2dc0ddf410f532d6f53": "0x6c6b935b8bbd400000",
  	"0x72feaf124579523954645b7fafff0378d1c8242e": "0x3635c9adc5dea00000",
  	"0x7301dc4cf26d7186f2a11bf8b08bf229463f64a3": "0x6c6b935b8bbd400000",
  	"0x730447f97ce9b25f22ba1afb36df27f9586beb9b": "0x2c73c937742c500000",
  	"0x7306de0e288b56cfdf987ef0d3cc29660793f6dd": "0x1b8abfb62ec8f60000",
  	"0x730d8763c6a4fd824ab8b859161ef7e3a96a1200": "0x43c33c1937564800000",
  	"0x73128173489528012e76b41a5e28c68ba4e3a9d4": "0x3635c9adc5dea00000",
  	"0x7313461208455455465445a459b06c3773b0eb30": "0x6c6b935b8bbd400000",
  	"0x732fead60f7bfdd6a9dec48125e3735db1b6654f": "0x1158e460913d00000",
  	"0x734223d27ff23e5906caed22595701bb34830ca1": "0x6c6b935b8bbd400000",
  	"0x73473e72115110d0c3f11708f86e77be2bb0983c": "0x1158e460913d00000",
  	"0x7352586d021ad0cf77e0e928404a59f374ff4582": "0xb8507a820728200000",
  	"0x73550beb732ba9ddafda7ae406e18f7feb0f8bb2": "0x97c9ce4cf6d5c00000",
  	"0x735b97f2fc1bd24b12076efaf3d1288073d20c8c": "0x1158e460913d00000",
  	"0x735e328666ed5637142b3306b77ccc5460e72c3d": "0x6ab8f37879c9910000",
  	"0x7363cd90fbab5bb8c49ac20fc62c398fe6fb744c": "0x6c6b935b8bbd400000",
  	"0x736b44503dd2f6dd5469ff4c5b2db8ea4fec65d0": "0x1104ee759f21e30000",
  	"0x736bf1402c83800f893e583192582a134eb532e9": "0x21e19d293c01f260000",
  	"0x738ca94db7ce8be1c3056cd6988eb376359f3353": "0x5665b96cf35acf00000",
  	"0x73914b22fc2f131584247d82be4fecbf978ad4ba": "0x6c6b935b8bbd400000",
  	"0x73932709a97f02c98e51b091312865122385ae8e": "0x4d853c8f8908980000",
  	"0x7393cbe7f9ba2165e5a7553500b6e75da3c33abf": "0x56bc75e2d63100000",
  	"0x73b4d499de3f38bf35aaf769a6e318bc6d123692": "0x6c6b935b8bbd400000",
  	"0x73bedd6fda7ba3272185087b6351fc133d484e37": "0x11226bf9dce59780000",
  	"0x73bfe7710f31cab949b7a2604fbf5239cee79015": "0x6c6b935b8bbd400000",
  	"0x73cf80ae9688e1580e68e782cd0811f7aa494d2c": "0x1a4aba225c207400000",
  	"0x73d7269ff06c9ffd33754ce588f74a966abbbbba": "0x165c96647b38a200000",
  	"0x73d8fee3cb864dce22bb26ca9c2f086d5e95e63b": "0x3635c9adc5dea00000",
  	"0x73df3c3e7955f4f2d859831be38000b1076b3884": "0x6acb3df27e1f880000",
  	"0x73e4a2b60cf48e8baf2b777e175a5b1e4d0c2d8f": "0x56bc75e2d63100000",
  	"0x740af1eefd3365d78ba7b12cb1a673e06a077246": "0x42bf06b78ed3b500000",
  	"0x740bfd52e01667a3419b029a1b8e45576a86a2db": "0x38ebad5cdc902800000",
  	"0x740f641614779dcfa88ed1d425d60db42a060ca6": "0x3622c6760810570000",
  	"0x7412c9bc30b4df439f023100e63924066afd53af": "0x1b1ae4d6e2ef500000",
  	"0x741693c30376508513082020cc2b63e9fa92131b": "0x410d586a20a4c00000",
  	"0x7421ce5be381738ddc83f02621974ff0686c79b8": "0x58788cb94b1d800000",
  	"0x74316adf25378c10f576d5b41a6f47fa98fce33d": "0x1238131e5c7ad50000",
  	"0x743651b55ef8429df50cf81938c2508de5c8870f": "0x6c6b935b8bbd400000",
  	"0x743de50026ca67c94df54f066260e1d14acc11ac": "0x6c6b935b8bbd400000",
  	"0x7445202f0c74297a004eb3726aa6a82dd7c02fa1": "0x6c6b935b8bbd400000",
  	"0x744b03bba8582ae5498e2dc22d19949467ab53fc": "0x1b1ae4d6e2ef500000",
  	"0x744c0c77ba7f236920d1e434de5da33e48ebf02c": "0x6acb3df27e1f880000",
  	"0x7450ff7f99eaa9116275deac68e428df5bbcd8b9": "0x6c6b935b8bbd400000",
  	"0x7456c5b2c5436e3e571008933f1805ccfe34e9ec": "0x3635c9adc5dea00000",
  	"0x745ad3abc6eeeb2471689b539e789ce2b8268306": "0x3d4194bea011928000",
  	"0x745aecbaf9bb39b74a67ea1ce623de368481baa6": "0x21e19e0c9bab2400000",
  	"0x745ccf2d819edbbddea8117b5c49ed3c2a066e93": "0xd8d726b7177a800000",
  	"0x7462c89caa9d8d7891b2545def216f7464d5bb21": "0x5eaed54a28b310000",
  	"0x74648caac748dd135cd91ea14c28e1bd4d7ff6ae": "0xa80d24677efef00000",
  	"0x7471f72eeb300624eb282eab4d03723c649b1b58": "0x1b1ae4d6e2ef5000000",
  	"0x747abc9649056d3926044d28c3ad09ed17b67d70": "0x10f0dbae61009528000",
  	"0x747ff7943b71dc4dcdb1668078f83dd7cc4520c2": "0x340aad21b3b700000",
  	"0x7480de62254f2ba82b578219c07ba5be430dc3cb": "0x17da3a04c7b3e000000",
  	"0x7484d26becc1eea8c6315ec3ee0a450117dc86a0": "0x28a857425466f800000",
  	"0x74863acec75d03d53e860e64002f2c165e538377": "0x3635c9adc5dea00000",
  	"0x7489cc8abe75cda4ef0d01cef2605e47eda67ab1": "0x73f75d1a085ba0000",
  	"0x748c285ef1233fe4d31c8fb1378333721c12e27a": "0x6c6b935b8bbd400000",
  	"0x749087ac0f5a97c6fad021538bf1d6cda18e0daa": "0x3635c9adc5dea00000",
  	"0x7495ae78c0d90261e2140ef2063104731a60d1ed": "0x1db50718925210000",
  	"0x749a4a768b5f237248938a12c623847bd4e688dc": "0x3e733628714200000",
  	"0x749ad6f2b5706bbe2f689a44c4b640b58e96b992": "0x56bc75e2d63100000",
  	"0x74a17f064b344e84db6365da9591ff1628257643": "0x1158e460913d00000",
  	"0x74aeec915de01cc69b2cb5a6356feea14658c6c5": "0xc9a95ee2986520000",
  	"0x74afe54902d615782576f8baac13ac970c050f6e": "0x9a1aaa3a9fba70000",
  	"0x74b7e0228baed65957aebb4d916d333aae164f0e": "0x6c6b935b8bbd400000",
  	"0x74bc4a5e2045f4ff8db184cf3a9b0c065ad807d2": "0x6c6b935b8bbd400000",
  	"0x74bce9ec38362d6c94ccac26d5c0e13a8b3b1d40": "0x363526410442f50000",
  	"0x74bf7a5ab59293149b5c60cf364263e5ebf1aa0d": "0x6470c3e771e3c0000",
  	"0x74c73c90528a157336f1e7ea20620ae53fd24728": "0x1e63a2e538f16e30000",
  	"0x74d1a4d0c7524e018d4e06ed3b648092b5b6af2c": "0x2b5e3af16b1880000",
  	"0x74d366b07b2f56477d7c7077ac6fe497e0eb6559": "0x10f0cf064dd59200000",
  	"0x74d37a51747bf8b771bfbf43943933d100d21483": "0x3635c9adc5dea00000",
  	"0x74d671d99cbea1ab57906375b63ff42b50451d17": "0x3635c9adc5dea00000",
  	"0x74ebf4425646e6cf81b109ce7bf4a2a63d84815f": "0x22b1c8c1227a00000",
  	"0x74ed33acf43f35b98c9230b9e6642ecb5330839e": "0x24f6dffb498d280000",
  	"0x74ef2869cbe608856045d8c2041118579f2236ea": "0x33cd64591956e0000",
  	"0x74fc5a99c0c5460503a13b0509459da19ce7cd90": "0xad78ebc5ac6200000",
  	"0x750bbb8c06bbbf240843cc75782ee02f08a97453": "0x2d43f3ebfafb2c0000",
  	"0x7514adbdc63f483f304d8e94b67ff3309f180b82": "0x21c4a06e2d13598000",
  	"0x7517f16c28d132bb40e3ba36c6aef131c462da17": "0xfc936392801c0000",
  	"0x751a2ca34e7187c163d28e3618db28b13c196d26": "0x1b1ae4d6e2ef500000",
  	"0x751abcb6cc033059911815c96fd191360ab0442d": "0x1b1ae4d6e2ef5000000",
  	"0x7526e482529f0a14eec98871dddd0e721b0cd9a2": "0x1158e460913d00000",
  	"0x7529f3797bb6a20f7ea6492419c84c867641d81c": "0x6c6b935b8bbd400000",
  	"0x752a5ee232612cd3005fb26e5b597de19f776be6": "0x127fcb8afae20d00000",
  	"0x752c9febf42f66c4787bfa7eb17cf5333bba5070": "0x6a99f2b54fdd580000",
  	"0x7539333046deb1ef3c4daf50619993f444e1de68": "0x40138b917edfb80000",
  	"0x7553aa23b68aa5f57e135fe39fdc235eaca8c98c": "0x3635c9adc5dea00000",
  	"0x755a60bf522fbd8fff9723446b7e343a7068567e": "0x43c33c1937564800000",
  	"0x755f587e5efff773a220726a13d0f2130d9f896b": "0x3635c9adc5dea00000",
  	"0x75621865b6591365606ed378308c2d1def4f222c": "0xa80d24677efef00000",
  	"0x75636cdb109050e43d5d6ec47e359e218e857eca": "0x4d8b2276c8962280000",
  	"0x7566496162ba584377be040a4f87777a707acaeb": "0xd8d726b7177a800000",
  	"0x756b84eb85fcc1f4fcdcc2b08db6a86e135fbc25": "0xae8e7a0bb575d00000",
  	"0x756f45e3fa69347a9a973a725e3c98bc4db0b5a0": "0xad78ebc5ac6200000",
  	"0x757b65876dbf29bf911d4f0692a2c9beb1139808": "0xdf93a59337d6dd8000",
  	"0x757fa55446c460968bb74b5ebca96c4ef2c709c5": "0x3708baed3d68900000",
  	"0x75804aac64b4199083982902994d9c5ed8828f11": "0x1e3d07b0a620e40000",
  	"0x7592c69d067b51b6cc639d1164d5578c60d2d244": "0x1158e460913d00000",
  	"0x75abe5270f3a78ce007cf37f8fbc045d489b7bb1": "0x6c6acc67d7b1d40000",
  	"0x75ac547017134c04ae1e11d60e63ec04d18db4ef": "0x14542ba12a337c00000",
  	"0x75b0e9c942a4f0f6f86d3f95ff998022fa67963b": "0x50c5e761a444080000",
  	"0x75b95696e8ec4510d56868a7c1a735c68b244890": "0x15af1d78b58c4000000",
  	"0x75be8ff65e5788aec6b2a52d5fa7b1e7a03ba675": "0x3abcdc5343d740000",
  	"0x75c11d024d12ae486c1095b7a7b9c4af3e8edeb9": "0x1158e460913d00000",
  	"0x75c1ad23d23f24b384d0c3149177e86697610d21": "0x15c5bcd6c288bbd0000",
  	"0x75c2ffa1bef54919d2097f7a142d2e14f9b04a58": "0x90f358504032a10000",
  	"0x75d67ce14e8d29e8c2ffe381917b930b1aff1a87": "0xa2a15d09519be00000",
  	"0x75de7e9352e90b13a59a5878ffecc7831cac4d82": "0x9489237adb9a500000",
  	"0x75f7539d309e9039989efe2e8b2dbd865a0df088": "0x855b5ba65c84f00000",
  	"0x7608f437b31f18bc0b64d381ae86fd978ed7b31f": "0x2b5e3af16b1880000",
  	"0x760ff3354e0fde938d0fb5b82cef5ba15c3d2916": "0x21e19e0c9bab2400000",
  	"0x761a6e362c97fbbd7c5977acba2da74687365f49": "0x9f74ae1f953d00000",
  	"0x761e6caec189c230a162ec006530193e67cf9d19": "0x6c6b935b8bbd400000",
  	"0x761f8a3a2af0a8bdbe1da009321fb29764eb62a1": "0x21e19e0c9bab2400000",
  	"0x762998e1d75227fced7a70be109a4c0b4ed86414": "0x1158e460913d00000",
  	"0x762d6f30dab99135e4eca51d5243d6c8621102d5": "0xf498941e664280000",
  	"0x76331e30796ce664b2700e0d4153700edc869777": "0x6c6b935b8bbd400000",
  	"0x763886e333c56feff85be3951ab0b889ce262e95": "0x6c6b935b8bbd400000",
  	"0x763a7cbab70d7a64d0a7e52980f681472593490c": "0x2086ac351052600000",
  	"0x763eece0b08ac89e32bfa4bece769514d8cb5b85": "0xd8d726b7177a800000",
  	"0x7640a37f8052981515bce078da93afa4789b5734": "0x6c6b935b8bbd400000",
  	"0x7641f7d26a86cddb2be13081810e01c9c83c4b20": "0xb98bc829a6f90000",
  	"0x764692cccb33405dd0ab0c3379b49caf8e6221ba": "0x1158e460913d00000",
  	"0x764d5212263aff4a2a14f031f04ec749dc883e45": "0x6449e84e47a8a80000",
  	"0x764fc46d428b6dbc228a0f5f55c9508c772eab9f": "0x581767ba6189c400000",
  	"0x76506eb4a780c951c74a06b03d3b8362f0999d71": "0x1b1ae4d6e2ef500000",
  	"0x765be2e12f629e6349b97d21b62a17b7c830edab": "0x14542ba12a337c00000",
  	"0x76628150e2995b5b279fc83e0dd5f102a671dd1c": "0x878678326eac9000000",
  	"0x766b3759e8794e926dac473d913a8fb61ad0c2c9": "0x4b06dbbb40f4a0000",
  	"0x7670b02f2c3cf8fd4f4730f3381a71ea431c33c7": "0xe7eeba3410b740000",
  	"0x767a03655af360841e810d83f5e61fb40f4cd113": "0x35659ef93f0fc40000",
  	"0x767ac690791c2e23451089fe6c7083fe55deb62b": "0x2c73c937742c500000",
  	"0x767fd7797d5169a05f7364321c19843a8c348e1e": "0x104e70464b1580000",
  	"0x76846f0de03b5a76971ead298cdd08843a4bc6c6": "0xd71b0fe0a28e0000",
  	"0x768498934e37e905f1d0e77b44b574bcf3ec4ae8": "0x43c33c1937564800000",
  	"0x768ce0daa029b7ded022e5fc574d11cde3ecb517": "0x1174a5cdf88bc80000",
  	"0x7693bdeb6fc82b5bca721355223175d47a084b4d": "0x4a89f54ef0121c00000",
  	"0x76aaf8c1ac012f8752d4c09bb46607b6651d5ca8": "0x1158e460913d00000",
  	"0x76ab87dd5a05ad839a4e2fc8c85aa6ba05641730": "0x6c6b935b8bbd400000",
  	"0x76afc225f4fa307de484552bbe1d9d3f15074c4a": "0xa290b5c7ad39680000",
  	"0x76becae4a31d36f3cb577f2a43594fb1abc1bb96": "0x543a9ce0e1332f00000",
  	"0x76c27535bcb59ce1fa2d8c919cabeb4a6bba01d1": "0x6c6b935b8bbd400000",
  	"0x76ca22bcb8799e5327c4aa2a7d0949a1fcce5f29": "0x52a03f228c5ae20000",
  	"0x76cac488111a4fd595f568ae3a858770fc915d5f": "0xad78ebc5ac6200000",
  	"0x76cb9c8b69f4387675c48253e234cb7e0d74a426": "0x190f4482eb91dae0000",
  	"0x76f83ac3da30f7092628c7339f208bfc142cb1ee": "0x9a18ffe7427d640000",
  	"0x76f9ad3d9bbd04ae055c1477c0c35e7592cb2a20": "0x8833f11e3458f200000",
  	"0x76ffc157ad6bf8d56d9a1a7fddbc0fea010aabf4": "0x3635c9adc5dea00000",
  	"0x77028e409cc43a3bd33d21a9fc53ec606e94910e": "0xd255d112e103a00000",
  	"0x770c2fb2c4a81753ac0182ea460ec09c90a516f8": "0x1158e460913d00000",
  	"0x770d98d31b4353fceee8560c4ccf803e88c0c4e0": "0x2086ac351052600000",
  	"0x7713ab8037411c09ba687f6f9364f0d3239fac28": "0x21e19e0c9bab2400000",
  	"0x771507aeee6a255dc2cd9df55154062d0897b297": "0x121ea68c114e510000",
  	"0x7719888795ad745924c75760ddb1827dffd8cda8": "0x6c6b4c4da6ddbe0000",
  	"0x7727af101f0aaba4d23a1cafe17c6eb5dab1c6dc": "0x6c6b935b8bbd400000",
  	"0x772c297f0ad194482ee8c3f036bdeb01c201d5cc": "0xad78ebc5ac6200000",
  	"0x77306ffe2e4a8f3ca826c1a249f7212da43aeffd": "0x43c33c1937564800000",
  	"0x773141127d8cf318aebf88365add3d5527d85b6a": "0x3636d7af5ec98e0000",
  	"0x7746b6c6699c8f34ca2768a820f1ffa4c207fe05": "0xd8d8583fa2d52f0000",
  	"0x7751f363a0a7fd0533190809ddaf9340d8d11291": "0x1158e460913d00000",
  	"0x7757a4b9cc3d0247ccaaeb9909a0e56e1dd6dcc2": "0x1158e460913d00000",
  	"0x775c10c93e0db7205b2643458233c64fc33fd75b": "0x6c6b935b8bbd400000",
  	"0x77617ebc4bebc5f5ddeb1b7a70cdeb6ae2ffa024": "0x6acb3df27e1f880000",
  	"0x776943ffb2ef5cdd35b83c28bc046bd4f4677098": "0xa2a15d09519be00000",
  	"0x77701e2c493da47c1b58f421b5495dee45bea39b": "0x148f649cf6142a58000",
  	"0x77798f201257b9c35204957057b54674aefa51df": "0x813ca56906d340000",
  	"0x778c43d11afe3b586ff374192d96a7f23d2b9b7f": "0x8bb4fcfa3b7d6b8000",
  	"0x778c79f4de1953ebce98fe8006d53a81fb514012": "0x36330322d5238c0000",
  	"0x779274bf1803a336e4d3b00ddd93f2d4f5f4a62e": "0x3635c9adc5dea00000",
  	"0x77a17122fa31b98f1711d32a99f03ec326f33d08": "0x5c283d410394100000",
  	"0x77a34907f305a54c85db09c363fde3c47e6ae21f": "0x35659ef93f0fc40000",
  	"0x77a769fafdecf4a638762d5ba3969df63120a41d": "0x6c6b935b8bbd400000",
  	"0x77be6b64d7c733a436adec5e14bf9ad7402b1b46": "0x3635c9adc5dea00000",
  	"0x77bfe93ccda750847e41a1affee6b2da96e7214e": "0x1043561a8829300000",
  	"0x77c4a697e603d42b12056cbba761e7f51d0443f5": "0x24dce54d34a1a00000",
  	"0x77cc02f623a9cf98530997ea67d95c3b491859ae": "0x497303c36ea0c20000",
  	"0x77d43fa7b481dbf3db530cfbf5fdced0e6571831": "0x6c6b935b8bbd400000",
  	"0x77da5e6c72fb36bce1d9798f7bcdf1d18f459c2e": "0x13695bb6cf93e0000",
  	"0x77f4e3bdf056883cc87280dbe640a18a0d02a207": "0xa81993a2bfb5b0000",
  	"0x77f609ca8720a023262c55c46f2d26fb3930ac69": "0xf015f25736420000",
  	"0x77f81b1b26fc84d6de97ef8b9fbd72a33130cc4a": "0x3635c9adc5dea00000",
  	"0x7819b0458e314e2b53bfe00c38495fd4b9fdf8d6": "0x1158e460913d00000",
  	"0x781b1501647a2e06c0ed43ff197fccec35e1700b": "0xa2a15d09519be00000",
  	"0x782f52f0a676c77716d574c81ec4684f9a020a97": "0x2e14e206b730ad8000",
  	"0x78355df0a230f83d032c703154414de3eedab557": "0x6c6b935b8bbd400000",
  	"0x7836f7ef6bc7bd0ff3acaf449c84dd6b1e2c939f": "0xe08de7a92cd97c0000",
  	"0x7837fcb876da00d1eb3b88feb3df3fa4042fac82": "0x5f68e8131ecf800000",
  	"0x783eec8aa5dac77b2e6623ed5198a431abbaee07": "0x17da3a04c7b3e00000",
  	"0x785c8ea774d73044a734fa790a1b1e743e77ed7c": "0xcf152640c5c830000",
  	"0x7860a3de38df382ae4a4dce18c0c07b98bce3dfa": "0x3635c9adc5dea00000",
  	"0x78634371e17304cbf339b1452a4ce438dc764cce": "0x21e19e0c9bab2400000",
  	"0x7864dc999fe4f8e003c0f43decc39aae1522dc0f": "0x51e102bd8ece00000",
  	"0x78746a958dced4c764f876508c414a68342cecb9": "0x2be374fe8e2c40000",
  	"0x787d313fd36b053eeeaedbce74b9fb0678333289": "0x5c058b7842719600000",
  	"0x78859c5b548b700d9284cee4b6633c2f52e529c2": "0xa030dcebbd2f4c0000",
  	"0x788e809741a3b14a22a4b1d937c82cfea489eebe": "0x17b7883c06916600000",
  	"0x78a1e254409fb1b55a7cb4dd8eba3b30c8bad9ef": "0x56bc75e2d63100000",
  	"0x78a5e89900bd3f81dd71ba869d25fec65261df15": "0xafd812fee03d5700000",
  	"0x78b978a9d7e91ee529ea4fc4b76feaf8762f698c": "0x6c6b935b8bbd4000000",
  	"0x78ce3e3d474a8a047b92c41542242d0a08c70f99": "0x21e19e0c9bab2400000",
  	"0x78cf8336b328db3d87813a472b9e89b75e0cf3bc": "0x3635c9adc5dea00000",
  	"0x78d4f8c71c1e68a69a98f52fcb45da8af56ea1a0": "0x6c6b935b8bbd400000",
  	"0x78df2681d6d602e22142d54116dea15d454957aa": "0x102794ad20da680000",
  	"0x78e08bc533413c26e291b3143ffa7cc9afb97b78": "0xad78ebc5ac6200000",
  	"0x78e83f80b3678c7a0a4e3e8c84dccde064426277": "0x61093d7c2c6d380000",
  	"0x78f5c74785c5668a838072048bf8b453594ddaab": "0x15af1d78b58c400000",
  	"0x790f91bd5d1c5cc4739ae91300db89e1c1303c93": "0x6c6b935b8bbd400000",
  	"0x7917e5bd82a9790fd650d043cdd930f7799633db": "0xd8d4602c26bf6c0000",
  	"0x7919e7627f9b7d54ea3b14bb4dd4649f4f39dee0": "0x5a87e7d7f5f6580000",
  	"0x791f6040b4e3e50dcf3553f182cd97a90630b75d": "0xd8d726b7177a800000",
  	"0x7930c2d9cbfa87f510f8f98777ff8a8448ca5629": "0xad6eedd17cf3b8000",
  	"0x794529d09d017271359730027075b87ad83dae6e": "0x10ce1d3d8cb3180000",
  	"0x794b51c39e53d9e762b0613b829a44b472f4fff3": "0x2435e0647841cc8000",
  	"0x79551cede376f747e3716c8d79400d766d2e0195": "0x9cb37afa4ff78680000",
  	"0x795ebc2626fc39b0c86294e0e837dcf523553090": "0x3635c9adc5dea00000",
  	"0x796ebbf49b3e36d67694ad79f8ff36767ac6fab0": "0x34bc4fdde27c00000",
  	"0x796f87ba617a2930b1670be92ed1281fb0b346e1": "0x6f5e86fb528280000",
  	"0x797427e3dbf0feae7a2506f12df1dc40326e8505": "0x3635c9adc5dea00000",
  	"0x797510e386f56393ced8f477378a444c484f7dad": "0x3635c9adc5dea00000",
  	"0x797bb7f157d9feaa17f76da4f704b74dc1038341": "0xb50fcfafebecb00000",
  	"0x7988901331e387f713faceb9005cb9b65136eb14": "0x6acb3df27e1f880000",
  	"0x7989d09f3826c3e5af8c752a8115723a84d80970": "0x1686f8614cf0ad0000",
  	"0x7995bd8ce2e0c67bf1c7a531d477bca1b2b97561": "0x14248d617829ece0000",
  	"0x79aeb34566b974c35a5881dec020927da7df5d25": "0x6c6b935b8bbd400000",
  	"0x79b120eb8806732321288f675a27a9225f1cd2eb": "0x85a0bf37dec9e40000",
  	"0x79b48d2d6137c3854d611c01ea42427a0f597bb7": "0xa5aa85009e39c0000",
  	"0x79b8aad879dd30567e8778d2d231c8f37ab8734e": "0x6c6b935b8bbd400000",
  	"0x79bf2f7b6e328aaf26e0bb093fa22da29ef2f471": "0x61093d7c2c6d380000",
  	"0x79c130c762b8765b19d2abc9a083ab8f3aad7940": "0xd5967be4fc3f100000",
  	"0x79c1be19711f73bee4e6316ae7549459aacea2e0": "0x15af1d78b58c400000",
  	"0x79c6002f8452ca157f1317e80a2faf24475559b7": "0x1158e460913d00000",
  	"0x79cac6494f11ef2798748cb53285bd8e22f97cda": "0x6c6b935b8bbd400000",
  	"0x79cfa9780ae6d87b2c31883f09276986c89a6735": "0x3635c9adc5dea00000",
  	"0x79dba256472db4e058f2e4cdc3ea4e8a42773833": "0x4f2591f896a6500000",
  	"0x79ed10cf1f6db48206b50919b9b697081fbdaaf3": "0x6c6b935b8bbd400000",
  	"0x79f08e01ce0988e63c7f8f2908fade43c7f9f5c9": "0xfc936392801c0000",
  	"0x79fd6d48315066c204f9651869c1096c14fc9781": "0x6c6b935b8bbd400000",
  	"0x79ffb4ac13812a0b78c4a37b8275223e176bfda5": "0xf015f25736420000",
  	"0x7a0589b143a8e5e107c9ac66a9f9f8597ab3e7ab": "0x51e932d76e8f7b0000",
  	"0x7a0a78a9cc393f91c3d9e39a6b8c069f075e6bf5": "0x487a9a304539440000",
  	"0x7a1370a742ec2687e761a19ac5a794329ee67404": "0xa2a1326761e2920000",
  	"0x7a2dfc770e24368131b7847795f203f3d50d5b56": "0x269fec7f0361d200000",
  	"0x7a33834e8583733e2d52aead589bd1affb1dd256": "0x3635c9adc5dea00000",
  	"0x7a36aba5c31ea0ca7e277baa32ec46ce93cf7506": "0x43c33c1937564800000",
  	"0x7a381122bada791a7ab1f6037dac80432753baad": "0x21e19e0c9bab2400000",
  	"0x7a48d877b63a8f8f9383e9d01e53e80c528e955f": "0x1b1ae4d6e2ef5000000",
  	"0x7a4f9b850690c7c94600dbee0ca4b0a411e9c221": "0x678a932062e4180000",
  	"0x7a63869fc767a4c6b1cd0e0649f3634cb121d24b": "0x433874f632cc60000",
  	"0x7a67dd043a504fc2f2fc7194e9becf484cecb1fb": "0xd8d726b7177a80000",
  	"0x7a6b26f438d9a352449155b8876cbd17c9d99b64": "0x14542ba12a337c00000",
  	"0x7a6d781c77c4ba1fcadf687341c1e31799e93d27": "0xeda838c4929080000",
  	"0x7a7068e1c3375c0e599db1fbe6b2ea23b8f407d2": "0x6c6b935b8bbd400000",
  	"0x7a74cee4fa0f6370a7894f116cd00c1147b83e59": "0x2b5e3af16b18800000",
  	"0x7a79e30ff057f70a3d0191f7f53f761537af7dff": "0x15af1d78b58c400000",
  	"0x7a7a4f807357a4bbe68e1aa806393210c411ccb3": "0x65a4da25d3016c00000",
  	"0x7a8563867901206f3f2bf0fa3e1c8109cabccd85": "0x76d41c62494840000",
  	"0x7a8797690ab77b5470bf7c0c1bba612508e1ac7d": "0x1e09296c3378de40000",
  	"0x7a8c89c014509d56d7b68130668ff6a3ecec7370": "0x1043561a8829300000",
  	"0x7a94b19992ceb8ce63bc92ee4b5aded10c4d9725": "0x38d1a8064bb64c80000",
  	"0x7aa79ac04316cc8d08f20065baa6d4142897d54e": "0x4be4e7267b6ae00000",
  	"0x7aad4dbcd3acf997df93586956f72b64d8ad94ee": "0xd8d726b7177a800000",
  	"0x7ab256b204800af20137fabcc916a23258752501": "0x43c33c1937564800000",
  	"0x7aba56f63a48bc0817d6b97039039a7ad62fae2e": "0x2086ac351052600000",
  	"0x7abb10f5bd9bc33b8ec1a82d64b55b6b18777541": "0x43c33c1937564800000",
  	"0x7ac48d40c664cc9a6d89f1c5f5c80a1c70e744e6": "0xa31062beeed7000000",
  	"0x7ac58f6ffc4f8107ae6e30378e4e9f99c57fbb24": "0x22b1c8c1227a00000",
  	"0x7ad3f307616f19dcb143e6444dab9c3c33611f52": "0x2b5e3af16b1880000",
  	"0x7ad82caea1a8b4ed05319b9c9870173c814e06ee": "0x2164b7a04ac8a00000",
  	"0x7ade5d66b944bb860c0efdc86276d58f4653f711": "0x6c6b935b8bbd400000",
  	"0x7adfedb06d91f3cc7390450b85550270883c7bb7": "0x1178fa40515db40000",
  	"0x7ae1c19e53c71cee4c73fae2d7fc73bf9ab5e392": "0x3635c9adc5dea00000",
  	"0x7ae659eb3bc46852fa86fac4e21c768d50388945": "0xf810c1cb501b80000",
  	"0x7aea25d42b2612286e99c53697c6bc4100e2dbbf": "0x6c6b935b8bbd400000",
  	"0x7aef7b551f0b9c46e755c0f38e5b3a73fe1199f5": "0x50c5e761a444080000",
  	"0x7b0b31ff6e24745ead8ed9bb85fc0bf2fe1d55d4": "0x2b5e3af16b18800000",
  	"0x7b0fea1176d52159333a143c294943da36bbddb4": "0x1fc7da64ea14c100000",
  	"0x7b11673cc019626b290cbdce26046f7e6d141e21": "0x1b1ae4d6e2ef500000",
  	"0x7b122162c913e7146cad0b7ed37affc92a0bf27f": "0x51af096b2301d18000",
  	"0x7b1bf53a9cbe83a7dea434579fe72aac8d2a0cd0": "0xad4c8316a0b0c0000",
  	"0x7b1daf14891b8a1e1bd429d8b36b9a4aa1d9afbf": "0x1b1ae4d6e2ef500000",
  	"0x7b1fe1ab4dfd0088cdd7f60163ef59ec2aee06f5": "0x6c6b935b8bbd400000",
  	"0x7b25bb9ca8e702217e9333225250e53c36804d48": "0x65ea3db75546600000",
  	"0x7b27d0d1f3dd3c140294d0488b783ebf4015277d": "0x15af1d78b58c400000",
  	"0x7b4007c45e5a573fdbb6f8bd746bf94ad04a3c26": "0x33821f5135d259a0000",
  	"0x7b43c7eea8d62355b0a8a81da081c6446b33e9e0": "0xd8d726b7177a800000",
  	"0x7b4d2a38269069c18557770d591d24c5121f5e83": "0x25f273933db5700000",
  	"0x7b6175ec9befc738249535ddde34688cd36edf25": "0x21e19e0c9bab2400000",
  	"0x7b66126879844dfa34fe65c9f288117fefb449ad": "0x14542ba12a337c00000",
  	"0x7b6a84718dd86e63338429ac811d7c8a860f21f1": "0x61093d7c2c6d380000",
  	"0x7b712c7af11676006a66d2fc5c1ab4c479ce6037": "0x1b1ae4d6e2ef5000000",
  	"0x7b73242d75ca9ad558d650290df17692d54cd8b8": "0x6c6e59e67c78540000",
  	"0x7b761feb7fcfa7ded1f0eb058f4a600bf3a708cb": "0xf95dd2ec27cce00000",
  	"0x7b827cae7ff4740918f2e030ab26cb98c4f46cf5": "0x194684c0b39de100000",
  	"0x7b893286427e72db219a21fc4dcd5fbf59283c31": "0x21e19e0c9bab2400000",
  	"0x7b9226d46fe751940bc416a798b69ccf0dfab667": "0xe3aeb5737240a00000",
  	"0x7b98e23cb96beee80a168069ebba8f20edd55ccf": "0xba0c91587c14a0000",
  	"0x7bb0fdf5a663b5fba28d9c902af0c811e252f298": "0xad78ebc5ac6200000",
  	"0x7bb9571f394b0b1a8eba5664e9d8b5e840677bea": "0x11164759ffb320000",
  	"0x7bb984c6dbb9e279966afafda59c01d02627c804": "0x1b464311d45a6880000",
  	"0x7bbbec5e70bdead8bb32b42805988e9648c0aa97": "0x3636d7af5ec98e0000",
  	"0x7bca1da6c80a66baa5db5ac98541c4be276b447d": "0x24cf049680fa3c0000",
  	"0x7bddb2ee98de19ee4c91f661ee8e67a91d054b97": "0x3635c9adc5dea00000",
  	"0x7be2f7680c802da6154c92c0194ae732517a7169": "0xfc936392801c0000",
  	"0x7be7f2456971883b9a8dbe4c91dec08ac34e8862": "0xa2a15d09519be00000",
  	"0x7be8ccb4f11b66ca6e1d57c0b5396221a31ba53a": "0x1158e460913d00000",
  	"0x7beb81fb2f5e91526b2ac9795e76c69bcff04bc0": "0xeb22e794f0a8d600000",
  	"0x7c0883054c2d02bc7a852b1f86c42777d0d5c856": "0x1b1ae4d6e2ef500000",
  	"0x7c0f5e072043c9ee740242197e78cc4b98cdf960": "0xad78ebc5ac6200000",
  	"0x7c1df24a4f7fb2c7b472e0bb006cb27dcd164156": "0x3635c9adc5dea00000",
  	"0x7c29d47d57a733f56b9b217063b513dc3b315923": "0xd8d726b7177a800000",
  	"0x7c2b9603884a4f2e464eceb97d17938d828bc02c": "0xa2a15d09519be00000",
  	"0x7c382c0296612e4e97e440e02d3871273b55f53b": "0xab640391201300000",
  	"0x7c3eb713c4c9e0381cd8154c7c9a7db8645cde17": "0xad78ebc5ac6200000",
  	"0x7c4401ae98f12ef6de39ae24cf9fc51f80eba16b": "0xad78ebc5ac6200000",
  	"0x7c45f0f8442a56dbd39dbf159995415c52ed479b": "0x6c6b935b8bbd400000",
  	"0x7c532db9e0c06c26fd40acc56ac55c1ee92d3c3a": "0x3f870857a3e0e3800000",
  	"0x7c60a05f7a4a5f8cf2784391362e755a8341ef59": "0x6694f0182a37ae0000",
  	"0x7c60e51f0be228e4d56fdd2992c814da7740c6bc": "0xad78ebc5ac6200000",
  	"0x7c6924d07c3ef5891966fe0a7856c87bef9d2034": "0x6c6b935b8bbd400000",
  	"0x7c8bb65a6fbb49bd413396a9d7e31053bbb37aa9": "0x14542ba12a337c00000",
  	"0x7c9a110cb11f2598b2b20e2ca400325e41e9db33": "0x581767ba6189c400000",
  	"0x7cbca88fca6a0060b960985c9aa1b02534dc2208": "0x19127a1391ea2a0000",
  	"0x7cbeb99932e97e6e02058cfc62d0b26bc7cca52b": "0x6c6b935b8bbd400000",
  	"0x7cc24a6a958c20c7d1249660f7586226950b0d9a": "0x6acb3df27e1f880000",
  	"0x7cd20eccb518b60cab095b720f571570caaa447e": "0x1b1ae4d6e2ef500000",
  	"0x7cd5d81eab37e11e6276a3a1091251607e0d7e38": "0x3684d5ef981f40000",
  	"0x7cdf74213945953db39ad0e8a9781add792e4d1d": "0x6c6b935b8bbd400000",
  	"0x7ce4686446f1949ebed67215eb0d5a1dd72c11b8": "0x7839d321b81ab80000",
  	"0x7cef4d43aa417f9ef8b787f8b99d53f1fea1ee88": "0x678a932062e4180000",
  	"0x7d0350e40b338dda736661872be33f1f9752d755": "0x2b4f5a6f191948000",
  	"0x7d04d2edc058a1afc761d9c99ae4fc5c85d4c8a6": "0x42a9c4675c9467d00000",
  	"0x7d0b255efb57e10f7008aa22d40e9752dfcf0378": "0x19f8e7559924c0000",
  	"0x7d13d6705884ab2157dd8dcc7046caf58ee94be4": "0x1d0da07cbb3ee9c00000",
  	"0x7d273e637ef1eac481119413b91c989dc5eac122": "0x1b1ae4d6e2ef500000",
  	"0x7d2a52a7cf0c8436a8e007976b6c26b7229d1e15": "0x17bf06b32a241c0000",
  	"0x7d34803569e00bd6b59fff081dfa5c0ab4197a62": "0x5cd87cb7b9fb860000",
  	"0x7d34ff59ae840a7413c6ba4c5bb2ba2c75eab018": "0xa2a15d09519be00000",
  	"0x7d392852f3abd92ff4bb5bb26cb60874f2be6795": "0x3636c25e66ece70000",
  	"0x7d445267c59ab8d2a2d9e709990e09682580c49f": "0x3635c9adc5dea00000",
  	"0x7d551397f79a2988b064afd0efebee802c7721bc": "0x857e0d6f1da76a00000",
  	"0x7d5aa33fc14b51841a06906edb2bb49c2a117269": "0x104400a2470e680000",
  	"0x7d5d2f73949dadda0856b206989df0078d51a1e5": "0x23c757072b8dd000000",
  	"0x7d6e990daa7105de2526339833f77b5c0b85d84f": "0x43c33c1937564800000",
  	"0x7d73863038ccca22f96affda10496e51e1e6cd48": "0x1158e460913d00000",
  	"0x7d7dd5ee614dbb6fbfbcd26305247a058c41faa1": "0x6c6b935b8bbd400000",
  	"0x7d7e7c61779adb7706c94d32409a2bb4e994bf60": "0x2ef20d9fc71a140000",
  	"0x7d82e523cc2dc591da3954e8b6bb2caf6461e69c": "0x7d8dc2efffb1a90000",
  	"0x7d858493f07415e0912d05793c972113eae8ae88": "0x628dd177d2bc280000",
  	"0x7d901b28bf7f88ef73d8f73cca97564913ea8a24": "0x33c5499031720c0000",
  	"0x7d980f4b566bb045517e4c14c87750de9346744b": "0x487a9a304539440000",
  	"0x7d9c59631e2ba2e8e82891f3979922aaa3b567a1": "0x1b1ae4d6e2ef5000000",
  	"0x7d9d221a3df89ddd7b5f61c1468c6787d6b333e6": "0x77b227cd83be80000",
  	"0x7da7613445a21299aa74f0ad71431ec43fbb1be9": "0x3afb087b876900000",
  	"0x7db4c7d5b797e9296e6382f203693db409449d62": "0x15af1d78b58c400000",
  	"0x7db9eacc52e429dc83b461c5f4d86010e5383a28": "0x3635c9adc5dea00000",
  	"0x7dd46da677e161825e12e80dc446f58276e1127c": "0x2c73c937742c500000",
  	"0x7dd8d7a1a34fa1f8e73ccb005fc2a03a15b8229c": "0xad78ebc5ac6200000",
  	"0x7ddd57165c87a2707f025dcfc2508c09834759bc": "0x4be4e7267b6ae00000",
  	"0x7de442c82386154d2e993cbd1280bb7ca6b12ada": "0xd8f2e8247ec9480000",
  	"0x7de7fe419cc61f91f408d234cc80d5ca3d054d99": "0x1158e460913d00000",
  	"0x7dece6998ae1900dd3770cf4b93812bad84f0322": "0x56bc75e2d63100000",
  	"0x7dfc342dffcf45dfee74f84c0995397bd1a63172": "0xd8d726b7177a80000",
  	"0x7dfd2962b575bcbeee97f49142d63c30ab009f66": "0xd8d726b7177a800000",
  	"0x7e1e29721d6cb91057f6c4042d8a0bbc644afe73": "0x8a9aba557e36c0000",
  	"0x7e236666b2d06e63ea4e2ab84357e2dfc977e50e": "0x36356633ebd8ea0000",
  	"0x7e24d9e22ce1da3ce19f219ccee523376873f367": "0x13fd9079caa60ff0000",
  	"0x7e24fbdad290175eb2df6d180a19b9a9f41370be": "0x3635c9adc5dea00000",
  	"0x7e268f131ddf687cc325c412f78ba961205e9112": "0x36364ee7d301b3c0000",
  	"0x7e29290038493559194e946d4e460b96fc38a156": "0x10c13c527763880000",
  	"0x7e2ba86da52e785d8625334f3397ba1c4bf2e8d1": "0xaadec983fcff40000",
  	"0x7e3f63e13129a221ba1ab06326342cd98b5126ae": "0x56a02659a523340000",
  	"0x7e47637e97c14622882be057bea229386f4052e5": "0x17da3a04c7b3e00000",
  	"0x7e4e9409704121d1d77997026ff06ea9b19a8b90": "0x8d16549ed58fa40000",
  	"0x7e59dc60be8b2fc19abd0a5782c52c28400bce97": "0x3635c9adc5dea00000",
  	"0x7e5b19ae1be94ff4dee635492a1b012d14db0213": "0x56bc75e2d63100000",
  	"0x7e5d9993104e4cb545e179a2a3f971f744f98482": "0x6c6b935b8bbd400000",
  	"0x7e71171f2949fa0c3ac254254b1f0440e5e6a038": "0x22b1c8c1227a00000",
  	"0x7e7c1e9a61a08a83984835c70ec31d34d3eaa87f": "0xa5aa85009e39c0000",
  	"0x7e7f18a02eccaa5d61ab8fbf030343c434a25ef7": "0x39fbae8d042dd0000",
  	"0x7e81f6449a03374191f3b7cb05d938b72e090dff": "0x56bc75e2d63100000",
  	"0x7e8649e690fc8c1bfda1b5e186581f649b50fe33": "0x556f64c1fe7fa0000",
  	"0x7e87863ec43a481df04d017762edcb5caa629b5a": "0x222c8eb3ff6640000",
  	"0x7e8f96cc29f57b0975120cb593b7dd833d606b53": "0xaadec983fcff40000",
  	"0x7e972a8a7c2a44c93b21436c38d21b9252c345fe": "0x61093d7c2c6d380000",
  	"0x7e99dfbe989d3ba529d19751b7f4317f8953a3e2": "0x15af1d78b58c400000",
  	"0x7ea0f96ee0a573a330b56897761f3d4c0130a8e3": "0x487a9a304539440000",
  	"0x7ea791ebab0445a00efdfc4e4a8e9a7e7565136d": "0xfc936392801c0000",
  	"0x7eaba035e2af3793fd74674b102540cf190addb9": "0x45026c835b60440000",
  	"0x7eb4b0185c92b6439a08e7322168cb353c8a774a": "0x227196ca04983ca0000",
  	"0x7ebd95e9c470f7283583dc6e9d2c4dce0bea8f84": "0x2f6f10780d22cc00000",
  	"0x7ed0a5a847bef9a9da7cba1d6411f5c316312619": "0x228eb37e8751d0000",
  	"0x7edafba8984baf631a820b6b92bbc2c53655f6bd": "0x6c6b935b8bbd400000",
  	"0x7edb02c61a227287611ad950696369cc4e647a68": "0xeda838c4929080000",
  	"0x7ee5ca805dce23af89c2d444e7e40766c54c7404": "0xd0bd412edbd820000",
  	"0x7ee604c7a9dc2909ce321de6b9b24f5767577555": "0x12bf9c7985cf62d8000",
  	"0x7ef16fd8d15b378a0fba306b8d03dd98fc92619f": "0x25f273933db5700000",
  	"0x7ef98b52bee953bef992f305fda027f8911c5851": "0x1be722206996bc8000",
  	"0x7efc90766a00bc52372cac97fabd8a3c831f8ecd": "0x890b0c2e14fb80000",
  	"0x7efec0c6253caf397f71287c1c07f6c9582b5b86": "0x1a2cbcb84f30d58000",
  	"0x7f01dc7c3747ca608f983dfc8c9b39e755a3b914": "0xb386cad5f7a5a0000",
  	"0x7f0662b410298c99f311d3a1454a1eedba2fea76": "0xad78ebc5ac6200000",
  	"0x7f06c89d59807fa60bc60136fcf814cbaf2543bd": "0x21e19e0c9bab2400000",
  	"0x7f0b90a1fdd48f27b268feb38382e55ddb50ef0f": "0x32f51edbaaa3300000",
  	"0x7f0ec3db804692d4d1ea3245365aab0590075bc4": "0xd8d726b7177a800000",
  	"0x7f0f04fcf37a53a4e24ede6e93104e78be1d3c9e": "0x6c6b935b8bbd400000",
  	"0x7f13d760498d7193ca6859bc95c901386423d76c": "0x10f0cf064dd59200000",
  	"0x7f150afb1a77c2b45928c268c1e9bdb4641d47d8": "0x6c6b935b8bbd400000",
  	"0x7f1619988f3715e94ff1d253262dc5581db3de1c": "0x30ca024f987b900000",
  	"0x7f1c81ee1697fc144b7c0be5493b5615ae7fddca": "0x1b1dab61d3aa640000",
  	"0x7f2382ffd8f83956467937f9ba72374623f11b38": "0x2086ac351052600000",
  	"0x7f3709391f3fbeba3592d175c740e87a09541d02": "0x1a055690d9db800000",
  	"0x7f389c12f3c6164f6446566c77669503c2792527": "0x556f64c1fe7fa0000",
  	"0x7f3a1e45f67e92c880e573b43379d71ee089db54": "0x152d02c7e14af6800000",
  	"0x7f3d7203c8a447f7bf36d88ae9b6062a5eee78ae": "0x14542ba12a337c00000",
  	"0x7f46bb25460dd7dae4211ca7f15ad312fc7dc75c": "0x16a6502f15a1e540000",
  	"0x7f49e7a4269882bd8722d4a6f566347629624079": "0x6c6b935b8bbd400000",
  	"0x7f49f20726471ac1c7a83ef106e9775ceb662566": "0x14061b9d77a5e980000",
  	"0x7f4b5e278578c046cceaf65730a0e068329ed5b6": "0x65ea3db75546600000",
  	"0x7f4f593b618c330ba2c3d5f41eceeb92e27e426c": "0x966edc756b7cfc0000",
  	"0x7f541491d2ac00d2612f94aa7f0bcb014651fbd4": "0x14620c57dddae00000",
  	"0x7f5ae05ae0f8cbe5dfe721f044d7a7bef4c27997": "0x340aad21b3b700000",
  	"0x7f603aec1759ea5f07c7f8d41a1428fbbaf9e762": "0x1158e460913d00000",
  	"0x7f616c6f008adfa082f34da7d0650460368075fb": "0x3635c9adc5dea00000",
  	"0x7f61fa6cf5f898b440dac5abd8600d6d691fdef9": "0xf2dc7d47f15600000",
  	"0x7f655c6789eddf455cb4b88099720639389eebac": "0x14542ba12a337c00000",
  	"0x7f6b28c88421e4857e459281d78461692489d3fb": "0x6c6b935b8bbd400000",
  	"0x7f6efb6f4318876d2ee624e27595f44446f68e93": "0x54069233bf7f780000",
  	"0x7f7192c0df1c7db6d9ed65d71184d8e4155a17ba": "0x453728d33942c0000",
  	"0x7f7a3a21b3f5a65d81e0fcb7d52dd00a1aa36dba": "0x56bc75e2d63100000",
  	"0x7f8dbce180ed9c563635aad2d97b4cbc428906d9": "0x90f534608a72880000",
  	"0x7f993ddb7e02c282b898f6155f680ef5b9aff907": "0x43c33c1937564800000",
  	"0x7f9f9b56e4289dfb58e70fd5f12a97b56d35c6a5": "0x6acb3df27e1f880000",
  	"0x7fa37ed67887751a471f0eb306be44e0dbcd6089": "0x3976747fe11a100000",
  	"0x7faa30c31519b584e97250ed2a3cf3385ed5fd50": "0x6c6b935b8bbd400000",
  	"0x7fcf5ba6666f966c5448c17bf1cb0bbcd8019b06": "0x56bc3d0aebe498000",
  	"0x7fd679e5fb0da2a5d116194dcb508318edc580f3": "0x1639e49bba162800000",
  	"0x7fdba031c78f9c096d62d05a369eeab0bccc55e5": "0x97c9ce4cf6d5c00000",
  	"0x7fdbc3a844e40d96b2f3a635322e6065f4ca0e84": "0x6c6b935b8bbd400000",
  	"0x7fdfc88d78bf1b285ac64f1adb35dc11fcb03951": "0x7c06fda02fb0360000",
  	"0x7fea1962e35d62059768c749bedd96cab930d378": "0x6c6b935b8bbd400000",
  	"0x7fef8c38779fb307ec6f044bebe47f3cfae796f1": "0x92340f86cf09e8000",
  	"0x7ff0c63f70241bece19b737e5341b12b109031d8": "0x12c1b6eed03d280000",
  	"0x7ffabfbc390cbe43ce89188f0868b27dcb0f0cad": "0x1595182224b26480000",
  	"0x7ffd02ed370c7060b2ae53c078c8012190dfbb75": "0x21e19e0c9bab2400000",
  	"0x80022a1207e910911fc92849b069ab0cdad043d3": "0xb98bc829a6f90000",
  	"0x8009a7cbd192b3aed4adb983d5284552c16c7451": "0xd8d726b7177a800000",
  	"0x800e7d631c6e573a90332f17f71f5fd19b528cb9": "0x83d6c7aab63600000",
  	"0x80156d10efa8b230c99410630d37e269d4093cea": "0x6c6b935b8bbd400000",
  	"0x801732a481c380e57ed62d6c29de998af3fa3b13": "0x56bc75e2d63100000",
  	"0x801d65c518b11d0e3f4f470221417013c8e53ec5": "0xd8d726b7177a800000",
  	"0x8026435aac728d497b19b3e7e57c28c563954f2b": "0x5dc892aa1131c80000",
  	"0x802dc3c4ff2d7d925ee2859f4a06d7ba60f1308c": "0x550940c8fd34c0000",
  	"0x8030b111c6983f0485ddaca76224c6180634789f": "0x4563918244f400000",
  	"0x8035bcffaefdeeea35830c497d14289d362023de": "0x1043561a8829300000",
  	"0x8035fe4e6b6af27ae492a578515e9d39fa6fa65b": "0xd8d726b7177a800000",
  	"0x8043ed22f997e5a2a4c16e364486ae64975692c4": "0x3d4904ffc9112e8000",
  	"0x8043fdd0bc4c973d1663d55fc135508ec5d4f4fa": "0x1158e460913d00000",
  	"0x804ca94972634f633a51f3560b1d06c0b293b3b1": "0xad78ebc5ac6200000",
  	"0x80522ddf944ec52e27d724ed4c93e1f7be6083d6": "0xad78ebc5ac6200000",
  	"0x80591a42179f34e64d9df75dcd463b28686f5574": "0x43c33c1937564800000",
  	"0x805ce51297a0793b812067f017b3e7b2df9bb1f9": "0x56bc75e2d63100000",
  	"0x805d846fb0bc02a7337226d685be9ee773b9198a": "0x43c30fb0884a96c0000",
  	"0x8063379a7bf2cb923a84c5093e68dac7f75481c5": "0x1176102e6e32df0000",
  	"0x806854588ecce541495f81c28a290373df0274b2": "0x1f8cdf5c6e8d580000",
  	"0x806f44bdeb688037015e84ff218049e382332a33": "0x6c5db2a4d815dc0000",
  	"0x80744618de396a543197ee4894abd06398dd7c27": "0x6c6b935b8bbd400000",
  	"0x8077c3e4c445586e094ce102937fa05b737b568c": "0x56bc75e2d63100000",
  	"0x80907f593148b57c46c177e23d25abc4aae18361": "0x56bc75e2d63100000",
  	"0x80977316944e5942e79b0e3abad38da746086519": "0x21a754a6dc5280000",
  	"0x80a0f6cc186cf6201400736e065a391f52a9df4a": "0x21e19e0c9bab2400000",
  	"0x80abec5aa36e5c9d098f1b942881bd5acac6963d": "0x6c6b935b8bbd400000",
  	"0x80b23d380b825c46e0393899a85556462da0e18c": "0x6c6b935b8bbd400000",
  	"0x80b42de170dbd723f454e88f7716452d92985092": "0x104623c0762dd10000",
  	"0x80b79f338390d1ba1b3737a29a0257e5d91e0731": "0x1158e460913d00000",
  	"0x80bf995ed8ba92701d10fec49f9e7d014dbee026": "0x1f0437ca1a7e128000",
  	"0x80c04efd310f440483c73f744b5b9e64599ce3ec": "0x410d586a20a4c00000",
  	"0x80c3a9f695b16db1597286d1b3a8b7696c39fa27": "0x56bc75e2d63100000",
  	"0x80c53ee7e3357f94ce0d7868009c208b4a130125": "0x6c6b935b8bbd400000",
  	"0x80cc21bd99f39005c58fe4a448909220218f66cb": "0x3636c9796436740000",
  	"0x80d5c40c59c7f54ea3a55fcfd175471ea35099b3": "0x3635c9adc5dea00000",
  	"0x80da2fdda29a9e27f9e115975e69ae9cfbf3f27e": "0xad78ebc5ac6200000",
  	"0x80e7b3205230a566a1f061d922819bb4d4d2a0e1": "0x2f6f10780d22cc00000",
  	"0x80ea1acc136eca4b68c842a95adf6b7fee7eb8a2": "0xd8d726b7177a800000",
  	"0x80f07ac09e7b2c3c0a3d1e9413a544c73a41becb": "0x1158e460913d00000",
  	"0x810db25675f45ea4c7f3177f37ce29e22d67999c": "0xad78ebc5ac6200000",
  	"0x81139bfdcca656c430203f72958c543b6580d40c": "0x6c6b935b8bbd400000",
  	"0x811461a2b0ca90badac06a9ea16e787b33b196cc": "0x8e3f50b173c100000",
  	"0x81164deb10814ae08391f32c08667b6248c27d7a": "0x155bd9307f9fe80000",
  	"0x81186931184137d1192ac88cd3e1e5d0fdb86a74": "0x9d3595ab2438d00000",
  	"0x812a55c43caedc597218379000ce510d548836fd": "0xfc936392801c0000",
  	"0x812ea7a3b2c86eed32ff4f2c73514cc63bacfbce": "0x3635c9adc5dea00000",
  	"0x8134dd1c9df0d6c8a5812426bb55c761ca831f08": "0x6a2160bb57ccc0000",
  	"0x814135da8f9811075783bf1ab67062af8d3e9f40": "0x1158e460913d00000",
  	"0x81498ca07b0f2f17e8bbc7e61a7f4ae7be66b78b": "0x581fbb5b33bb00000",
  	"0x81556db27349ab8b27004944ed50a46e941a0f5f": "0xd8bb6549b02bb80000",
  	"0x8155fa6c51eb31d808412d748aa086105018122f": "0x65ea3db75546600000",
  	"0x8156360bbd370961ceca6b6691d75006ad204cf2": "0x878678326eac9000000",
  	"0x8161d940c3760100b9080529f8a60325030f6edc": "0x1043561a8829300000",
  	"0x8164e78314ae16b28926cc553d2ccb16f356270d": "0x1ca134e95fb32c80000",
  	"0x8165cab0eafb5a328fc41ac64dae715b2eef2c65": "0x3635c9adc5dea00000",
  	"0x8168edce7f2961cf295b9fcd5a45c06cdeda6ef5": "0xad78ebc5ac6200000",
  	"0x816d9772cf11399116cc1e72c26c6774c9edd739": "0xad78ebc5ac6200000",
  	"0x8173c835646a672e0152be10ffe84162dd256e4c": "0x1aabdf2145b4300000",
  	"0x817493cd9bc623702a24a56f9f82e3fd48f3cd31": "0x9e4b23f12d4ca00000",
  	"0x8179c80970182cc5b7d82a4df06ea94db63a25f3": "0x276f259de66bf40000",
  	"0x817ac33bd8f847567372951f4a10d7a91ce3f430": "0xad7c406c66dc18000",
  	"0x818ffe271fc3973565c303f213f6d2da89897ebd": "0x136e05342fee1b98000",
  	"0x8197948121732e63d9c148194ecad46e30b749c8": "0xd8d726b7177a800000",
  	"0x819af9a1c27332b1c369bbda1b3de1c6e933d640": "0x1109e654b98f7a0000",
  	"0x819cdaa5303678ef7cec59d48c82163acc60b952": "0x31351545f79816c0000",
  	"0x819eb4990b5aba5547093da12b6b3c1093df6d46": "0x3635c9adc5dea00000",
  	"0x81a88196fac5f23c3e12a69dec4b880eb7d97310": "0x6c6b935b8bbd400000",
  	"0x81bccbff8f44347eb7fca95b27ce7c952492aaad": "0x840c12165dd780000",
  	"0x81bd75abd865e0c3f04a0b4fdbcb74d34082fbb7": "0xd8d726b7177a800000",
  	"0x81c18c2a238ddc4cba230a072dd7dc101e620273": "0x487a9a304539440000",
  	"0x81c9e1aee2d3365d53bcfdcd96c7c538b0fd7eec": "0x62a992e53a0af00000",
  	"0x81cfad760913d3c322fcc77b49c2ae3907e74f6e": "0xaadec983fcff40000",
  	"0x81d619ff5726f2405f12904c72eb1e24a0aaee4f": "0x43c33c1937564800000",
  	"0x81efe296ae76c860d1c5fbd33d47e8ce9996d157": "0x3635c9adc5dea00000",
  	"0x81f8de2c283d5fd4afbda85dedf9760eabbbb572": "0xa2a15d09519be00000",
  	"0x820c19291196505b65059d9914b7090be1db87de": "0x796e3ea3f8ab00000",
  	"0x821cb5cd05c7ef909fe1be60733d8963d760dc41": "0xd8d726b7177a800000",
  	"0x821d798af19989c3ae5b84a7a7283cd7fda1fabe": "0x43c33c1937564800000",
  	"0x821eb90994a2fbf94bdc3233910296f76f9bf6e7": "0x21e19e0c9bab2400000",
  	"0x82249fe70f61c6b16f19a324840fdc020231bb02": "0x20336b08a93635b0000",
  	"0x8228ebc087480fd64547ca281f5eace3041453b9": "0x6acb3df27e1f880000",
  	"0x8229ceb9f0d70839498d44e6abed93c5ca059f5d": "0x1a1c1b3c989a20100000",
  	"0x822edff636563a6106e52e9a2598f7e6d0ef2782": "0x1f4f9693d42d38000",
  	"0x823219a25976bb2aa4af8bad41ac3526b493361f": "0x6c6b935b8bbd400000",
  	"0x8232d1f9742edf8dd927da353b2ae7b4cbce7592": "0x243d4d18229ca20000",
  	"0x8234f463d18485501f8f85ace4972c9b632dbccc": "0x6c6b935b8bbd400000",
  	"0x823768746737ce6da312d53e54534e106f967cf3": "0x1158e460913d00000",
  	"0x823ba7647238d113bce9964a43d0a098118bfe4d": "0xad78ebc5ac6200000",
  	"0x824074312806da4748434266ee002140e3819ac2": "0x51b1d3839261ac0000",
  	"0x82438fd2b32a9bdd674b49d8cc5fa2eff9781847": "0x1158e460913d00000",
  	"0x82485728d0e281563758c75ab27ed9e882a0002d": "0x7f808e9291e6c0000",
  	"0x824b3c3c443e19295d7ef6faa7f374a4798486a8": "0x1158e460913d00000",
  	"0x8251358ca4e060ddb559ca58bc0bddbeb4070203": "0x6c6b935b8bbd400000",
  	"0x825135b1a7fc1605614c8aa4d0ac6dbad08f480e": "0x4d853c8f8908980000",
  	"0x825309a7d45d1812f51e6e8df5a7b96f6c908887": "0x8034f7d9b166d40000",
  	"0x825a7f4e10949cb6f8964268f1fa5f57e712b4c4": "0x1158e460913d00000",
  	"0x8261fa230c901d43ff579f4780d399f31e6076bc": "0x6c6b935b8bbd400000",
  	"0x8262169b615870134eb4ac6c5f471c6bf2f789fc": "0x19127a1391ea2a0000",
  	"0x8263ece5d709e0d7ae71cca868ed37cd2fef807b": "0x35ab028ac154b80000",
  	"0x826ce5790532e0548c6102a30d3eac836bd6388f": "0x3cfc82e37e9a7400000",
  	"0x826eb7cd7319b82dd07a1f3b409071d96e39677f": "0x3635c9adc5dea00000",
  	"0x827531a6c5817ae35f82b00b9754fcf74c55e232": "0xc328093e61ee400000",
  	"0x8275cd684c3679d5887d03664e338345dc3cdde1": "0xdb44e049bb2c0000",
  	"0x8284923b62e68bbf7c2b9f3414d13ef6c812a904": "0xd255d112e103a00000",
  	"0x828ba651cb930ed9787156299a3de44cd08b7212": "0x487a9a304539440000",
  	"0x82a15cef1d6c8260eaf159ea3f0180d8677dce1c": "0x6c6b935b8bbd400000",
  	"0x82a8b96b6c9e13ebec1e9f18ac02a60ea88a48ff": "0x6c6b8c408e73b30000",
  	"0x82a8cbbfdff02b2e38ae4bbfca15f1f0e83b1aea": "0x49b991c27ef6d8000",
  	"0x82e4461eb9d849f0041c1404219e4272c4900ab4": "0x6c6b935b8bbd400000",
  	"0x82e577b515cb2b0860aafe1ce09a59e09fe7d040": "0x2086ac351052600000",
  	"0x82ea01e3bf2e83836e71704e22a2719377efd9c3": "0xa4cc799563c3800000",
  	"0x82f2e991fd324c5f5d17768e9f61335db6319d6c": "0x1b1ae4d6e2ef500000",
  	"0x82f39b2758ae42277b86d69f75e628d958ebcab0": "0x878678326eac9000000",
  	"0x82f854c9c2f087dffa985ac8201e626ca5467686": "0x152d02c7e14af6800000",
  	"0x82ff716fdf033ec7e942c909d9831867b8b6e2ef": "0x61093d7c2c6d380000",
  	"0x8308ed0af7f8a3c1751fafc877b5a42af7d35882": "0x3635c9adc5dea00000",
  	"0x831c44b3084047184b2ad218680640903750c45d": "0x6acb3df27e1f880000",
  	"0x83210583c16a4e1e1dac84ebd37e3d0f7c57eba4": "0x6c6b935b8bbd400000",
  	"0x832c54176bdf43d2c9bcd7b808b89556b89cbf31": "0xad78ebc5ac6200000",
  	"0x833316985d47742bfed410604a91953c05fb12b0": "0x6c6b935b8bbd400000",
  	"0x8334764b7b397a4e578f50364d60ce44899bff94": "0x503b203e9fba20000",
  	"0x833b6a8ec8da408186ac8a7d2a6dd61523e7ce84": "0x3635c9adc5dea000000",
  	"0x833d3fae542ad5f8b50ce19bde2bec579180c88c": "0x12c1b6eed03d280000",
  	"0x833db42c14163c7be4cab86ac593e06266d699d5": "0x24e40d2b6943ef900000",
  	"0x83563bc364ed81a0c6da3b56ff49bbf267827a9c": "0x3ab91d17b20de500000",
  	"0x837a645dc95c49549f899c4e8bcf875324b2f57c": "0x208c394af1c8880000",
  	"0x838bd565f99fde48053f7917fe333cf84ad548ab": "0xad78ebc5ac6200000",
  	"0x83908aa7478a6d1c9b9b0281148f8f9f242b9fdc": "0x6c6b935b8bbd400000",
  	"0x8392e53776713578015bff4940cf43849d7dcba1": "0x84df0355d56170000",
  	"0x8397a1bc47acd647418159b99cea57e1e6532d6e": "0x1f10fa827b550b40000",
  	"0x8398e07ebcb4f75ff2116de77c1c2a99f303a4cf": "0x1b1ae4d6e2ef500000",
  	"0x83a3148833d9644984f7c475a7850716efb480ff": "0xb8507a820728200000",
  	"0x83a402438e0519773d5448326bfb61f8b20cf52d": "0x52663ccab1e1c00000",
  	"0x83a93b5ba41bf88720e415790cdc0b67b4af34c4": "0xad78ebc5ac6200000",
  	"0x83c23d8a502124ee150f08d71dc6727410a0f901": "0x7331f3bfe661b180000",
  	"0x83c897a84b695eebe46679f7da19d776621c2694": "0x1b1ae4d6e2ef500000",
  	"0x83d532d38d6dee3f60adc68b936133c7a2a1b0dd": "0x1b1ae4d6e2ef500000",
  	"0x83dbf8a12853b40ac61996f8bf1dc8fdbaddd329": "0x34957444b840e80000",
  	"0x83dbfd8eda01d0de8e158b16d0935fc2380a5dc7": "0x2086ac351052600000",
  	"0x83e48055327c28b5936fd9f4447e73bdb2dd3376": "0x90f534608a72880000",
  	"0x83fe5a1b328bae440711beaf6aad6026eda6d220": "0x43c33c1937564800000",
  	"0x84008a72f8036f3feba542e35078c057f32a8825": "0x56bc75e2d63100000",
  	"0x840ec83ea93621f034e7bb3762bb8e29ded4c479": "0x878678326eac900000",
  	"0x841145b44840c946e21dbc190264b8e0d5029369": "0x3f870857a3e0e3800000",
  	"0x84232107932b12e03186583525ce023a703ef8d9": "0x6c6b935b8bbd400000",
  	"0x84244fc95a6957ed7c1504e49f30b8c35eca4b79": "0x6c6b935b8bbd400000",
  	"0x8431277d7bdd10457dc017408c8dbbbd414a8df3": "0x222c8eb3ff6640000",
  	"0x84375afbf59b3a1d61a1be32d075e0e15a4fbca5": "0xad78ebc5ac6200000",
  	"0x843bd3502f45f8bc4da370b323bdac3fcf5f19a6": "0x50039d63d11c900000",
  	"0x84503334630d77f74147f68b2e086613c8f1ade9": "0x56bc75e2d631000000",
  	"0x845203750f7148a9aa262921e86d43bf641974fd": "0x56bc75e2d63100000",
  	"0x8461ecc4a6a45eb1a5b947fb86b88069b91fcd6f": "0x6c6b935b8bbd400000",
  	"0x84675e9177726d45eaa46b3992a340ba7f710c95": "0x3635c9adc5dea00000",
  	"0x84686c7bad762c54b667d59f90943cd14d117a26": "0x1158e460913d00000",
  	"0x8489f6ad1d9a94a297789156899db64154f1dbb5": "0x137407c03c8c268000",
  	"0x848c994a79003fe7b7c26cc63212e1fc2f9c19eb": "0x6c6b935b8bbd400000",
  	"0x848fbd29d67cf4a013cb02a4b176ef244e9ee68d": "0x1172a636bbdc20000",
  	"0x84949dba559a63bfc845ded06e9f2d9b7f11ef24": "0x6c6b935b8bbd400000",
  	"0x849ab80790b28ff1ffd6ba394efc7463105c36f7": "0x1e02be4ae6c840000",
  	"0x849b116f596301c5d8bb62e0e97a8248126e39f3": "0x1043561a8829300000",
  	"0x84a74ceecff65cb93b2f949d773ef1ad7fb4a245": "0x50a9b444685c70000",
  	"0x84aac7fa197ff85c30e03b7a5382b957f41f3afb": "0x88b23acffd9900000",
  	"0x84af1b157342d54368260d17876230a534b54b0e": "0x35659ef93f0fc40000",
  	"0x84b0ee6bb837d3a4c4c5011c3a228c0edab4634a": "0x1158e460913d00000",
  	"0x84b4b74e6623ba9d1583e0cfbe49643f16384149": "0x1158e460913d00000",
  	"0x84b6b6adbe2f5b3e2d682c66af1bc4905340c3ed": "0x2192f8d22215008000",
  	"0x84b91e2e2902d05e2b591b41083bd7beb2d52c74": "0x215e5128b4504648000",
  	"0x84bcbf22c09607ac84341d2edbc03bfb1739d744": "0x1b1ae4d6e2ef500000",
  	"0x84bfcef0491a0ae0694b37ceac024584f2aa0467": "0x6c6acc67d7b1d40000",
  	"0x84cb7da0502df45cf561817bbd2362f451be02da": "0x487a9a304539440000",
  	"0x84cc7878da605fdb019fab9b4ccfc157709cdda5": "0x48798513af04c90000",
  	"0x84db1459bb00812ea67ecb3dc189b72187d9c501": "0x811b8fbda85ab8000",
  	"0x84e9949680bece6841b9a7e5250d08acd87d16cd": "0xad78ebc5ac6200000",
  	"0x84e9cf8166c36abfa49053b7a1ad4036202681ef": "0x6c6b935b8bbd400000",
  	"0x84ec06f24700fe42414cb9897c154c88de2f6132": "0x487a9a304539440000",
  	"0x84f522f0520eba52dd18ad21fa4b829f2b89cb97": "0x10c5106d5134f130000",
  	"0x850b9db18ff84bf0c7da49ea3781d92090ad7e64": "0x8cf23f909c0fa00000",
  	"0x8510ee934f0cbc900e1007eb38a21e2a5101b8b2": "0x5bf0ba6634f680000",
  	"0x8516fcaf77c893970fcd1a958ba9a00e49044019": "0xaa3eb1691bce58000",
  	"0x851aa91c82f42fad5dd8e8bb5ea69c8f3a5977d1": "0x80e561f2578798000",
  	"0x851c0d62be4635d4777e8035e37e4ba8517c6132": "0x1b1ae4d6e2ef500000",
  	"0x851dc38adb4593729a76f33a8616dab6f5f59a77": "0x56bc75e2d63100000",
  	"0x8532490897bbb4ce8b7f6b837e4cba848fbe9976": "0x56bc75e2d63100000",
  	"0x853e6abaf44469c72f151d4e223819aced4e3728": "0x6c6b935b8bbd400000",
  	"0x854691ce714f325ced55ce5928ce9ba12facd1b8": "0xed70b5e9c3f2f00000",
  	"0x854c0c469c246b83b5d1b3eca443b39af5ee128a": "0x56bc75e2d631000000",
  	"0x855d9aef2c39c6230d09c99ef6494989abe68785": "0x8ba52e6fc45e40000",
  	"0x8563c49361b625e768771c96151dbfbd1c906976": "0x6c6b935b8bbd400000",
  	"0x8566610901aace38b83244f3a9c831306a67b9dc": "0xb08213bcf8ffe00000",
  	"0x856aa23c82d7215bec8d57f60ad75ef14fa35f44": "0x43c33c1937564800000",
  	"0x856e5ab3f64c9ab56b009393b01664fc0324050e": "0x61093d7c2c6d380000",
  	"0x856eb204241a87830fb229031343dc30854f581a": "0x3635c9adc5dea00000",
  	"0x85732c065cbd64119941aed430ac59670b6c51c4": "0x27a57362ab0a0e8000",
  	"0x8578e10212ca14ff0732a8241e37467db85632a9": "0x14542ba12a337c00000",
  	"0x8579dadf1a395a3471e20b6f763d9a0ff19a3f6f": "0xd8d726b7177a800000",
  	"0x857f100b1a5930225efc7e9020d78327b41c02cb": "0x6c6b935b8bbd400000",
  	"0x85946d56a4d371a93368539690b60ec825107454": "0x5dc892aa1131c80000",
  	"0x8599cbd5a6a9dcd4b966be387d69775da5e33c6f": "0xc51f1b1d52622900000",
  	"0x859c600cf13d1d0273d5d1da3cd789e495899f27": "0x90f534608a72880000",
  	"0x85a2f6ea94d05e8c1d9ae2f4910338a358e98ded": "0x6c6b935b8bbd400000",
  	"0x85b16f0b8b34dff3804f69e2168a4f7b24d1042b": "0x112f423c7646d40000",
  	"0x85b2998d0c73302cb2ba13f489313301e053be15": "0x21e19e0c9bab2400000",
  	"0x85bb51bc3bfe9a1b2a2f6b1cda95bca8b38c8d5e": "0x11712da04ba1ef0000",
  	"0x85c8f3cc7a354feac99a5e7bfe7cdfa351cfe355": "0x15af1d78b58c400000",
  	"0x85ca1e727e9d1a87991cc2c41840ebb9edf21d1b": "0xb98bc829a6f90000",
  	"0x85ca8bc6da2803d0725f5e1a456c89f9bc774e2f": "0x2086ac351052600000",
  	"0x85d0d88754ac84b8b21ba93dd2bfec72626faba8": "0x3635c9adc5dea00000",
  	"0x85eb256b51c819d60ea61a82d12c9358d59c1cae": "0x18efc84ad0c7b00000",
  	"0x85f0e7c1e3aff805a627a2aaf2cff6b4c0dbe9cb": "0x1158e460913d00000",
  	"0x86026cad3fe4ea1ce7fca260d3d45eb09ea6a364": "0xad78ebc5ac6200000",
  	"0x860f5ffc10de767ded807f71e861d647dfd219b1": "0x21e19e0c9bab2400000",
  	"0x86153063a1ae7f02f1a88136d4d69c7c5e3e4327": "0x3635c9adc5dea00000",
  	"0x86245f596691093ece3f3d3ca2263eace81941d9": "0xa31062beeed700000",
  	"0x862569211e8c6327b5415e3a67e5738b15baaf6e": "0x796e3ea3f8ab00000",
  	"0x86297d730fe0f7a9ee24e08fb1087b31adb306a7": "0x6c6b935b8bbd400000",
  	"0x8644cc281be332ccced36da483fb2a0746d9ba2e": "0x15af1d78b58c400000",
  	"0x86499a1228ff2d7ee307759364506f8e8c8307a5": "0x6acb3df27e1f880000",
  	"0x864bec5069f855a4fd5892a6c4491db07c88ff7c": "0x3635c9adc5dea00000",
  	"0x86570ab259c9b1c32c9729202f77f590c07dd612": "0xad78ebc5ac6200000",
  	"0x8663a241a0a89e70e182c845e2105c8ad7264bcf": "0x323b13d8398f3238000",
  	"0x8667fa1155fed732cfb8dca5a0d765ce0d0705ed": "0x46ec965c393b10000",
  	"0x8668af868a1e98885f937f2615ded6751804eb2d": "0x1158e460913d00000",
  	"0x86740a46648e845a5d96461b18091ff57be8a16f": "0x14c0973485bf39400000",
  	"0x867eba56748a5904350d2ca2a5ce9ca00b670a9b": "0x43c33c1937564800000",
  	"0x86806474c358047d9406e6a07f40945bc8328e67": "0x1752eb0f7013d100000",
  	"0x86883d54cd3915e549095530f9ab1805e8c5432d": "0xd8d726b7177a800000",
  	"0x868c23be873466d4c74c220a19b245d1787e807f": "0x4a13bbbd92c88e8000",
  	"0x86924fb211aad23cf5ce600e0aae806396444087": "0x21e19e0c9bab2400000",
  	"0x8693e9b8be94425eef7969bc69f9d42f7cad671e": "0x3637096c4bcc690000",
  	"0x869f1aa30e4455beb1822091de5cadec79a8f946": "0x1b1ae4d6e2ef5000000",
  	"0x86a1eadeeb30461345d9ef6bd05216fa247c0d0c": "0x6c6b935b8bbd400000",
  	"0x86a5f8259ed5b09e188ce346ee92d34aa5dd93fa": "0xad78ebc5ac6200000",
  	"0x86b7bd563ceab686f96244f9ddc02ad7b0b14bc2": "0x21e19e0c9bab2400000",
  	"0x86c28b5678af37d727ec05e4447790f15f71f2ea": "0xad78ebc5ac6200000",
  	"0x86c4ce06d9ac185bb148d96f7b7abe73f441006d": "0x21e19e0c9bab2400000",
  	"0x86c8d0d982b539f48f9830f9891f9d607a942659": "0x2ced37761824fb00000",
  	"0x86c934e38e53be3b33f274d0539cfca159a4d0d1": "0x34957444b840e80000",
  	"0x86ca0145957e6b0dfe36875fbe7a0dec55e17a28": "0x21e19e0c9bab2400000",
  	"0x86caafacf32aa0317c032ac36babed974791dc03": "0x878678326eac9000000",
  	"0x86cdb7e51ac44772be3690f61d0e59766e8bfc18": "0xd8d726b7177a800000",
  	"0x86df73bd377f2c09de63c45d67f283eaefa0f4ab": "0x3635c9adc5dea00000",
  	"0x86e3fe86e93da486b14266eadf056cbfa4d91443": "0x6c6b935b8bbd400000",
  	"0x86e8670e27598ea09c3899ab7711d3b9fe901c17": "0xad78ebc5ac6200000",
  	"0x86ef6426211949cc37f4c75e7850369d0cf5f479": "0x2d65f32ea045af60000",
  	"0x86f05d19063e9369c6004eb3f123943a7cff4eab": "0x6c6acc67d7b1d40000",
  	"0x86f23e9c0aafc78b9c404dcd60339a925bffa266": "0x15af1d78b58c400000",
  	"0x86f4f40ad984fbb80933ae626e0e42f9333fdd41": "0x3635c9adc5dea00000",
  	"0x86f95c5b11a293940e35c0b898d8b75f08aab06d": "0x644e3e875fccf740000",
  	"0x86fff220e59305c09f483860d6f94e96fbe32f57": "0x2535b6ab4c0420000",
  	"0x870796abc0db84af82da52a0ed68734de7e636f5": "0x1043561a8829300000",
  	"0x870f15e5df8b0eabd02569537a8ef93b56785c42": "0x150894e849b3900000",
  	"0x87183160d172d2e084d327b86bcb7c1d8e6784ef": "0xd8d8583fa2d52f0000",
  	"0x871b8a8b51dea1989a5921f13ec1a955a515ad47": "0x1b1ae4d6e2ef5000000",
  	"0x8725e8c753b3acbfdca55f3c62dfe1a59454968a": "0x3637096c4bcc690000",
  	"0x8737dae671823a8d5917e0157ace9c43468d946b": "0x6c6acc67d7b1d40000",
  	"0x873b7f786d3c99ff012c4a7cae2677270240b9c5": "0x5dc892aa1131c80000",
  	"0x873c6f70efb6b1d0f2bbc57eebcd70617c6ce662": "0x36f0d5275d09570000",
  	"0x873e49135c3391991060290aa7f6ccb8f85a78db": "0x1158e460913d00000",
  	"0x875061ee12e820041a01942cb0e65bb427b00060": "0x97c9ce4cf6d5c00000",
  	"0x87584a3f613bd4fac74c1e780b86d6caeb890cb2": "0x5c283d410394100000",
  	"0x8764d02722000996ecd475b433298e9f540b05bf": "0xad78ebc5ac6200000",
  	"0x876c3f218b4776df3ca9dbfb270de152d94ed252": "0x56bc75e2d63100000",
  	"0x8775a610c502b9f1e6ad4cdadb8ce29bff75f6e4": "0x2086ac351052600000",
  	"0x87764e3677eef604cbc59aed24abdc566b09fc25": "0xa2a15d09519be00000",
  	"0x8787d12677a5ec291e57e31ffbfad105c3324b87": "0x2a24eb53208f3128000",
  	"0x8794bf47d54540ece5c72237a1ffb511ddb74762": "0x6c6b935b8bbd400000",
  	"0x87a53ea39f59a35bada8352521645594a1a714cb": "0x678a932062e4180000",
  	"0x87a7c508ef71582dd9a54372f89cb01f252fb180": "0xad78ebc5ac6200000",
  	"0x87af25d3f6f8eea15313d5fe4557e810c524c083": "0x42bf06b78ed3b500000",
  	"0x87b10f9c280098179a2b76e9ce90be61fc844d0d": "0x487a9a304539440000",
  	"0x87bf7cd5d8a929e1c785f9e5449106ac232463c9": "0x437b11fcc45640000",
  	"0x87c498170934b8233d1ad1e769317d5c475f2f40": "0x3708baed3d68900000",
  	"0x87cf36ad03c9eae9053abb5242de9117bb0f2a0b": "0x1b1ae4d6e2ef500000",
  	"0x87d7ac0653ccc67aa9c3469eef4352193f7dbb86": "0x2a5a058fc295ed000000",
  	"0x87e3062b2321e9dfb0875ce3849c9b2e3522d50a": "0x21e19e0c9bab2400000",
  	"0x87e6034ecf23f8b5639d5f0ea70a22538a920423": "0x11c7ea162e78200000",
  	"0x87ef6d8b6a7cbf9b5c8c97f67ee2adc2a73b3f77": "0xadd1bd23c3c480000",
  	"0x87fb26c31e48644d693134205cae43b21f18614b": "0x4a4491bd6dcd280000",
  	"0x87fc4635263944ce14a46c75fa4a821f39ce7f72": "0x1158e460913d00000",
  	"0x87fcbe7c4193ffcb08143779c9bec83fe7fda9fc": "0x56f985d38644b8000",
  	"0x88015d7203c5e0224aeda286ed12f1a51b789333": "0x10f08eda8e555098000",
  	"0x88106c27d20b74b4b98ca62b232bd5c97411171f": "0xaadec983fcff40000",
  	"0x881230047c211d2d5b00d8de4c5139de5e3227c7": "0x21e19e0c9bab2400000",
  	"0x882aa798bf41df179f85520130f15ccdf59b5e58": "0x6c6b935b8bbd400000",
  	"0x882bd3a2e9d74110b24961c53777f22f1f46dc5d": "0x2d4ca05e2b43ca80000",
  	"0x882c8f81872c79fed521cb5f950d8b032322ea69": "0x878678326eac9000000",
  	"0x882f75708386653c80171d0663bfe30b017ed0ad": "0x6c6b935b8bbd400000",
  	"0x88344909644c7ad4930fd873ca1c0da2d434c07f": "0x727739fcb004d0000",
  	"0x8834b2453471f324fb26be5b25166b5b5726025d": "0x1f0ff8f01daad40000",
  	"0x883a78aeabaa50d8ddd8570bcd34265f14b19363": "0xd25522fda379a18000",
  	"0x8845e9f90e96336bac3c616be9d88402683e004c": "0x6c6b935b8bbd400000",
  	"0x8846928d683289a2d11df8db7a9474988ef01348": "0x21e19e0c9bab2400000",
  	"0x884980eb4565c1048317a8f47fdbb461965be481": "0xd8d6119a8146050000",
  	"0x884a7a39d0916e05f1c242df55607f37df8c5fda": "0x4f4843c157c8ca00000",
  	"0x885493bda36a0432976546c1ddce71c3f4570021": "0xbbf510ddfcb260000",
  	"0x88609e0a465b6e99fce907166d57e9da0814f5c8": "0x43c33c1937564800000",
  	"0x886d0a9e17c9c095af2ea2358b89ec705212ee94": "0x18493fba64ef00000",
  	"0x88797e58675ed5cc4c19980783dbd0c956085153": "0x6c6b935b8bbd400000",
  	"0x887cac41cd706f3345f2d34ac34e01752a6e5909": "0x20465cee9da1370000",
  	"0x88888a57bd9687cbf950aeeacf9740dcc4d1ef59": "0x62a992e53a0af00000",
  	"0x8889448316ccf14ed86df8e2f478dc63c4338340": "0xd2f13f7789f00000",
  	"0x888c16144933197cac26504dd76e06fd6600c789": "0x56bc75e2d63100000",
  	"0x888e94917083d152202b53163939869d271175b4": "0xd8d726b7177a800000",
  	"0x889087f66ff284f8b5efbd29493b706733ab1447": "0x215f835bc769da80000",
  	"0x8895eb726226edc3f78cc6a515077b3296fdb95e": "0xd5967be4fc3f100000",
  	"0x88975a5f1ef2528c300b83c0c607b8e87dd69315": "0x486cb9799191e0000",
  	"0x889da40fb1b60f9ea9bd7a453e584cf7b1b4d9f7": "0x22b1c8c1227a00000",
  	"0x889da662eb4a0a2a069d2bc24b05b4ee2e92c41b": "0x5a2c8c5456c9f28000",
  	"0x88a122a2382c523931fb51a0ccad3beb5b7259c3": "0x6c6b935b8bbd400000",
  	"0x88a2154430c0e41147d3c1fee3b3b006f851edbd": "0x36356633ebd8ea0000",
  	"0x88b217ccb786a254cf4dc57f5d9ac3c455a30483": "0x3224f42723d4540000",
  	"0x88bc43012edb0ea9f062ac437843250a39b78fbb": "0x43c33c1937564800000",
  	"0x88c2516a7cdb09a6276d7297d30f5a4db1e84b86": "0xd8d726b7177a800000",
  	"0x88c361640d6b69373b081ce0c433bd590287d5ec": "0xa968163f0a57b400000",
  	"0x88d541c840ce43cefbaf6d19af6b9859b573c145": "0x93739534d28680000",
  	"0x88de13b09931877c910d593165c364c8a1641bd3": "0xa2a15d09519be00000",
  	"0x88dec5bd3f4eba2d18b8aacefa7b721548c319ba": "0x4a4491bd6dcd280000",
  	"0x88e6f9b247f988f6c0fc14c56f1de53ec69d43cc": "0x56bc75e2d63100000",
  	"0x88ee7f0efc8f778c6b687ec32be9e7d6f020b674": "0x6c6b935b8bbd400000",
  	"0x88f1045f19f2d3191816b1df18bb6e1435ad1b38": "0xd02ab486cedc00000",
  	"0x89009e3c6488bd5e570d1da34eabe28ed024de1b": "0x43c33c1937564800000",
  	"0x89054430dcdc28ac15fa635ef87c105e602bf70c": "0x5dacd13ca9e300000",
  	"0x8908760cd39b9c1e8184e6a752ee888e3f0b7045": "0x14542ba12a337c00000",
  	"0x890fe11f3c24db8732d6c2e772e2297c7e65f139": "0xd5627137da8b5900000",
  	"0x8914a680a5aec5226d4baaec2e5552b44dd7c874": "0x56cd55fc64dfe0000",
  	"0x891cb8238c88e93a1bcf61db49bd82b47a7f4f84": "0x914878a8c05ee00000",
  	"0x8925da4549e15155e57a628522cea9dddf627d81": "0x3636c25e66ece70000",
  	"0x893017ff1adad499aa065401b4236ce6e92b625a": "0x6c6acc67d7b1d40000",
  	"0x8933491760c8f0b4df8caac78ed835caee21046d": "0x43c33c1937564800000",
  	"0x893608751d68d046e85802926673cdf2f57f7cb8": "0x11164759ffb320000",
  	"0x8938d1b4daee55a54d738cf17e4477f6794e46f7": "0xfc936392801c0000",
  	"0x893a6c2eb8b40ab096b4f67e74a897b840746e86": "0x5dc892aa1131c80000",
  	"0x893cdddf5377f3c751bf2e541120045a47cba101": "0x56bc75e2d63100000",
  	"0x895613236f3584216ad75c5d3e07e3fa6863a778": "0x6c6b935b8bbd400000",
  	"0x8957727e72cf629020f4e05edf799aa7458062d0": "0x77432217e683600000",
  	"0x895d694e880b13ccd0848a86c5ce411f88476bbf": "0xad6eedd17cf3b8000",
  	"0x895ec5545644e0b78330fffab8ddeac9e833156c": "0x2086ac351052600000",
  	"0x896009526a2c7b0c09a6f63a80bdf29d9c87de9c": "0xbbb86b8223edeb0000",
  	"0x8967d7b9bdb7b4aed22e65a15dc803cb7a213f10": "0x15af1d78b58c400000",
  	"0x896e335ca47af57962fa0f4dbf3e45e688cba584": "0x4a2fc0ab6052120000",
  	"0x8973aefd5efaee96095d9e288f6a046c97374b43": "0x7a4c4a0f332140000",
  	"0x898c72dd736558ef9e4be9fdc34fef54d7fc7e08": "0x3635c9adc5dea00000",
  	"0x899b3c249f0c4b81df75d212004d3d6d952fd223": "0x6c6b935b8bbd400000",
  	"0x89ab13ee266d779c35e8bb04cd8a90cc2103a95b": "0xcb49b44ba602d800000",
  	"0x89c433d601fad714da6369308fd26c1dc9942bbf": "0x6c6b935b8bbd400000",
  	"0x89d75b8e0831e46f80bc174188184e006fde0eae": "0x3635c9adc5dea00000",
  	"0x89e3b59a15864737d493c1d23cc53dbf8dcb1362": "0xd8d726b7177a800000",
  	"0x89fc8e4d386b0d0bb4a707edf3bd560df1ad8f4e": "0xa030dcebbd2f4c0000",
  	"0x89fee30d1728d96cecc1dab3da2e771afbcfaa41": "0x6c6acc67d7b1d40000",
  	"0x8a1cc5ac111c49bfcfd848f37dd768aa65c88802": "0x21e19e0c9bab2400000",
  	"0x8a20e5b5cee7cd1f5515bace3bf4f77ffde5cc07": "0x4563918244f400000",
  	"0x8a217db38bc35f215fd92906be42436fe7e6ed19": "0x14542ba12a337c00000",
  	"0x8a243a0a9fea49b839547745ff2d11af3f4b0522": "0x35659ef93f0fc40000",
  	"0x8a247d186510809f71cffc4559471c3910858121": "0x61093d7c2c6d380000",
  	"0x8a3470282d5e2a2aefd7a75094c822c4f5aeef8a": "0xd28bc606478a58000",
  	"0x8a36869ad478997cbf6d8924d20a3c8018e9855b": "0x1158e460913d00000",
  	"0x8a4314fb61cd938fc33e15e816b113f2ac89a7fb": "0x17764e7aed65100000",
  	"0x8a4f4a7f52a355ba105fca2072d3065fc8f7944b": "0x1b1ae4d6e2ef500000",
  	"0x8a5831282ce14a657a730dc18826f7f9b99db968": "0xeabe8a5b41c1360000",
  	"0x8a5fb75793d043f1bcd43885e037bd30a528c927": "0x13536e6d2e9ac20000",
  	"0x8a66abbc2d30ce21a833b0db8e561d5105e0a72c": "0x25f1de5c76acdf0000",
  	"0x8a746c5d67064711bfca685b95a4fe291a27028e": "0x22b1c8c1227a00000",
  	"0x8a780ab87a9145fe10ed60fa476a740af4cab1d2": "0x121b2e5e6464780000",
  	"0x8a7a06be199a3a58019d846ac9cbd4d95dd757de": "0xa2a423944256f40000",
  	"0x8a810114b2025db9fbb50099a6e0cb9e2efa6bdc": "0x678a932062e4180000",
  	"0x8a86e4a51c013b1fb4c76bcf30667c78d52eedef": "0x6c6b935b8bbd400000",
  	"0x8a9eca9c5aba8e139f8003edf1163afb70aa3aa9": "0x23c757072b8dd00000",
  	"0x8ab839aeaf2ad37cb78bacbbb633bcc5c099dc46": "0x6c6b935b8bbd400000",
  	"0x8ac89bd9b8301e6b0677fa25fcf0f58f0cc7b611": "0x1158e460913d00000",
  	"0x8adc53ef8c18ed3051785d88e996f3e4b20ecd51": "0x8e4d316827686400000",
  	"0x8ae6f80b70e1f23c91fbd5a966b0e499d95df832": "0xaadec983fcff40000",
  	"0x8ae9ef8c8a8adfa6ab798ab2cdc405082a1bbb70": "0x6c6b935b8bbd400000",
  	"0x8af626a5f327d7506589eeb7010ff9c9446020d2": "0x4be4e7267b6ae00000",
  	"0x8b01da34d470c1d115acf4d8113c4dd8a8c338e4": "0x5572dcefab697900000",
  	"0x8b07d050754dc9ba230db01c310afdb5395aa1b3": "0x666b06e62a6200000",
  	"0x8b20ad3b94656dbdc0dd21a393d8a7d9e02138cb": "0xa2a15d09519be00000",
  	"0x8b27392206b958cd375d7ef8af2cf8ef0598c0bc": "0x3635c9adc5dea00000",
  	"0x8b30c04098d7a7e6420c357ea7bfa49bac9a8a18": "0x1b1b113f91fb0140000",
  	"0x8b338411f26ccf37658cc75521d77629099e467d": "0x6c6b935b8bbd400000",
  	"0x8b36224c7356e751f0c066c35e3b44860364bfc2": "0x3627bac7a3d9278000",
  	"0x8b3696f3c60de32432a2e4c395ef0303b7e81e75": "0x65a4da25d3016c00000",
  	"0x8b393fb0813ee101db1e14ecc7d322c72b8c0473": "0x18b26a313e8ae90000",
  	"0x8b48e19d39dd35b66e6e1bb6b9c657cb2cf59d04": "0x3c755ac9c024a018000",
  	"0x8b505e2871f7deb7a63895208e8227dcaa1bff05": "0xcf68efc308d79bc0000",
  	"0x8b57b2bc83cc8d4de331204e893f2f3b1db1079a": "0x22b1c8c1227a00000",
  	"0x8b5c914b128bf1695c088923fa467e7911f351fa": "0x556f64c1fe7fa0000",
  	"0x8b5f29cc2faa262cdef30ef554f50eb488146eac": "0x13b68705c9720810000",
  	"0x8b7056f6abf3b118d026e944d5c073433ca451d7": "0x3635c6204739d98000",
  	"0x8b714522fa2839620470edcf0c4401b713663df1": "0xad78ebc5ac6200000",
  	"0x8b74a7cb1bb8c58fce267466a30358adaf527f61": "0x2e257784e25b4500000",
  	"0x8b7e9f6f05f7e36476a16e3e7100c9031cf404af": "0x3635c9adc5dea00000",
  	"0x8b81156e698639943c01a75272ad3d35851ab282": "0x12b3165f65d3e50000",
  	"0x8b9577920053b1a00189304d888010d9ef2cb4bf": "0x1b1ae4d6e2ef500000",
  	"0x8b9841862e77fbbe919470935583a93cf027e450": "0x6c6c5334427f1f0000",
  	"0x8b997dbc078ad02961355da0a159f2927ed43d64": "0xaadec983fcff40000",
  	"0x8b9fda7d981fe9d64287f85c94d83f9074849fcc": "0x2f6f10780d22cc00000",
  	"0x8bb0212f3295e029cab1d961b04133a1809e7b91": "0x6c6b935b8bbd400000",
  	"0x8bbeacfc29cfe93402db3c41d99ab759662e73ec": "0x6c6b935b8bbd400000",
  	"0x8bc1ff8714828bf286ff7e8a7709106548ed1b18": "0x21e19e0c9bab2400000",
  	"0x8bd0b65a50ef5cef84fec420be7b89ed1470ceb9": "0x28a77936e92c81c0000",
  	"0x8bd6b1c6d74d010d1008dba6ef835d4430b35c32": "0x2b5e3af16b1880000",
  	"0x8bd8d4c4e943f6c8073921dc17e3e8d7a0761627": "0x9f04219d8d34950000",
  	"0x8bdfda6c215720eda2136f91052321af4e936c1f": "0x3635e619bb04d40000",
  	"0x8bea40379347a5c891d59a6363315640f5a7e07a": "0x6c6b76ef96970c0000",
  	"0x8bf02bd748690e1fd1c76d270833048b66b25fd3": "0x27fade568eba9600000",
  	"0x8bf297f8f453523ed66a1acb7676856337b93bf0": "0xd8d726b7177a800000",
  	"0x8bf373d076814cbc57e1c6d16a82c5be13c73d37": "0xad78ebc5ac6200000",
  	"0x8c1023fde1574db8bb54f1739670157ca47da652": "0x179cf9ac3a1b1770000",
  	"0x8c1fbe5f0aea359c5aa1fa08c8895412ca8e05a6": "0x3635c9adc5dea00000",
  	"0x8c22426055b76f11f0a2de1a7f819a619685fe60": "0x6b56051582a9700000",
  	"0x8c2b7d8b608d28b77f5caa9cd645242a823e4cd9": "0x62a992e53a0af00000",
  	"0x8c2fbeee8eacc5c5d77c16abd462ee9c8145f34b": "0x692ae8897081d00000",
  	"0x8c3a9ee71f729f236cba3867b4d79d8ceee25dbc": "0x56bc75e2d63100000",
  	"0x8c50aa2a9212bcde56418ae261f0b35e7a9dbb82": "0x15af1d78b58c400000",
  	"0x8c54c7f8b9896e75d7d5f5c760258699957142ad": "0x22b1c8c1227a00000",
  	"0x8c5d16ed65e3ed7e8b96ca972bc86173e3500b03": "0x6c6b935b8bbd400000",
  	"0x8c6aa882ee322ca848578c06cb0fa911d3608305": "0x2086ac351052600000",
  	"0x8c6ae7a05a1de57582ae2768204276c0ff47ed03": "0x2c0bb3dd30c4e2000000",
  	"0x8c6f9f4e5b7ae276bf58497bd7bf2a7d25245f64": "0x93fe5c57d710680000",
  	"0x8c75956e8fed50f5a7dd7cfd27da200f6746aea6": "0x3635c9adc5dea00000",
  	"0x8c7cb4e48b25031aa1c4f92925d631a8c3edc761": "0x3635c9adc5dea00000",
  	"0x8c7fa5cae82fedb69ab189d3ff27ae209293fb93": "0x15af880d8cdb830000",
  	"0x8c81410ea8354cc5c65c41be8bd5de733c0b111d": "0x205b4dfa1ee74780000",
  	"0x8c83d424a3cf24d51f01923dd54a18d6b6fede7b": "0xd8d726b7177a800000",
  	"0x8c900a8236b08c2b65405d39d75f20062a7561fd": "0x58e7926ee858a00000",
  	"0x8c93c3c6db9d37717de165c3a1b4fe51952c08de": "0x15af1d78b58c400000",
  	"0x8c999591fd72ef7111efca7a9e97a2356b3b000a": "0xdd64e2aa0a67500000",
  	"0x8ca6989746b06e32e2487461b1ce996a273acfd7": "0x1158e460913d00000",
  	"0x8cb3aa3fcd212854d7578fcc30fdede6742a312a": "0x1043561a8829300000",
  	"0x8cc0d7c016fa7aa950114aa1db094882eda274ea": "0x8a9aba557e36c0000",
  	"0x8cc652dd13e7fe14dabbb36d5d320db9ffee8a54": "0x61093d7c2c6d380000",
  	"0x8ccabf25077f3aa41545344d53be1b2b9c339000": "0x5be866c562c5440000",
  	"0x8ccf3aa21ab742576ad8c422f71bb188591dea8a": "0x3635c9adc5dea00000",
  	"0x8cd0cd22e620eda79c0461e896c93c44837e2968": "0x6c6b935b8bbd400000",
  	"0x8cde8b732e6023878eb23ed16229124b5f7afbec": "0x73f75d1a085ba0000",
  	"0x8ce22f9fa372449a420610b47ae0c8d565481232": "0x6c6b935b8bbd400000",
  	"0x8ce4949d8a16542d423c17984e6739fa72ceb177": "0x54b405926f4a63d8000",
  	"0x8ce5e3b5f591d5eca38abf228f2e3c35134bdac0": "0x7dc35b84897c380000",
  	"0x8cee38d6595788a56e3fb94634b3ffe1fbdb26d6": "0x43c33c1937564800000",
  	"0x8ceea15eec3bdad8023f98ecf25b2b8fef27db29": "0x6c6b935b8bbd400000",
  	"0x8cf3546fd1cda33d58845fc8fcfecabca7c5642a": "0x1f1e39932cb3278000",
  	"0x8cf6da0204dbc4860b46ad973fc111008d9e0c46": "0xad78ebc5ac6200000",
  	"0x8cfedef198db0a9143f09129b3fd64dcbb9b4956": "0x6c6b935b8bbd400000",
  	"0x8d04a5ebfb5db409db0617c9fa5631c192861f4a": "0x34957444b840e80000",
  	"0x8d06e464245cad614939e0af0845e6d730e20374": "0xadc8a28f3d87d8000",
  	"0x8d07d42d831c2d7c838aa1872b3ad5d277176823": "0x12ee1f9ddbee680000",
  	"0x8d0b9ea53fd263415eac11391f7ce9123c447062": "0x6c6b935b8bbd400000",
  	"0x8d1794da509cb297053661a14aa892333231e3c1": "0xad201a6794ff80000",
  	"0x8d1abd897dacd4312e18080c88fb9647eab44052": "0xbb59a27953c600000",
  	"0x8d2303341e1e1eb5e8189bde03f73a60a2a54861": "0x56bc75e2d63100000",
  	"0x8d238e036596987643d73173c37b0ad06055b96c": "0x7148bf0a2af0660000",
  	"0x8d2e31b08803b2c5f13d398ecad88528209f6057": "0x21db8bbcad11e840000",
  	"0x8d378f0edc0bb0f0686d6a20be6a7692c4fa24b8": "0x56bc75e2d63100000",
  	"0x8d4b603c5dd4570c34669515fdcc665890840c77": "0xfc936392801c0000",
  	"0x8d51a4cc62011322c696fd725b9fb8f53feaaa07": "0x3635c9adc5dea00000",
  	"0x8d544c32c07fd0842c761d53a897d6c950bb7599": "0xad78ebc5ac6200000",
  	"0x8d5ef172bf77315ea64e85d0061986c794c6f519": "0xd5967be4fc3f100000",
  	"0x8d616b1eee77eef6f176e0698db3c0c141b2fc8f": "0x1b1ae4d6e2ef500000",
  	"0x8d6170ff66978e773bb621bf72b1ba7be3a7f87e": "0xad78ebc5ac6200000",
  	"0x8d620bde17228f6cbba74df6be87264d985cc179": "0x56bc75e2d63100000",
  	"0x8d629c20608135491b5013f1002586a0383130e5": "0x4a4491bd6dcd280000",
  	"0x8d6657f59711b1f803c6ebef682f915b62f92dc9": "0x6c6b935b8bbd400000",
  	"0x8d667637e29eca05b6bfbef1f96d460eefbf9984": "0xd8d726b7177a800000",
  	"0x8d6df209484d7b94702b03a53e56b9fb0660f6f0": "0x6c6b935b8bbd400000",
  	"0x8d795c5f4a5689ad62da961671f028065286d554": "0x6f05b59d3b20000000",
  	"0x8d7f3e61299c2db9b9c0487cf627519ed00a9123": "0x5e74a8505e80a00000",
  	"0x8d89170b92b2be2c08d57c48a7b190a2f146720f": "0x42bf06b78ed3b500000",
  	"0x8d93dac785f88f1a84bf927d53652b45a154ccdd": "0x890b0c2e14fb80000",
  	"0x8d9952d0bb4ebfa0efd01a3aa9e8e87f0525742e": "0xbb9125542263900000",
  	"0x8d9a0c70d2262042df1017d6c303132024772712": "0x6c6b935b8bbd400000",
  	"0x8d9ed7f4553058c26f7836a3802d3064eb1b363d": "0x4e1003b28d9280000",
  	"0x8da1178f55d97772bb1d24111a404a4f8715b95d": "0x2f9ac3f6de00808000",
  	"0x8da1d359ba6cb4bcc57d7a437720d55db2f01c72": "0x4563918244f400000",
  	"0x8dab948ae81da301d972e3f617a912e5a753712e": "0x15af1d78b58c400000",
  	"0x8daddf52efbd74da95b969a5476f4fbbb563bfd2": "0x2d43f3ebfafb2c0000",
  	"0x8db185fe1b70a94a6a080e7e23a8bedc4acbf34b": "0x4be4e7267b6ae00000",
  	"0x8db58e406e202df9bc703c480bd8ed248d52a032": "0x6c6b935b8bbd400000",
  	"0x8dbc3e6cb433e194f40f82b40faadb1f8b856116": "0x678a932062e4180000",
  	"0x8dc1d5111d09af25fdfcac455c7cec283e6d6775": "0x6c6b935b8bbd400000",
  	"0x8dd484ff8a307364eb66c525a571aac701c5c318": "0xd8d726b7177a800000",
  	"0x8dd6a9bae57f518549ada677466fea8ab04fd9b4": "0xd8d726b7177a800000",
  	"0x8dde3cb8118568ef4503fe998ccdf536bf19a098": "0xd8d726b7177a800000",
  	"0x8dde60eb08a099d7daa356daaab2470d7b025a6b": "0xaadec983fcff40000",
  	"0x8df339214b6ad1b24663ce716034749d6ef838d9": "0x2544faa778090e00000",
  	"0x8df53d96191471e059de51c718b983e4a51d2afd": "0x6c6b935b8bbd4000000",
  	"0x8dfbafbc0e5b5c86cd1ad697feea04f43188de96": "0x15252b7f5fa0de0000",
  	"0x8e073bad25e42218615f4a0e6b2ea8f8de2230c0": "0x823d629d026bfa0000",
  	"0x8e0fee38685a94aabcd7ce857b6b1409824f75b8": "0x1b1ae4d6e2ef500000",
  	"0x8e23facd12c765c36ab81a6dd34d8aa9e68918ae": "0x911e4868dba9b0000",
  	"0x8e2f9034c9254719c38e50c9aa64305ed696df1e": "0x1004e2e45fb7ee00000",
  	"0x8e3240b0810e1cf407a500804740cf8d616432a4": "0x22f6655ef0b388000",
  	"0x8e486a0442d171c8605be348fee57eb5085eff0d": "0xd8d726b7177a800000",
  	"0x8e6156336be2cdbe32140df08a2ba55fd0a58463": "0x4099e1d6357180000",
  	"0x8e670815fb67aeaea57b86534edc00cdf564fee5": "0xb2e4b323d9c5100000",
  	"0x8e6d7485cbe990acc1ad0ee9e8ccf39c0c93440e": "0x33c5499031720c0000",
  	"0x8e74e0d1b77ebc823aca03f119854cb12027f6d7": "0x16b352da5e0ed3000000",
  	"0x8e78f351457d016f4ad2755ec7424e5c21ba6d51": "0x7ea28327577080000",
  	"0x8e7936d592008fdc7aa04edeeb755ab513dbb89d": "0x1158e460913d00000",
  	"0x8e7fd23848f4db07906a7d10c04b21803bb08227": "0x3635c9adc5dea00000",
  	"0x8e92aba38e72a098170b92959246537a2e5556c0": "0xe7eeba3410b740000",
  	"0x8e98766524b0cf2747c50dd43b9567594d9731de": "0x6c44b7c26182280000",
  	"0x8e9b35ad4a0a86f758446fffde34269d940ceacd": "0xd8d726b7177a800000",
  	"0x8e9c08f738661f9676236eff82ba6261dd3f4822": "0x56bc75e2d63100000",
  	"0x8e9c429266df057efa78dd1d5f77fc40742ad466": "0x10442ed1b56c7c8000",
  	"0x8ea656e71ec651bfa17c5a5759d86031cc359977": "0x56bc75e2d63100000",
  	"0x8eae29435598ba8f1c93428cdb3e2b4d31078e00": "0x6c6b935b8bbd400000",
  	"0x8eb1fbe4e5d3019cd7d30dae9c0d5b4c76fb6331": "0x6c6b935b8bbd400000",
  	"0x8eb51774af206b966b8909c45aa6722748802c0c": "0x1b1ae4d6e2ef500000",
  	"0x8eb8c71982a00fb84275293253f8044544b66b49": "0x15af1d78b58c400000",
  	"0x8ecbcfacbfafe9f00c3922a24e2cf0026756ca20": "0x131beb925ffd3200000",
  	"0x8eceb2e124536c5b5ffc640ed14ff15ed9a8cb71": "0x6c6b935b8bbd400000",
  	"0x8ed0af11ff2870da0681004afe18b013f7bd3882": "0xd8d726b7177a800000",
  	"0x8ed143701f2f72280fd04a7b4164281979ea87c9": "0xc249fdd327780000",
  	"0x8ed1528b447ed4297902f639c514d0944a88f8c8": "0xac6e77ab663a80000",
  	"0x8ed4284c0f47449c15b8d9b3245de8beb6ce80bf": "0x2b5e3af16b18800000",
  	"0x8ede7e3dc50749c6c50e2e28168478c34db81946": "0x43c30fb0884a96c0000",
  	"0x8ee584337ddbc80f9e3498df55f0a21eacb57fb1": "0x1158e460913d00000",
  	"0x8eebec1a62c08b05a7d1d59180af9ff0d18e3f36": "0x1b1ae4d6e2ef500000",
  	"0x8ef4d8a2c23c5279187b64e96f741404085385f3": "0x103dc1e9a9697b0000",
  	"0x8ef711e43a13918f1303e81d0ea78c9eefd67eb2": "0xd8d726b7177a800000",
  	"0x8efec058cc546157766a632775404a334aaada87": "0x6c5db2a4d815dc0000",
  	"0x8f02bda6c36922a6be6a509be51906d393f7b99b": "0x37490dc12ebe7f8000",
  	"0x8f0538ed71da1155e0f3bde5667ceb84318a1a87": "0x692ae8897081d00000",
  	"0x8f067c7c1bbd57780b7b9eeb9ec0032f90d0dcf9": "0x43c33c1937564800000",
  	"0x8f0ab894bd3f4e697dbcfb859d497a9ba195994a": "0x85d638b65472aa20000",
  	"0x8f0af37566d152802f1ae8f928b25af9b139b448": "0xad78ebc5ac6200000",
  	"0x8f1952eed1c548d9ee9b97d0169a07933be69f63": "0x3635c9adc5dea00000",
  	"0x8f1fcc3c51e252b693bc5b0ec3f63529fe69281e": "0x14542ba12a337c00000",
  	"0x8f226096c184ebb40105e08dac4d22e1c2d54d30": "0x109e437bd1618c0000",
  	"0x8f29a14a845ad458f2d108b568d813166bcdf477": "0x21e19e0c9bab2400000",
  	"0x8f31c7005197ec997a87e69bec48649ab94bb2a5": "0xd8d726b7177a800000",
  	"0x8f41b1fbf54298f5d0bc2d122f4eb95da4e5cd3d": "0x1333832f5e335c0000",
  	"0x8f47328ee03201c9d35ed2b5412b25decc859362": "0x6c6b935b8bbd400000",
  	"0x8f473d0ab876ddaa15608621d7013e6ff714b675": "0x19801c83b6c7c00000",
  	"0x8f4d1d41693e462cf982fd81d0aa701d3a5374c9": "0xd8d726b7177a800000",
  	"0x8f4d1e7e4561284a34fef9673c0d34e12af4aa03": "0x6c6b935b8bbd400000",
  	"0x8f4fb1aea7cd0f570ea5e61b40a4f4510b6264e4": "0xd8d726b7177a800000",
  	"0x8f561b41b209f248c8a99f858788376250609cf3": "0x5c283d410394100000",
  	"0x8f58d8348fc1dc4e0dd8343b6543c857045ee940": "0x2e3038df47303280000",
  	"0x8f60895fbebbb5017fcbff3cdda397292bf25ba6": "0x174406ff9f6fd28000",
  	"0x8f64b9c1246d857831643107d355b5c75fef5d4f": "0x6c6acc67d7b1d40000",
  	"0x8f660f8b2e4c7cc2b4ac9c47ed28508d5f8f8650": "0x43c33c1937564800000",
  	"0x8f69eafd0233cadb4059ab779c46edf2a0506e48": "0x60f06620a849450000",
  	"0x8f717ec1552f4c440084fba1154a81dc003ebdc0": "0x21e19e0c9bab2400000",
  	"0x8f8acb107607388479f64baaabea8ff007ada97d": "0x5c6f3080ad423f40000",
  	"0x8f8cd26e82e7c6defd02dfad07979021cbf7150c": "0xa2a15d09519be00000",
  	"0x8f8f37d0ad8f335d2a7101b41156b688a81a9cbe": "0x3cb71f51fc5580000",
  	"0x8f92844f282a92999ee5b4a8d773d06b694dbd9f": "0x692ae8897081d00000",
  	"0x8fac748f784a0fed68dba43319b42a75b4649c6e": "0x3154c9729d05780000",
  	"0x8fd9a5c33a7d9edce0997bdf77ab306424a11ea9": "0x6c6b935b8bbd400000",
  	"0x8feffadb387a1547fb284da9b8147f3e7c6dc6da": "0x2d627be45305080000",
  	"0x8ff46045687723dc33e4d099a06904f1ebb584dc": "0x6c6b935b8bbd400000",
  	"0x8ffa062122ac307418821adb9311075a3703bfa3": "0x3635c9adc5dea00000",
  	"0x8ffe322997b8e404422d19c54aadb18f5bc8e9b7": "0xd5967be4fc3f100000",
  	"0x900194c4b1074305d19de405b0ac78280ecaf967": "0x3635c9adc5dea00000",
  	"0x9003d270891ba2df643da8341583193545e3e000": "0xd8d726b7177a800000",
  	"0x90057af9aa66307ec9f033b29724d3b2f41eb6f9": "0x19d1d6aadb2c52e80000",
  	"0x900f0b8e35b668f81ef252b13855aa5007d012e7": "0x170a0f5040e5040000",
  	"0x9018cc1f48d2308e252ab6089fb99a7c1d569410": "0xad78ebc5ac6200000",
  	"0x901d99b699e5c6911519cb2076b4c76330c54d22": "0x6c6b935b8bbd400000",
  	"0x902d74a157f7d2b9a3378b1f56703730e03a1719": "0xd8d726b7177a800000",
  	"0x903413878aea3bc1086309a3fe768b65559e8cab": "0x1b1ae4d6e2ef5000000",
  	"0x904966cc2213b5b8cb5bd6089ef9cddbef7edfcc": "0x6c6b935b8bbd400000",
  	"0x904caa429c619d940f8e6741826a0db692b19728": "0x3635c9adc5dea00000",
  	"0x9052f2e4a3e3c12dd1c71bf78a4ec3043dc88b7e": "0xe7eeba3410b740000",
  	"0x905526568ac123afc0e84aa715124febe83dc87c": "0xf8699329677e0000",
  	"0x9092918707c621fdbd1d90fb80eb787fd26f7350": "0x855b5ba65c84f00000",
  	"0x909b5e763a39dcc795223d73a1dbb7d94ca75ac8": "0x6c6b935b8bbd400000",
  	"0x90acced7e48c08c6b934646dfa0adf29dc94074f": "0x30b4b157bbd490000",
  	"0x90b1f370f9c1eb0be0fb8e2b8ad96a416371dd8a": "0x30ca024f987b900000",
  	"0x90b62f131a5f29b45571513ee7a74a8f0b232202": "0x890b0c2e14fb80000",
  	"0x90bd62a050845261fa4a9f7cf241ea630b05efb8": "0x1b1ae4d6e2ef500000",
  	"0x90c41eba008e20cbe927f346603fc88698125969": "0x246ddf97976680000",
  	"0x90d2809ae1d1ffd8f63eda01de49dd552df3d1bc": "0xd8bb6549b02bb80000",
  	"0x90dc09f717fc2a5b69fd60ba08ebf40bf4e8246c": "0xd8d8583fa2d52f0000",
  	"0x90e300ac71451e401f887f6e7728851647a80e07": "0x15af1d78b58c400000",
  	"0x90e35aabb2deef408bb9b5acef714457dfde6272": "0x56cd55fc64dfe0000",
  	"0x90e7070f4d033fe6910c9efe5a278e1fc6234def": "0x571380819b3040000",
  	"0x90e93e4dc17121487952333614002be42356498e": "0x678a932062e4180000",
  	"0x90e9a9a82edaa814c284d232b6e9ba90701d4952": "0x56be03ca3e47d8000",
  	"0x90f774c9147dde90853ddc43f08f16d455178b8c": "0xd8d726b7177a800000",
  	"0x90fc537b210658660a83baa9ac4a8402f65746a8": "0x65ea3db75546600000",
  	"0x91050a5cffadedb4bb6eaafbc9e5013428e96c80": "0x5c283d410394100000",
  	"0x91051764af6b808e4212c77e30a5572eaa317070": "0x3635c9adc5dea00000",
  	"0x910b7d577a7e39aa23acf62ad7f1ef342934b968": "0x21e19e0c9bab2400000",
  	"0x910e996543344c6815fb97cda7af4b8698765a5b": "0x59af69829cf640000",
  	"0x911feea61fe0ed50c5b9e5a0d66071399d28bdc6": "0x340aad21b3b700000",
  	"0x911ff233e1a211c0172c92b46cf997030582c83a": "0x6acb3df27e1f880000",
  	"0x9120e71173e1ba19ba8f9f4fdbdcaa34e1d6bb78": "0x6c6b935b8bbd400000",
  	"0x91211712719f2b084d3b3875a85069f466363141": "0x3635c9adc5dea00000",
  	"0x912304118b80473d9e9fe3ee458fbe610ffda2bb": "0xad78ebc5ac6200000",
  	"0x91546b79ecf69f936b5a561508b0d7e50cc5992f": "0xe7eeba3410b740000",
  	"0x9156d18029350e470408f15f1aa3be9f040a67c6": "0x3635c9adc5dea00000",
  	"0x91620f3eb304e813d28b0297556d65dc4e5de5aa": "0xcf152640c5c8300000",
  	"0x916bf7e3c545921d3206d900c24f14127cbd5e70": "0x3d0ddbc7df2bb100000",
  	"0x916cf17d71412805f4afc3444a0b8dd1d9339d16": "0xc673ce3c40160000",
  	"0x917b8f9f3a8d09e9202c52c29e724196b897d35e": "0x8ba52e6fc45e40000",
  	"0x918967918cd897dd0005e36dc6c883ef438fc8c7": "0x796e3ea3f8ab00000",
  	"0x91898eab8c05c0222883cd4db23b7795e1a24ad7": "0x6c6b935b8bbd400000",
  	"0x9191f94698210516cf6321a142070e20597674ed": "0xee9d5be6fc110000",
  	"0x91a4149a2c7b1b3a67ea28aff34725e0bf8d7524": "0x692ae8897081d00000",
  	"0x91a787bc5196f34857fe0c372f4df376aaa76613": "0x6c6b935b8bbd400000",
  	"0x91a8baaed012ea2e63803b593d0d0c2aab4c5b0a": "0x5150ae84a8cdf00000",
  	"0x91ac5cfe67c54aa7ebfba448666c461a3b1fe2e1": "0x15c93492bf9dfc0000",
  	"0x91bb3f79022bf3c453f4ff256e269b15cf2c9cbd": "0x52585c13fe3a5c0000",
  	"0x91c75e3cb4aa89f34619a164e2a47898f5674d9c": "0x6c6b935b8bbd400000",
  	"0x91c80caa081b38351d2a0e0e00f80a34e56474c1": "0x3635c9adc5dea00000",
  	"0x91cc46aa379f856a6640dccd5a648a7902f849d9": "0xad78ebc5ac6200000",
  	"0x91d2a9ee1a6db20f5317cca7fbe2313895db8ef8": "0x1ccc3a52f306e280000",
  	"0x91d66ea6288faa4b3d606c2aa45c7b6b8a252739": "0x6c6b935b8bbd400000",
  	"0x91dbb6aaad149585be47375c5d6de5ff09191518": "0x43c33c1937564800000",
  	"0x91e8810652e8e6161525d63bb7751dc20f676076": "0x274d656ac90e340000",
  	"0x91f516146cda20281719978060c6be4149067c88": "0x6c6b935b8bbd400000",
  	"0x91f624b24a1fa5a056fe571229e7379db14b9a1e": "0x28a8517c669b3570000",
  	"0x91fe8a4c6164df8fa606995d6ba7adcaf1c893ce": "0x39992648a23c8a00000",
  	"0x921f5261f4f612760706892625c75e7bce96b708": "0x6c6b935b8bbd400000",
  	"0x9221c9ce01232665741096ac07235903ad1fe2fc": "0x6db63335522628000",
  	"0x9225983860a1cb4623c72480ac16272b0c95e5f5": "0x6c6b935b8bbd400000",
  	"0x9225d46a5a80943924a39e5b84b96da0ac450581": "0x878678326eac9000000",
  	"0x922a20c79a1d3a26dd3829677bf1d45c8f672bb6": "0xd8d726b7177a800000",
  	"0x92438e5203b6346ff886d7c36288aacccc78ceca": "0x3635c9adc5dea00000",
  	"0x9243d7762d77287b12638688b9854e88a769b271": "0x3635c9adc5dea00000",
  	"0x924bce7a853c970bb5ec7bb759baeb9c7410857b": "0xbe202d6a0eda0000",
  	"0x924efa6db595b79313277e88319625076b580a10": "0x6c6b935b8bbd400000",
  	"0x92558226b384626cad48e09d966bf1395ee7ea5d": "0x121ea68c114e510000",
  	"0x926082cb7eed4b1993ad245a477267e1c33cd568": "0x144a74badfa4b60000",
  	"0x926209b7fda54e8ddb9d9e4d3d19ebdc8e88c29f": "0x6c6b935b8bbd400000",
  	"0x9268d62646563611dc3b832a30aa2394c64613e3": "0x6c6b935b8bbd400000",
  	"0x92698e345378c62d8eda184d94366a144b0c105b": "0x4be4e7267b6ae00000",
  	"0x92793ac5b37268774a7130de2bbd330405661773": "0x22ca3587cf4eb0000",
  	"0x9279b2228cec8f7b4dda3f320e9a0466c2f585ca": "0x10f0cf064dd59200000",
  	"0x927cb7dc187036b5427bc7e200c5ec450c1d27d4": "0xbb59a27953c600000",
  	"0x927cc2bfda0e088d02eff70b38b08aa53cc30941": "0x646f60a1f986360000",
  	"0x9284f96ddb47b5186ee558aa31324df5361c0f73": "0x3635c9adc5dea000000",
  	"0x929d368eb46a2d1fbdc8ffa0607ede4ba88f59ad": "0x6c6b935b8bbd400000",
  	"0x92a7c5a64362e9f842a23deca21035857f889800": "0x6c6acc67d7b1d40000",
  	"0x92a898d46f19719c38126a8a3c27867ae2cee596": "0x6c6b935b8bbd400000",
  	"0x92a971a739799f8cb48ea8475d72b2d2474172e6": "0xd5967be4fc3f100000",
  	"0x92aae59768eddff83cfe60bb512e730a05a161d7": "0x5c9778410c76d18000",
  	"0x92ad1b3d75fba67d54663da9fc848a8ade10fa67": "0x6c6b935b8bbd400000",
  	"0x92ae5b7c7eb492ff1ffa16dd42ad9cad40b7f8dc": "0x2ee449550898e40000",
  	"0x92c0f573eccf62c54810ee6ba8d1f113542b301b": "0xb7726f16ccb1e00000",
  	"0x92c13fe0d6ce87fd50e03def9fa6400509bd7073": "0x22b1c8c1227a00000",
  	"0x92c94c2820dfcf7156e6f13088ece7958b3676fd": "0x52d542804f1ce0000",
  	"0x92cfd60188efdfb2f8c2e7b1698abb9526c1511f": "0x6c6b935b8bbd400000",
  	"0x92d8ad9a4d61683b80d4a6672e84c20d62421e80": "0x1158e460913d00000",
  	"0x92dca5e102b3b81b60f1a504634947c374a88ccb": "0x6c6b935b8bbd400000",
  	"0x92e435340e9d253c00256389f52b067d55974e76": "0xe873f44133cb00000",
  	"0x92e4392816e5f2ef5fb65837cec2c2325cc64922": "0x21e19e0c9bab2400000",
  	"0x92e6581e1da1f9b846e09347333dc818e2d2ac66": "0xc55325ca7415e00000",
  	"0x931df34d1225bcd4224e63680d5c4c09bce735a6": "0x3afb087b876900000",
  	"0x931fe712f64207a2fd5022728843548bfb8cbb05": "0x6c6b935b8bbd400000",
  	"0x93235f340d2863e18d2f4c52996516138d220267": "0x4002e44fda7d40000",
  	"0x93258255b37c7f58f4b10673a932dd3afd90f4f2": "0x3635c9adc5dea00000",
  	"0x9328d55ccb3fce531f199382339f0e576ee840a3": "0xd8d726b7177a800000",
  	"0x9329ffdc268babde8874b366406c81445b9b2d35": "0x16e62f8c730ca18000",
  	"0x932b9c04d40d2ac83083d94298169dae81ab2ed0": "0x6c6b935b8bbd400000",
  	"0x933436c8472655f64c3afaaf7c4c621c83a62b38": "0x3635c9adc5dea00000",
  	"0x933bf33f8299702b3a902642c33e0bfaea5c1ca3": "0xd2f13f7789f00000",
  	"0x9340345ca6a3eabdb77363f2586043f29438ce0b": "0x1cc805da0dfff10000",
  	"0x9340b5f678e45ee05eb708bb7abb6ec8f08f1b6b": "0x14542ba12a337c00000",
  	"0x934af21b7ebfa467e2ced65aa34edd3a0ec71332": "0x7801f3e80cc0ff00000",
  	"0x935069444a6a984de2084e46692ab99f671fc727": "0x1e7e4171bf4d3a00000",
  	"0x93507e9e8119cbceda8ab087e7ecb071383d6981": "0x2f6f10780d22cc00000",
  	"0x93678a3c57151aeb68efdc43ef4d36cb59a009f3": "0x1a12a92bc3c3e0000",
  	"0x936dcf000194e3bff50ac5b4243a3ba014d661d8": "0x21e19e0c9bab2400000",
  	"0x936f3813f5f6a13b8e4ffec83fe7f826186a71cd": "0x1c30731cec03200000",
  	"0x9374869d4a9911ee1eaf558bc4c2b63ec63acfdd": "0x3635c9adc5dea00000",
  	"0x937563d8a80fd5a537b0e66d20a02525d5d88660": "0x878678326eac900000",
  	"0x9376dce2af2ec8dcda741b7e7345664681d93668": "0x3635c9adc5dea00000",
  	"0x93868ddb2a794d02ebda2fa4807c76e3609858dc": "0x6dee15fc7c24a78000",
  	"0x939c4313d2280edf5e071bced846063f0a975d54": "0x1969368974c05b000000",
  	"0x93a6b3ab423010f981a7489d4aad25e2625c5741": "0x44680fe6a1ede4e8000",
  	"0x93aa8f92ebfff991fc055e906e651ac768d32bc8": "0x32f51edbaaa3300000",
  	"0x93b4bf3fdff6de3f4e56ba6d7799dc4b93a6548f": "0x10910d4cdc9f60000",
  	"0x93bc7d9a4abd44c8bbb8fe8ba804c61ad8d6576c": "0xd8d6119a8146050000",
  	"0x93c2e64e5de5589ed25006e843196ee9b1cf0b3e": "0x5a87e7d7f5f6580000",
  	"0x93c88e2d88621e30f58a9586bed4098999eb67dd": "0x69b5afac750bb800000",
  	"0x93e0f37ecdfb0086e3e862a97034447b1e4dec1a": "0x1a055690d9db80000",
  	"0x93e303411afaf6c107a44101c9ac5b36e9d6538b": "0xdf9ddfecd0365400000",
  	"0x93f18cd2526040761488c513174d1e7963768b2c": "0x82ffac9ad593720000",
  	"0x940f715140509ffabf974546fab39022a41952d2": "0x4be4e7267b6ae00000",
  	"0x942c6b8c955bc0d88812678a236725b32739d947": "0x54069233bf7f780000",
  	"0x943d37864a4a537d35c8d99723cd6406ce2562e6": "0x6c6b935b8bbd400000",
  	"0x94439ca9cc169a79d4a09cae5e67764a6f871a21": "0xd02ab486cedc00000",
  	"0x94449c01b32a7fa55af8104f42cdd844aa8cbc40": "0x38111a1f4f03c100000",
  	"0x9445ba5c30e98961b8602461d0385d40fbd80311": "0x21e19e0c9bab2400000",
  	"0x944f07b96f90c5f0d7c0c580533149f3f585a078": "0x402f4cfee62e80000",
  	"0x9454b3a8bff9709fd0e190877e6cb6c89974dbd6": "0x90f534608a72880000",
  	"0x945d96ea573e8df7262bbfa572229b4b16016b0f": "0xb589ef914c1420000",
  	"0x945e18769d7ee727c7013f92de24d117967ff317": "0x6c6b935b8bbd400000",
  	"0x94612781033b57b146ee74e753c672017f5385e4": "0xc328093e61ee400000",
  	"0x94644ad116a41ce2ca7fbec609bdef738a2ac7c7": "0x10f0cf064dd59200000",
  	"0x9470cc36594586821821c5c996b6edc83b6d5a32": "0x14d1120d7b1600000",
  	"0x9475c510ec9a26979247744c3d8c3b0e0b5f44d3": "0x21e19e0c9bab2400000",
  	"0x947e11e5ea290d6fc3b38048979e0cd44ec7c17f": "0x6c6b935b8bbd400000",
  	"0x9483d98f14a33fdc118d403955c29935edfc5f70": "0x18ea3b34ef51880000",
  	"0x949131f28943925cfc97d41e0cea0b262973a730": "0x97c9ce4cf6d5c00000",
  	"0x949f84f0b1d7c4a7cf49ee7f8b2c4a134de32878": "0x252248deb6e6940000",
  	"0x949f8c107bc7f0aceaa0f17052aadbd2f9732b2e": "0x6c6b935b8bbd400000",
  	"0x94a7cda8f481f9d89d42c303ae1632b3b709db1d": "0x1043561a8829300000",
  	"0x94a9a71691317c2064271b51c9353fbded3501a8": "0xb50fcfafebecb00000",
  	"0x94ad4bad824bd0eb9ea49c58cebcc0ff5e08346b": "0x692ae8897081d00000",
  	"0x94bbc67d13f89ebca594be94bc5170920c30d9f3": "0x458ffa3150a540000",
  	"0x94be3ae54f62d663b0d4cc9e1ea8fe9556ea9ebf": "0x143132ca843180000",
  	"0x94c055e858357aaa30cf2041fa9059ce164a1f91": "0x43c25e0dcc1bd1c0000",
  	"0x94c742fd7a8b7906b3bfe4f8904fc0be5c768033": "0x43c33c1937564800000",
  	"0x94ca56de777fd453177f5e0694c478e66aff8a84": "0x1b1ae4d6e2ef500000",
  	"0x94d81074db5ae197d2bb1373ab80a87d121c4bd3": "0x1fd933494aa5fe00000",
  	"0x94db807873860aac3d5aea1e885e52bff2869954": "0xae8e7a0bb575d00000",
  	"0x94e1f5cb9b8abace03a1a6428256553b690c2355": "0x1158e460913d00000",
  	"0x94ef8be45077c7d4c5652740de946a62624f713f": "0x56cf5593a18f88000",
  	"0x94f13f9f0836a3ee2437a84922d2984dc0f7d53b": "0xa2a0329bc38abe0000",
  	"0x94f8f057db7e60e675ad940f155885d1a477348e": "0x15be6174e1912e0000",
  	"0x94fcceadfe5c109c5eaeaf462d43873142c88e22": "0x1043561a88293000000",
  	"0x95034e1621865137cd4739b346dc17da3a27c34e": "0x55a6e79ccd1d300000",
  	"0x950c68a40988154d2393fff8da7ccda99614f72c": "0xf94146fd8dcde58000",
  	"0x950fe9c6cad50c18f11a9ed9c45740a6180612d0": "0x1b1ae4d6e2ef5000000",
  	"0x952183cfd38e352e579d36decec5b18450f7fba0": "0x6c6b935b8bbd400000",
  	"0x95278b08dee7c0f2c8c0f722f9fcbbb9a5241fda": "0x829309f64f0db00000",
  	"0x952c57d2fb195107d4cd5ca300774119dfad2f78": "0x6c6b935b8bbd400000",
  	"0x953572f0ea6df9b197cae40e4b8ecc056c4371c5": "0x3635c9adc5dea00000",
  	"0x953ef652e7b769f53d6e786a58952fa93ee6abe7": "0x9b0a791f1211300000",
  	"0x95447046313b2f3a5e19b948fd3b8bedc82c717c": "0x1b1ae4d6e2ef500000",
  	"0x955db3b74360b9a268677e73cea821668af6face": "0x65a4da25d3016c00000",
  	"0x9560e8ac6718a6a1cdcff189d603c9063e413da6": "0xd8d726b7177a800000",
  	"0x9567a0de811de6ff095b7ee64e7f1b83c2615b80": "0xe7eeba3410b740000",
  	"0x95681cdae69b2049ce101e325c759892cac3f811": "0x9ae92a9bc94c400000",
  	"0x9568b7de755628af359a84543de23504e15e41e6": "0x878678326eac9000000",
  	"0x9569c63a9284a805626db3a32e9d236393476151": "0x6acb3df27e1f880000",
  	"0x95809e8da3fbe4b7f281f0b8b1715f420f7d7d63": "0x6c6b935b8bbd400000",
  	"0x959f57fded6ae37913d900b81e5f48a79322c627": "0xddb26104749118000",
  	"0x959ff17f1d51b473b44010052755a7fa8c75bd54": "0x6acb3df27e1f880000",
  	"0x95a577dc2eb3ae6cb9dfc77af697d7efdfe89a01": "0x75f610f70ed200000",
  	"0x95cb6d8a6379f94aba8b885669562c4d448e56a7": "0x6c6b935b8bbd400000",
  	"0x95d550427b5a514c751d73a0f6d29fb65d22ed10": "0x1043561a8829300000",
  	"0x95d98d0c1069908f067a52acac2b8b534da37afd": "0x6f59b630a929708000",
  	"0x95df4e3445d7662624c48eba74cf9e0a53e9f732": "0xbdbc41e0348b3000000",
  	"0x95e6a54b2d5f67a24a4875af75107ca7ea9fd2fa": "0x487a9a304539440000",
  	"0x95e6f93dac228bc7585a25735ac2d076cc3a4017": "0x14542ba12a337c00000",
  	"0x95e7616424cd0961a71727247437f0069272280e": "0x15af1d78b58c400000",
  	"0x95e80a82c20cbe3d2060242cb92d735810d034a2": "0x1c32e463fd4b98000",
  	"0x95f62d0243ede61dad9a3165f53905270d54e242": "0x57473d05dabae80000",
  	"0x95fb5afb14c1ef9ab7d179c5c300503fd66a5ee2": "0x1daf7a02b0dbe8000",
  	"0x9610592202c282ab9bd8a884518b3e0bd4758137": "0xe873f44133cb00000",
  	"0x961c59adc74505d1864d1ecfcb8afa0412593c93": "0x878678326eac9000000",
  	"0x962c0dec8a3d464bf39b1215eafd26480ae490cd": "0x6c82e3eaa513e80000",
  	"0x962cd22a8edf1e4f4e55b4b15ddbfb5d9d541971": "0x6c6b935b8bbd400000",
  	"0x96334bfe04fffa590213eab36514f338b864b736": "0x15af1d78b58c400000",
  	"0x9637dc12723d9c78588542eab082664f3f038d9d": "0x3635c9adc5dea00000",
  	"0x964eab4b276b4cd8983e15ca72b106900fe41fce": "0x1b1ae4d6e2ef500000",
  	"0x9662ee021926682b31c5f200ce457abea76c6ce9": "0x24590e8589eb6a0000",
  	"0x966c04781cb5e67dde3235d7f8620e1ab663a9a5": "0x100d2050da6351600000",
  	"0x967076a877b18ec15a415bb116f06ef32645dba3": "0x6c6b935b8bbd400000",
  	"0x967bfaf76243cdb9403c67d2ceefdee90a3feb73": "0x349d87f2a2dc2f0000",
  	"0x967d4142af770515dd7062af93498dbfdff29f20": "0x11854d0f9cee40000",
  	"0x968b14648f018333687cd213fa640aec04ce6323": "0x3635c9adc5dea00000",
  	"0x968dea60df3e09ae3c8d3505e9c080454be0e819": "0x14542ba12a337c00000",
  	"0x96924191b7df655b3319dc6d6137f481a73a0ff3": "0xd9ecb4fd208e500000",
  	"0x9696052138338c722f1140815cf7749d0d3b3a74": "0x1b1ae4d6e2ef500000",
  	"0x96a55f00dff405dc4de5e58c57f6f6f0cac55d2f": "0x6a6616379c87b58000",
  	"0x96aa573fed2f233410dbae5180145b23c31a02f0": "0x5dc892aa1131c80000",
  	"0x96ad579bbfa8db8ebec9d286a72e4661eed8e356": "0x3a0ba42bec61830000",
  	"0x96b434fe0657e42acc8212b6865139dede15979c": "0xd8d726b7177a800000",
  	"0x96b906ea729f4655afe3e57d35277c967dfa1577": "0x3635c9adc5dea00000",
  	"0x96d62dfd46087f62409d93dd606188e70e381257": "0x6c6b935b8bbd400000",
  	"0x96d9cca8f55eea0040ec6eb348a1774b95d93ef4": "0xd8d726b7177a800000",
  	"0x96e7c0c9d5bf10821bf140c558a145b7cac21397": "0x393ef1a5127c800000",
  	"0x96ea6ac89a2bac95347b51dba63d8bd5ebdedce1": "0x6c6b935b8bbd400000",
  	"0x96eafbf2fb6f4db9a436a74c45b5654452e23819": "0x1158e460913d00000",
  	"0x96eb523e832f500a017de13ec27f5d366c560eff": "0x10acceba43ee280000",
  	"0x96f0462ae6f8b96088f7e9c68c74b9d8ad34b347": "0x61093d7c2c6d380000",
  	"0x96f820500b70f4a3e3239d619cff8f222075b135": "0xad78ebc5ac6200000",
  	"0x96fe59c3dbb3aa7cc8cb62480c65e56e6204a7e2": "0x43c33c1937564800000",
  	"0x96ff6f509968f36cb42cba48db32f21f5676abf8": "0x6acb3df27e1f880000",
  	"0x970938522afb5e8f994873c9fbdc26e3b37e314c": "0x3635c9adc5dea00000",
  	"0x970abd53a54fca4a6429207c182d4d57bb39d4a0": "0x6c6b935b8bbd400000",
  	"0x970d8b8a0016d143054f149fb3b8e550dc0797c7": "0x3635c9adc5dea00000",
  	"0x972c2f96aa00cf8a2f205abcf8937c0c75f5d8d9": "0xad78ebc5ac6200000",
  	"0x973f4e361fe5decd989d4c8f7d7cc97990385daf": "0x150f8543a387420000",
  	"0x974d0541ab4a47ec7f75369c0069b64a1b817710": "0x15af1d78b58c400000",
  	"0x974d2f17895f2902049deaaecf09c3046507402d": "0xcc19c29437ab8000",
  	"0x9752d14f5e1093f071711c1adbc4e3eb1e5c57f3": "0x6c6b935b8bbd400000",
  	"0x9756e176c9ef693ee1eec6b9f8b151d313beb099": "0x410d586a20a4c00000",
  	"0x975f3764e97bbccf767cbd3b795ba86d8ba9840e": "0x12c1b6eed03d280000",
  	"0x976a18536af41874426308871bcd1512a775c9f8": "0x21e19e0c9bab2400000",
  	"0x976e3ceaf3f1af51f8c29aff5d7fa21f0386d8ee": "0xd02ab486cedc00000",
  	"0x9777cc61cf756be3b3c20cd4491c69d275e7a120": "0x21e19e0c9bab2400000",
  	"0x97810bafc37e84306332aacb35e92ad911d23d24": "0x3635c9adc5dea00000",
  	"0x978c430ce4359b06bc2cdf5c2985fc950e50d5c8": "0x1a055690d9db800000",
  	"0x9795f64319fc17dd0f8261f9d206fb66b64cd0c9": "0xad78ebc5ac6200000",
  	"0x9799ca21dbcf69bfa1b3f72bac51b9e3ca587cf9": "0x5c283d410394100000",
  	"0x979cbf21dfec8ace3f1c196d82df962534df394f": "0x9991d478dd4d160000",
  	"0x979d681c617da16f21bcaca101ed16ed015ab696": "0x65ea3db75546600000",
  	"0x979f30158b574b999aab348107b9eed85b1ff8c1": "0x34957444b840e80000",
  	"0x97a86f01ce3f7cfd4441330e1c9b19e1b10606ef": "0x6c6b935b8bbd400000",
  	"0x97b91efe7350c2d57e7e406bab18f3617bcde14a": "0x21e1999bbd5d2be0000",
  	"0x97d0d9725e3b70e675843173938ed371b62c7fac": "0x93739534d28680000",
  	"0x97d9e46a7604d7b5a4ea4ee61a42b3d2350fc3ed": "0x6c6b935b8bbd400000",
  	"0x97dc26ec670a31e0221d2a75bc5dc9f90c1f6fd4": "0x2b5e3af16b1880000",
  	"0x97de21e421c37fe4b8025f9a51b7b390b5df7804": "0x10f0cf064dd592000000",
  	"0x97e28973b860c567402800fbb63ce39a048a3d79": "0x542253a126ce40000",
  	"0x97e5cc6127c4f885be02f44b42d1c8b0ac91e493": "0xad78ebc5ac6200000",
  	"0x97f1fe4c8083e596212a187728dd5cf80a31bec5": "0x1158e460913d00000",
  	"0x97f7760657c1e202759086963eb4211c5f8139b9": "0xa8a097fcb3d17680000",
  	"0x97f99b6ba31346cd98a9fe4c308f87c5a58c5151": "0x14542ba12a337c00000",
  	"0x980a84b686fc31bdc83c221058546a71b11f838a": "0x2a415548af86818000",
  	"0x9810e34a94db6ed156d0389a0e2b80f4fd6b0a8a": "0x6c6b935b8bbd400000",
  	"0x981ddf0404e4d22dda556a0726f00b2d98ab9569": "0x36356633ebd8ea0000",
  	"0x981f712775c0dad97518ffedcb47b9ad1d6c2762": "0x16a6502f15a1e540000",
  	"0x9834682180b982d166badb9d9d1d9bbf016d87ee": "0x6c6b935b8bbd400000",
  	"0x9836b4d30473641ab56aeee19242761d72725178": "0x6c6b935b8bbd400000",
  	"0x98397342ec5f3d4cb877e54ef5d6f1d366731bd4": "0x14061b9d77a5e980000",
  	"0x9846648836a307a057184fd51f628a5f8c12427c": "0x40b69bf43dce8f00000",
  	"0x984a7985e3cc7eb5c93691f6f8cc7b8f245d01b2": "0x14542ba12a337c00000",
  	"0x985d70d207892bed398590024e2421b1cc119359": "0x43c33c1937564800000",
  	"0x986df47e76e4d7a789cdee913cc9831650936c9d": "0x10f0cf064dd59200000",
  	"0x9874803fe1f3a0365e7922b14270eaeb032cc1b5": "0x3cf5928824c6c20000",
  	"0x9875623495a46cdbf259530ff838a1799ec38991": "0x6c6b935b8bbd400000",
  	"0x987618c85656207c7bac1507c0ffefa2fb64b092": "0x37dfe433189e38000",
  	"0x987c9bcd6e3f3990a52be3eda4710c27518f4f72": "0x15af1d78b58c400000",
  	"0x9882967cee68d2a839fad8ab4a7c3dddf6c0adc8": "0x4878be1ffaf95d0000",
  	"0x98855c7dfbee335344904a12c40c731795b13a54": "0x39fbae8d042dd00000",
  	"0x989c0ccff654da03aeb11af701054561d6297e1d": "0xd8d726b7177a800000",
  	"0x98a0e54c6d9dc8be96276cebf4fec460f6235d85": "0x6ac882100952c78000",
  	"0x98b769cc305cecfb629a00c907069d7ef9bc3a12": "0x168d28e3f00280000",
  	"0x98ba4e9ca72fddc20c69b4396f76f8183f7a2a4e": "0x2b5e3af16b188000000",
  	"0x98be696d51e390ff1c501b8a0f6331b628ddc5ad": "0x6c6b935b8bbd400000",
  	"0x98bed3a72eccfbafb923489293e429e703c7e25b": "0x6c6b935b8bbd400000",
  	"0x98bf4af3810b842387db70c14d46099626003d10": "0xd8d726b7177a800000",
  	"0x98c10ebf2c4f97cba5a1ab3f2aafe1cac423f8cb": "0x1043561a8829300000",
  	"0x98c19dba810ba611e68f2f83ee16f6e7744f0c1f": "0xad78ebc5ac6200000",
  	"0x98c5494a03ac91a768dffc0ea1dde0acbf889019": "0x2a5a058fc295ed000000",
  	"0x98d204f9085f8c8e7de23e589b64c6eff692cc63": "0x6c6b935b8bbd400000",
  	"0x98d3731992d1d40e1211c7f735f2189afa0702e0": "0x1b1ae4d6e2ef5000000",
  	"0x98e2b6d606fd2d6991c9d6d4077fdf3fdd4585da": "0x30df1a6f8ad6280000",
  	"0x98e3e90b28fccaee828779b8d40a5568c4116e21": "0x22b1c8c1227a00000",
  	"0x98e6f547db88e75f1f9c8ac2c5cf1627ba580b3e": "0x3635c9adc5dea00000",
  	"0x98f4af3af0aede5fafdc42a081ecc1f89e3ccf20": "0x1fd933494aa5fe00000",
  	"0x98f6b8e6213dbc9a5581f4cce6655f95252bdb07": "0x115872b0bca4300000",
  	"0x9909650dd5b1397b8b8b0eb69499b291b0ad1213": "0xad78ebc5ac6200000",
  	"0x991173601947c2084a62d639527e961512579af9": "0x2086ac351052600000",
  	"0x99129d5b3c0cde47ea0def4dfc070d1f4a599527": "0x6c6b935b8bbd400000",
  	"0x9917d68d4af341d651e7f0075c6de6d7144e7409": "0x132d4476c08e6f00000",
  	"0x991ac7ca7097115f26205eee0ef7d41eb4e311ae": "0x1158e460913d00000",
  	"0x992365d764c5ce354039ddfc912e023a75b8e168": "0xfc936392801c0000",
  	"0x992646ac1acaabf5ddaba8f9429aa6a94e7496a7": "0x3637507a30abeb0000",
  	"0x99268327c373332e06c3f6164287d455b9d5fa4b": "0x6c6b935b8bbd400000",
  	"0x9928ff715afc3a2b60f8eb4cc4ba4ee8dab6e59d": "0x17da3a04c7b3e00000",
  	"0x9932ef1c85b75a9b2a80057d508734c51085becc": "0x2b83fa5301d590000",
  	"0x993f146178605e66d517be782ef0b3c61a4e1925": "0x17c1f0535d7a5830000",
  	"0x99413704b1a32e70f3bc0d69dd881c38566b54cb": "0x5cc6b694631f7120000",
  	"0x994152fc95d5c1ca8b88113abbad4d710e40def6": "0x1b1ae4d6e2ef500000",
  	"0x9944fee9d34a4a880023c78932c00b59d5c82a82": "0x28a8a56b3690070000",
  	"0x994cc2b5227ec3cf048512467c41b7b7b748909f": "0x6c6b935b8bbd400000",
  	"0x9971df60f0ae66dce9e8c84e17149f09f9c52f64": "0xad78ebc5ac6200000",
  	"0x9976947eff5f6ae5da08dd541192f378b428ff94": "0x1b1ae4d6e2ef5000000",
  	"0x997d6592a31589acc31b9901fbeb3cc3d65b3215": "0x6c6b935b8bbd400000",
  	"0x9982a5890ffb5406d3aca8d2bfc1dd70aaa80ae0": "0x6c6b935b8bbd400000",
  	"0x99878f9d6e0a7ed9aec78297b73879a80195afe0": "0xd7c198710e66b00000",
  	"0x998c1f93bcdb6ff23c10d0dc924728b73be2ff9f": "0x365bf3a433eaf30000",
  	"0x9991614c5baa47dd6c96874645f97add2c3d8380": "0x6acb3df27e1f880000",
  	"0x99924a9816bb7ddf3fec1844828e9ad7d06bf4e6": "0x5f68e8131ecf800000",
  	"0x99997668f7c1a4ff9e31f9977ae3224bcb887a85": "0xfc936392801c00000",
  	"0x999c49c174ca13bc836c1e0a92bff48b271543ca": "0xb1cf24ddd0b1400000",
  	"0x99a4de19ded79008cfdcd45d014d2e584b8914a8": "0x5150ae84a8cdf00000",
  	"0x99a96bf2242ea1b39ece6fcc0d18aed00c0179f3": "0x1043561a8829300000",
  	"0x99b018932bcad355b6792b255db6702dec8ce5dd": "0xd8d8583fa2d52f0000",
  	"0x99b743d1d9eff90d9a1934b4db21d519d89b4a38": "0x56bc75e2d63100000",
  	"0x99b8c824869de9ed24f3bff6854cb6dd45cc3f9f": "0x65ea3db75546600000",
  	"0x99c0174cf84e0783c220b4eb6ae18fe703854ad3": "0x7079a2573d0c780000",
  	"0x99c1d9f40c6ab7f8a92fce2fdce47a54a586c53f": "0x35659ef93f0fc40000",
  	"0x99c236141daec837ece04fdaee1d90cf8bbdc104": "0x766516acac0d200000",
  	"0x99c31fe748583787cdd3e525b281b218961739e3": "0x3708baed3d68900000",
  	"0x99c475bf02e8b9214ada5fad02fdfd15ba365c0c": "0x2009c5c8bf6fdc0000",
  	"0x99c883258546cc7e4e971f522e389918da5ea63a": "0xd8d726b7177a800000",
  	"0x99c9f93e45fe3c1418c353e4c5ac3894eef8121e": "0x585baf145050b0000",
  	"0x99d1579cd42682b7644e1d4f7128441eeffe339d": "0x43c33c1937564800000",
  	"0x99d1b585965f406a42a49a1ca70f769e765a3f98": "0x3894f0e6f9b9f700000",
  	"0x99dfd0504c06c743e46534fd7b55f1f9c7ec3329": "0x6c6b935b8bbd400000",
  	"0x99f4147ccc6bcb80cc842e69f6d00e30fa4133d9": "0x15af1d78b58c400000",
  	"0x99f77f998b20e0bcdcd9fc838641526cf25918ef": "0x61093d7c2c6d380000",
  	"0x99fad50038d0d9d4c3fbb4bce05606ecadcd5121": "0x6c6b935b8bbd400000",
  	"0x99fe0d201228a753145655d428eb9fd94985d36d": "0x6920bff3515a3a0000",
  	"0x9a079c92a629ca15c8cafa2eb28d5bc17af82811": "0x1b1ae4d6e2ef500000",
  	"0x9a0d3cee3d9892ea3b3700a27ff84140d9025493": "0x340aad21b3b700000",
  	"0x9a24ce8d485cc4c86e49deb39022f92c7430e67e": "0x46791fc84e07d00000",
  	"0x9a2ce43b5d89d6936b8e8c354791b8afff962425": "0x6c6b935b8bbd400000",
  	"0x9a390162535e398877e416787d6239e0754e937c": "0x3635c9adc5dea00000",
  	"0x9a3da65023a13020d22145cfc18bab10bd19ce4e": "0x18bf6ea3464a3a0000",
  	"0x9a3e2b1bf346dd070b027357feac44a4b2c97db8": "0x21e19e0c9bab2400000",
  	"0x9a4ca8b82117894e43db72b9fa78f0b9b93ace09": "0x2b5e3af16b1880000",
  	"0x9a522e52c195bfb7cf5ffaaedb91a3ba7468161d": "0x3635c9adc5dea00000",
  	"0x9a5af31c7e06339ac8b4628d7c4db0ce0f45c8a4": "0x1b1ae4d6e2ef500000",
  	"0x9a633fcd112cceeb765fe0418170732a9705e79c": "0xfc936392801c0000",
  	"0x9a63d185a79129fdab19b58bb631ea36a420544e": "0x246ddf97976680000",
  	"0x9a6708ddb8903c289f83fe889c1edcd61f854423": "0x3635c9adc5dea00000",
  	"0x9a6ff5f6a7af7b7ae0ed9c20ecec5023d281b786": "0x8a12b9bd6a67ec0000",
  	"0x9a82826d3c29481dcc2bd2950047e8b60486c338": "0x43c33c1937564800000",
  	"0x9a8eca4189ff4aa8ff7ed4b6b7039f0902219b15": "0x1158e460913d00000",
  	"0x9a953b5bcc709379fcb559d7b916afdaa50cadcc": "0x56bc75e2d63100000",
  	"0x9a990b8aeb588d7ee7ec2ed8c2e64f7382a9fee2": "0x1d127db69fd8b0000",
  	"0x9a9d1dc0baa77d6e20c3d849c78862dd1c054c87": "0x2fb474098f67c00000",
  	"0x9aa48c66e4fb4ad099934e32022e827427f277ba": "0x21e19e0c9bab2400000",
  	"0x9aa8308f42910e5ade09c1a5e282d6d91710bdbf": "0xad78ebc5ac6200000",
  	"0x9aaafa0067647ed999066b7a4ca5b4b3f3feaa6f": "0x3635c9adc5dea00000",
  	"0x9ab988b505cfee1dbe9cd18e9b5473b9a2d4f536": "0x1158e460913d000000",
  	"0x9ab98d6dbb1eaae16d45a04568541ad3d8fe06cc": "0xec50464fe23f38000",
  	"0x9aba2b5e27ff78baaab5cdc988b7be855cebbdce": "0x21e0c0013070adc0000",
  	"0x9ac4da51d27822d1e208c96ea64a1e5b55299723": "0x56c5579f722140000",
  	"0x9ac85397792a69d78f286b86432a07aeceb60e64": "0xc673ce3c40160000",
  	"0x9ac907ee85e6f3e223459992e256a43fa08fa8b2": "0x21e19e0c9bab2400000",
  	"0x9ad47fdcf9cd942d28effd5b84115b31a658a13e": "0xb259ec00d53b280000",
  	"0x9adbd3bc7b0afc05d1d2eda49ff863939c48db46": "0xad6eedd17cf3b8000",
  	"0x9adf458bff3599eee1a26398853c575bc38c6313": "0xf2dc7d47f15600000",
  	"0x9ae13bd882f2576575921a94974cbea861ba0d35": "0xab4dcf399a3a600000",
  	"0x9ae9476bfecd3591964dd325cf8c2a24faed82c1": "0xd8d726b7177a800000",
  	"0x9af100cc3dae83a33402051ce4496b16615483f6": "0x6c6b935b8bbd400000",
  	"0x9af11399511c213181bfda3a8b264c05fc81b3ce": "0x2f6f10780d22cc00000",
  	"0x9af5c9894c33e42c2c518e3ac670ea9505d1b53e": "0xfc936392801c0000",
  	"0x9af9dbe47422d177f945bdead7e6d82930356230": "0xd5967be4fc3f100000",
  	"0x9afa536b4c66bc38d875c4b30099d9261fdb38eb": "0xb2a8f842a77bc8000",
  	"0x9b06ad841dffbe4ccf46f1039fc386f3c321446e": "0x6c6b935b8bbd400000",
  	"0x9b1168de8ab64b47552f3389800a9cc08b4666cf": "0x5dc892aa1131c80000",
  	"0x9b1811c3051f46e664ae4bc9c824d18592c4574a": "0xad6eedd17cf3b8000",
  	"0x9b18478655a4851cc906e660feac61f7f4c8bffc": "0xe2478d38907d840000",
  	"0x9b22a80d5c7b3374a05b446081f97d0a34079e7f": "0xa2a15d09519be00000",
  	"0x9b2be7f56754f505e3441a10f7f0e20fd3ddf849": "0x126e72a69a50d00000",
  	"0x9b32cf4f5115f4b34a00a64c617de06387354323": "0x5b81ed888207c8000",
  	"0x9b43dcb95fde318075a567f1e6b57617055ef9e8": "0xd5967be4fc3f100000",
  	"0x9b444fd337e5d75293adcfff70e1ea01db023222": "0x56bc75e2d63100000",
  	"0x9b4824ff9fb2abda554dee4fb8cf549165570631": "0x1158e460913d00000",
  	"0x9b4c2715780ca4e99e60ebf219f1590c8cad500a": "0x56bc75e2d631000000",
  	"0x9b59eb213b1e7565e45047e04ea0374f10762d16": "0x6c6b935b8bbd400000",
  	"0x9b5c39f7e0ac168c8ed0ed340477117d1b682ee9": "0x55005f0c614480000",
  	"0x9b5ec18e8313887df461d2902e81e67a8f113bb1": "0x56bc75e2d63100000",
  	"0x9b64d3cd8d2b73f66841b5c46bb695b88a9ab75d": "0x1203a4f760c168000",
  	"0x9b658fb361e046d4fcaa8aef6d02a99111223625": "0x6c6b935b8bbd400000",
  	"0x9b6641b13e172fc072ca4b8327a3bc28a15b66a9": "0x68155a43676e00000",
  	"0x9b68f67416a63bf4451a31164c92f672a68759e9": "0xcb49b44ba602d800000",
  	"0x9b773669e87d76018c090f8255e54409b9dca8b2": "0x1158e460913d00000",
  	"0x9b77ebced7e215f0920e8c2b870024f6ecb2ff31": "0x3635c9adc5dea00000",
  	"0x9b7c8810cc7cc89e804e6d3e38121850472877fe": "0x6c6b935b8bbd400000",
  	"0x9ba53dc8c95e9a472feba2c4e32c1dc4dd7bab46": "0x487a9a304539440000",
  	"0x9bacd3d40f3b82ac91a264d9d88d908eac8664b9": "0x43c33c1937564800000",
  	"0x9bb760d5c289a3e1db18db095345ca413b9a43c2": "0xaadec983fcff40000",
  	"0x9bb76204186af2f63be79168601687fc9bad661f": "0x1043561a8829300000",
  	"0x9bb9b02a26bfe1ccc3f0c6219e261c397fc5ca78": "0x487a9a304539440000",
  	"0x9bc573bcda23b8b26f9073d90c230e8e71e0270b": "0x362f75a4305d0c0000",
  	"0x9bd7c38a4210304a4d653edeff1b3ce45fce7843": "0xf498941e664280000",
  	"0x9bd88068e13075f3a8cac464a5f949d6d818c0f6": "0x14542ba12a337c00000",
  	"0x9bd905f1719fc7acd0159d4dc1f8db2f21472338": "0x3635c9adc5dea00000",
  	"0x9bdbdc9b973431d13c89a3f9757e9b3b6275bfc7": "0x1b1a7dcf8a44d38000",
  	"0x9be3c329b62a28b8b0886cbd8b99f8bc930ce3e6": "0x409e52b48369a0000",
  	"0x9bf58efbea0784eb068adecfa0bb215084c73a35": "0x13a6b2b564871a00000",
  	"0x9bf672d979b36652fc5282547a6a6bc212ae4368": "0x238fd42c5cf0400000",
  	"0x9bf703b41c3624e15f4054962390bcba3052f0fd": "0x1483e01533c2e3c0000",
  	"0x9bf71f7fb537ac54f4e514947fa7ff6728f16d2f": "0x1cf84a30a0a0c0000",
  	"0x9bf9b3b2f23cf461eb591f28340bc719931c8364": "0x3635c9adc5dea00000",
  	"0x9bfc659c9c601ea42a6b21b8f17084ec87d70212": "0x21e19e0c9bab2400000",
  	"0x9bfff50db36a785555f07652a153b0c42b1b8b76": "0x6c6b935b8bbd400000",
  	"0x9c05e9d0f0758e795303717e31da213ca157e686": "0x3635c9adc5dea00000",
  	"0x9c1b771f09af882af0643083de2aa79dc097c40e": "0x8670e9ec6598c00000",
  	"0x9c28a2c4086091cb5da226a657ce3248e8ea7b6f": "0xf2dc7d47f15600000",
  	"0x9c2fd54089af665df5971d73b804616039647375": "0x3635c9adc5dea00000",
  	"0x9c344098ba615a398f11d009905b177c44a7b602": "0x3635c9adc5dea00000",
  	"0x9c3d0692ceeef80aa4965ceed262ffc7f069f2dc": "0xad78ebc5ac6200000",
  	"0x9c405cf697956138065e11c5f7559e67245bd1a5": "0xad78ebc5ac6200000",
  	"0x9c45202a25f6ad0011f115a5a72204f2f2198866": "0x10fcf3a62b080980000",
  	"0x9c49deff47085fc09704caa2dca8c287a9a137da": "0x1b1ae4d6e2ef5000000",
  	"0x9c4bbcd5f1644a6f075824ddfe85c571d6abf69c": "0x6194049f30f7200000",
  	"0x9c526a140683edf1431cfaa128a935e2b614d88b": "0x6046f37e5945c0000",
  	"0x9c54e4ed479a856829c6bb42da9f0b692a75f728": "0x197a8f6dd5519800000",
  	"0x9c581a60b61028d934167929b22d70b313c34fd0": "0xa968163f0a57b400000",
  	"0x9c5cc111092c122116f1a85f4ee31408741a7d2f": "0x1ab2cf7c9f87e20000",
  	"0x9c6bc9a46b03ae5404f043dfcf21883e4110cc33": "0xad78ebc5ac6200000",
  	"0x9c78963fbc263c09bd72e4f8def74a9475f7055c": "0x2eb8eb1a172dcb80000",
  	"0x9c78fbb4df769ce2c156920cfedfda033a0e254a": "0x6acb3df27e1f880000",
  	"0x9c7b6dc5190fe2912963fcd579683ec7395116b0": "0x2a1129d09367200000",
  	"0x9c80bc18e9f8d4968b185da8c79fa6e11ffc3e23": "0xd02ab486cedc00000",
  	"0x9c98fdf1fdcd8ba8f4c5b04c3ae8587efdf0f6e6": "0x14542ba12a337c00000",
  	"0x9c99a1da91d5920bc14e0cb914fdf62b94cb8358": "0x43c33c1937564800000",
  	"0x9c99b62606281b5cefabf36156c8fe62839ef5f3": "0xd8d726b7177a800000",
  	"0x9c9a07a8e57c3172a919ef64789474490f0d9f51": "0x21e19e0c9bab2400000",
  	"0x9c9de44724a4054da0eaa605abcc802668778bea": "0xad7d5ca3fa5a20000",
  	"0x9c9f3b8a811b21f3ff3fe20fe970051ce66a824f": "0x3ec2debc07d4be0000",
  	"0x9c9f89a3910f6a2ae8a91047a17ab788bddec170": "0x21e19e0c9bab2400000",
  	"0x9ca0429f874f8dcee2e9c062a9020a842a587ab9": "0x6c6b935b8bbd400000",
  	"0x9ca42ee7a0b898f6a5cc60b5a5d7b1bfa3c33231": "0x6c6b935b8bbd400000",
  	"0x9cb28ac1a20a106f7f373692c5ce4c73f13732a1": "0x3635c9adc5dea00000",
  	"0x9ccddcb2cfc2b25b08729a0a98d9e6f0202ea2c1": "0x56bc75e2d63100000",
  	"0x9ce27f245e02d1c312c1d500788c9def7690453b": "0xad78ebc5ac6200000",
  	"0x9ce5363b13e8238aa4dd15acd0b2e8afe0873247": "0xad78ebc5ac6200000",
  	"0x9cf2928beef09a40f9bfc953be06a251116182fb": "0x14542ba12a337c00000",
  	"0x9d069197d1de50045a186f5ec744ac40e8af91c6": "0x6c6b935b8bbd400000",
  	"0x9d0e7d92fb305853d798263bf15e97c72bf9d7e0": "0x3635c9adc5dea00000",
  	"0x9d0f347e826b7dceaad279060a35c0061ecf334b": "0xd8d726b7177a800000",
  	"0x9d207517422cc0d60de7c237097a4d4fce20940c": "0x1b1ae4d6e2ef500000",
  	"0x9d250ae4f110d71cafc7b0adb52e8d9acb6679b8": "0x2156d6e997213c00000",
  	"0x9d2bfc36106f038250c01801685785b16c86c60d": "0x5077d75df1b675800000",
  	"0x9d30cb237bc096f17036fc80dd21ca68992ca2d9": "0x66ee7318fdc8f300000",
  	"0x9d32962ea99700d93228e9dbdad2cc37bb99f07e": "0xb4632bedd4ded40000",
  	"0x9d34dac25bd15828faefaaf28f710753b39e89dc": "0x3b1c56fed02df00000",
  	"0x9d369165fb70b81a3a765f188fd60cbe5e7b0968": "0x6c6b935b8bbd400000",
  	"0x9d40e012f60425a340d82d03a1c757bfabc706fb": "0x9346f3addc88d8000",
  	"0x9d4174aa6af28476e229dadb46180808c67505c1": "0x421afda42ed6970000",
  	"0x9d4213339a01551861764c87a93ce8f85f87959a": "0xad78ebc5ac6200000",
  	"0x9d460c1b379ddb19a8c85b4c6747050ddf17a875": "0xb50fcfafebecb00000",
  	"0x9d47ba5b4c8505ad8da42934280b61a0e1e8b971": "0x56bc75e2d63100000",
  	"0x9d4d321177256ebd9afbda304135d517c3dc5693": "0x2164b7a04ac8a00000",
  	"0x9d4ff989b7bed9ab109d10c8c7e55f02d76734ad": "0x3635c9adc5dea00000",
  	"0x9d511543b3d9dc60d47f09d49d01b6c498d82078": "0x26197b9516fc3940000",
  	"0x9d6ecfa03af2c6e144b7c4692a86951e902e9e1f": "0xa2a5aa60ad243f0000",
  	"0x9d7655e9f3e5ba5d6e87e412aebe9ee0d49247ee": "0x8e09311c1d80fa0000",
  	"0x9d7831e834c20b1baa697af1d8e0c621c5afff9a": "0x4b06dbbb40f4a0000",
  	"0x9d78a975b7db5e4d8e28845cfbe7e31401be0dd9": "0x48a43c54602f700000",
  	"0x9d799e943e306ba2e5b99c8a6858cbb52c0cf735": "0x1043561a8829300000",
  	"0x9d7fda7070bf3ee9bbd9a41f55cad4854ae6c22c": "0x255cba3c46fcf120000",
  	"0x9d81aea69aed6ad07089d61445348c17f34bfc5b": "0x1043561a8829300000",
  	"0x9d911f3682f32fe0792e9fb6ff3cfc47f589fca5": "0xd8d726b7177a800000",
  	"0x9d913b5d339c95d87745562563fea98b23c60cc4": "0x941302c7f4d230000",
  	"0x9d93fab6e22845f8f45a07496f11de71530debc7": "0x6c4fd1ee246e780000",
  	"0x9d99b189bbd9a48fc2e16e8fcda33bb99a317bbb": "0x3d16e10b6d8bb20000",
  	"0x9d9c4efe9f433989e23be94049215329fa55b4cb": "0xde3b28903c6b58000",
  	"0x9d9e57fde30e5068c03e49848edce343b7028358": "0x5dc892aa1131c80000",
  	"0x9da3302240af0511c6fd1857e6ddb7394f77ab6b": "0xa80d24677efef00000",
  	"0x9da4ec407077f4b9707b2d9d2ede5ea5282bf1df": "0xd8d726b7177a800000",
  	"0x9da609fa3a7e6cf2cc0e70cdabe78dc4e382e11e": "0x410d586a20a4c00000",
  	"0x9da61ccd62bf860656e0325d7157e2f160d93bb5": "0x10f0ca956f8799e0000",
  	"0x9da6e075989c7419094cc9f6d2e49393bb199688": "0x259bb71d5adf3f00000",
  	"0x9da8e22ca10e67fea44e525e4751eeac36a31194": "0xe18398e7601900000",
  	"0x9db2e15ca681f4c66048f6f9b7941ed08b1ff506": "0xd8d726b7177a800000",
  	"0x9dc10fa38f9fb06810e11f60173ec3d2fd6a751e": "0x6acb3df27e1f880000",
  	"0x9dd2196624a1ddf14a9d375e5f07152baf22afa2": "0x41b05e2463a5438000",
  	"0x9dd46b1c6d3f05e29e9c6f037eed9a595af4a9aa": "0x1b1ae4d6e2ef500000",
  	"0x9ddd355e634ee9927e4b7f6c97e7bf3a2f1e687a": "0x2b5e3af16b1880000",
  	"0x9de20ae76aa08263b205d5142461961e2408d266": "0xda933d8d8c6700000",
  	"0x9de20bc37e7f48a80ffd7ad84ffbf1a1abe1738c": "0xad78ebc5ac6200000",
  	"0x9de7386dde401ce4c67b71b6553f8aa34ea5a17d": "0x340aad21b3b700000",
  	"0x9deb39027af877992b89f2ec4a1f822ecdf12693": "0x6c6b935b8bbd400000",
  	"0x9defe56a0ff1a1947dba0923f7dd258d8f12fa45": "0x5b12aefafa804000000",
  	"0x9df057cd03a4e27e8e032f857985fd7f01adc8d7": "0x6c6b935b8bbd400000",
  	"0x9df32a501c0b781c0281022f42a1293ffd7b892a": "0x1e7e4171bf4d3a00000",
  	"0x9e01765aff08bc220550aca5ea2e1ce8e5b09923": "0x3635c9adc5dea00000",
  	"0x9e20e5fd361eabcf63891f5b87b09268b8eb3793": "0x56bc75e2d63100000",
  	"0x9e232c08c14dc1a6ed0b8a3b2868977ba5c17d10": "0x1158e460913d00000",
  	"0x9e23c5e4b782b00a5fadf1aead87dacf5b0367a1": "0x1158e460913d00000",
  	"0x9e35399071a4a101e9194daa3f09f04a0b5f9870": "0xd8d726b7177a800000",
  	"0x9e3eb509278fe0dcd8e0bbe78a194e06b6803943": "0x32f51edbaaa3300000",
  	"0x9e427272516b3e67d4fcbf82f59390d04c8e28e5": "0xd8d726b7177a800000",
  	"0x9e4cec353ac3e381835e3c0991f8faa5b7d0a8e6": "0x21e18b9e9ab45e48000",
  	"0x9e5811b40be1e2a1e1d28c3b0774acde0a09603d": "0xa2a15d09519be00000",
  	"0x9e5a311d9f69898a7c6a9d6360680438e67a7b2f": "0x50c5e761a444080000",
  	"0x9e7c2050a227bbfd60937e268cea3e68fea8d1fe": "0x56bc75e2d63100000",
  	"0x9e7f65a90e8508867bccc914256a1ea574cf07e3": "0x433874f632cc600000",
  	"0x9e8144e08e89647811fe6b72d445d6a5f80ad244": "0x21e19e0c9bab2400000",
  	"0x9e8f64ddcde9b8b451bafaa235a9bf511a25ac91": "0x90f534608a72880000",
  	"0x9e951f6dc5e352afb8d04299d2478a451259bf56": "0x3e7419881a73a0000",
  	"0x9e960dcd03d5ba99cb115d17ff4c09248ad4d0be": "0xad78ebc5ac6200000",
  	"0x9eaf6a328a4076024efa6b67b48b21eedcc0f0b8": "0x890b0c2e14fb80000",
  	"0x9eb1ff71798f28d6e989fa1ea0588e27ba86cb7d": "0x7a1fe160277000000",
  	"0x9eb281c32719c40fdb3e216db0f37fbc73a026b7": "0x1158e460913d00000",
  	"0x9eb3a7cb5e6726427a3a361cfa8d6164dbd0ba16": "0x2b95bdcc39b6100000",
  	"0x9eb7834e171d41e069a77947fca87622f0ba4e48": "0x56bc75e2d63100000",
  	"0x9ec03e02e587b7769def538413e97f7e55be71d8": "0x42bf06b78ed3b500000",
  	"0x9ecbabb0b22782b3754429e1757aaba04b81189f": "0x2ca7bb061f5e998000",
  	"0x9ece1400800936c7c6485fcdd3626017d09afbf6": "0x10ce1d3d8cb3180000",
  	"0x9ed4e63f526542d44fddd34d59cd25388ffd6bda": "0xd29b34a46348940000",
  	"0x9ed80eda7f55054db9fb5282451688f26bb374c1": "0x1043561a8829300000",
  	"0x9edc90f4be210865214ab5b35e5a8dd77415279d": "0xd8d726b7177a800000",
  	"0x9edeac4c026b93054dc5b1d6610c6f3960f2ad73": "0x410d586a20a4c00000",
  	"0x9ee93f339e6726ec65eea44f8a4bfe10da3d3282": "0x6c6b935b8bbd400000",
  	"0x9ee9760cc273d4706aa08375c3e46fa230aff3d5": "0x1e52e336cde22180000",
  	"0x9eeb07bd2b7890195e7d46bdf2071b6617514ddb": "0x6c6b935b8bbd400000",
  	"0x9eef442d291a447d74c5d253c49ef324eac1d8f0": "0xb96608c8103bf00000",
  	"0x9ef1896b007c32a15114fb89d73dbd47f9122b69": "0xd8d726b7177a800000",
  	"0x9f017706b830fb9c30efb0a09f506b9157457534": "0x6c6b935b8bbd400000",
  	"0x9f10f2a0463b65ae30b070b3df18cf46f51e89bd": "0x678a932062e4180000",
  	"0x9f19fac8a32437d80ac6837a0bb7841729f4972e": "0x233df3299f61720000",
  	"0x9f1aa8fcfc89a1a5328cbd6344b71f278a2ca4a0": "0x1b1ae4d6e2ef500000",
  	"0x9f21302ca5096bea7402b91b0fd506254f999a3d": "0x4397451a003dd80000",
  	"0x9f271d285500d73846b18f733e25dd8b4f5d4a8b": "0x2723c346ae18080000",
  	"0x9f3497f5ef5fe63095836c004eb9ce02e9013b4b": "0x2256861bf9cf080000",
  	"0x9f3a74fd5e7edcc1162993171381cbb632b7cff0": "0x21e19e0c9bab2400000",
  	"0x9f46e7c1e9078cae86305ac7060b01467d6685ee": "0x243d4d18229ca20000",
  	"0x9f496cb2069563144d0811677ba0e4713a0a4143": "0x3cd2e0bf63a4480000",
  	"0x9f4a7195ac7c151ca258cafda0cab083e049c602": "0x53538c32185cee0000",
  	"0x9f4ac9c9e7e24cb2444a0454fa5b9ad9d92d3853": "0x2d43f3ebfafb2c0000",
  	"0x9f5f44026b576a4adb41e95961561d41039ca391": "0xd8d726b7177a80000",
  	"0x9f607b3f12469f446121cebf3475356b71b4328c": "0xd8d726b7177a800000",
  	"0x9f61beb46f5e853d0a8521c7446e68e34c7d0973": "0x1e5b8fa8fe2ac00000",
  	"0x9f64a8e8dacf4ade30d10f4d59b0a3d5abfdbf74": "0x36369ed7747d260000",
  	"0x9f662e95274121f177566e636d23964cf1fd686f": "0x6c6b935b8bbd400000",
  	"0x9f6a322a6d469981426ae844865d7ee0bb15c7b3": "0x2b5ee57929fdb8000",
  	"0x9f7986924aeb02687cd64189189fb167ded2dd5c": "0x35659ef93f0fc40000",
  	"0x9f7a0392f857732e3004a375e6b1068d49d83031": "0x6c6b935b8bbd400000",
  	"0x9f8245c3ab7d173164861cd3991b94f1ba40a93a": "0x9b0a791f1211300000",
  	"0x9f83a293c324d4106c18faa8888f64d299054ca0": "0xad78ebc5ac6200000",
  	"0x9f86a066edb61fcb5856de93b75c8c791864b97b": "0x6c6b935b8bbd400000",
  	"0x9f98eb34d46979b0a6de8b05aa533a89b825dcf1": "0x4b06dbbb40f4a0000",
  	"0x9f9fe0c95f10fee87af1af207236c8f3614ef02f": "0x14542ba12a337c00000",
  	"0x9faea13c733412dc4b490402bfef27a0397a9bc3": "0x10ce1d3d8cb3180000",
  	"0x9fbe066de57236dc830725d32a02aef9246c6c5e": "0x6c6b935b8bbd400000",
  	"0x9fd1052a60506bd1a9ef003afd9d033c267d8e99": "0x3635c9adc5dea00000",
  	"0x9fd64373f2fbcd9c0faca60547cad62e26d9851f": "0x3635c9adc5dea00000",
  	"0x9fe501aa57ead79278937cd6308c5cfa7a5629fe": "0x2b5ee57929fdb8000",
  	"0x9ffc5fe06f33f5a480b75aa94eb8556d997a16c0": "0x1158e460913d00000",
  	"0x9ffcf5ef46d933a519d1d16c6ba3189b27496224": "0x3635c9adc5dea00000",
  	"0x9ffedcc36b7cc312ad2a9ede431a514fccb49ba3": "0x244f579f3f5ca40000",
  	"0xa006268446643ec5e81e7acb3f17f1c351ee2ed9": "0xd8d726b7177a800000",
  	"0xa008019863c1a77c1499eb39bbd7bf2dd7a31cb9": "0x76d41c62494840000",
  	"0xa009bf076f1ba3fa57d2a7217218bed5565a7a7a": "0x3635c9adc5dea00000",
  	"0xa01e9476df84431825c836e8803a97e22fa5a0cd": "0x14542ba12a337c00000",
  	"0xa01f12d70f44aa7b113b285c22dcdb45873454a7": "0xfc936392801c0000",
  	"0xa01fd1906a908506dedae1e208128872b56ee792": "0xa2a15d09519be00000",
  	"0xa0228240f99e1de9cb32d82c0f2fa9a3d44b0bf3": "0x56bc75e2d631000000",
  	"0xa02bde6461686e19ac650c970d0672e76dcb4fc2": "0x1e09296c3378de40000",
  	"0xa02c1e34064f0475f7fa831ccb25014c3aa31ca2": "0x340aad21b3b700000",
  	"0xa02dc6aa328b880de99eac546823fccf774047fb": "0x6acb3df27e1f880000",
  	"0xa02e3f8f5959a7aab7418612129b701ca1b80010": "0x1158e460913d00000",
  	"0xa0347f0a98776390165c166d32963bf74dcd0a2f": "0x3635c9adc5dea00000",
  	"0xa035a3652478f82dbd6d115faa8ca946ec9e681d": "0x5f4e42dd4afec0000",
  	"0xa03a3dc7c533d1744295be955d61af3f52b51af5": "0x22b1c8c1227a00000",
  	"0xa0459ef3693aacd1647cd5d8929839204cef53be": "0x3635c9adc5dea00000",
  	"0xa04f2ae02add14c12faf65cb259022d0830a8e26": "0x152d02c7e14af6800000",
  	"0xa06cd1f396396c0a64464651d7c205efaf387ca3": "0x6c6acc67d7b1d40000",
  	"0xa072691c8dd7cd4237ff72a75c1a9506d0ce5b9e": "0x140ec80fa7ee880000",
  	"0xa072cebe62a9e9f61cc3fbf88a9efbfe3e9a8d70": "0x15af1d78b58c400000",
  	"0xa07682000b1bcf3002f85c80c0fa2949bd1e82fd": "0xd8d726b7177a800000",
  	"0xa07aa16d74aee8a9a3288d52db1551d593883297": "0x2086ac351052600000",
  	"0xa08d215b5b6aac4861a281ac7e400b78fef04cbf": "0x1158e460913d00000",
  	"0xa0951970dfd0832fb83bda12c23545e79041756c": "0x2086ac351052600000",
  	"0xa09f4d5eaa65a2f4cb750a49923401dae59090af": "0x796e3ea3f8ab00000",
  	"0xa0a0e65204541fca9b2fb282cd95138fae16f809": "0x21e19e0c9bab2400000",
  	"0xa0aa5f0201f04d3bbeb898132f7c11679466d901": "0x1fbed5215bb4c0000",
  	"0xa0aadbd9509722705f6d2358a5c79f37970f00f6": "0xad78ebc5ac6200000",
  	"0xa0b771951ce1deee363ae2b771b73e07c4b5e800": "0x4be4e7267b6ae00000",
  	"0xa0de5c601e696635c698b7ae9ca4539fc7b941ec": "0x12c3cbd704c9770000",
  	"0xa0e8ba661b48154cf843d4c2a5c0f792d528ee29": "0x15af1d78b58c400000",
  	"0xa0fc7e53c5ebd27a2abdac45261f84ab3b51aefb": "0xa313daec9bc0d90000",
  	"0xa0ff5b4cf016027e8323497d4428d3e5a83b8795": "0x16598d3c83ec0420000",
  	"0xa106465bbd19e1b6bce50d1b1157dc59095a3630": "0x6c6b935b8bbd400000",
  	"0xa106e6923edd53ca8ed650968a9108d6ccfd9670": "0x202fe1505afec898000",
  	"0xa109e18bb0a39c9ef82fa19597fc5ed8e9eb6d58": "0x58e7926ee858a00000",
  	"0xa11a03c4bb26d21eff677d5d555c80b25453ee7a": "0x3cb2759bc410f8000",
  	"0xa11effab6cf0f5972cffe4d56596e98968144a8f": "0x5a87e7d7f5f6580000",
  	"0xa1204dad5f560728a35c0d8fc79481057bf77386": "0x3635c9adc5dea00000",
  	"0xa12623e629df93096704b16084be2cd89d562da4": "0x1ccc9324511e4500000",
  	"0xa12a6c2d985daf0e4f5f207ae851aaf729b332cd": "0x152d02c7e14af6800000",
  	"0xa1336dfb96b6bcbe4b3edf3205be5723c90fad52": "0x10f0cf064dd59200000",
  	"0xa13b9d82a99b3c9bba5ae72ef2199edc7d3bb36c": "0x6c6acc67d7b1d40000",
  	"0xa13cfe826d6d1841dcae443be8c387518136b5e8": "0x1da56a4b0835bf800000",
  	"0xa1432ed2c6b7777a88e8d46d388e70477f208ca5": "0x1b1a7e413a196c50000",
  	"0xa144f6b60f72d64a21e330dadb62d8990ade2b09": "0x3635c9adc5dea00000",
  	"0xa15025f595acdbf3110f77c5bf24477e6548f9e8": "0x6c6b935b8bbd400000",
  	"0xa158148a2e0f3e92dc2ce38febc20107e3253c96": "0x6c6b935b8bbd400000",
  	"0xa16160851d2b9c349b92e46f829abfb210943595": "0x61093d7c2c6d380000",
  	"0xa166f911c644ac3213d29e0e1ae010f794d5ad26": "0x6c6b935b8bbd400000",
  	"0xa16d9e3d63986159a800b46837f45e8bb980ee0b": "0x6e1175da7ad1200000",
  	"0xa17070c2e9c5a940a4ec0e4954c4d7d643be8f49": "0x6c6b17033b361c8000",
  	"0xa17c9e4323069518189d5207a0728dcb92306a3f": "0x3635c9adc5dea00000",
  	"0xa18360e985f2062e8f8efe02ad2cbc91ad9a5aad": "0xa2a15d09519be00000",
  	"0xa1911405cf6e999ed011f0ddcd2a4ff7c28f2526": "0x22b1c8c1227a00000",
  	"0xa192698007cc11aa603d221d5feea076bcf7c30d": "0x6c6b935b8bbd400000",
  	"0xa192f06ab052d5fd7f94eea8318e827815fe677a": "0x71f8a93d01e540000",
  	"0xa1998144968a5c70a6415554cefec2824690c4a5": "0x1158e460913d00000",
  	"0xa1a1f0fa6d20b50a794f02ef52085c9d036aa6ca": "0x3635c9adc5dea00000",
  	"0xa1ae8d4540d4db6fdde7146f415b431eb55c7983": "0xaadec983fcff40000",
  	"0xa1b47c4d0ed6018842e6cfc8630ac3a3142e5e6b": "0x1158e460913d00000",
  	"0xa1c4f45a82e1c478d845082eb18875c4ea6539ab": "0x2a5a058fc295ed000000",
  	"0xa1dcd0e5b05a977c9623e5ae2f59b9ada2f33e31": "0x56bc75e2d63100000",
  	"0xa1e4380a3b1f749673e270229993ee55f35663b4": "0x6c6b935b8bbd400000",
  	"0xa1f193a0592f1feb9fdfc90aa813784eb80471c9": "0x4be4e7267b6ae00000",
  	"0xa1f2854050f872658ed82e52b0ad7bbc1cb921f6": "0x6d0317e2b326f70000",
  	"0xa1f5b840140d5a9acef402ac3cc3886a68cad248": "0x6c6b935b8bbd400000",
  	"0xa1f765c44fe45f790677944844be4f2d42165fbd": "0xc7e9cfde768ec70000",
  	"0xa1f7dde1d738d8cd679ea1ee965bee224be7d04d": "0x3d184450e5e93c0000",
  	"0xa1f8d8bcf90e777f19b3a649759ad95027abdfc3": "0xad78ebc5ac6200000",
  	"0xa202547242806f6e70e74058d6e5292defc8c8d4": "0x6c8754c8f30c080000",
  	"0xa20d071b1b003063497d7990e1249dabf36c35f7": "0x3635c9adc5dea00000",
  	"0xa20d8ff60caae31d02e0b665fa435d76f77c9442": "0x1a8a909dfcef400000",
  	"0xa211da03cc0e31ecce5309998718515528a090df": "0xad78ebc5ac6200000",
  	"0xa21442ab05340ade68c915f3c3399b9955f3f7eb": "0x2a034919dfbfbc0000",
  	"0xa2222259dd9c3e3ded127084f808e92a1887302c": "0x8c8339dafed480000",
  	"0xa22ade0ddb5c6ef8d0cd8de94d82b11082cb2e91": "0x374b57f3cef2700000",
  	"0xa24c3ab62181e9a15b78c4621e4c7c588127be26": "0x8cde43a83d3310000",
  	"0xa257ad594bd88328a7d90fc0a907df95eecae316": "0x1c3786ff3846930000",
  	"0xa25b086437fd2192d0a0f64f6ed044f38ef3da32": "0x12290f15180bdc0000",
  	"0xa276b058cb98d88beedb67e543506c9a0d9470d8": "0x90aafc76e02fbe0000",
  	"0xa282e969cac9f7a0e1c0cd90f5d0c438ac570da3": "0x2207eb89fc27380000",
  	"0xa291e9c7990d552dd1ae16cebc3fca342cbaf1d1": "0x43c33c1937564800000",
  	"0xa29319e81069e5d60df00f3de5adee3505ecd5fb": "0x6c6b935b8bbd400000",
  	"0xa2968fc1c64bac0b7ae0d68ba949874d6db253f4": "0x43c33c1937564800000",
  	"0xa29d5bda74e003474872bd5894b88533ff64c2b5": "0x21e19e0c9bab2400000",
  	"0xa29d661a6376f66d0b74e2fe9d8f26c0247ec84c": "0xdf3304079c13d20000",
  	"0xa2a435de44a01bd0ecb29e44e47644e46a0cdffb": "0x1b1d445a7affe78000",
  	"0xa2ace4c993bb1e5383f8ac74e179066e814f0591": "0x56bc75e2d63100000",
  	"0xa2b701f9f5cdd09e4ba62baebae3a88257105885": "0x3635c9adc5dea00000",
  	"0xa2c5854ff1599f98892c5725d262be1da98aadac": "0x1109ff333010e78000",
  	"0xa2c7eaffdc2c9d937345206c909a52dfb14c478f": "0x7c0860e5a80dc0000",
  	"0xa2d2aa626b09d6d4e4b13f7ffc5a88bd7ad36742": "0xfb8078507553830000",
  	"0xa2d38de1c73906f6a7ca6efeb97cf6f69cc421be": "0x3635c9adc5dea00000",
  	"0xa2dc65ee256b59a5bd7929774f904b358df3ada1": "0x483bce28beb09f80000",
  	"0xa2e0683a805de6a05edb2ffbb5e96f0570b637c3": "0x1158e460913d00000",
  	"0xa2e1b8aa900e9c139b3fa122354f6156d92a18b1": "0x1b1ae4d6e2ef500000",
  	"0xa2e2b5941e0c01944bfe1d5fb4e8a34b922ccfb1": "0xad78ebc5ac6200000",
  	"0xa2e460a989cb15565f9ecca7d121a18e4eb405b6": "0x6c6b935b8bbd400000",
  	"0xa2ecce2c49f72a0995a0bda57aacf1e9f001e22a": "0xd8d726b7177a800000",
  	"0xa2f472fe4f22b77db489219ea4023d11582a9329": "0x878678326eac9000000",
  	"0xa2f798e077b07d86124e1407df32890dbb4b6379": "0xad78ebc5ac6200000",
  	"0xa2f86bc061884e9eef05640edd51a2f7c0596c69": "0x6c6c44fe47ec050000",
  	"0xa2fa17c0fb506ce494008b9557841c3f641b8cae": "0x1158e460913d00000",
  	"0xa304588f0d850cd8d38f76e9e83c1bf63e333ede": "0x2285601216c8c0000",
  	"0xa3058c51737a4e96c55f2ef6bd7bb358167ec2a7": "0x20db3ae4481ad48000",
  	"0xa309df54cabce70c95ec3033149cd6678a6fd4cf": "0xc1f12c75101580000",
  	"0xa30a45520e5206d9004070e6af3e7bb2e8dd5313": "0x15af1d78b58c400000",
  	"0xa30e0acb534c9b3084e8501da090b4eb16a2c0cd": "0x6c6b935b8bbd400000",
  	"0xa3203095edb7028e6871ce0a84f548459f83300a": "0xd8d726b7177a800000",
  	"0xa321091d3018064279db399d2b2a88a6f440ae24": "0xad78ebc5ac62000000",
  	"0xa3232d068d50064903c9ebc563b515acc8b7b097": "0x6c8754c8f30c080000",
  	"0xa3241d890a92baf52908dc4aa049726be426ebd3": "0x43c2da661ca2f540000",
  	"0xa3294626ec2984c43b43da4d5d8e4669b11d4b59": "0x36a4cf636319c00000",
  	"0xa32cf7dde20c3dd5679ff5e325845c70c5962662": "0x1158e460913d00000",
  	"0xa339a3d8ca280e27d2415b26d1fc793228b66043": "0x36f28695b78ff00000",
  	"0xa33cb450f95bb46e25afb50fe05feee6fb8cc8ea": "0x2a1129d09367200000",
  	"0xa33f70da7275ef057104dfa7db64f472e9f5d553": "0x45946b0f9e9d60000",
  	"0xa34076f84bd917f20f8342c98ba79e6fb08ecd31": "0xe3aeb5737240a00000",
  	"0xa3430e1f647f321ed34739562323c7d623410b56": "0x3634fb9f1489a70000",
  	"0xa34f9d568bf7afd94c2a5b8a5ff55c66c4087999": "0x847d503b220eb00000",
  	"0xa35606d51220ee7f2146d411582ee4ee4a45596e": "0xd8aabe080bc9400000",
  	"0xa356551bb77d4f45a6d7e09f0a089e79cca249cb": "0x126e72a69a50d00000",
  	"0xa35c19132cac1935576abfed6c0495fb07881ba0": "0x6c6b935b8bbd400000",
  	"0xa365918bfe3f2627b9f3a86775d8756e0fd8a94b": "0x15af1d78b58c400000",
  	"0xa36e0d94b95364a82671b608cb2d373245612909": "0x821d221b5291f8000",
  	"0xa375b4bc24a24e1f797593cc302b2f331063fa5c": "0xad78ebc5ac6200000",
  	"0xa37622ac9bbdc4d82b75015d745b9f8de65a28ec": "0x9dc05cce28c2b80000",
  	"0xa379a5070c503d2fac89b8b3afa080fd45ed4bec": "0x42bf06b78ed3b500000",
  	"0xa3802d8a659e89a2c47e905430b2a827978950a7": "0x3635c9adc5dea00000",
  	"0xa38306cb70baa8e49186bd68aa70a83d242f2907": "0x6c6b935b8bbd400000",
  	"0xa38476691d34942eea6b2f76889223047db4617a": "0x6c6b935b8bbd400000",
  	"0xa387ce4e961a7847f560075c64e1596b5641d21c": "0x243d4d18229ca20000",
  	"0xa387ecde0ee4c8079499fd8e03473bd88ad7522a": "0x6acb3df27e1f880000",
  	"0xa3883a24f7f166205f1a6a9949076c26a76e7178": "0x62a992e53a0af00000",
  	"0xa38b5bd81a9db9d2b21d5ec7c60552cd02ed561b": "0x14542ba12a337c00000",
  	"0xa390ca122b8501ee3e5e07a8ca4b419f7e4dae15": "0x56bc75e2d63100000",
  	"0xa3932a31d6ff75fb3b1271ace7caa7d5e1ff1051": "0x43c33c1937564800000",
  	"0xa394ad4fd9e6530e6f5c53faecbede81cb172da1": "0x12f939c99edab800000",
  	"0xa3979a92760a135adf69d72f75e167755f1cb8c3": "0x56bc75e2d63100000",
  	"0xa39bfee4aec9bd75bd22c6b672898ca9a1e95d32": "0x21e19e0c9bab2400000",
  	"0xa3a262afd2936819230892fde84f2d5a594ab283": "0x65ea3db75546600000",
  	"0xa3a2e319e7d3a1448b5aa2468953160c2dbcba71": "0x6c6b935b8bbd400000",
  	"0xa3a57b0716132804d60aac281197ff2b3d237b01": "0x4be4e7267b6ae00000",
  	"0xa3a93ef9dbea2636263d06d8492f6a41de907c22": "0x340aad21b3b700000",
  	"0xa3ae1879007d801cb5f352716a4dd8ba2721de3d": "0x2a5a058fc295ed000000",
  	"0xa3ba0d3a3617b1e31b4e422ce269e873828d5d69": "0x2e141ea081ca080000",
  	"0xa3bc979b7080092fa1f92f6e0fb347e28d995045": "0x97c9ce4cf6d5c00000",
  	"0xa3bff1dfa9971668360c0d82828432e27bf54e67": "0xad78ebc5ac6200000",
  	"0xa3c14ace28b192cbb062145fcbbd5869c67271f6": "0x1b1ae4d6e2ef5000000",
  	"0xa3c33afc8cb4704e23153de2049d35ae71332472": "0x2b58addb89a2580000",
  	"0xa3d0b03cffbb269f796ac29d80bfb07dc7c6ad06": "0x6c6b935b8bbd400000",
  	"0xa3d583a7b65b23f60b7905f3e4aa62aac87f4227": "0x38befa126d5a9f8000",
  	"0xa3db364a332d884ba93b2617ae4d85a1489bea47": "0x5c283d410394100000",
  	"0xa3e051fb744aa3410c3b88f899f5d57f168df12d": "0xa030dcebbd2f4c0000",
  	"0xa3e3a6ea509573e21bd0239ece0523a7b7d89b2f": "0x6acb3df27e1f880000",
  	"0xa3f4ad14e0bb44e2ce2c14359c75b8e732d37054": "0xad78ebc5ac6200000",
  	"0xa3facc50195c0b4933c85897fecc5bbd995c34b8": "0x1158e460913d00000",
  	"0xa4035ab1e5180821f0f380f1131b7387c8d981cd": "0x1158e460913d00000",
  	"0xa40aa2bbce0c72b4d0dfffcc42715b2b54b01bfa": "0x3635c9adc5dea00000",
  	"0xa419a984142363267575566089340eea0ea20819": "0x6c6acc67d7b1d40000",
  	"0xa421dbb89b3a07419084ad10c3c15dfe9b32d0c2": "0x43c33c1937564800000",
  	"0xa422e4bf0bf74147cc895bed8f16d3cef3426154": "0x12ef3f62ee11368000",
  	"0xa4259f8345f7e3a8b72b0fec2cf75e321fda4dc2": "0x678a932062e4180000",
  	"0xa42908e7fe53980a9abf4044e957a54b70e99cbe": "0x6c6b935b8bbd400000",
  	"0xa429fa88731fdd350e8ecd6ea54296b6484fe695": "0x6ac5c62d9486070000",
  	"0xa430995ddb185b9865dbe62539ad90d22e4b73c2": "0x21e19e0c9bab2400000",
  	"0xa436c75453ccca4a1f1b62e5c4a30d86dde4be68": "0x6c6b935b8bbd400000",
  	"0xa437fe6ec103ca8d158f63b334224eccac5b3ea3": "0x1b1ae4d6e2ef5000000",
  	"0xa43b6da6cb7aac571dff27f09d39f846f53769b1": "0x14998f32ac78700000",
  	"0xa43b81f99356c0af141a03010d77bd042c71c1ee": "0x6c6b935b8bbd400000",
  	"0xa43e1947a9242b355561c30a829dfeeca2815af8": "0xd23d99969fd6918000",
  	"0xa4489a50ead5d5445a7bee4d2d5536c2a76c41f8": "0xad78ebc5ac6200000",
  	"0xa44fe800d96fcad73b7170d0f610cb8c0682d6ce": "0xd8d726b7177a800000",
  	"0xa45432a6f2ac9d56577b938a37fabac8cc7c461c": "0x3635c9adc5dea00000",
  	"0xa466d770d898d8c9d405e4a0e551efafcde53cf9": "0x1ab2cf7c9f87e20000",
  	"0xa4670731175893bbcff4fa85ce97d94fc51c4ba8": "0x1b1ae4d6e2ef5000000",
  	"0xa46b4387fb4dcce011e76e4d73547d4481e09be5": "0x487a9a304539440000",
  	"0xa46cd237b63eea438c8e3b6585f679e4860832ac": "0x3635c9adc5dea00000",
  	"0xa47779d8bc1c7bce0f011ccb39ef68b854f8de8f": "0x6c6b935b8bbd400000",
  	"0xa4826b6c3882fad0ed5c8fbb25cc40cc4f33759f": "0x701b43e34433d00000",
  	"0xa4875928458ec2005dbb578c5cd33580f0cf1452": "0x3635c9adc5dea00000",
  	"0xa49f523aa51364cbc7d995163d34eb590ded2f08": "0x9027421b2a9fbc0000",
  	"0xa4a49f0bc8688cc9e6dc04e1e08d521026e65574": "0xad78ebc5ac6200000",
  	"0xa4a7d306f510cd58359428c0d2f7c3609d5674d7": "0xb58cb61c3ccf340000",
  	"0xa4a83a0738799b971bf2de708c2ebf911ca79eb2": "0x2086ac351052600000",
  	"0xa4b09de6e713dc69546e76ef0acf40b94f0241e6": "0x117dc0627ec8700000",
  	"0xa4d2b429f1ad5349e31704969edc5f25ee8aca10": "0x21e19e0c9bab2400000",
  	"0xa4d6c82eddae5947fbe9cdfbd548ae33d91a7191": "0x1b1ae4d6e2ef5000000",
  	"0xa4da34450d22ec0ffcede0004b02f7872ee0b73a": "0x50f616673f0830000",
  	"0xa4dd59ab5e517d398e49fa537f899fed4c15e95d": "0x43c33c1937564800000",
  	"0xa4e623451e7e94e7e89ba5ed95c8a83a62ffc4ea": "0x1158e460913d00000",
  	"0xa4ed11b072d89fb136759fc69b428c48aa5d4ced": "0xe3f1527a03ca80000",
  	"0xa4fb14409a67b45688a8593e5cc2cf596ced6f11": "0x61093d7c2c6d380000",
  	"0xa514d00edd7108a6be839a638db2415418174196": "0x65a4da25d3016c00000",
  	"0xa522de7eb6ae1250522a513133a93bd42849475c": "0x43c33c1937564800000",
  	"0xa524a8cccc49518d170a328270a2f88133fbaf5d": "0xff7022dac108a0000",
  	"0xa539b4a401b584dfe0f344b1b422c65543167e2e": "0xad78ebc5ac6200000",
  	"0xa53ead54f7850af21438cbe07af686279a315b86": "0x21e19e0c9bab2400000",
  	"0xa543a066fb32a8668aa0736a0c9cd40d78098727": "0x3635c9adc5dea00000",
  	"0xa567770b6ae320bdde50f904d663e746a61dace6": "0x6c6b935b8bbd400000",
  	"0xa568db4d57e4d67462d733c69a9e0fe26e218327": "0x3b6bff9266c0ae0000",
  	"0xa5698035391e67a49013c0002079593114feb353": "0xd02ab486cedc00000",
  	"0xa570223ae3caa851418a9843a1ac55db4824f4fd": "0xad78ebc5ac6200000",
  	"0xa57360f002e0d64d2d74457d8ca4857ee00bcddf": "0x1233e232f618aa0000",
  	"0xa575f2891dcfcda83c5cf01474af11ee01b72dc2": "0x56cd55fc64dfe0000",
  	"0xa5783bf33432ff82ac498985d7d460ae67ec3673": "0x62a992e53a0af00000",
  	"0xa5874d754635a762b381a5c4c792483af8f23d1d": "0x2b5e3af16b1880000",
  	"0xa5a4227f6cf98825c0d5baff5315752ccc1a1391": "0x21e19e0c9bab2400000",
  	"0xa5ab4bd3588f46cb272e56e93deed386ba8b753d": "0x4842f04105872c8000",
  	"0xa5bad86509fbe0e0e3c0e93f6d381f1af6e9d481": "0x14542ba12a337c00000",
  	"0xa5c336083b04f9471b8c6ed73679b74d66c363ec": "0xa3650a4c9d20e20000",
  	"0xa5cd123992194b34c4781314303b03c54948f4b9": "0x6cfcc3d91da5630000",
  	"0xa5d5b8b62d002def92413710d13b6ff8d4fc7dd3": "0x15af1d78b58c400000",
  	"0xa5d96e697d46358d119af7819dc7087f6ae47fef": "0x317bee8af3315a78000",
  	"0xa5de5e434fdcdd688f1c31b6fb512cb196724701": "0x2b5e3af16b18800000",
  	"0xa5e0fc3c3affed3db6710947d1d6fb017f3e276d": "0x6c6b935b8bbd400000",
  	"0xa5e93b49ea7c509de7c44d6cfeddef5910deaaf2": "0x6c6b935b8bbd400000",
  	"0xa5e9cd4b74255d22b7d9b27ae8dd43ed6ed0252b": "0x298db2f54411d98000",
  	"0xa5f0077b351f6c505cd515dfa6d2fa7f5c4cd287": "0x878678326eac9000000",
  	"0xa5f075fd401335577b6683c281e6d101432dc6e0": "0x914878a8c05ee00000",
  	"0xa5fe2ce97f0e8c3856be0de5f4dcb2ce5d389a16": "0x13db0b8b6863e0000",
  	"0xa5ff62222d80c013cec1a0e8850ed4d354dac16d": "0xb41075c168b180000",
  	"0xa609c26dd350c235e44b2b9c1dddccd0a9d9f837": "0x3635c9adc5dea00000",
  	"0xa60c1209754f5d87b181da4f0817a81859ef9fd8": "0x2b5e3af16b1880000",
  	"0xa6101c961e8e1c15798ffcd0e3201d7786ec373a": "0x14542ba12a337c00000",
  	"0xa613456996408af1c2e93e177788ab55895e2b32": "0x15919ff477c88b80000",
  	"0xa61887818f914a20e31077290b83715a6b2d6ef9": "0x65ea3db75546600000",
  	"0xa61a54df784a44d71b771b87317509211381f200": "0x3635c9adc5dea00000",
  	"0xa61cdbadf04b1e54c883de6005fcdf16beb8eb2f": "0x6c6b935b8bbd400000",
  	"0xa639acd96b31ba53b0d08763229e1f06fd105e9d": "0x1b1ae4d6e2ef5000000",
  	"0xa642501004c90ea9c9ed1998ba140a4cd62c6f5f": "0xd94fb8b10f8b18000",
  	"0xa644ed922cc237a3e5c4979a995477f36e50bc62": "0x1fa73d845d7e960000",
  	"0xa646a95c6d6f59f104c6541d7760757ab392b08c": "0xe3aeb5737240a00000",
  	"0xa6484cc684c4c91db53eb68a4da45a6a6bda3067": "0x14542ba12a337c00000",
  	"0xa64e5ffb704c2c9139d77ef61d8cdfa31d7a88e9": "0x7c0860e5a80dc0000",
  	"0xa65426cff378ed23253513b19f496de45fa7e18f": "0x18650127cc3dc800000",
  	"0xa66a4963b27f1ee1932b172be5964e0d3ae54b51": "0x960db77681e940000",
  	"0xa67f38819565423aa85f3e3ab61bc763cbab89dd": "0x7377b022c6be080000",
  	"0xa68c313445c22d919ee46cc2d0cdff043a755825": "0x41374fd21b0d88000",
  	"0xa68e0c30cba3bc5a883e540320f999c7cd558e5c": "0x6192333762a58c8000",
  	"0xa690f1a4b20ab7ba34628620de9ca040c43c1963": "0xd8d726b7177a800000",
  	"0xa69d7cd17d4842fe03f62a90b2fbf8f6af7bb380": "0x56bc75e2d63100000",
  	"0xa6a08252c8595177cc2e60fc27593e2379c81fb1": "0x11651ac3e7a758000",
  	"0xa6a0de421ae54f6d17281308f5646d2f39f7775d": "0x6c6b935b8bbd400000",
  	"0xa6b2d573297360102c07a18fc21df2e7499ff4eb": "0xd96fce90cfabcc0000",
  	"0xa6c910ce4d494a919ccdaaa1fc3b82aa74ba06cf": "0x1b1ae4d6e2ef5000000",
  	"0xa6e3baa38e104a1e27a4d82869afb1c0ae6eff8d": "0x11140eead8b710000",
  	"0xa6eebbe464d39187bf80ca9c13d72027ec5ba8be": "0xa2a15d09519be00000",
  	"0xa6f62b8a3d7f11220701ab9ffffcb327959a2785": "0x1b6e291f18dba80000",
  	"0xa6f93307f8bce03195fece872043e8a03f7bd11a": "0x9c734bad5111580000",
  	"0xa701df79f594901afe1444485e6b20c3bda2b9b3": "0x3635c9adc5dea00000",
  	"0xa7024cfd742c1ec13c01fea18d3042e65f1d5dee": "0x263119a28abd0b08000",
  	"0xa718aaad59bf395cba2b23e09b02fe0c89816247": "0x36303c97e468780000",
  	"0xa7247c53d059eb7c9310f628d7fc6c6a0a773f08": "0x1b1ae4d6e2ef500000",
  	"0xa7253763cf4a75df92ca1e766dc4ee8a2745147b": "0x2463770e90a8f500000",
  	"0xa72ee666c4b35e82a506808b443cebd5c632c7dd": "0x2b5e3af16b18800000",
  	"0xa74444f90fbb54e56f3ac9b6cfccaa4819e4614a": "0x1158e460913d00000",
  	"0xa747439ad0d393b5a03861d77296326de8bb9db9": "0x3635c9adc5dea00000",
  	"0xa7607b42573bb6f6b4d4f23c7e2a26b3a0f6b6f0": "0x57473d05dabae80000",
  	"0xa76929890a7b47fb859196016c6fdd8289ceb755": "0x10f0cf064dd59200000",
  	"0xa76b743f981b693072a131b22ba510965c2fefd7": "0xfc936392801c0000",
  	"0xa76d3f156251b72c0ccf4b47a3393cbd6f49a9c5": "0x487a9a304539440000",
  	"0xa77428bcb2a0db76fc8ef1e20e461a0a32c5ac15": "0x15be6174e1912e0000",
  	"0xa7758cecb60e8f614cce96137ef72b4fbd07774a": "0x1b1ae4d6e2ef500000",
  	"0xa7775e4af6a23afa201fb78b915e51a515b7a728": "0x68155a43676e00000",
  	"0xa77f3ee19e9388bbbb2215c62397b96560132360": "0xad78ebc5ac6200000",
  	"0xa7859fc07f756ea7dcebbccd42f05817582d973f": "0x21e19e0c9bab2400000",
  	"0xa7966c489f4c748a7ae980aa27a574251767caf9": "0xa2a15d09519be00000",
  	"0xa7a3bb6139b0ada00c1f7f1f9f56d994ba4d1fa8": "0x6c6b935b8bbd400000",
  	"0xa7a3f153cdc38821c20c5d8c8241b294a3f82b24": "0x1b1ae4d6e2ef500000",
  	"0xa7a517d7ad35820b09d497fa7e5540cde9495853": "0x6c6b935b8bbd400000",
  	"0xa7c9d388ebd873e66b1713448397d0f37f8bd3a8": "0x10f0cf064dd59200000",
  	"0xa7dcbba9b9bf6762c145416c506a71e3b497209c": "0x6c6acc67d7b1d40000",
  	"0xa7e74f0bdb278ff0a805a648618ec52b166ff1be": "0x56bc75e2d63100000",
  	"0xa7e83772bc200f9006aa2a260dbaa8483dc52b30": "0xb42d5366637e50000",
  	"0xa7ef35ce87eda6c28df248785815053ec97a5045": "0x10f0ce949e00f930000",
  	"0xa7f9220c8047826bd5d5183f4e676a6d77bfed36": "0x85068976be81c0000",
  	"0xa807104f2703d679f8deafc442befe849e42950b": "0x6c6b935b8bbd400000",
  	"0xa80cb1738bac08d4f9c08b4deff515545fa8584f": "0x1b1ae4d6e2ef500000",
  	"0xa819d2ece122e028c8e8a04a064d02b9029b08b9": "0x3635c9adc5dea00000",
  	"0xa825fd5abb7926a67cf36ba246a24bd27be6f6ed": "0xf43fc2c04ee00000",
  	"0xa8285539869d88f8a961533755717d7eb65576ae": "0xad78ebc5ac6200000",
  	"0xa83382b6e15267974a8550b98f7176c1a353f9be": "0xbffdaf2fc1b1a40000",
  	"0xa8446c4781a737ac4328b1e15b8a0b3fbb0fd668": "0x48794d1f246192a0000",
  	"0xa8455b411765d6901e311e726403091e42c56683": "0xb73aec3bfe14500000",
  	"0xa86613e6c4a4c9c55f5c10bcda32175dcbb4af60": "0x243d6c2e36be6ae0000",
  	"0xa86db07d9f812f4796622d40e03d135874a88a74": "0x1158e460913d00000",
  	"0xa87f7abd6fa31194289678efb63cf584ee5e2a61": "0xd8d726b7177a800000",
  	"0xa880e2a8bf88a1a82648b4013c49c4594c433cc8": "0x1004e2e45fb7ee00000",
  	"0xa88577a073fbaf33c4cd202e00ea70ef711b4006": "0x6c6b935b8bbd400000",
  	"0xa8914c95b560ec13f140577338c32bcbb77d3a7a": "0x9c2007651b2500000",
  	"0xa89ac93b23370472daac337e9afdf642543f3e57": "0x21e19e0c9bab2400000",
  	"0xa89df34859edd7c820db887740d8ff9e15157c7b": "0x6c6b935b8bbd400000",
  	"0xa8a43c009100616cb4ae4e033f1fc5d7e0b6f152": "0xd588d078b43f4d8000",
  	"0xa8a708e84f82db86a35502193b4c6ee9a76ebe8f": "0x3708baed3d68900000",
  	"0xa8a7b68adab4e3eadff19ffa58e34a3fcec0d96a": "0x14542ba12a337c00000",
  	"0xa8a8dbdd1a85d1beee2569e91ccc4d09ae7f6ea1": "0x13a6b2b564871a00000",
  	"0xa8aca748f9d312ec747f8b6578142694c7e9f399": "0x6c6b935b8bbd400000",
  	"0xa8b65ba3171a3f77a6350b9daf1f8d55b4d201eb": "0x2862f3b0d222040000",
  	"0xa8beb91c2b99c8964aa95b6b4a184b1269fc3483": "0x15af1d78b58c400000",
  	"0xa8c0b02faf02cb5519dda884de7bbc8c88a2da81": "0xe7c2518505060000",
  	"0xa8c1d6aa41fe3d65f67bd01de2a866ed1ed9ae52": "0x1a055690d9db80000",
  	"0xa8cafac32280d021020bf6f2a9782883d7aabe12": "0x56bc75e2d63100000",
  	"0xa8db0b9b201453333c757f6ad9bcb555c02da93b": "0x7742b7830f341d0000",
  	"0xa8e42a4e33d7526cca19d9a36dcd6e8040d0ea73": "0x3a8c02c5ea2de00000",
  	"0xa8e7201ff619faffc332e6ad37ed41e301bf014a": "0x2086ac351052600000",
  	"0xa8ee1df5d44b128469e913569ef6ac81eeda4fc8": "0x1b1ae4d6e2ef500000",
  	"0xa8ef9ad274436042903e413c3b0c62f5f52ed584": "0x21e19e0c9bab2400000",
  	"0xa8f37f0ab3a1d448a9e3ce40965f97a646083a34": "0x11e0e4f8a50bd40000",
  	"0xa8f89dd5cc6e64d7b1eeace00702022cd7d2f03d": "0x25f273933db5700000",
  	"0xa90476e2efdfee4f387b0f32a50678b0efb573b5": "0x21e19e0c9bab2400000",
  	"0xa9145046fa3628cf5fd4c613927be531e6db1fdd": "0x6124fee993bc00000",
  	"0xa914cdb571bfd93d64da66a4e108ea134e50d000": "0x4d8738994713798000",
  	"0xa91a5a7b341f99c535144e20be9c6b3bb4c28e4d": "0x126753aa224a70b0000",
  	"0xa9252551a624ae513719dabe5207fbefb2fd7749": "0x22b1c8c1227a00000",
  	"0xa927d48bb6cb814bc609cbcaa9151f5d459a27e1": "0xeb935090064180000",
  	"0xa929c8bd71db0c308dac06080a1747f21b1465aa": "0x1b1ae4d6e2ef500000",
  	"0xa94bbb8214cf8da0c2f668a2ac73e86248528d4b": "0x340aad21b3b7000000",
  	"0xa951b244ff50cfae591d5e1a148df6a938ef2a1a": "0x5e001584dfcf580000",
  	"0xa960b1cadd3b5c1a8e6cb3abcaf52ee7c3d9fa88": "0x528bc3545e52680000",
  	"0xa961171f5342b173dd70e7bfe5b5ca238b13bcdd": "0xb82794a9244f0c8000",
  	"0xa975b077fcb4cc8efcbf838459b6fa243a4159d6": "0x22b1c8c1227a00000",
  	"0xa97beb3a48c45f1528284cb6a95f7de453358ec6": "0x690836c0af5f5600000",
  	"0xa97e072144499fe5ebbd354acc7e7efb58985d08": "0x90f534608a72880000",
  	"0xa986762f7a4f294f2e0b173279ad2c81a2223458": "0x1158e460913d00000",
  	"0xa98f109835f5eacd0543647c34a6b269e3802fac": "0x15af1d78b58c400000",
  	"0xa997dfc7986a27050848fa1c64d7a7d6e07acca2": "0x7c0860e5a80dc0000",
  	"0xa99991cebd98d9c838c25f7a7416d9e244ca250d": "0x3635c9adc5dea00000",
  	"0xa9a1cdc33bfd376f1c0d76fb6c84b6b4ac274d68": "0x10f0cf064dd59200000",
  	"0xa9a8eca11a23d64689a2aa3e417dbb3d336bb59a": "0xe3453cd3b67ba8000",
  	"0xa9acf600081bb55bb6bfbab1815ffc4e17e85a95": "0xad78ebc5ac6200000",
  	"0xa9ad1926bc66bdb331588ea8193788534d982c98": "0x65a4da25d3016c00000",
  	"0xa9af21acbe482f8131896a228036ba51b19453c3": "0x2b5e021980cc18000",
  	"0xa9b2d2e0494eab18e07d37bbb856d80e80f84cd3": "0x21e19e0c9bab2400000",
  	"0xa9ba6f413b82fcddf3affbbdd09287dcf50415ca": "0xd8d726b7177a800000",
  	"0xa9be88ad1e518b0bbb024ab1d8f0e73f790e0c76": "0x97c9ce4cf6d5c00000",
  	"0xa9bfc410dddb20711e45c07387eab30a054e19ac": "0x3e99601edf4e530000",
  	"0xa9d4a2bcbe5b9e0869d70f0fe2e1d6aacd45edc5": "0xac6e77ab663a80000",
  	"0xa9d64b4f3bb7850722b58b478ba691375e224e42": "0x14542ba12a337c00000",
  	"0xa9d6f871ca781a759a20ac3adb972cf12829a208": "0x3224f42723d4540000",
  	"0xa9dc0424c6969d798358b393b1933a1f51bee00a": "0x43c33c1937564800000",
  	"0xa9e194661aac704ee9dea043974e9692ded84a5d": "0x1a26a51422a0700000",
  	"0xa9e28337e6357193d9e2cb236b01be44b81427df": "0x77432217e683600000",
  	"0xa9e6e25e656b762558619f147a21985b8874edfe": "0x6c6b935b8bbd400000",
  	"0xa9e9dbce7a2cb03694799897bed7c54d155fdaa8": "0xab5ae8fc99d658000",
  	"0xa9ed377b7d6ec25971c1a597a3b0f3bead57c98f": "0x15af1d78b58c400000",
  	"0xaa0200f1d17e9c54da0647bb96395d57a78538d8": "0x393ef1a5127c800000",
  	"0xaa0ca3737337178a0caac3099c584b056c56301c": "0x2fb474098f67c00000",
  	"0xaa136b47962bb8b4fb540db4ccf5fdd042ffb8cf": "0x1b1b6bd7af64c70000",
  	"0xaa14422d6f0ae5a758194ed15780c838d67f1ee1": "0x60932056c449de80000",
  	"0xaa16269aac9c0d803068d82fc79151dadd334b66": "0xd8d726b7177a800000",
  	"0xaa167026d39ab7a85635944ed9edb2bfeba11850": "0x1c1d5e21b4fcf680000",
  	"0xaa1b3768c16d821f580e76c8e4c8e86d7dc78853": "0x15af1d78b58c400000",
  	"0xaa1df92e51dff70b1973e0e924c66287b494a178": "0x1cf84a30a0a0c00000",
  	"0xaa2c670096d3f939305325427eb955a8a60db3c5": "0x6c95590699232d0000",
  	"0xaa3135cb54f102cbefe09e96103a1a796718ff54": "0x32222d9c331940000",
  	"0xaa321fdbd449180db8ddd34f0fe906ec18ee0914": "0x252248deb6e6940000",
  	"0xaa3925dc220bb4ae2177b2883078b6dc346ca1b2": "0x1b1ae4d6e2ef5000000",
  	"0xaa3f29601a1331745e05c42830a15e71938a6237": "0x5c283d410394100000",
  	"0xaa47a4ffc979363232c99b99fada0f2734b0aeee": "0x1b8489df4dbff940000",
  	"0xaa493d3f4fb866491cf8f800efb7e2324ed7cfe5": "0x5c283d410394100000",
  	"0xaa56a65dc4abb72f11bae32b6fbb07444791d5c9": "0x2894e975bf496c0000",
  	"0xaa5afcfd8309c2df9d15be5e6a504e7d706624c5": "0x13cf422e305a1378000",
  	"0xaa8eb0823b07b0e6d20aadda0e95cf3835be192e": "0x1bc16d674ec800000",
  	"0xaa91237e740d25a92f7fa146faa18ce56dc6e1f3": "0x3224f42723d4540000",
  	"0xaa960e10c52391c54e15387cc67af827b5316dcc": "0x6c6b935b8bbd400000",
  	"0xaa9bd4589535db27fa2bc903ca17d679dd654806": "0x6c6b935b8bbd400000",
  	"0xaaa8defe11e3613f11067fb983625a08995a8dfc": "0xad78ebc5ac6200000",
  	"0xaaaae68b321402c8ebc13468f341c63c0cf03fce": "0x52663ccab1e1c00000",
  	"0xaaad1baade5af04e2b17439e935987bf8c2bb4b9": "0x6c6b935b8bbd400000",
  	"0xaab00abf5828d7ebf26b47ceaccdb8ba03325166": "0x21e19e0c9bab2400000",
  	"0xaabdb35c1514984a039213793f3345a168e81ff1": "0x10cac896d239000000",
  	"0xaaca60d9d700e78596bbbbb1f1e2f70f4627f9d8": "0x3635bb77cb4b860000",
  	"0xaaced8a9563b1bc311dbdffc1ae7f57519c4440c": "0x6c6b935b8bbd400000",
  	"0xaad2b7f8106695078e6c138ec81a7486aaca1eb2": "0xad78ebc5ac6200000",
  	"0xaae61e43cb0d0c96b30699f77e00d711d0a3979b": "0x3635c9adc5dea00000",
  	"0xaae732eda65988c3a00c7f472f351c463b1c968e": "0x6c6b935b8bbd400000",
  	"0xaaf023fef290a49bb78bb7abc95d669c50d528b0": "0xad78ebc5ac6200000",
  	"0xaaf5b207b88b0de4ac40d747cee06e172df6e745": "0x6a7b71d7f51d0900000",
  	"0xaaf9ee4b886c6d1e95496fd274235bf4ecfcb07d": "0x4be4e7267b6ae00000",
  	"0xaafb7b013aa1f8541c7e327bf650adbd194c208f": "0x499e092d01f4780000",
  	"0xab098633eeee0ccefdf632f9575456f6dd80fc86": "0x2a5a058fc295ed000000",
  	"0xab0ced762e1661fae1a92afb1408889413794825": "0x678a932062e4180000",
  	"0xab14d221e33d544629198cd096ed63dfa28d9f47": "0x14542ba12a337c00000",
  	"0xab209fdca979d0a647010af9a8b52fc7d20d8cd1": "0x1eee2532c7c2d040000",
  	"0xab27ba78c8e5e3daef31ad05aef0ff0325721e08": "0x195ece006e02d00000",
  	"0xab2871e507c7be3965498e8fb462025a1a1c4264": "0x2a034919dfbfbc0000",
  	"0xab3861226ffec1289187fb84a08ec3ed043264e8": "0x3635c9adc5dea00000",
  	"0xab3d86bc82927e0cd421d146e07f919327cdf6f9": "0x678a932062e4180000",
  	"0xab3e62e77a8b225e411592b1af300752fe412463": "0x215f835bc769da80000",
  	"0xab3e78294ba886a0cfd5d3487fb3a3078d338d6e": "0x6acb3df27e1f880000",
  	"0xab4004c0403f7eabb0ea586f212156c4203d67f1": "0x6c6acc67d7b1d40000",
  	"0xab416fe30d58afe5d9454c7fce7f830bcc750356": "0x6353701c605db8000",
  	"0xab4572fbb1d72b575d69ec6ad17333873e8552fc": "0x6c6ac54cda68470000",
  	"0xab5a79016176320973e8cd38f6375530022531c0": "0x3635c9adc5dea00000",
  	"0xab5dfc1ea21adc42cf8c3f6e361e243fd0da61e5": "0x1043561a8829300000",
  	"0xab6b65eab8dfc917ec0251b9db0ecfa0fa032849": "0x1b1ae4d6e2ef500000",
  	"0xab7091932e4bc39dbb552380ca934fd7166d1e6e": "0xb50fcfafebecb00000",
  	"0xab7416ff32254951cbbc624ec7fb45fc7ecaa872": "0x126e72a69a50d00000",
  	"0xab7c42c5e52d641a07ad75099c62928b7f86622f": "0x12361aa21d14ba0000",
  	"0xab7d54c7c6570efca5b4b8ce70f52a5773e5d53b": "0xf283abe9d9f380000",
  	"0xab7e0b83ed9a424c6d1e6a6f87a4dbf06409c7d6": "0x821ab0d44149800000",
  	"0xab84a0f147ad265400002b85029a41fc9ce57f85": "0x3635c9adc5dea00000",
  	"0xab93b26ece0a0aa21365afed1fa9aea31cd54468": "0x572b7b98736c200000",
  	"0xab948a4ae3795cbca13126e19253bdc21d3a8514": "0xad78ebc5ac6200000",
  	"0xab9ad36e5c74ce2e96399f57839431d0e79f96ab": "0x8e3f50b173c100000",
  	"0xabb2e6a72a40ba6ed908cdbcec3c5612583132fe": "0x4f2591f896a6500000",
  	"0xabc068b4979b0ea64a62d3b7aa897d73810dc533": "0x6acb3df27e1f880000",
  	"0xabc45f84db7382dde54c5f7d8938c42f4f3a3bc4": "0xad78ebc5ac6200000",
  	"0xabc4caeb474d4627cb6eb456ecba0ecd08ed8ae1": "0xd5967be4fc3f100000",
  	"0xabc74706964960dfe0dca3dca79e9216056f1cf4": "0x878678326eac9000000",
  	"0xabc9a99e8a2148a55a6d82bd51b98eb5391fdbaf": "0x14542ba12a337c00000",
  	"0xabcdbc8f1dd13af578d4a4774a62182bedf9f9be": "0x1fcc27bc459d20000",
  	"0xabd154903513b8da4f019f68284b0656a1d0169b": "0x3635c9adc5dea00000",
  	"0xabd21eff954fc6a7de26912a7cbb303a6607804e": "0x523c9aa696eb940000",
  	"0xabd4d6c1666358c0406fdf3af248f78ece830104": "0x727de34a24f9000000",
  	"0xabd9605b3e91acfd777830d16463478ae0fc7720": "0x73f75d1a085ba0000",
  	"0xabdc9f1bcf4d19ee96591030e772c334302f7d83": "0x87e5e11a81cb5f80000",
  	"0xabde147b2af789eaa586547e66c4fa2664d328a4": "0xd6b6081f34c128000",
  	"0xabe07ced6ac5ddf991eff6c3da226a741bd243fe": "0x21e19e0c9bab2400000",
  	"0xabf12fa19e82f76c718f01bdca0003674523ef30": "0x6c6b935b8bbd400000",
  	"0xabf728cf9312f22128024e7046c251f5dc5901ed": "0x641e8a13563d8f80000",
  	"0xabf8ffe0708a99b528cc1ed4e9ce4b0d0630be8c": "0x7ab5c2aeeee6380000",
  	"0xabfcf5f25091ce57875fc674dcf104e2a73dd2f2": "0x11164759ffb320000",
  	"0xabfe936425dcc7b74b955082bbaaf2a11d78bc05": "0x4be4e7267b6ae00000",
  	"0xac024f594f9558f04943618eb0e6b2ee501dc272": "0x6c6b935b8bbd400000",
  	"0xac122a03cd058c122e5fe17b872f4877f9df9572": "0x6ac5c62d9486070000",
  	"0xac142eda1157b9a9a64390df7e6ae694fac98905": "0xad78ebc5ac6200000",
  	"0xac1dfc984b71a19929a81d81f04a7cbb14073703": "0x2086ac351052600000",
  	"0xac21c1e5a3d7e0b50681679dd6c792dbca87decb": "0x152d02c7e14af6800000",
  	"0xac2889b5966f0c7f9edb42895cb69d1c04f923a2": "0x10f0cf064dd59200000",
  	"0xac28b5edea05b76f8c5f97084541277c96696a4c": "0x3635c9adc5dea00000",
  	"0xac2c8e09d06493a63858437bd20be01962450365": "0x678a932062e4180000",
  	"0xac2e766dac3f648f637ac6713fddb068e4a4f04d": "0xaadec983fcff40000",
  	"0xac3900298dd14d7cc96d4abb428da1bae213ffed": "0x53ca12974851c010000",
  	"0xac3da526cfce88297302f34c49ca520dc271f9b2": "0x2b5e3af16b18800000",
  	"0xac4460a76e6db2b9fcd152d9c7718d9ac6ed8c6f": "0xad78ebc5ac6200000",
  	"0xac4acfc36ed6094a27e118ecc911cd473e8fb91f": "0x61913e14403c0c0000",
  	"0xac4cc256ae74d624ace80db078b2207f57198f6b": "0x6c7974123f64a40000",
  	"0xac4ee9d502e7d2d2e99e59d8ca7d5f00c94b4dd6": "0x3635c9adc5dea00000",
  	"0xac52b77e15664814f39e4f271be641308d91d6cc": "0xbed1d0263d9f00000",
  	"0xac5999a89d2dd286d5a80c6dee7e86aad40f9e12": "0xd255d112e103a00000",
  	"0xac5f627231480d0d95302e6d89fc32cb1d4fe7e3": "0xad78ebc5ac6200000",
  	"0xac608e2bac9dd20728d2947effbbbf900a9ce94b": "0x1454b0db37568fc0000",
  	"0xac6d02e9a46b379fac4ac9b1d7b5d47bc850ce16": "0x5f68e8131ecf800000",
  	"0xac6f68e837cf1961cb14ab47446da168a16dde89": "0x487a9a304539440000",
  	"0xac77bdf00fd5985b5db12bbef800380abc2a0677": "0x3635c9adc5dea00000",
  	"0xac7e03702723cb16ee27e22dd0b815dc2d5cae9f": "0x3635c9adc5dea000000",
  	"0xac8b509aefea1dbfaf2bb33500d6570b6fd96d51": "0x62a992e53a0af00000",
  	"0xac8e87ddda5e78fcbcb9fa7fc3ce038f9f7d2e34": "0x6c6b935b8bbd400000",
  	"0xac9fff68c61b011efbecf038ed72db97bb9e7281": "0x205b4dfa1ee74780000",
  	"0xaca1e6bc64cc3180f620e94dc5b1bcfd8158e45d": "0x6c6b935b8bbd400000",
  	"0xaca2a838330b17302da731d30db48a04f0f207c1": "0x487a9a304539440000",
  	"0xacaaddcbf286cb0e215dda55598f7ff0f4ada5c6": "0x3635c9adc5dea00000",
  	"0xacb94338554bc488cc88ae2d9d94080d6bdf8410": "0x3635c9adc5dea00000",
  	"0xacbc2d19e06c3babbb5b6f052b6bf7fc37e07229": "0xad78ebc5ac6200000",
  	"0xacbd185589f7a68a67aa4b1bd65077f8c64e4e21": "0xad78ebc5ac6200000",
  	"0xacc062702c59615d3444ef6214b8862b009a02ed": "0x514fcb24ff9c500000",
  	"0xacc0909fda2ea6b7b7a88db7a0aac868091ddbf6": "0x133765f1e26c78000",
  	"0xacc1c78786ab4d2b3b277135b5ba123e0400486b": "0x44591d67fecc80000",
  	"0xacc46a2a555c74ded4a2bd094e821b97843b40c0": "0x692ae8897081d00000",
  	"0xacc59f3b30ceffc56461cc5b8df48902240e0e7b": "0x6c6b935b8bbd400000",
  	"0xacce01e0a70610dc70bb91e9926fa9957f372fba": "0x1d1c5f3eda20c40000",
  	"0xacd8dd91f714764c45677c63d852e56eb9eece2e": "0x6c6b935b8bbd400000",
  	"0xace2abb63b0604409fbde3e716d2876d44e8e5dd": "0x83d6c7aab63600000",
  	"0xacec91ef6941cf630ba9a3e787a012f4a2d91dd4": "0x10f0cf064dd592000000",
  	"0xad0a4ae478e9636e88c604f242cf5439c6d45639": "0xbed1d0263d9f000000",
  	"0xad1799aad7602b4540cd832f9db5f11150f1687a": "0x6c6b935b8bbd400000",
  	"0xad1d68a038fd2586067ef6d135d9628e79c2c924": "0xfe09a5279e2abc0000",
  	"0xad2a5c00f923aaf21ab9f3fb066efa0a03de2fb2": "0x3635bb77cb4b860000",
  	"0xad3565d52b688added08168b2d3872d17d0a26ae": "0x56bc75e2d63100000",
  	"0xad377cd25eb53e83ae091a0a1d2b4516f484afde": "0x692ae8897081d00000",
  	"0xad414d29cb7ee973fec54e22a388491786cf5402": "0x2f6f10780d22cc00000",
  	"0xad44357e017e244f476931c7b8189efee80a5d0a": "0x1043561a8829300000",
  	"0xad57aa9d00d10c439b35efcc0becac2e3955c313": "0xad78ebc5ac6200000",
  	"0xad59a78eb9a74a7fbdaefafa82eada8475f07f95": "0x1b1ae4d6e2ef500000",
  	"0xad5a8d3c6478b69f657db3837a2575ef8e1df931": "0x20156e104c1b30000",
  	"0xad660dec825522a9f62fcec3c5b731980dc286ea": "0xa2a15d09519be00000",
  	"0xad6628352ed3390bafa86d923e56014cfcb360f4": "0x6c6b935b8bbd400000",
  	"0xad728121873f0456d0518b80ab6580a203706595": "0x1b1ae4d6e2ef500000",
  	"0xad732c976593eec4783b4e2ecd793979780bfedb": "0x6c6b935b8bbd400000",
  	"0xad7dd053859edff1cb6f9d2acbed6dd5e332426f": "0x6acb3df27e1f880000",
  	"0xad80d865b85c34d2e6494b2e7aefea6b9af184db": "0xd8d726b7177a800000",
  	"0xad8bfef8c68a4816b3916f35cb7bfcd7d3040976": "0x878678326eac9000000",
  	"0xad8e48a377695de014363a523a28b1a40c78f208": "0x3635c9adc5dea00000",
  	"0xad910a23d6850613654af786337ad2a70868ac6d": "0x6c68ccd09b022c0000",
  	"0xad927e03d1599a78ca2bf0cad2a183dceb71eac0": "0x6acb3df27e1f880000",
  	"0xad92ca066edb7c711dfc5b166192d1edf8e77185": "0x79f905c6fd34e800000",
  	"0xad94235fc3b3f47a2413af31e884914908ef0c45": "0x1b1b0142d815840000",
  	"0xad9e97a0482f353a05c0f792b977b6c7e811fa5f": "0xad78ebc5ac6200000",
  	"0xad9f4c890a3b511cee51dfe6cfd7f1093b76412c": "0x1b767cbfeb0ce40000",
  	"0xadaa0e548c035affed64ca678a963fabe9a26bfd": "0x3cb71f51fc5580000",
  	"0xadb948b1b6fefe207de65e9bbc2de98e605d0b57": "0x6c6b935b8bbd400000",
  	"0xadc19ec835afe3e58d87dc93a8a9213c90451326": "0x6adbe5342282000000",
  	"0xadc8228ef928e18b2a807d00fb3c6c79cd1d9e96": "0x13c69df334ee80000",
  	"0xaddb26317227f45c87a2cb90dc4cfd02fb23caf8": "0x3635c9adc5dea00000",
  	"0xade6f8163bf7c7bb4abe8e9893bd0cc112fe8872": "0x11c25d004d01f80000",
  	"0xadeb204aa0c38e179e81a94ed8b3e7d53047c26b": "0x20f5b1eaad8d800000",
  	"0xadeb52b604e5f77faaac88275b8d6b49e9f9f97f": "0x71426b00956ed20000",
  	"0xadf1acfe99bc8c14b304c8d905ba27657b8a7bc4": "0x43c33c1937564800000",
  	"0xadf85203c8376a5fde9815384a350c3879c4cb93": "0x3e31fc675815aa0000",
  	"0xadff0d1d0b97471e76d789d2e49c8a74f9bd54ff": "0x65ea3db75546600000",
  	"0xae062c448618643075de7a0030342dced63dbad7": "0x2cc6cd8cc282b30000",
  	"0xae10e27a014f0d306baf266d4897c89aeee2e974": "0x43c33c1937564800000",
  	"0xae126b382cf257fad7f0bc7d16297e54cc7267da": "0x1043561a8829300000",
  	"0xae13a08511110f32e53be4127845c843a1a57c7b": "0x1b1ae4d6e2ef500000",
  	"0xae179a460db66326743d24e67523a57b246daf7f": "0x10007ae7ce5bbe40000",
  	"0xae222865799079aaf4f0674a0cdaab02a6d570ff": "0x6c6b935b8bbd400000",
  	"0xae239acffd4ebe2e1ba5b4170572dc79cc6533ec": "0x28a857425466f800000",
  	"0xae2f9c19ac76136594432393b0471d08902164d3": "0x25df05c6a897e40000",
  	"0xae34861d342253194ffc6652dfde51ab44cad3fe": "0x194608686316bd8000",
  	"0xae36f7452121913e800e0fcd1a65a5471c23846f": "0x8e3f50b173c100000",
  	"0xae3f98a443efe00f3e711d525d9894dc9a61157b": "0x1004e2e45fb7ee0000",
  	"0xae47e2609cfafe369d66d415d939de05081a9872": "0x5baecf025f9b6500000",
  	"0xae4f122e35c0b1d1e4069291457c83c07f965fa3": "0x3635c9adc5dea00000",
  	"0xae5055814cb8be0c117bb8b1c8d2b63b4698b728": "0x1bc932ec573a38000",
  	"0xae538c73c5b38d8d584d7ebdadefb15cabe48357": "0x3627e8f712373c0000",
  	"0xae57cc129a96a89981dac60d2ffb877d5dc5e432": "0x3c3a2394b396550000",
  	"0xae5aa1e6c2b60f6fd3efe721bb4a719cbe3d6f5d": "0x2b24c6b55a5e620000",
  	"0xae5c9bdad3c5c8a1220444aea5c229c1839f1d64": "0x19e2a4c818b9060000",
  	"0xae5ce3355a7ba9b332760c0950c2bc45a85fa9a0": "0x15af1d78b58c400000",
  	"0xae5d221afcd3d29355f508eadfca408ce33ca903": "0x152d02c7e14af6800000",
  	"0xae635bf73831119d2d29c0d04ff8f8d8d0a57a46": "0x487a9a304539440000",
  	"0xae648155a658370f929be384f7e001047e49dd46": "0x2df24ae32be20440000",
  	"0xae6f0c73fdd77c489727512174d9b50296611c4c": "0x14542ba12a337c00000",
  	"0xae70e69d2c4a0af818807b1a2705f79fd0b5dbc4": "0x35659ef93f0fc40000",
  	"0xae7739124ed153052503fc101410d1ffd8cd13b7": "0x3634fb9f1489a70000",
  	"0xae78bb849139a6ba38ae92a09a69601cc4cb62d1": "0x1b1ae4d6e2ef500000",
  	"0xae842210f44d14c4a4db91fc9d3b3b50014f7bf7": "0xd8d726b7177a800000",
  	"0xae842e81858ecfedf6506c686dc204ac15bf8b24": "0x22b1c8c1227a00000",
  	"0xae8954f8d6166de507cf61297d0fc7ca6b9e7128": "0x1043561a8829300000",
  	"0xae9ecd6bdd952ef497c0050ae0ab8a82a91898ce": "0x1a055690d9db80000",
  	"0xae9f5c3fbbe0c9bcbf1af8ff74ea280b3a5d8b08": "0x5dc892aa1131c80000",
  	"0xaead88d689416b1c91f2364421375b7d3c70fb2e": "0x6c6b935b8bbd400000",
  	"0xaeadfcd0978edad74a32bd01a0a51d37f246e661": "0xe18398e7601900000",
  	"0xaeb916ebf49d0f86c13f7331cef19e129937512d": "0x2085655b8d1b0a0000",
  	"0xaebd4f205de799b64b3564b256d42a711d37ef99": "0x3fcf8b4574f84e0000",
  	"0xaec27ce2133e82d052520afb5c576d9f7eb93ed2": "0xdd04120ba09cfe60000",
  	"0xaec27ff5d7f9ddda91183f46f9d52543b6cd2b2f": "0x18650127cc3dc80000",
  	"0xaee49d68adedb081fd43705a5f78c778fb90de48": "0x1158e460913d00000",
  	"0xaef5b12258a18dec07d5ec2e316574919d79d6d6": "0x6c6b935b8bbd400000",
  	"0xaefcfe88c826ccf131d54eb4ea9eb80e61e1ee25": "0x126e72a69a50d00000",
  	"0xaf06f5fa6d1214ec43967d1bd4dde74ab814a938": "0x4c53ecdc18a600000",
  	"0xaf1148ef6c8e103d7530efc91679c9ac27000993": "0xad78ebc5ac6200000",
  	"0xaf203e229d7e6d419df4378ea98715515f631485": "0x6acb3df27e1f880000",
  	"0xaf2058c7282cf67c8c3cf930133c89617ce75d29": "0x177224aa844c7200000",
  	"0xaf26f7c6bf453e2078f08953e4b28004a2c1e209": "0x56bc75e2d63100000",
  	"0xaf3087e62e04bf900d5a54dc3e946274da92423b": "0x1158e460913d00000",
  	"0xaf3614dcb68a36e45a4e911e62796247222d595b": "0x7a81065f1103bc0000",
  	"0xaf3615c789d0b1152ad4db25fe5dcf222804cf62": "0x3635c9adc5dea00000",
  	"0xaf3cb5965933e7dad883693b9c3e15beb68a4873": "0x6c6b935b8bbd400000",
  	"0xaf4493e8521ca89d95f5267c1ab63f9f45411e1b": "0xad78ebc5ac6200000",
  	"0xaf4cf41785161f571d0ca69c94f8021f41294eca": "0x215f835bc769da80000",
  	"0xaf529bdb459cc185bee5a1c58bf7e8cce25c150d": "0xaadec983fcff40000",
  	"0xaf67fd3e127fd9dc36eb3fcd6a80c7be4f7532b2": "0x5a87e7d7f5f6580000",
  	"0xaf771039345a343001bc0f8a5923b126b60d509c": "0x35659ef93f0fc40000",
  	"0xaf7f79cb415a1fb8dbbd094607ee8d41fb7c5a3b": "0x21e19e0c9bab2400000",
  	"0xaf87d2371ef378957fbd05ba2f1d66931b01e2b8": "0x25f273933db5700000",
  	"0xaf880fc7567d5595cacce15c3fc14c8742c26c9e": "0x73f75d1a085ba0000",
  	"0xaf8e1dcb314c950d3687434d309858e1a8739cd4": "0xe7eeba3410b740000",
  	"0xaf992dd669c0883e5515d3f3112a13f617a4c367": "0x6c6b935b8bbd400000",
  	"0xafa1d5ad38fed44759c05b8993c1aa0dace19f40": "0x4563918244f400000",
  	"0xafa539586e4719174a3b46b9b3e663a7d1b5b987": "0x10f0cf064dd59200000",
  	"0xafa6946effd5ff53154f82010253df47ae280ccc": "0x6acb3df27e1f880000",
  	"0xafc8ebe8988bd4105acc4c018e546a1e8f9c7888": "0x1b1ae4d6e2ef500000",
  	"0xafcc7dbb8356d842d43ae7e23c8422b022a30803": "0x66ffcbfd5e5a3000000",
  	"0xafd019ff36a09155346b69974815a1c912c90aa4": "0x6c6b935b8bbd400000",
  	"0xafdac5c1cb56e245bf70330066a817eaafac4cd1": "0x1158e460913d00000",
  	"0xafdd1b786162b8317e20f0e979f4b2ce486d765d": "0x1158e460913d00000",
  	"0xaff1045adf27a1aa329461b24de1bae9948a698b": "0x1cf84a30a0a0c0000",
  	"0xaff107960b7ec34ed690b665024d60838c190f70": "0x1b1ae4d6e2ef500000",
  	"0xaff11ccf699304d5f5862af86083451c26e79ae5": "0x6c5db2a4d815dc0000",
  	"0xaff161740a6d909fe99c59a9b77945c91cc91448": "0x340aad21b3b700000",
  	"0xaffc99d5ebb4a84fe7788d97dce274b038240438": "0x10f0cf064dd59200000",
  	"0xaffea0473722cb7f0e0e86b9e11883bf428d8d54": "0x692ae8897081d00000",
  	"0xb00996b0566ecb3e7243b8227988dcb352c21899": "0x28a857425466f800000",
  	"0xb01e389b28a31d8e4995bdd7d7c81beeab1e4119": "0x3635c9adc5dea00000",
  	"0xb02d062873334545cea29218e4057760590f7423": "0xacb6a1c7d93a880000",
  	"0xb02fa29387ec12e37f6922ac4ce98c5b09e0b00f": "0x6c6b935b8bbd400000",
  	"0xb036916bdacf94b69e5a8a65602975eb026104dd": "0x1158e460913d00000",
  	"0xb041310fe9eed6864cedd4bee58df88eb4ed3cac": "0x21e19e0c9bab2400000",
  	"0xb055af4cadfcfdb425cf65ba6431078f07ecd5ab": "0x56bc75e2d63100000",
  	"0xb0571153db1c4ed7acaefe13ecdfdb72e7e4f06a": "0x110cff796ac195200000",
  	"0xb06eab09a610c6a53d56a946b2c43487ac1d5b2d": "0x3635c9adc5dea00000",
  	"0xb07249e055044a9155359a402937bbd954fe48b6": "0x56bc75e2d63100000",
  	"0xb07618328a901307a1b7a0d058fcd5786e9e72fe": "0x667495d4a4330ce0000",
  	"0xb079bb4d9866143a6da72ae7ac0022062981315c": "0x29331e6558f0e00000",
  	"0xb07bcc085ab3f729f24400416837b69936ba8873": "0x6c6d84bccdd9ce0000",
  	"0xb07bcf1cc5d4462e5124c965ecf0d70dc27aca75": "0x56bc75e2d631000000",
  	"0xb07cb9c12405b711807543c4934465f87f98bd2d": "0x6c6b935b8bbd400000",
  	"0xb07fdeaff91d4460fe6cd0e8a1b0bd8d22a62e87": "0x11d2529f3535ab00000",
  	"0xb09fe6d4349b99bc37938054022d54fca366f7af": "0x2a5a058fc295ed000000",
  	"0xb0aa00950c0e81fa3210173e729aaf163a27cd71": "0x878678326eac9000000",
  	"0xb0ac4eff6680ee14169cdadbffdb30804f6d25f5": "0x6c6b935b8bbd400000",
  	"0xb0b36af9aeeedf97b6b02280f114f13984ea3260": "0x35659ef93f0fc40000",
  	"0xb0b779b94bfa3c2e1f587bcc9c7e21789222378f": "0x54069233bf7f780000",
  	"0xb0baeb30e313776c4c6d247402ba4167afcda1cc": "0x6acb3df27e1f880000",
  	"0xb0bb29a861ea1d424d45acd4bfc492fb8ed809b7": "0x4563918244f400000",
  	"0xb0c1b177a220e41f7c74d07cde8569c21c75c2f9": "0x12f939c99edab800000",
  	"0xb0c7ce4c0dc3c2bbb99cc1857b8a455f611711ce": "0xd8d726b7177a800000",
  	"0xb0cef8e8fb8984a6019f01c679f272bbe68f5c77": "0x83d6c7aab63600000",
  	"0xb0d32bd7e4e695b7b01aa3d0416f80557dba9903": "0x3739ff0f6e613300000",
  	"0xb0d3c9872b85056ea0c0e6d1ecf7a77e3ce6ab85": "0x10f08eda8e555098000",
  	"0xb0e469c886593815b3495638595daef0665fae62": "0x692ae8897081d00000",
  	"0xb0e760bb07c081777345e0578e8bc898226d4e3b": "0x6c6b935b8bbd400000",
  	"0xb1043004ec1941a8cf4f2b00b15700ddac6ff17e": "0x3635c9adc5dea00000",
  	"0xb105dd3d987cffd813e9c8500a80a1ad257d56c6": "0x6c6acc67d7b1d40000",
  	"0xb10fd2a647102f881f74c9fbc37da632949f2375": "0x22b1c8c1227a00000",
  	"0xb115ee3ab7641e1aa6d000e41bfc1ec7210c2f32": "0x2c0bb3dd30c4e200000",
  	"0xb1178ad47383c31c8134a1941cbcd474d06244e2": "0x3635c9adc5dea00000",
  	"0xb1179589e19db9d41557bbec1cb24ccc2dec1c7f": "0x152d02c7e14af6800000",
  	"0xb119e79aa9b916526581cbf521ef474ae84dcff4": "0x4fba1001e5befe0000",
  	"0xb11fa7fb270abcdf5a2eab95aa30c4b53636efbf": "0x2b5e3af16b18800000",
  	"0xb124bcb6ffa430fcae2e86b45f27e3f21e81ee08": "0x6c6b935b8bbd400000",
  	"0xb129a5cb7105fe810bd895dc7206a991a4545488": "0x1a055690d9db80000",
  	"0xb12ed07b8a38ad5506363fc07a0b6d799936bdaf": "0x21e19e0c9bab2400000",
  	"0xb134c004391ab4992878337a51ec242f42285742": "0x6c6b935b8bbd400000",
  	"0xb13f93af30e8d7667381b2b95bc1a699d5e3e129": "0x16c4abbebea0100000",
  	"0xb1459285863ea2db3759e546ceb3fb3761f5909c": "0x3cd72a894087e08000",
  	"0xb146a0b925553cf06fcaf54a1b4dfea621290757": "0x6c6e59e67c78540000",
  	"0xb14a7aaa8f49f2fb9a8102d6bbe4c48ae7c06fb2": "0x1b1ae4d6e2ef5000000",
  	"0xb14bbeff70720975dc6191b2a44ff49f2672873c": "0x7c0860e5a80dc0000",
  	"0xb14cc8de33d6338236539a489020ce4655a32bc6": "0x1b1ae4d6e2ef5000000",
  	"0xb14ddb0386fb606398b8cc47565afae00ff1d66a": "0xa12aff083e66f00000",
  	"0xb153f828dd076d4a7c1c2574bb2dee1a44a318a8": "0x15af1d78b58c400000",
  	"0xb1540e94cff3465cc3d187e7c8e3bdaf984659e2": "0xa215e44390e3330000",
  	"0xb158db43fa62d30e65f3d09bf781c7b67372ebaa": "0x6c5db2a4d815dc0000",
  	"0xb161725fdcedd17952d57b23ef285b7e4b1169e8": "0x2b6dfed3664958000",
  	"0xb16479ba8e7df8f63e1b95d149cd8529d735c2da": "0x2de33a6aac32548000",
  	"0xb166e37d2e501ae73c84142b5ffb5aa655dd5a99": "0x6c5db2a4d815dc0000",
  	"0xb183ebee4fcb42c220e47774f59d6c54d5e32ab1": "0x56f7a9c33c04d10000",
  	"0xb188078444027e386798a8ae68698919d5cc230d": "0xe7eeba3410b740000",
  	"0xb1896a37e5d8825a2d01765ae5de629977de8352": "0xad78ebc5ac6200000",
  	"0xb18e67a5050a1dc9fb190919a33da838ef445014": "0x1158e460913d00000",
  	"0xb1a2b43a7433dd150bb82227ed519cd6b142d382": "0x946d620d744b880000",
  	"0xb1c0d08b36e184f9952a4037e3e53a667d070a4e": "0x3635c9adc5dea00000",
  	"0xb1c328fb98f2f19ab6646f0a7c8c566fda5a8540": "0x878678326eac900000",
  	"0xb1c751786939bba0d671a677a158c6abe7265e46": "0x21e19e0c9bab2400000",
  	"0xb1cd4bdfd104489a026ec99d597307a04279f173": "0x43c33c1937564800000",
  	"0xb1cf94f8091505055f010ab4bac696e0ca0f67a1": "0x55a6e79ccd1d300000",
  	"0xb1d6b01b94d854fe8b374aa65e895cf22aa2560e": "0x32f51edbaaa3300000",
  	"0xb1dba5250ba9625755246e067967f2ad2f0791de": "0x10f0cf064dd592000000",
  	"0xb1e2dd95e39ae9775c55aeb13f12c2fa233053ba": "0x6c6b935b8bbd400000",
  	"0xb1e6e810c24ab0488de9e01e574837829f7c77d0": "0x15af1d78b58c400000",
  	"0xb1e9c5f1d21e61757a6b2ee75913fc5a1a4101c3": "0x6c6b935b8bbd400000",
  	"0xb203d29e6c56b92699c4b92d1f6f84648dc4cfbc": "0x15af1d78b58c400000",
  	"0xb216dc59e27c3d7279f5cd5bb2becfb2606e14d9": "0x15af1d78b58c400000",
  	"0xb21b7979bf7c5ca01fa82dd640b41c39e6c6bc75": "0x6c6acc67d7b1d40000",
  	"0xb223bf1fbf80485ca2b5567d98db7bc3534dd669": "0xd8d726b7177a800000",
  	"0xb22d5055d9623135961e6abd273c90deea16a3e7": "0x4be4e7267b6ae00000",
  	"0xb22dadd7e1e05232a93237baed98e0df92b1869e": "0x6c6b935b8bbd400000",
  	"0xb234035f7544463ce1e22bc553064684c513cd51": "0xd89fa3dc48dcf0000",
  	"0xb247cf9c72ec482af3eaa759658f793d670a570c": "0x31708ae00454400000",
  	"0xb2676841ee9f2d31c172e82303b0fe9bbf9f1e09": "0xad78ebc5ac6200000",
  	"0xb279c7d355c2880392aad1aa21ee867c3b3507df": "0x445be3f2ef87940000",
  	"0xb27c1a24204c1e118d75149dd109311e07c073ab": "0xa80d24677efef00000",
  	"0xb28181a458a440f1c6bb1de8400281a3148f4c35": "0x14620c57dddae00000",
  	"0xb28245037cb192f75785cb86cbfe7c930da258b0": "0x3635c9adc5dea000000",
  	"0xb287f7f8d8c3872c1b586bcd7d0aedbf7e732732": "0x1158e460913d00000",
  	"0xb28bb39f3466517cd46f979cf59653ee7d8f152e": "0x18650127cc3dc80000",
  	"0xb28dbfc6499894f73a71faa00abe0f4bc9d19f2a": "0x56bc75e2d63100000",
  	"0xb2968f7d35f208871631c6687b3f3daeabc6616c": "0x875c47f289f760000",
  	"0xb29f5b7c1930d9f97a115e067066f0b54db44b3b": "0x3635c9adc5dea00000",
  	"0xb2a144b1ea67b9510f2267f9da39d3f93de26642": "0x6c6b935b8bbd400000",
  	"0xb2a2c2111612fb8bbb8e7dd9378d67f1a384f050": "0x1158e460913d00000",
  	"0xb2a498f03bd7178bd8a789a00f5237af79a3e3f8": "0x41bad155e6512200000",
  	"0xb2aa2f1f8e93e79713d92cea9ffce9a40af9c82d": "0x6c6b935b8bbd400000",
  	"0xb2b516fdd19e7f3864b6d2cf1b252a4156f1b03b": "0x2e983c76115fc0000",
  	"0xb2b7cdb4ff4b61d5b7ce0b2270bbb5269743ec04": "0x6c6b935b8bbd400000",
  	"0xb2bdbedf95908476d7148a370cc693743628057f": "0xd8d726b7177a800000",
  	"0xb2bfaa58b5196c5cb7f89de15f479d1838de713d": "0x1236efcbcbb340000",
  	"0xb2c53efa33fe4a3a1a80205c73ec3b1dbcad0602": "0x6801dab35918938000",
  	"0xb2d0360515f17daba90fcbac8205d569b915d6ac": "0x14542ba12a337c00000",
  	"0xb2d1e99af91231858e7065dd1918330dc4c747d5": "0x3894f0e6f9b9f700000",
  	"0xb2d9ab9664bcf6df203c346fc692fd9cbab9205e": "0x17be78976065180000",
  	"0xb2ddb786d3794e270187d0451ad6c8b79e0e8745": "0x15af1d78b58c400000",
  	"0xb2e085fddd1468ba07415b274e734e11237fb2a9": "0x56bc75e2d63100000",
  	"0xb2e9d76bf50fc36bf7d3944b63e9ca889b699968": "0x9032ea62b74b100000",
  	"0xb2f9c972c1e9737755b3ff1b3088738396395b26": "0x43c33c1937564800000",
  	"0xb2fc84a3e50a50af02f94da0383ed59f71ff01d7": "0x65a4da25d3016c00000",
  	"0xb3050beff9de33c80e1fa15225e28f2c413ae313": "0x25f273933db5700000",
  	"0xb31196714a48dff726ea9433cd2912f1a414b3b3": "0x914878a8c05ee00000",
  	"0xb3145b74506d1a8d047cdcdc55392a7b5350799a": "0x1b6229741c0d3d5d8000",
  	"0xb320834836d1dbfda9e7a3184d1ad1fd4320ccc0": "0x3635c9adc5dea00000",
  	"0xb323dcbf2eddc5382ee4bbbb201ca3931be8b438": "0x6c6b935b8bbd400000",
  	"0xb32400fd13c5500917cb037b29fe22e7d5228f2d": "0x878678326eac9000000",
  	"0xb325674c01e3f7290d5226339fbeac67d221279f": "0x97c9ce4cf6d5c00000",
  	"0xb32825d5f3db249ef4e85cc4f33153958976e8bc": "0x1b2df9d219f5798000",
  	"0xb32af3d3e8d075344926546f2e32887bf93b16bd": "0xad78ebc5ac6200000",
  	"0xb32f1c2689a5ce79f1bc970b31584f1bcf2283e7": "0x1158e460913d00000",
  	"0xb33c0323fbf9c26c1d8ac44ef74391d0804696da": "0x1158e460913d00000",
  	"0xb34f04b8db65bba9c26efc4ce6efc50481f3d65d": "0x43c33c1937564800000",
  	"0xb3557d39b5411b84445f5f54f38f62d2714d0087": "0x2086ac351052600000",
  	"0xb358e97c70b605b1d7d729dfb640b43c5eafd1e7": "0x43c33c1937564800000",
  	"0xb35e8a1c0dac7e0e66dbac736a592abd44012561": "0xcfce55aa12b30000",
  	"0xb3667894b7863c068ad344873fcff4b5671e0689": "0x43c33c1937564800000",
  	"0xb3717731dad65132da792d876030e46ac227bb8a": "0x3635c9adc5dea00000",
  	"0xb3731b046c8ac695a127fd79d0a5d5fa6ae6d12e": "0x6c4fd1ee246e780000",
  	"0xb37c2b9f50637bece0ca959208aefee6463ba720": "0x15af1d78b58c400000",
  	"0xb388b5dfecd2c5e4b596577c642556dbfe277855": "0x1158e460913d00000",
  	"0xb38c4e537b5df930d65a74d043831d6b485bbde4": "0x15af1d78b58c400000",
  	"0xb39139576194a0866195151f33f2140ad1cc86cf": "0x152d02c7e14af6800000",
  	"0xb39f4c00b2630cab7db7295ef43d47d501e17fd7": "0xd8d726b7177a800000",
  	"0xb3a64b1176724f5409e1414a3523661baee74b4a": "0x16368ff4ff9c10000",
  	"0xb3a6bd41f9d9c3201e050b87198fbda399342210": "0xc461e1dd1029b58000",
  	"0xb3a8c2cb7d358e5739941d945ba9045a023a8bbb": "0x3635c9adc5dea00000",
  	"0xb3ae54fba09d3ee1d6bdd1e957923919024c35fa": "0x38d2cee65b22a8000",
  	"0xb3b7f493b44a2c8d80ec78b1cdc75a652b73b06c": "0x6c6b935b8bbd400000",
  	"0xb3c228731d186d2ded5b5fbe004c666c8e469b86": "0x19274b259f6540000",
  	"0xb3c260609b9df4095e6c5dff398eeb5e2df49985": "0xdc55fdb17647b0000",
  	"0xb3c65b845aba6cd816fbaae983e0e46c82aa8622": "0x3635c9adc5dea00000",
  	"0xb3c94811e7175b148b281c1a845bfc9bb6fbc115": "0xad78ebc5ac6200000",
  	"0xb3e20eb4de18bd060221689894bee5aeb25351ee": "0x3fc80cce516598000",
  	"0xb3e3c439069880156600c2892e448d4136c92d9b": "0x2e141ea081ca080000",
  	"0xb3f82a87e59a39d0d2808f0751eb72c2329cdcc5": "0x10f0cf064dd59200000",
  	"0xb3fc1d6881abfcb8becc0bb021b8b73b7233dd91": "0x2b5e3af16b1880000",
  	"0xb40594c4f3664ef849cca6227b8a25aa690925ee": "0xd8d726b7177a800000",
  	"0xb41eaf5d51a5ba1ba39bb418dbb54fab750efb1f": "0x3635c9adc5dea00000",
  	"0xb424d68d9d0d00cec1938c854e15ffb880ba0170": "0xad78ebc5ac6200000",
  	"0xb4256273962bf631d014555cc1da0dcc31616b49": "0x6c6b935b8bbd400000",
  	"0xb43067fe70d9b55973ba58dc64dd7f311e554259": "0xad78ebc5ac6200000",
  	"0xb43657a50eecbc3077e005d8f8d94f377876bad4": "0x1ec1b3a1ff75a0000",
  	"0xb43c27f7a0a122084b98f483922541c8836cee2c": "0x26c29e47c4844c0000",
  	"0xb4413576869c08f9512ad311fe925988a52d3414": "0x21e19e0c9bab2400000",
  	"0xb44605552471a6eee4daab71ff3bb41326d473e0": "0x2d7e3d51ba53d00000",
  	"0xb447571dacbb3ecbb6d1cf0b0c8f3838e52324e2": "0x1a318667fb4058000",
  	"0xb44783c8e57b480793cbd69a45d90c7b4f0c48ac": "0x1158e460913d00000",
  	"0xb44815a0f28e569d0e921a4ade8fb2642526497a": "0x302379bf2ca2e0000",
  	"0xb4496ddb27799a222457d73979116728e8a1845b": "0x8d819ea65fa62f8000",
  	"0xb4524c95a7860e21840296a616244019421c4aba": "0x1b1ae4d6e2ef5000000",
  	"0xb45cca0d36826662683cf7d0b2fdac687f02d0c4": "0x3635c9adc5dea00000",
  	"0xb46440c797a556e04c7d9104660491f96bb076bf": "0xcec76f0e71520000",
  	"0xb46ace865e2c50ea4698d216ab455dff5a11cd72": "0x3635c9adc5dea00000",
  	"0xb46d1182e5aacaff0d26b2fcf72f3c9ffbcdd97d": "0xaa2a603cdd7f2c0000",
  	"0xb48921c9687d5510744584936e8886bdbf2df69b": "0x3635c9adc5dea00000",
  	"0xb498bb0f520005b6216a4425b75aa9adc52d622b": "0xd8d726b7177a800000",
  	"0xb4b11d109f608fa8edd3fea9f8c315649aeb3d11": "0x10f0cf064dd59200000",
  	"0xb4b14bf45455d0ab0803358b7524a72be1a2045b": "0x1b1ae4d6e2ef500000",
  	"0xb4b185d943ee2b58631e33dff5af6854c17993ac": "0x3635c9adc5dea00000",
  	"0xb4bf24cb83686bc469869fefb044b909716993e2": "0x6c6b935b8bbd400000",
  	"0xb4c20040ccd9a1a3283da4d4a2f365820843d7e2": "0x3635c9adc5dea00000",
  	"0xb4c8170f7b2ab536d1d9a25bdd203ae1288dc3d5": "0xad78ebc5ac6200000",
  	"0xb4d82f2e69943f7de0f5f7743879406fac2e9cec": "0x22b1c8c1227a00000",
  	"0xb4dd460cd016725a64b22ea4f8e06e06674e033e": "0x1231bb8748547a80000",
  	"0xb4dd5499daeb2507fb2de12297731d4c72b16bb0": "0x1158e460913d00000",
  	"0xb5046cb3dc1dedbd364514a2848e44c1de4ed147": "0x37b7d9bb820405e0000",
  	"0xb508f987b2de34ae4cf193de85bff61389621f88": "0x14542ba12a337c00000",
  	"0xb50955aa6e341571986608bdc891c2139f540cdf": "0x6acb3df27e1f880000",
  	"0xb50c149a1906fad2786ffb135aab501737e9e56f": "0x150894e849b3900000",
  	"0xb50c9f5789ae44e2dce017c714caf00c830084c2": "0x155bd9307f9fe80000",
  	"0xb514882c979bb642a80dd38754d5b8c8296d9a07": "0x33c5499031720c0000",
  	"0xb51ddcb4dd4e8ae6be336dd9654971d9fec86b41": "0x16d464f83de2948000",
  	"0xb51e558eb5512fbcfa81f8d0bd938c79ebb5242b": "0x26c29e47c4844c0000",
  	"0xb523fff9749871b35388438837f7e6e0dea9cb6b": "0x6c6b935b8bbd400000",
  	"0xb52dfb45de5d74e3df208332bc571c809b8dcf32": "0x14542ba12a337c00000",
  	"0xb535f8db879fc67fec58824a5cbe6e5498aba692": "0x678a932062e4180000",
  	"0xb537d36a70eeb8d3e5c80de815225c1158cb92c4": "0x5150ae84a8cdf00000",
  	"0xb53bcb174c2518348b818aece020364596466ba3": "0x6c6b935b8bbd400000",
  	"0xb5493ef173724445cf345c035d279ba759f28d51": "0x1158e460913d00000",
  	"0xb553d25d6b5421e81c2ad05e0b8ba751f8f010e3": "0x6c6b935b8bbd400000",
  	"0xb55474ba58f0f2f40e6cbabed4ea176e011fcad6": "0x6acb3df27e1f880000",
  	"0xb555d00f9190cc3677aef314acd73fdc39399259": "0x6c6b935b8bbd400000",
  	"0xb557ab9439ef50d237b553f02508364a466a5c03": "0xad78ebc5ac6200000",
  	"0xb56a780028039c81caf37b6775c620e786954764": "0x6c6b935b8bbd400000",
  	"0xb56ad2aec6c8c3f19e1515bbb7dd91285256b639": "0x3635c9adc5dea00000",
  	"0xb57413060af3f14eb479065f1e9d19b3757ae8cc": "0x22b1c8c1227a00000",
  	"0xb57549bfbc9bdd18f736b22650e48a73601fa65c": "0x182d7e4cfda0380000",
  	"0xb577b6befa054e9c040461855094b002d7f57bd7": "0x1823f3cf621d23400000",
  	"0xb57b04fa23d1203fae061eac4542cb60f3a57637": "0xa5aa85009e39c0000",
  	"0xb5870ce342d43343333673038b4764a46e925f3e": "0x3635c9adc5dea00000",
  	"0xb587b44a2ca79e4bc1dd8bfdd43a207150f2e7e0": "0x222c8eb3ff66400000",
  	"0xb589676d15a04448344230d4ff27c95edf122c49": "0x3635c9adc5dea00000",
  	"0xb58b52865ea55d8036f2fab26098b352ca837e18": "0xfc936392801c0000",
  	"0xb5906b0ae9a28158e8ac550e39da086ee3157623": "0xad78ebc5ac6200000",
  	"0xb5a4679685fa14196c2e9230c8c4e33bffbc10e2": "0x4be4e7267b6ae00000",
  	"0xb5a589dd9f4071dbb6fba89b3f5d5dae7d96c163": "0x6c6b935b8bbd400000",
  	"0xb5a606f4ddcbb9471ec67f658caf2b00ee73025e": "0xea756ea92afc740000",
  	"0xb5ad5157dda921e6bafacd9086ae73ae1f611d3f": "0x6c6b935b8bbd400000",
  	"0xb5add1e7809f7d03069bfe883b0a932210be8712": "0x3635c9adc5dea00000",
  	"0xb5ba29917c78a1d9e5c5c713666c1e411d7f693a": "0xa80d24677efef00000",
  	"0xb5c816a8283ca4df68a1a73d63bd80260488df08": "0xad78ebc5ac6200000",
  	"0xb5cac5ed03477d390bb267d4ebd46101fbc2c3da": "0xaadec983fcff40000",
  	"0xb5cdbc4115406f52e5aa85d0fea170d2979cc7ba": "0x487a9a304539440000",
  	"0xb5d9934d7b292bcf603b2880741eb760288383a0": "0xe7c2518505060000",
  	"0xb5dd50a15da34968890a53b4f13fe1af081baaaa": "0xd8d726b7177a800000",
  	"0xb5fa8184e43ed3e0b8ab91216461b3528d84fd09": "0x914878a8c05ee00000",
  	"0xb5fb7ea2ddc1598b667a9d57dd39e85a38f35d56": "0x1b1ae4d6e2ef500000",
  	"0xb600429752f399c80d0734744bae0a022eca67c6": "0x1158e460913d00000",
  	"0xb600feab4aa96c537504d96057223141692c193a": "0x15af1d78b58c400000",
  	"0xb6047cdf932db3e4045f4976122341537ed5961e": "0x1158e460913d00000",
  	"0xb615e940143eb57f875893bc98a61b3d618c1e8c": "0x1158e460913d00000",
  	"0xb61c34fcacda701a5aa8702459deb0e4ae838df8": "0x7695a92c20d6fe00000",
  	"0xb63064bd3355e6e07e2d377024125a33776c4afa": "0x8375a2abcca24400000",
  	"0xb635a4bc71fb28fdd5d2c322983a56c284426e69": "0x93739534d28680000",
  	"0xb646df98b49442746b61525c81a3b04ba3106250": "0x6acb3df27e1f880000",
  	"0xb65941d44c50d24666670d364766e991c02e11c2": "0x2086ac351052600000",
  	"0xb65bd780c7434115162027565223f44e5498ff8c": "0x43c30fb0884a96c0000",
  	"0xb66411e3a02dedb726fa79107dc90bc1cae64d48": "0x6c6b935b8bbd400000",
  	"0xb66675142e3111a1c2ea1eb2419cfa42aaf7a234": "0x3635c9adc5dea00000",
  	"0xb66f92124b5e63035859e390628869dbdea9485e": "0x215f835bc769da80000",
  	"0xb672734afcc224e2e609fc51d4f059732744c948": "0x1004e2e45fb7ee0000",
  	"0xb6771b0bf3427f9ae7a93e7c2e61ee63941fdb08": "0x3fb26692954bfc00000",
  	"0xb67a80f170197d96cdcc4ab6cba627b4afa6e12c": "0x821ab0d44149800000",
  	"0xb68899e7610d4c93a23535bcc448945ba1666f1c": "0xad78ebc5ac6200000",
  	"0xb6a82933c9eadabd981e5d6d60a6818ff806e36b": "0x15af1d78b58c400000",
  	"0xb6aacb8cb30bab2ae4a2424626e6e12b02d04605": "0x1b1ae4d6e2ef5000000",
  	"0xb6b34a263f10c3d2eceb0acc559a7b2ab85ce565": "0xd8d726b7177a800000",
  	"0xb6bfe1c3ef94e1846fb9e3acfe9b50c3e9069233": "0x6c6acc67d7b1d40000",
  	"0xb6cd7432d5161be79768ad45de3e447a07982063": "0xd8d726b7177a800000",
  	"0xb6ce4dc560fc73dc69fb7a62e388db7e72ea764f": "0x345df169e9a3580000",
  	"0xb6decf82969819ba02de29b9b593f21b64eeda0f": "0x281d901f4fdd100000",
  	"0xb6e6c3222b6b6f9be2875d2a89f127fb64100fe2": "0x1b21d5323cc30200000",
  	"0xb6e8afd93dfa9af27f39b4df06076710bee3dfab": "0x15af1d78b58c40000",
  	"0xb6f78da4f4d041b3bc14bc5ba519a5ba0c32f128": "0x247dd32c3fe195048000",
  	"0xb6fb39786250081426a342c70d47ee521e5bc563": "0x32d26d12e980b600000",
  	"0xb70dba9391682b4a364e77fe99256301a6c0bf1f": "0xad78ebc5ac6200000",
  	"0xb71623f35107cf7431a83fb3d204b29ee0b1a7f4": "0x11164759ffb320000",
  	"0xb71a13ba8e95167b80331b52d69e37054fe7a826": "0xad78ebc5ac6200000",
  	"0xb71b62f4b448c02b1201cb5e394ae627b0a560ee": "0x1b1ae4d6e2ef500000",
  	"0xb72220ade364d0369f2d2da783ca474d7b9b34ce": "0x1b1ab319f5ec750000",
  	"0xb7230d1d1ff2aca366963914a79df9f7c5ea2c98": "0x1b1ae4d6e2ef5000000",
  	"0xb7240af2af90b33c08ae9764103e35dce3638428": "0x1cadd2fe9686e638000",
  	"0xb727a9fc82e1cffc5c175fa1485a9befa2cdbdd1": "0x3627e8f712373c0000",
  	"0xb72c2a011c0df50fbb6e28b20ae1aad217886790": "0xd8d726b7177a800000",
  	"0xb7382d37db0398ac72410cf9813de9f8e1ec8dad": "0x3636c25e66ece70000",
  	"0xb73b4ff99eb88fd89b0b6d57a9bc338e886fa06a": "0x1bc16d674ec800000",
  	"0xb73d6a77559c86cf6574242903394bacf96e3570": "0x4f1a77ccd3ba00000",
  	"0xb74372dbfa181dc9242f39bf1d3731dffe2bdacf": "0x6c6b935b8bbd400000",
  	"0xb7479dab5022c4d5dbaaf8de171b4e951dd1a457": "0x4563918244f400000",
  	"0xb749b54e04d5b19bdcedfb84da7701ab478c27ae": "0x914878a8c05ee00000",
  	"0xb74ed2666001c16333cf7af59e4a3d4860363b9c": "0xa7ebd5e4363a00000",
  	"0xb75149e185f6e3927057739073a1822ae1cf0df2": "0xd8d8583fa2d52f0000",
  	"0xb753a75f9ed10b21643a0a3dc0517ac96b1a4068": "0x15c8185b2c1ff40000",
  	"0xb756ad52f3bf74a7d24c67471e0887436936504c": "0x43c33c1937564800000",
  	"0xb7576e9d314df41ec5506494293afb1bd5d3f65d": "0x1158e460913d00000",
  	"0xb758896f1baa864f17ebed16d953886fee68aae6": "0x3635c9adc5dea00000",
  	"0xb768b5234eba3a9968b34d6ddb481c8419b3655d": "0xcfce55aa12b30000",
  	"0xb782bfd1e2de70f467646f9bc09ea5b1fcf450af": "0xe7eeba3410b740000",
  	"0xb7a2c103728b7305b5ae6e961c94ee99c9fe8e2b": "0xa968163f0a57b400000",
  	"0xb7a31a7c38f3db09322eae11d2272141ea229902": "0x6c6b935b8bbd400000",
  	"0xb7a6791c16eb4e2162f14b6537a02b3d63bfc602": "0x2a526391ac93760000",
  	"0xb7a7f77c348f92a9f1100c6bd829a8ac6d7fcf91": "0x62a992e53a0af00000",
  	"0xb7c077946674ba9341fb4c747a5d50f5d2da6415": "0x3635c9adc5dea00000",
  	"0xb7c0d0cc0b4d342d4062bac624ccc3c70cc6da3f": "0xd8d726b7177a800000",
  	"0xb7c9f12b038e73436d17e1c12ffe1aeccdb3f58c": "0x1d460162f516f00000",
  	"0xb7cc6b1acc32d8b295df68ed9d5e60b8f64cb67b": "0x1043561a8829300000",
  	"0xb7ce684b09abda53389a875369f71958aeac3bdd": "0x6c6b935b8bbd400000",
  	"0xb7d12e84a2e4c4a6345af1dd1da9f2504a2a996e": "0xad78ebc5ac6200000",
  	"0xb7d252ee9402b0eef144295f0e69f0db586c0871": "0x23c757072b8dd00000",
  	"0xb7d581fe0af1ec383f3b3c416783f385146a7612": "0x43c33c1937564800000",
  	"0xb7f67314cb832e32e63b15a40ce0d7ffbdb26985": "0x398279264a818d0000",
  	"0xb8040536958d5998ce4bec0cfc9c2204989848e9": "0x52ea70d498fd50a0000",
  	"0xb8310a16cc6abc465007694b930f978ece1930bd": "0x281d901f4fdd100000",
  	"0xb834acf3015322c58382eeb2b79638906e88b6de": "0x5150ae84a8cdf000000",
  	"0xb84b53d0bb125656cddc52eb852ab71d7259f3d5": "0x3635c9adc5dea000000",
  	"0xb84c8b9fd33ece00af9199f3cf5fe0cce28cd14a": "0xcf152640c5c8300000",
  	"0xb85218f342f8012eda9f274e63ce2152b2dcfdab": "0xa80d24677efef00000",
  	"0xb8555010776e3c5cb311a5adeefe9e92bb9a64b9": "0xd8d726b7177a800000",
  	"0xb85f26dd0e72d9c29ebaf697a8af77472c2b58b5": "0x28519acc7190c700000",
  	"0xb85ff03e7b5fc422981fae5e9941dacbdaba7584": "0x487a9a304539440000",
  	"0xb86607021b62d340cf2652f3f95fd2dc67698bdf": "0x10f0cf064dd59200000",
  	"0xb87de1bcd29269d521b8761cc39cfb4319d2ead5": "0x3635c9adc5dea00000",
  	"0xb87f5376c2de0b6cc3c179c06087aa473d6b4674": "0x487a9a304539440000",
  	"0xb884add88d83dc564ab8e0e02cbdb63919aea844": "0x6c6b935b8bbd400000",
  	"0xb88a37c27f78a617d5c091b7d5b73a3761e65f2a": "0x6c6b935b8bbd400000",
  	"0xb8947822d5ace7a6ad8326e95496221e0be6b73d": "0x1158e460913d00000",
  	"0xb89c036ed7c492879921be41e10ca1698198a74c": "0x62a992e53a0af00000",
  	"0xb89f4632df5909e58b2a9964f74feb9a3b01e0c5": "0x48875bcc6e7cbeb8000",
  	"0xb8a79c84945e47a9c3438683d6b5842cff7684b1": "0x6c6b935b8bbd400000",
  	"0xb8a979352759ba09e35aa5935df175bff678a108": "0x1158e460913d00000",
  	"0xb8ab39805bd821184f6cbd3d2473347b12bf175c": "0x6685ac1bfe32c0000",
  	"0xb8ac117d9f0dba80901445823c4c9d4fa3fedc6e": "0x3564c4427a8fc7d8000",
  	"0xb8bc9bca7f71b4ed12e620438d620f53c114342f": "0x1b1ae4d6e2ef500000",
  	"0xb8bedd576a4b4c2027da735a5bc3f533252a1808": "0x6c6b935b8bbd400000",
  	"0xb8c2703d8c3f2f44c584bc10e7c0a6b64c1c097e": "0x12cddb8ead6f9f80000",
  	"0xb8cc0f060aad92d4eb8b36b3b95ce9e90eb383d7": "0x1fc3842bd1f071c00000",
  	"0xb8d2ddc66f308c0158ae3ccb7b869f7d199d7b32": "0x2dcbf4840eca000000",
  	"0xb8d389e624a3a7aebce4d3e5dbdf6cdc29932aed": "0xad78ebc5ac6200000",
  	"0xb8d531a964bcea13829620c0ced72422dadb4cca": "0x93715cc5ab8a70000",
  	"0xb8d5c324a8209d7c8049d0d4aede02ba80ab578b": "0x393928629fff75e8000",
  	"0xb8f20005b61352ffa7699a1b52f01f5ab39167f1": "0x21e19e0c9bab2400000",
  	"0xb8f30758faa808dbc919aa7b425ec922b93b8129": "0x3636d7af5ec98e0000",
  	"0xb9013c51bd078a098fae05bf2ace0849c6be17a5": "0x4563918244f400000",
  	"0xb9144b677c2dc614ceefdf50985f1183208ea64c": "0x6c6b935b8bbd400000",
  	"0xb916b1a01cdc4e56e7657715ea37e2a0f087d106": "0x826e3181e027068000",
  	"0xb91d9e916cd40d193db60e79202778a0087716fc": "0x15f1ba7f4716200000",
  	"0xb9231eb26e5f9e4b4d288f03906704fab96c87d6": "0x42bf06b78ed3b500000",
  	"0xb92427ad7578b4bfe20a9f63a7c5506d5ca12dc8": "0x6c6b935b8bbd400000",
  	"0xb927abd2d28aaaa24db31778d27419df8e1b04bb": "0x17e11c2a26f478000",
  	"0xb94d47b3c052a5e50e4261ae06a20f45d8eee297": "0x6c6b935b8bbd400000",
  	"0xb95396daaa490df2569324fcc6623be052f132ca": "0x6c6b935b8bbd400000",
  	"0xb959dce02e91d9db02b1bd8b7d17a9c41a97af09": "0x1b1ae4d6e2ef5000000",
  	"0xb95c9b10aa981cf4a67a71cc52c504dee8cf58bd": "0xd8d726b7177a800000",
  	"0xb95cfda8465ba9c2661b249fc3ab661bdfa35ff0": "0x114a4e79a2c2108000",
  	"0xb96841cabbc7dbd69ef0cf8f81dff3c8a5e21570": "0x28a857425466f800000",
  	"0xb97a6733cd5fe99864b3b33460d1672434d5cafd": "0x6c65bbaa46c2cf8000",
  	"0xb981ad5e6b7793a23fc6c1e8692eb2965d18d0da": "0x21e18d2c821c7520000",
  	"0xb98ca31785ef06be49a1e47e864f60d076ca472e": "0xd8d726b7177a800000",
  	"0xb9920fd0e2c735c256463caa240fb7ac86a93dfa": "0x5f68e8131ecf800000",
  	"0xb992a967308c02b98af91ee760fd3b6b4824ab0e": "0x6c6b935b8bbd400000",
  	"0xb9a985501ee950829b17fae1c9cf348c3156542c": "0xff17517ca9a620000",
  	"0xb9b0a3219a3288d9b35b091b14650b8fe23dce2b": "0x2f6f10780d22cc00000",
  	"0xb9cf71b226583e3a921103a5316f855a65779d1b": "0x5150ae84a8cdf000000",
  	"0xb9e90c1192b3d5d3e3ab0700f1bf655f5dd4347a": "0x1b19e50b44977c0000",
  	"0xb9fd3833e88e7cf1fa9879bdf55af4b99cd5ce3f": "0x3635c9adc5dea00000",
  	"0xba0249e01d945bef93ee5ec61925e03c5ca509fd": "0xd8d726b7177a800000",
  	"0xba0f39023bdb29eb1862a9f9059cab5d306e662f": "0x6c6b935b8bbd400000",
  	"0xba10f2764290f875434372f79dbf713801caac01": "0x33c5499031720c0000",
  	"0xba1531fb9e791896bcf3a80558a359f6e7c144bd": "0xd5967be4fc3f100000",
  	"0xba176dbe3249e345cd4fa967c0ed13b24c47e586": "0x15aef9f1c31c7f0000",
  	"0xba1f0e03cb9aa021f4dcebfa94e5c889c9c7bc9e": "0x6d190c475169a200000",
  	"0xba1fcaf223937ef89e85675503bdb7ca6a928b78": "0x22b1c8c1227a000000",
  	"0xba24fc436753a739db2c8d40e6d4d04c528e86fa": "0x2c0bb3dd30c4e200000",
  	"0xba42f9aace4c184504abf5425762aca26f71fbdc": "0x207077dd8a79c0000",
  	"0xba469aa5c386b19295d4a1b5473b540353390c85": "0x6c6b935b8bbd400000",
  	"0xba6440aeb3737b8ef0f1af9b0c15f4c214ffc7cf": "0x3635c9adc5dea00000",
  	"0xba6d31b9a261d640b5dea51ef2162c3109f1eba8": "0x10f0cf064dd59200000",
  	"0xba70e8b4759c0c3c82cc00ac4e9a94dd5bafb2b8": "0x3043fa33c412d70000",
  	"0xba8a63f3f40de4a88388bc50212fea8e064fbb86": "0x6c6b935b8bbd400000",
  	"0xba8e46d69d2e2343d86c60d82cf42c2041a0c1c2": "0x56bc75e2d63100000",
  	"0xbaa4b64c2b15b79f5f204246fd70bcbd86e4a92a": "0x1b1ae4d6e2ef500000",
  	"0xbac8922c4acc7d2cb6fd59a14eb45cf3e702214b": "0x2b5e3af16b18800000",
  	"0xbad235d5085dc7b068a67c412677b03e1836884c": "0x6c6b935b8bbd400000",
  	"0xbad4425e171c3e72975eb46ac0a015db315a5d8f": "0x6c6b935b8bbd400000",
  	"0xbadc2aef9f5951a8d78a6b35c3d0b3a4e6e2e739": "0x14542ba12a337c00000",
  	"0xbade43599e02f84f4c3014571c976b13a36c65ab": "0xd8d726b7177a800000",
  	"0xbae9b82f7299631408659dd74e891cb8f3860fe5": "0x6acb3df27e1f880000",
  	"0xbb0366a7cfbd3445a70db7fe5ae34885754fd468": "0x14def2c42ebd6400000",
  	"0xbb076aac92208069ea318a31ff8eeb14b7e996e3": "0x813ca56906d340000",
  	"0xbb0857f1c911b24b86c8a70681473fe6aaa1cce2": "0x56bc75e2d63100000",
  	"0xbb19bf91cbad74cceb5f811db27e411bc2ea0656": "0xf43fc2c04ee00000",
  	"0xbb27c6a7f91075475ab229619040f804c8ec7a6a": "0x21e19e0c9bab2400000",
  	"0xbb371c72c9f0316cea2bd9c6fbb4079e775429ef": "0x5f68e8131ecf800000",
  	"0xbb3b010b18e6e2be1135871026b7ba15ea0fde24": "0x2207c80309b77700000",
  	"0xbb3b9005f46fd2ca3b30162599928c77d9f6b601": "0x1b1ae7f2b1bf7db0000",
  	"0xbb3fc0a29c034d710812dcc775c8cab9d28d6975": "0x39d4e844d1cf5f0000",
  	"0xbb48eaf516ce2dec3e41feb4c679e4957641164f": "0xcf152640c5c8300000",
  	"0xbb4b4a4b548070ff41432c9e08a0ca6fa7bc9f76": "0x2e141ea081ca080000",
  	"0xbb56a404723cff20d0685488b05a02cdc35aacaa": "0x1158e460913d00000",
  	"0xbb618e25221ad9a740b299ed1406bc3934b0b16d": "0x3635c9adc5dea00000",
  	"0xbb61a04bffd57c10470d45c39103f64650347616": "0x3635c9adc5dea00000",
  	"0xbb6823a1bd819f13515538264a2de052b4442208": "0x16368ff4ff9c10000",
  	"0xbb6c284aac8a69b75cddb00f28e145583b56bece": "0x6c6b935b8bbd400000",
  	"0xbb75cb5051a0b0944b4673ca752a97037f7c8c15": "0xad78ebc5ac6200000",
  	"0xbb993b96ee925ada7d99d786573d3f89180ce3aa": "0x6c6b935b8bbd400000",
  	"0xbba3c68004248e489573abb2743677066b24c8a7": "0x6c6b935b8bbd400000",
  	"0xbba4fac3c42039d828e742cde0efffe774941b39": "0x6c6ad382d4fb610000",
  	"0xbba8ab22d2fedbcfc63f684c08afdf1c175090b5": "0x55f29f37e4e3b8000",
  	"0xbba976f1a1215f7512871892d45f7048acd356c8": "0x6c6b935b8bbd400000",
  	"0xbbab000b0408ed015a37c04747bc461ab14e151b": "0x14542ba12a337c00000",
  	"0xbbabf6643beb4bd01c120bd0598a0987d82967d1": "0xb5328178ad0f2a0000",
  	"0xbbb4ee1d82f2e156442cc93338a2fc286fa28864": "0x4a4491bd6dcd280000",
  	"0xbbb5a0f4802c8648009e8a6998af352cde87544f": "0x52d542804f1ce0000",
  	"0xbbb643d2187b364afc10a6fd368d7d55f50d1a3c": "0x3635c9adc5dea00000",
  	"0xbbb8ffe43f98de8eae184623ae5264e424d0b8d7": "0x5d53ffde928080000",
  	"0xbbbd6ecbb5752891b4ceb3cce73a8f477059376f": "0x1f399b1438a100000",
  	"0xbbbf39b1b67995a42241504f9703d2a14a515696": "0x55a6e79ccd1d300000",
  	"0xbbc8eaff637e94fcc58d913c7770c88f9b479277": "0xad78ebc5ac6200000",
  	"0xbbc9d8112e5beb02dd29a2257b1fe69b3536a945": "0x6c6b935b8bbd400000",
  	"0xbbca65b3266ea2fb73a03f921635f912c7bede00": "0x6acb3df27e1f880000",
  	"0xbbf84292d954acd9e4072fb860b1504106e077ae": "0x5150ae84a8cdf00000",
  	"0xbbf85aaaa683738f073baef44ac9dc34c4c779ea": "0x6c6b935b8bbd400000",
  	"0xbbf8616d97724af3def165d0e28cda89b800009a": "0x62ef12e2b17618000",
  	"0xbbfe0a830cace87b7293993a7e9496ce64f8e394": "0x14542ba12a337c00000",
  	"0xbc0ca4f217e052753614d6b019948824d0d8688b": "0x15af1d78b58c400000",
  	"0xbc0e8745c3a549445c2be900f52300804ab56289": "0x7029bf5dd4c53b28000",
  	"0xbc0f98598f88056a26339620923b8f1eb074a9fd": "0xad78ebc5ac6200000",
  	"0xbc1609d685b76b48ec909aa099219022f89b2ccd": "0x40138b917edfb80000",
  	"0xbc171e53d17ac9b61241ae436deec7af452e7496": "0x121ea68c114e5100000",
  	"0xbc1b021a78fde42d9b5226d6ec26e06aa3670090": "0x4563918244f400000",
  	"0xbc1e80c181616342ebb3fb3992072f1b28b802c6": "0xd8d726b7177a800000",
  	"0xbc237148d30c13836ffa2cad520ee4d2e5c4eeff": "0x6acb3df27e1f880000",
  	"0xbc46d537cf2edd403565bde733b2e34b215001bd": "0x43c33c1937564800000",
  	"0xbc4e471560c99c8a2a4b1b1ad0c36aa6502b7c4b": "0x28a857425466f800000",
  	"0xbc62b3096a91e7dc11a1592a293dd2542150d751": "0x3635c9adc5dea00000",
  	"0xbc69a0d2a31c3dbf7a9122116901b2bdfe9802a0": "0xa2a15d09519be00000",
  	"0xbc6b58364bf7f1951c309e0cba0595201cd73f9a": "0x62401a457e45f80000",
  	"0xbc73f7b1ca3b773b34249ada2e2c8a9274cc17c2": "0x6c6b935b8bbd400000",
  	"0xbc7afc8477412274fc265df13c054473427d43c6": "0x70c95920ce3250000",
  	"0xbc967fe4418c18b99858966d870678dca2b88879": "0x1d9cbdd8d7ed2100000",
  	"0xbc999e385c5aebcac8d6f3f0d60d5aa725336d0d": "0x6c6b935b8bbd400000",
  	"0xbc9c95dfab97a574cea2aa803b5caa197cef0cff": "0x16c4abbebea0100000",
  	"0xbc9e0ec6788f7df4c7fc210aacd220c27e45c910": "0x1b1ae4d6e2ef500000",
  	"0xbca3ffd4683fba0ad3bbc90734b611da9cfb457e": "0xad78ebc5ac6200000",
  	"0xbcaed0acb6a76f113f7c613555a2c3b0f5bf34a5": "0xa7ebd5e4363a00000",
  	"0xbcaf347918efb2d63dde03e39275bbe97d26df50": "0x56bc75e2d63100000",
  	"0xbcb422dc4dd2aae94abae95ea45dd1731bb6b0ba": "0x18424f5f0b1b4e0000",
  	"0xbcbd31252ec288f91e298cd812c92160e738331a": "0x6b1bc2cac09a590000",
  	"0xbcbf6ba166e2340db052ea23d28029b0de6aa380": "0xd255d112e103a00000",
  	"0xbcc84597b91e73d5c5b4d69c80ecf146860f779a": "0xed70b5e9c3f2f00000",
  	"0xbcc9593b2da6df6a34d71b1aa38dacf876f95b88": "0x1158e460913d00000",
  	"0xbcd95ef962462b6edfa10fda87d72242fe3edb5c": "0x121d06e12fff988000",
  	"0xbcd99edc2160f210a05e3a1fa0b0434ced00439b": "0x6c6b935b8bbd400000",
  	"0xbcdfacb9d9023c3417182e9100e8ea1d373393a3": "0x3342d60dff1960000",
  	"0xbce13e22322acfb355cd21fd0df60cf93add26c6": "0xad78ebc5ac6200000",
  	"0xbce40475d345b0712dee703d87cd7657fc7f3b62": "0x1a420db02bd7d580000",
  	"0xbcedc4267ccb89b31bb764d7211171008d94d44d": "0xad78ebc5ac6200000",
  	"0xbcfc98e5c82b6adb180a3fcb120b9a7690c86a3f": "0x6acb3df27e1f880000",
  	"0xbd043b67c63e60f841ccca15b129cdfe6590c8e3": "0xad78ebc5ac6200000",
  	"0xbd047ff1e69cc6b29ad26497a9a6f27a903fc4dd": "0x2ee449550898e40000",
  	"0xbd08e0cddec097db7901ea819a3d1fd9de8951a2": "0x1158e460913d00000",
  	"0xbd09126c891c4a83068059fe0e15796c4661a9f4": "0x2b5e3af16b18800000",
  	"0xbd0c5cd799ebc48642ef97d74e8e429064fee492": "0x11ac28a8c729580000",
  	"0xbd17eed82b9a2592019a1b1b3c0fbad45c408d22": "0xd8d726b7177a80000",
  	"0xbd1803370bddb129d239fd16ea8526a6188ae58e": "0x1b1ae4d6e2ef500000",
  	"0xbd2b70fecc37640f69514fc7f3404946aad86b11": "0x410d586a20a4c00000",
  	"0xbd3097a79b3c0d2ebff0e6e86ab0edadbed47096": "0x5a87e7d7f5f6580000",
  	"0xbd325d4029e0d8729f6d399c478224ae9e7ae41e": "0xd255d112e103a00000",
  	"0xbd432a3916249b4724293af9146e49b8280a7f2a": "0xd8d726b7177a800000",
  	"0xbd47f5f76e3b930fd9485209efa0d4763da07568": "0x3635c9adc5dea00000",
  	"0xbd4b60faec740a21e3071391f96aa534f7c1f44e": "0x9ddc1e3b901180000",
  	"0xbd4bd5b122d8ef7b7c8f0667450320db2116142e": "0x2086ac351052600000",
  	"0xbd51ee2ea143d7b1d6b77e7e44bdd7da12f485ac": "0x477e06ccb2b9280000",
  	"0xbd59094e074f8d79142ab1489f148e32151f2089": "0x1158e460913d00000",
  	"0xbd5a8c94bd8be6470644f70c8f8a33a8a55c6341": "0xad78ebc5ac6200000",
  	"0xbd5e473abce8f97a6932f77c2facaf9cc0a00514": "0x3c9258a106a6b70000",
  	"0xbd5f46caab2c3d4b289396bbb07f203c4da82530": "0x4563918244f400000",
  	"0xbd66ffedb530ea0b2e856dd12ac2296c31fe29e0": "0xad78ebc5ac6200000",
  	"0xbd67d2e2f82da8861341bc96a2c0791fddf39e40": "0xad7c07947c8fb0000",
  	"0xbd6a474d66345bcdd707594adb63b30c7822af54": "0xd8d726b7177a800000",
  	"0xbd723b289a7367b6ece2455ed61edb49670ab9c4": "0x10f0cdea164213f8000",
  	"0xbd73c3cbc26a175062ea0320dd84b253bce64358": "0x155bd9307f9fe80000",
  	"0xbd7419dc2a090a46e2873d7de6eaaad59e19c479": "0x170bcb671759f080000",
  	"0xbd8765f41299c7f479923c4fd18f126d7229047d": "0xd8d726b7177a800000",
  	"0xbd93e550403e2a06113ed4c3fba1a8913b19407e": "0x6c6b935b8bbd400000",
  	"0xbd9e56e902f4be1fc8768d8038bac63e2acbbf8e": "0x36356633ebd8ea0000",
  	"0xbda4be317e7e4bed84c0495eee32d607ec38ca52": "0x7d32277978ef4e8000",
  	"0xbdb60b823a1173d45a0792245fb496f1fd3301cf": "0x6c6b935b8bbd400000",
  	"0xbdbaf6434d40d6355b1e80e40cc4ab9c68d96116": "0x56bc75e2d63100000",
  	"0xbdc02cd4330c93d6fbda4f6db2a85df22f43c233": "0x6c6b935b8bbd400000",
  	"0xbdc461462b6322b462bdb33f22799e8108e2417d": "0x243d4d18229ca20000",
  	"0xbdc739a699700b2e8e2c4a4c7b058a0e513ddebe": "0x6c6b935b8bbd400000",
  	"0xbdc74873af922b9df474853b0fa7ff0bf8c82695": "0xd8c9460063d31c0000",
  	"0xbdca2a0ff34588af625fa8e28fc3015ab5a3aa00": "0x7ed73f773552fc0000",
  	"0xbdd3254e1b3a6dc6cc2c697d45711aca21d516b2": "0x6c6b935b8bbd400000",
  	"0xbddfa34d0ebf1b04af53b99b82494a9e3d8aa100": "0x28a857425466f800000",
  	"0xbde4c73f969b89e9ceae66a2b51844480e038e9a": "0x3635c9adc5dea00000",
  	"0xbde9786a84e75b48f18e726dd78d70e4af3ed802": "0x1369fb96128ac480000",
  	"0xbded11612fb5c6da99d1e30e320bc0995466141e": "0x15af1d78b58c400000",
  	"0xbded7e07d0711e684de65ac8b2ab57c55c1a8645": "0x2009c5c8bf6fdc0000",
  	"0xbdf693f833c3fe471753184788eb4bfe4adc3f96": "0x6acb3df27e1f880000",
  	"0xbdf6e68c0cd7584080e847d72cbb23aad46aeb1d": "0x6acb3df27e1f880000",
  	"0xbe0a2f385f09dbfce96732e12bb40ac349871ba8": "0x574c115e02b8be0000",
  	"0xbe0c2a80b9de084b172894a76cf4737a4f529e1a": "0x6c6acc67d7b1d40000",
  	"0xbe1cd7f4c472070968f3bde268366b21eeea8321": "0xe91a7cd19fa3b00000",
  	"0xbe2346a27ff9b702044f500deff2e7ffe6824541": "0x1158e460913d00000",
  	"0xbe2471a67f6047918772d0e36839255ed9d691ae": "0xd8d726b7177a800000",
  	"0xbe2b2280523768ea8ac35cd9e888d60a719300d4": "0x6c6b935b8bbd400000",
  	"0xbe2b326e78ed10e550fee8efa8f8070396522f5a": "0x857e0d6f1da76a00000",
  	"0xbe305a796e33bbf7f9aeae6512959066efda1010": "0x24dce54d34a1a000000",
  	"0xbe478e8e3dde6bd403bb2d1c657c4310ee192723": "0x1ab2cf7c9f87e20000",
  	"0xbe4e7d983f2e2a636b1102ec7039efebc842e98d": "0x393ef1a5127c80000",
  	"0xbe4fd073617022b67f5c13499b827f763639e4e3": "0x6c6b935b8bbd400000",
  	"0xbe525a33ea916177f17283fca29e8b350b7f530b": "0x8f019aaf46e8780000",
  	"0xbe53322f43fbb58494d7cce19dda272b2450e827": "0xad7ceaf425c150000",
  	"0xbe538246dd4e6f0c20bf5ad1373c3b463a131e86": "0xad78ebc5ac6200000",
  	"0xbe5a60689998639ad75bc105a371743eef0f7940": "0x1b327c73e1257a0000",
  	"0xbe5cba8d37427986e8ca2600e858bb03c359520f": "0xa030dcebbd2f4c0000",
  	"0xbe60037e90714a4b917e61f193d834906703b13a": "0x5c283d410394100000",
  	"0xbe633a3737f68439bac7c90a52142058ee8e8a6f": "0x340aad21b3b7000000",
  	"0xbe659d85e7c34f8833ea7f488de1fbb5d4149bef": "0x1ebd23ad9d5bb720000",
  	"0xbe73274d8c5aa44a3cbefc8263c37ba121b20ad3": "0x1b1ae4d6e2ef500000",
  	"0xbe86d0b0438419ceb1a038319237ba5206d72e46": "0x3634fb9f1489a70000",
  	"0xbe8d7f18adfe5d6cc775394989e1930c979d007d": "0x3635c9adc5dea00000",
  	"0xbe9186c34a52514abb9107860f674f97b821bd5b": "0x1ba01ee40603100000",
  	"0xbe935793f45b70d8045d2654d8dd3ad24b5b6137": "0x2fb474098f67c00000",
  	"0xbe98a77fd41097b34f59d7589baad021659ff712": "0x30ca024f987b900000",
  	"0xbe9b8c34b78ee947ff81472eda7af9d204bc8466": "0x821ab0d4414980000",
  	"0xbea00df17067a43a82bc1daecafb6c14300e89e6": "0x62a992e53a0af00000",
  	"0xbea0afc93aae2108a3fac059623bf86fa582a75e": "0x5c283d410394100000",
  	"0xbeb3358c50cf9f75ffc76d443c2c7f55075a0589": "0x90f534608a72880000",
  	"0xbeb4fd315559436045dcb99d49dcec03f40c42dc": "0x6c6b935b8bbd400000",
  	"0xbec2e6de39c07c2bae556acfbee2c4728b9982e3": "0x1f0ff8f01daad40000",
  	"0xbec6640f4909b58cbf1e806342961d607595096c": "0x6c6acc67d7b1d40000",
  	"0xbec8caf7ee49468fee552eff3ac5234eb9b17d42": "0x6c6b935b8bbd400000",
  	"0xbecef61c1c442bef7ce04b73adb249a8ba047e00": "0x363b56c3a754c80000",
  	"0xbed4649df646e2819229032d8868556fe1e053d3": "0xfc936392801c0000",
  	"0xbed4c8f006a27c1e5f7ce205de75f516bfb9f764": "0x3635c9adc5dea000000",
  	"0xbee8d0b008421954f92d000d390fb8f8e658eaee": "0x3635c9adc5dea00000",
  	"0xbeecd6af900c8b064afcc6073f2d85d59af11956": "0x6c6b935b8bbd400000",
  	"0xbeef94213879e02622142bea61290978939a60d7": "0x136857b32ad86048000",
  	"0xbef07d97c3481f9d6aee1c98f9d91a180a32442b": "0x152d02c7e14af6800000",
  	"0xbefb448c0c5f683fb67ee570baf0db5686599751": "0x6acb3df27e1f880000",
  	"0xbf05070c2c34219311c4548b2614a438810ded6d": "0x6c6b935b8bbd400000",
  	"0xbf05ff5ecf0df2df887759fb8274d93238ac267d": "0x2b5e3af16b18800000",
  	"0xbf09d77048e270b662330e9486b38b43cd781495": "0x5c539b7bf4ff28800000",
  	"0xbf17f397f8f46f1bae45d187148c06eeb959fa4d": "0x3649c59624bb300000",
  	"0xbf183641edb886ce60b8190261e14f42d93cce01": "0x15b3557f1937f8000",
  	"0xbf2aea5a1dcf6ed3b5e8323944e983fedfd1acfb": "0x55a6e79ccd1d300000",
  	"0xbf4096bc547dbfc4e74809a31c039e7b389d5e17": "0xd5967be4fc3f100000",
  	"0xbf49c14898316567d8b709c2e50594b366c6d38c": "0x27bf38c6544df50000",
  	"0xbf4c73a7ede7b164fe072114843654e4d8781dde": "0x6c6b935b8bbd400000",
  	"0xbf50ce2e264b9fe2b06830617aedf502b2351b45": "0x3635c9adc5dea00000",
  	"0xbf59aee281fa43fe97194351a9857e01a3b897b2": "0x2086ac351052600000",
  	"0xbf68d28aaf1eeefef646b65e8cc8d190f6c6da9c": "0x6c6b935b8bbd400000",
  	"0xbf6925c00751008440a6739a02bf2b6cdaab5e3a": "0x3635c9adc5dea00000",
  	"0xbf7701fc6225d5a17815438a8941d21ebc5d059d": "0x65ea3db75546600000",
  	"0xbf8b8005d636a49664f74275ef42438acd65ac91": "0xad78ebc5ac6200000",
  	"0xbf92418a0c6c31244d220260cb3e867dd7b4ef49": "0x56900d33ca7fc0000",
  	"0xbf9acd4445d9c9554689cabbbab18800ff1741c2": "0x3635c9adc5dea00000",
  	"0xbf9f271f7a7e12e36dd2fe9facebf385fe6142bd": "0x366f84f7bb7840000",
  	"0xbfa8c858df102cb12421008b0a31c4c7190ad560": "0xad78ebc5ac6200000",
  	"0xbfaeb91067617dcf8b44172b02af615674835dba": "0x8b59e884813088000",
  	"0xbfb0ea02feb61dec9e22a5070959330299c43072": "0x43c33c1937564800000",
  	"0xbfbca418d3529cb393081062032a6e1183c6b2dc": "0x1b1ae4d6e2ef5000000",
  	"0xbfbe05e88c9cbbcc0e92a405fac1d85de248ee24": "0x56bc75e2d63100000",
  	"0xbfbfbcb656c2992be8fcde8219fbc54aadd59f29": "0x21e18d2c821c7520000",
  	"0xbfc57aa666fae28e9f107a49cb5089a4e22151dd": "0x3635c9adc5dea00000",
  	"0xbfcb9730246304700da90b4153e71141622e1c41": "0x3635c9adc5dea00000",
  	"0xbfd93c90c29c07bc5fb5fc49aeea55a40e134f35": "0x5ede20f01a459800000",
  	"0xbfe3a1fc6e24c8f7b3250560991f93cba2cf8047": "0x10f0cf064dd592000000",
  	"0xbfe6bcb0f0c07852643324aa5df5fd6225abc3ca": "0x409e52b48369a0000",
  	"0xbff5df769934b8943ca9137d0efef2fe6ebbb34e": "0x56bc75e2d63100000",
  	"0xbffb6929241f788693273e7022e60e3eab1fe84f": "0x6c6b935b8bbd400000",
  	"0xc0064f1d9474ab915d56906c9fb320a2c7098c9b": "0x13683f7f3c15d80000",
  	"0xc007f0bdb6e7009202b7af3ea90902697c721413": "0xa2a0e43e7fb9830000",
  	"0xc00ab080b643e1c2bae363e0d195de2efffc1c44": "0x1b1ae4d6e2ef500000",
  	"0xc02077449a134a7ad1ef7e4d927affeceeadb5ae": "0xfc936392801c0000",
  	"0xc02471e3fc2ea0532615a7571d493289c13c36ef": "0x1158e460913d00000",
  	"0xc02d6eadeacf1b78b3ca85035c637bb1ce01f490": "0xd8d726b7177a800000",
  	"0xc033b1325a0af45472c25527853b1f1c21fa35de": "0x6c6b935b8bbd400000",
  	"0xc033be10cb48613bd5ebcb33ed4902f38b583003": "0xa2a15d09519be00000",
  	"0xc0345b33f49ce27fe82cf7c84d141c68f590ce76": "0x3635c9adc5dea00000",
  	"0xc03de42a109b657a64e92224c08dc1275e80d9b2": "0x1158e460913d00000",
  	"0xc04069dfb18b096c7867f8bee77a6dc7477ad062": "0x90f534608a72880000",
  	"0xc0413f5a7c2d9a4b8108289ef6ecd271781524f4": "0xa968163f0a57b400000",
  	"0xc043f2452dcb9602ef62bd360e033dd23971fe84": "0x6c6b935b8bbd400000",
  	"0xc04f4bd4049f044685b883b62959ae631d667e35": "0x13b80b99c5185700000",
  	"0xc056d4bd6bf3cbacac65f8f5a0e3980b852740ae": "0x56bc75e2d63100000",
  	"0xc05b740620f173f16e52471dc38b9c514a0b1526": "0x796e3ea3f8ab00000",
  	"0xc069ef0eb34299abd2e32dabc47944b272334824": "0x68155a43676e00000",
  	"0xc06cebbbf7f5149a66f7eb976b3e47d56516da2f": "0x6c6b935b8bbd400000",
  	"0xc0725ec2bdc33a1d826071dea29d62d4385a8c25": "0x8a08513463aa6100000",
  	"0xc07e3867ada096807a051a6c9c34cc3b3f4ad34a": "0x60f06620a849450000",
  	"0xc0895efd056d9a3a81c3da578ada311bfb9356cf": "0xad78ebc5ac6200000",
  	"0xc090fe23dcd86b358c32e48d2af91024259f6566": "0xad78ebc5ac6200000",
  	"0xc09a66172aea370d9a63da04ff71ffbbfcff7f94": "0x6c6b935b8bbd400000",
  	"0xc09e3cfc19f605ff3ec9c9c70e2540d7ee974366": "0x1b1ae4d6e2ef500000",
  	"0xc0a02ab94ebe56d045b41b629b98462e3a024a93": "0x56bc75e2d63100000",
  	"0xc0a39308a80e9e84aaaf16ac01e3b01d74bd6b2d": "0x7664ddd4c1c0b8000",
  	"0xc0a6cbad77692a3d88d141ef769a99bb9e3c9951": "0x56bc75e2d63100000",
  	"0xc0a7e8435dff14c25577739db55c24d5bf57a3d9": "0xa6dd90cae5114480000",
  	"0xc0ae14d724832e2fce2778de7f7b8daf7b12a93e": "0x1158e460913d00000",
  	"0xc0afb7d8b79370cfd663c68cc6b9702a37cd9eff": "0x3635c9adc5dea00000",
  	"0xc0b0b7a8a6e1acdd05e47f94c09688aa16c7ad8d": "0x37b6d02ac76710000",
  	"0xc0b3f244bca7b7de5b48a53edb9cbeab0b6d88c0": "0x13b80b99c5185700000",
  	"0xc0c04d0106810e3ec0e54a19f2ab8597e69a573d": "0x2b5e3af16b1880000",
  	"0xc0ca3277942e7445874be31ceb902972714f1823": "0xd8d726b7177a80000",
  	"0xc0cbad3ccdf654da22cbcf5c786597ca1955c115": "0x6c6b935b8bbd400000",
  	"0xc0cbf6032fa39e7c46ff778a94f7d445fe22cf30": "0x10ce1d3d8cb3180000",
  	"0xc0e0b903088e0c63f53dd069575452aff52410c3": "0xa2a15d09519be00000",
  	"0xc0e457bd56ec36a1246bfa3230fff38e5926ef22": "0x692ae8897081d00000",
  	"0xc0ed0d4ad10de03435b153a0fc25de3b93f45204": "0xab4dcf399a3a600000",
  	"0xc0f29ed0076611b5e55e130547e68a48e26df5e4": "0xa2a15d09519be00000",
  	"0xc1132878235c5ddba5d9f3228b5236e47020dc6f": "0x3635c9adc5dea00000",
  	"0xc1170dbaadb3dee6198ea544baec93251860fda5": "0x410d586a20a4c00000",
  	"0xc126573d87b0175a5295f1dd07c575cf8cfa15f2": "0x21e19e0c9bab2400000",
  	"0xc127aab59065a28644a56ba3f15e2eac13da2995": "0x2086ac351052600000",
  	"0xc12b7f40df9a2f7bf983661422ab84c9c1f50858": "0x1b1ae4d6e2ef5000000",
  	"0xc12cfb7b3df70fceca0ede263500e27873f8ed16": "0x3635c9adc5dea00000",
  	"0xc12f881fa112b8199ecbc73ec4185790e614a20f": "0x6c6b935b8bbd400000",
  	"0xc1384c6e717ebe4b23014e51f31c9df7e4e25b31": "0x1b1ae4d6e2ef500000",
  	"0xc1438c99dd51ef1ca8386af0a317e9b041457888": "0xc1daf81d8a3ce0000",
  	"0xc1631228efbf2a2e3a4092ee8900c639ed34fbc8": "0x33c5499031720c0000",
  	"0xc175be3194e669422d15fee81eb9f2c56c67d9c9": "0xad78ebc5ac6200000",
  	"0xc1827686c0169485ec15b3a7c8c01517a2874de1": "0x22b1c8c1227a00000",
  	"0xc18ab467feb5a0aadfff91230ff056464d78d800": "0x6c6b935b8bbd400000",
  	"0xc1950543554d8a713003f662bb612c10ad4cdf21": "0xfc936392801c0000",
  	"0xc1a41a5a27199226e4c7eb198b031b59196f9842": "0xa5aa85009e39c0000",
  	"0xc1b2a0fb9cad45cd699192cd27540b88d3384279": "0x1b1ae4d6e2ef500000",
  	"0xc1b2aa8cb2bf62cdc13a47ecc4657facaa995f98": "0x363793fa96e6a68000",
  	"0xc1b500011cfba95d7cd636e95e6cbf6167464b25": "0xad78ebc5ac6200000",
  	"0xc1b9a5704d351cfe983f79abeec3dbbbae3bb629": "0x1158e460913d00000",
  	"0xc1cbd2e2332a524cf219b10d871ccc20af1fb0fa": "0x3635c9adc5dea00000",
  	"0xc1cdc601f89c0428b31302d187e0dc08ad7d1c57": "0x14542ba12a337c00000",
  	"0xc1d4af38e9ba799040894849b8a8219375f1ac78": "0x43c33c1937564800000",
  	"0xc1e1409ca52c25435134d006c2a6a8542dfb7273": "0x1dd1e4bd8d1ee0000",
  	"0xc1eba5684aa1b24cba63150263b7a9131aeec28d": "0x1158e460913d00000",
  	"0xc1ec81dd123d4b7c2dd9b4d438a7072c11dc874c": "0x6c6b935b8bbd400000",
  	"0xc1f39bd35dd9cec337b96f47c677818160df37b7": "0x1158e460913d00000",
  	"0xc1ffad07db96138c4b2a530ec1c7de29b8a0592c": "0xf43fc2c04ee00000",
  	"0xc21fa6643a1f14c02996ad7144b75926e87ecb4b": "0x43c33c1937564800000",
  	"0xc2340a4ca94c9678b7494c3c852528ede5ee529f": "0x2a36b05a3fd7c8000",
  	"0xc239abdfae3e9af5457f52ed2b91fd0ab4d9c700": "0x6c6b935b8bbd400000",
  	"0xc23b2f921ce4a37a259ee4ad8b2158d15d664f59": "0x1608995e8bd3f8000",
  	"0xc24399b4bf86f7338fbf645e3b22b0e0b7973912": "0x6c6b935b8bbd400000",
  	"0xc24ccebc2344cce56417fb684cf81613f0f4b9bd": "0x54069233bf7f780000",
  	"0xc25266c7676632f13ef29be455ed948add567792": "0x487a9a304539440000",
  	"0xc25cf826550c8eaf10af2234fef904ddb95213be": "0x3635c9adc5dea00000",
  	"0xc2663f8145dbfec6c646fc5c49961345de1c9f11": "0x2567ac70392b880000",
  	"0xc270456885342b640b4cfc1b520e1a544ee0d571": "0x62a992e53a0af00000",
  	"0xc27376f45d21e15ede3b26f2655fcee02ccc0f2a": "0x1158e460913d00000",
  	"0xc2779771f0536d79a8708f6931abc44b3035e999": "0x43c4f8300dcb3480000",
  	"0xc27f4e08099d8cf39ee11601838ef9fc06d7fc41": "0x61093d7c2c6d380000",
  	"0xc282e6993fbe7a912ea047153ffd9274270e285b": "0x7960b331247638000",
  	"0xc2836188d9a29253e0cbda6571b058c289a0bb32": "0x6c6b935b8bbd400000",
  	"0xc2aa74847e86edfdd3f3db22f8a2152feee5b7f7": "0x6f118886b784a20000",
  	"0xc2b2cbe65bc6c2ee7a3c75b2e47c189c062e8d8b": "0x43c33c1937564800000",
  	"0xc2bae4a233c2d85724f0dabebda0249d833e37d3": "0x10f0cf064dd59200000",
  	"0xc2c13e72d268e7150dc799e7c6cf03c88954ced7": "0x25f273933db5700000",
  	"0xc2cb1ada5da9a0423873814793f16144ef36b2f3": "0x48557e3b7017df0000",
  	"0xc2d1778ef6ee5fe488c145f3586b6ebbe3fbb445": "0x3e1ff1e03b55a80000",
  	"0xc2d9eedbc9019263d9d16cc5ae072d1d3dd9db03": "0x43c33c1937564800000",
  	"0xc2e0584a71348cc314b73b2029b6230b92dbb116": "0x6c6b935b8bbd400000",
  	"0xc2e2d498f70dcd0859e50b023a710a6d4b2133bd": "0x383911f00cbce10000",
  	"0xc2ed5ffdd1add855a2692fe062b5d618742360d4": "0x410d586a20a4c00000",
  	"0xc2ee91d3ef58c9d1a589844ea1ae3125d6c5ba69": "0x34957444b840e80000",
  	"0xc2fafdd30acb6d6706e9293cb02641f9edbe07b5": "0x5100860b430f480000",
  	"0xc2fd0bf7c725ef3e047e5ae1c29fe18f12a7299c": "0x487a9a304539440000",
  	"0xc2fe7d75731f636dcd09dbda0671393ba0c82a7d": "0x77432217e683600000",
  	"0xc3107a9af3322d5238df0132419131629539577d": "0x1ab4e464d414310000",
  	"0xc3110be01dc9734cfc6e1ce07f87d77d1345b7e1": "0x10f0ce949e00f930000",
  	"0xc32038ca52aee19745be5c31fcdc54148bb2c4d0": "0x2b5aad72c65200000",
  	"0xc325c352801ba883b3226c5feb0df9eae2d6e653": "0xd5967be4fc3f100000",
  	"0xc32ec7e42ad16ce3e2555ad4c54306eda0b26758": "0x6c6b935b8bbd400000",
  	"0xc332df50b13c013490a5d7c75dbfa366da87b6d6": "0xd8d726b7177a800000",
  	"0xc33acdb3ba1aab27507b86b15d67faf91ecf6293": "0x6c6b935b8bbd400000",
  	"0xc33ece935a8f4ef938ea7e1bac87cb925d8490ca": "0x7038c16781f78480000",
  	"0xc340f9b91c26728c31d121d5d6fc3bb56d3d8624": "0x6c6b935b8bbd400000",
  	"0xc346cb1fbce2ab285d8e5401f42dd7234d37e86d": "0x486cb9799191e0000",
  	"0xc3483d6e88ac1f4ae73cc4408d6c03abe0e49dca": "0x39992648a23c8a00000",
  	"0xc348fc5a461323b57be303cb89361b991913df28": "0x152d02c7e14af6800000",
  	"0xc34e3ba1322ed0571183a24f94204ee49c186641": "0x327afefa4a7bc0000",
  	"0xc35b95a2a3737cb8f0f596b34524872bd30da234": "0x198be85235e2d500000",
  	"0xc3631c7698b6c5111989bf452727b3f9395a6dea": "0x243275896641dbe0000",
  	"0xc36c0b63bfd75c2f8efb060883d868cccd6cbdb4": "0xa2a15d09519be00000",
  	"0xc3756bcdcc7eec74ed896adfc335275930266e08": "0x14542ba12a337c00000",
  	"0xc384ac6ee27c39e2f278c220bdfa5baed626d9d3": "0x2086ac351052600000",
  	"0xc3a046e3d2b2bf681488826e32d9c061518cfe8c": "0x8cf23f909c0fa00000",
  	"0xc3a9226ae275df2cab312b911040634a9c9c9ef6": "0xd8d726b7177a800000",
  	"0xc3b928a76fad6578f04f0555e63952cd21d1520a": "0x6c6b935b8bbd400000",
  	"0xc3c2297329a6fd99117e54fc6af379b4d556547e": "0x14542ba12a337c00000",
  	"0xc3c3c2510d678020485a63735d1307ec4ca6302b": "0x3635c9adc5dea00000",
  	"0xc3cb6b36af443f2c6e258b4a39553a818747811f": "0x57473d05dabae80000",
  	"0xc3db5657bb72f10d58f231fddf11980aff678693": "0x14061b9d77a5e980000",
  	"0xc3db9fb6f46c480af34465d79753b4e2b74a67ce": "0x43c33c1937564800000",
  	"0xc3dd58903886303b928625257ae1a013d71ae216": "0x6c6b935b8bbd400000",
  	"0xc3e0471c64ff35fa5232cc3121d1d38d1a0fb7de": "0x6c6b935b8bbd400000",
  	"0xc3e20c96df8d4e38f50b265a98a906d61bc51a71": "0x6c6b935b8bbd400000",
  	"0xc3e387b03ce95ccfd7fa51dd840183bc43532809": "0x6c6b935b8bbd400000",
  	"0xc3f8f67295a5cd049364d05d23502623a3e52e84": "0x14542ba12a337c00000",
  	"0xc401c427cccff10decb864202f36f5808322a0a8": "0xb47b51a69cd4020000",
  	"0xc4088c025f3e85013f5439fb3440a17301e544fe": "0x7e09db4d9f3f340000",
  	"0xc41461a3cfbd32c9865555a4813137c076312360": "0x3635c6204739d98000",
  	"0xc420388fbee84ad656dd68cdc1fbaa9392780b34": "0xa2dca63aaf4c58000",
  	"0xc42250b0fe42e6b7dcd5c890a6f0c88f5f5fb574": "0x81ee4825359840000",
  	"0xc42d6aeb710e3a50bfb44d6c31092969a11aa7f3": "0x82263cafd8cea0000",
  	"0xc440c7ca2f964b6972ef664a2261dde892619d9c": "0x43c33c1937564800000",
  	"0xc44bdec8c36c5c68baa2ddf1d431693229726c43": "0x152d02c7e14af6800000",
  	"0xc44f4ab5bc60397c737eb0683391b633f83c48fa": "0x3635c9adc5dea00000",
  	"0xc452e0e4b3d6ae06b836f032ca09db409ddfe0fb": "0x2b5e3af16b18800000",
  	"0xc45a1ca1036b95004187cdac44a36e33a94ab5c3": "0xdd00f720301880000",
  	"0xc45d47ab0c9aa98a5bd62d16223ea2471b121ca4": "0x202e68f2c2aee40000",
  	"0xc4681e73bb0e32f6b726204831ff69baa4877e32": "0x62a992e53a0af00000",
  	"0xc46bbdef76d4ca60d316c07f5d1a780e3b165f7e": "0x6c6b935b8bbd400000",
  	"0xc47d610b399250f70ecf1389bab6292c91264f23": "0xfa7e7b5df3cd00000",
  	"0xc4803bb407c762f90b7596e6fde194931e769590": "0xd8d726b7177a800000",
  	"0xc48651c1d9c16bff4c9554886c3f3f26431f6f68": "0x23ab9599c43f080000",
  	"0xc489c83ffbb0252ac0dbe3521217630e0f491f14": "0xd8d726b7177a800000",
  	"0xc48b693cacefdbd6cb5d7895a42e3196327e261c": "0x3635c9adc5dea00000",
  	"0xc493489e56c3bdd829007dc2f956412906f76bfa": "0x2a791488e71540000",
  	"0xc496cbb0459a6a01600fc589a55a32b454217f9d": "0xeda838c4929080000",
  	"0xc49cfaa967f3afbf55031061fc4cef88f85da584": "0x6c6b935b8bbd400000",
  	"0xc4b6e5f09cc1b90df07803ce3d4d13766a9c46f4": "0x14542ba12a337c00000",
  	"0xc4bec96308a20f90cab18399c493fd3d065abf45": "0x2f6f10780d22cc00000",
  	"0xc4c01afc3e0f045221da1284d7878574442fb9ac": "0x1923c688b73ab040000",
  	"0xc4c15318d370c73318cc18bdd466dbaa4c6603bf": "0x11164759ffb320000",
  	"0xc4c6cb723dd7afa7eb535615e53f3cef14f18118": "0x6c6b8fce0d18798000",
  	"0xc4cc45a2b63c27c0b4429e58cd42da59be739bd6": "0x3635c9adc5dea00000",
  	"0xc4cf930e5d116ab8d13b9f9a7ec4ab5003a6abde": "0x1158e460913d000000",
  	"0xc4d916574e68c49f7ef9d3d82d1638b2b7ee0985": "0x55a6e79ccd1d300000",
  	"0xc4dac5a8a0264fbc1055391c509cc3ee21a6e04c": "0x1606b7fa039ce740000",
  	"0xc4dd048bfb840e2bc85cb53fcb75abc443c7e90f": "0xc971dc07c9c7900000",
  	"0xc4f2913b265c430fa1ab8adf26c333fc1d9b66f2": "0x1158e460913d00000",
  	"0xc4f7b13ac6d4eb4db3d4e6a252af8a07bd5957da": "0xad78ebc5ac6200000",
  	"0xc4f7d2e2e22084c44f70feaab6c32105f3da376f": "0x6acb3df27e1f880000",
  	"0xc4ff6fbb1f09bd9e102ba033d636ac1c4c0f5304": "0x3635c9adc5dea00000",
  	"0xc4ffadaaf2823fbea7bff702021bffc4853eb5c9": "0x24a19c1bd6f128000",
  	"0xc500b720734ed22938d78c5e48b2ba9367a575ba": "0x7129e1cdf373ee00000",
  	"0xc50fe415a641b0856c4e75bf960515441afa358d": "0x6c6b935b8bbd400000",
  	"0xc5134cfbb1df7a20b0ed7057622eeed280947dad": "0xcdff97fabcb4600000",
  	"0xc517d0315c878813c717e18cafa1eab2654e01da": "0x21e19e0c9bab2400000",
  	"0xc518799a5925576213e21896e0539abb85b05ae3": "0x3635c9adc5dea00000",
  	"0xc522e20fbf04ed7f6b05a37b4718d6fce0142e1a": "0xd8d726b7177a800000",
  	"0xc524086d46c8112b128b2faf6f7c7d8160a8386c": "0x15af1d78b58c400000",
  	"0xc52d1a0c73c2a1be84915185f8b34faa0adf1de3": "0x4be4eab3fa0fa68000",
  	"0xc53594c7cfb2a08f284cc9d7a63bbdfc0b319732": "0xa6b2328ff3a62c00000",
  	"0xc5374928cdf193705443b14cc20da423473cd9cf": "0x77d10509bb3af8000",
  	"0xc538a0ff282aaa5f4b75cfb62c70037ee67d4fb5": "0x6c6b935b8bbd400000",
  	"0xc53b50fd3b2b72bc6c430baf194a515585d3986d": "0x1158e460913d00000",
  	"0xc53d79f7cb9b70952fd30fce58d54b9f0b59f647": "0x113e2d6744345f80000",
  	"0xc549df83c6f65eec0f1dc9a0934a5c5f3a50fd88": "0x9dc05cce28c2b80000",
  	"0xc55005a6c37e8ca7e543ce259973a3cace961a4a": "0x6c6b935b8bbd400000",
  	"0xc555b93156f09101233c6f7cf6eb3c4f196d3346": "0xa2a15d09519be00000",
  	"0xc55a6b4761fd11e8c85f15174d74767cd8bd9a68": "0x73f75d1a085ba0000",
  	"0xc56e6b62ba6e40e52aab167d21df025d0055754b": "0x6c6b935b8bbd400000",
  	"0xc573e841fa08174a208b060ccb7b4c0d7697127f": "0x243d4d18229ca20000",
  	"0xc57612de91110c482e6f505bcd23f3c5047d1d61": "0xc2127af858da700000",
  	"0xc5843399d150066bf7979c34ba294620368ad7c0": "0xad78ebc5ac6200000",
  	"0xc58b9cc61dedbb98c33f224d271f0e228b583433": "0xd255d112e103a00000",
  	"0xc58f62fee9711e6a05dc0910b618420aa127f288": "0xd7c198710e66b00000",
  	"0xc593b546b7698710a205ad468b2c13152219a342": "0x54069233bf7f780000",
  	"0xc593d6e37d14b566643ac4135f243caa0787c182": "0x28a857425466f800000",
  	"0xc5a3b98e4593fea0b38c4f455a5065f051a2f815": "0x44cf468af25bf770000",
  	"0xc5a48a8500f9b4e22f0eb16c6f4649687674267d": "0x2c0ec50385043e8000",
  	"0xc5a629a3962552cb8eded889636aafbd0c18ce65": "0x21e19e0c9bab2400000",
  	"0xc5ae86b0c6c7e3900f1368105c56537faf8d743e": "0xa31062beeed700000",
  	"0xc5b009baeaf788a276bd35813ad65b400b849f3b": "0x3635c9adc5dea00000",
  	"0xc5b56cd234267c28e89c6f6b2266b086a12f970c": "0xd8d726b7177a800000",
  	"0xc5c6a4998a33feb764437a8be929a73ba34a0764": "0xa968163f0a57b400000",
  	"0xc5c73d61cce7c8fe4c8fce29f39092cd193e0fff": "0x1b1ae4d6e2ef5000000",
  	"0xc5c7590b5621ecf8358588de9b6890f2626143f1": "0xa2a15d09519be00000",
  	"0xc5cdcee0e85d117dabbf536a3f4069bf443f54e7": "0x6ac5c62d9486070000",
  	"0xc5d48ca2db2f85d8c555cb0e9cfe826936783f9e": "0xad78ebc5ac6200000",
  	"0xc5de1203d3cc2cea31c82ee2de5916880799eafd": "0x10f0cf064dd59200000",
  	"0xc5e488cf2b5677933971f64cb8202dd05752a2c0": "0x3635c9adc5dea00000",
  	"0xc5e812f76f15f2e1f2f9bc4823483c8804636f67": "0x3f514193abb840000",
  	"0xc5e9939334f1252ed2ba26814487dfd2982b3128": "0x3cb71f51fc5580000",
  	"0xc5eb42295e9cadeaf2af12dede8a8d53c579c469": "0xcf152640c5c8300000",
  	"0xc5edbbd2ca0357654ad0ea4793f8c5cecd30e254": "0x14542ba12a337c00000",
  	"0xc5f64babb7033142f20e46d7aa6201ed86f67103": "0x6c6b935b8bbd400000",
  	"0xc5f687717246da8a200d20e5e9bcac60b67f3861": "0x18d993f34aef10000",
  	"0xc6045b3c350b4ce9ca0c6b754fb41a69b97e9900": "0x3224f42723d4540000",
  	"0xc60b04654e003b4683041f1cbd6bc38fda7cdbd6": "0x6c6b935b8bbd400000",
  	"0xc61446b754c24e3b1642d9e51765b4d3e46b34b6": "0x6c6b935b8bbd400000",
  	"0xc618521321abaf5b26513a4a9528086f220adc6f": "0x176b344f2a78c0000",
  	"0xc6234657a807384126f8968ca1708bb07baa493c": "0x1158e460913d00000",
  	"0xc625f8c98d27a09a1bcabd5128b1c2a94856af30": "0xad78ebc5ac6200000",
  	"0xc6355ec4768c70a49af69513cd83a5bca7e3b9cd": "0x14542ba12a337c00000",
  	"0xc63ac417992e9f9b60386ed953e6d7dff2b090e8": "0xd8d8583fa2d52f0000",
  	"0xc63cd7882118b8a91e074d4c8f4ba91851303b9a": "0xe18398e7601900000",
  	"0xc652871d192422c6bc235fa063b44a7e1d43e385": "0x8670e9ec6598c0000",
  	"0xc667441e7f29799aba616451d53b3f489f9e0f48": "0x2f29ace68addd800000",
  	"0xc66ae4cee87fb3353219f77f1d6486c580280332": "0x19a16b06ff8cb0000",
  	"0xc674f28c8afd073f8b799691b2f0584df942e844": "0x6c6b935b8bbd400000",
  	"0xc697b70477cab42e2b8b266681f4ae7375bb2541": "0x12e5732baba5c980000",
  	"0xc69b855539ce1b04714728eec25a37f367951de7": "0x6c6b935b8bbd400000",
  	"0xc69be440134d6280980144a9f64d84748a37f349": "0x26c29e47c4844c0000",
  	"0xc69d663c8d60908391c8d236191533fdf7775613": "0x1a4aba225c20740000",
  	"0xc6a286e065c85f3af74812ed8bd3a8ce5d25e21d": "0xfc936392801c0000",
  	"0xc6a30ef5bb3320f40dc5e981230d52ae3ac19322": "0x9ddc1e3b901180000",
  	"0xc6ae287ddbe1149ba16ddcca4fe06aa2eaa988a9": "0x15af1d78b58c400000",
  	"0xc6c7c191379897dd9c9d9a33839c4a5f62c0890d": "0xd8d854b22430688000",
  	"0xc6cd68ec35362c5ad84c82ad4edc232125912d99": "0x5e0549c9632e1d80000",
  	"0xc6d8954e8f3fc533d2d230ff025cb4dce14f3426": "0x15af1d78b58c400000",
  	"0xc6dbdb9efd5ec1b3786e0671eb2279b253f215ed": "0x3635c9adc5dea00000",
  	"0xc6df2075ebd240d44869c2be6bdf82e63d4ef1f5": "0x1158e460913d00000",
  	"0xc6e2f5af979a03fd723a1b6efa728318cf9c1800": "0x243d4d18229ca20000",
  	"0xc6e324beeb5b36765ecd464260f7f26006c5c62e": "0x6c6b935b8bbd400000",
  	"0xc6e4cc0c7283fc1c85bc4813effaaf72b49823c0": "0xf031ec9c87dd30000",
  	"0xc6ee35934229693529dc41d9bb71a2496658b88e": "0x42bf06b78ed3b500000",
  	"0xc6fb1ee37417d080a0d048923bdabab095d077c6": "0xad78ebc5ac6200000",
  	"0xc70527d444c490e9fc3f5cc44e66eb4f306b380f": "0xd8d726b7177a800000",
  	"0xc70d856d621ec145303c0a6400cd17bbd6f5eaf7": "0x1158e460913d00000",
  	"0xc70fa45576bf9c865f983893002c414926f61029": "0x15b4aa8e9702680000",
  	"0xc71145e529c7a714e67903ee6206e4c3042b6727": "0x4d853c8f8908980000",
  	"0xc71b2a3d7135d2a85fb5a571dcbe695e13fc43cd": "0x3635c9adc5dea00000",
  	"0xc71f1d75873f33dcb2dd4b3987a12d0791a5ce27": "0x3708baed3d68900000",
  	"0xc71f92a3a54a7b8c2f5ea44305fccb84eee23148": "0x2b59ca131d2060000",
  	"0xc721b2a7aa44c21298e85039d00e2e460e670b9c": "0x7a1fe160277000000",
  	"0xc72cb301258e91bc08998a805dd192f25c2f9a35": "0x2009c5c8bf6fdc0000",
  	"0xc7368b9709a5c1b51c0adf187a65df14e12b7dba": "0x2026fc77f03e5ae8000",
  	"0xc739259e7f85f2659bef5f609ed86b3d596c201e": "0xad78ebc5ac6200000",
  	"0xc73e2112282215dc0762f32b7e807dcd1a7aae3e": "0x1760cbc623bb3500000",
  	"0xc749668042e71123a648975e08ed6382f83e05e2": "0x2f6f10780d22cc00000",
  	"0xc74a3995f807de1db01a2eb9c62e97d0548f696f": "0x3635c9adc5dea00000",
  	"0xc7506c1019121ff08a2c8c1591a65eb4bdfb4a3f": "0x2086ac351052600000",
  	"0xc75c37ce2da06bbc40081159c6ba0f976e3993b1": "0x3a7923151ecf580000",
  	"0xc75d2259306aec7df022768c69899a652185dbc4": "0xd8d726b7177a800000",
  	"0xc760971bbc181c6a7cf77441f24247d19ce9b4cf": "0x6c6b935b8bbd400000",
  	"0xc76130c73cb9210238025c9df95d0be54ac67fbe": "0x5150ae84a8cdf00000",
  	"0xc765e00476810947816af142d46d2ee7bca8cc4f": "0x1b1ae4d6e2ef500000",
  	"0xc7675e5647b9d8daf4d3dff1e552f6b07154ac38": "0x9c2007651b2500000",
  	"0xc77b01a6e911fa988d01a3ab33646beef9c138f3": "0x271b6fa5dbe6cc0000",
  	"0xc7837ad0a0bf14186937ace06c5546a36aa54f46": "0xd8d726b7177a800000",
  	"0xc79806032bc7d828f19ac6a640c68e3d820fa442": "0x1158e460913d00000",
  	"0xc799e34e88ff88be7de28e15e4f2a63d0b33c4cb": "0xad78ebc5ac6200000",
  	"0xc79d5062c796dd7761f1f13e558d73a59f82f38b": "0x1b1ae4d6e2ef5000000",
  	"0xc7a018f0968a51d1f6603c5c49dc545bcb0ff293": "0xd8d726b7177a800000",
  	"0xc7aff91929797489555a2ff1d14d5c695a108355": "0x3635c9adc5dea00000",
  	"0xc7b1c83e63203f9547263ef6282e7da33b6ed659": "0xfc936392801c0000",
  	"0xc7b39b060451000ca1049ba154bcfa00ff8af262": "0x152d02c7e14af6800000",
  	"0xc7bf17c4c11f98941f507e77084fffbd2dbd3db5": "0x3635c9adc5dea00000",
  	"0xc7bf2ed1ed312940ee6aded1516e268e4a604856": "0x14542ba12a337c00000",
  	"0xc7d44fe32c7f8cd5f1a97427b6cd3afc9e45023e": "0x55a6e79ccd1d300000",
  	"0xc7d5c7054081e918ec687b5ab36e973d18132935": "0x9ddc1e3b901180000",
  	"0xc7de5e8eafb5f62b1a0af2195cf793c7894c9268": "0x3635c9adc5dea00000",
  	"0xc7e330cd0c890ac99fe771fcc7e7b009b7413d8a": "0xd8d726b7177a800000",
  	"0xc7eac31abce6d5f1dea42202b6a674153db47a29": "0x2009c5c8bf6fdc0000",
  	"0xc7ec62b804b1f69b1e3070b5d362c62fb309b070": "0x2c46bf5416066110000",
  	"0xc7f72bb758016b374714d4899bce22b4aec70a31": "0x3a26c9478f5e2d0000",
  	"0xc80b36d1beafba5fcc644d60ac6e46ed2927e7dc": "0xb98bc829a6f90000",
  	"0xc811c2e9aa1ac3462eba5e88fcb5120e9f6e2ca2": "0x4be6d887bd876e0000",
  	"0xc817df1b91faf30fe3251571727c9711b45d8f06": "0x6c6acc67d7b1d40000",
  	"0xc81fb7d20fd2800192f0aac198d6d6a37d3fcb7d": "0xe1149331c2dde0000",
  	"0xc820c711f07705273807aaaa6de44d0e4b48be2e": "0x8670e9ec6598c0000",
  	"0xc8231ba5a411a13e222b29bfc1083f763158f226": "0x3637096c4bcc690000",
  	"0xc836e24a6fcf29943b3608e662290a215f6529ea": "0xfd45064eaee100000",
  	"0xc83ba6dd9549be1d3287a5a654d106c34c6b5da2": "0x17b7883c06916600000",
  	"0xc83e9d6a58253beebeb793e6f28b054a58491b74": "0xf46c2b6f5a9140000",
  	"0xc841884fa4785fb773b28e9715fae99a5134305d": "0x6c6b935b8bbd400000",
  	"0xc84d9bea0a7b9f140220fd8b9097cfbfd5edf564": "0x6ab9ec291ad7d8000",
  	"0xc852428d2b586497acd30c56aa13fb5582f84402": "0x3342d60dff19600000",
  	"0xc853215b9b9f2d2cd0741e585e987b5fb80c212e": "0x54069233bf7f780000",
  	"0xc85325eab2a59b3ed863c86a5f2906a04229ffa9": "0x193d7f7d253de00000",
  	"0xc85ef27d820403805fc9ed259fff64acb8d6346a": "0x6c6b935b8bbd400000",
  	"0xc8616b4ec09128cdff39d6e4b9ac86eec471d5f2": "0x10d3aa536e2940000",
  	"0xc86190904b8d079ec010e462cbffc90834ffaa5c": "0x22385a827e815500000",
  	"0xc8710d7e8b5a3bd69a42fe0fa8b87c357fddcdc8": "0xd8d726b7177a800000",
  	"0xc87352dba582ee2066b9c002a962e003134f78b1": "0x1b1ae4d6e2ef500000",
  	"0xc87c77e3c24adecdcd1038a38b56e18dead3b702": "0x1dd0c885f9a0d800000",
  	"0xc87d3ae3d88704d9ab0009dcc1a0067131f8ba3c": "0x6ac5c62d9486070000",
  	"0xc8814e34523e38e1f927a7dce8466a447a093603": "0x21e19e0c9bab2400000",
  	"0xc88255eddcf521c6f81d97f5a42181c9073d4ef1": "0xfc39044d00a2a8000",
  	"0xc885a18aabf4541b7b7b7ecd30f6fae6869d9569": "0x6c6b935b8bbd400000",
  	"0xc88ca1e6e5f4d558d13780f488f10d4ad3130d34": "0x54069233bf7f780000",
  	"0xc88eec54d305c928cc2848c2fee23531acb96d49": "0x6c6ad382d4fb610000",
  	"0xc89cf504b9f3f835181fd8424f5ccbc8e1bddf7d": "0x21e19e0c9bab2400000",
  	"0xc8a2c4e59e1c7fc54805580438aed3e44afdf00e": "0x2629f66e0c5300000",
  	"0xc8aa49e3809f0899f28ab57e6743709d58419033": "0x2fb474098f67c00000",
  	"0xc8ab1a3cf46cb8b064df2e222d39607394203277": "0x6c6b935b8bbd400000",
  	"0xc8b1850525d946f2ae84f317b15188c536a5dc86": "0x918ddc3a42a3d40000",
  	"0xc8d4e1599d03b79809e0130a8dc38408f05e8cd3": "0x9fad06241279160000",
  	"0xc8dd27f16bf22450f5771b9fe4ed4ffcb30936f4": "0xaadec983fcff40000",
  	"0xc8de7a564c7f4012a6f6d10fd08f47890fbf07d4": "0x1043561a8829300000",
  	"0xc8e2adeb545e499d982c0c117363ceb489c5b11f": "0x35659ef93f0fc40000",
  	"0xc8e558a3c5697e6fb23a2594c880b7a1b68f9860": "0x21e19e0c9bab2400000",
  	"0xc8f2b320e6dfd70906c597bad2f9501312c78259": "0x51934b8b3a57d00000",
  	"0xc90300cb1d4077e6a6d7e169a460468cf4a492d7": "0x6c6b935b8bbd400000",
  	"0xc90c3765156bca8e4897ab802419153cbe5225a9": "0xad78ebc5ac6200000",
  	"0xc910a970556c9716ea53af66ddef93143124913d": "0x55a6e79ccd1d300000",
  	"0xc9127b7f6629ee13fc3f60bc2f4467a20745a762": "0x37c9aa4e7ce421d8000",
  	"0xc91bb562e42bd46130e2d3ae4652b6a4eb86bc0f": "0x1d460162f516f00000",
  	"0xc9308879056dfe138ef8208f79a915c6bc7e70a8": "0x21e19e0c9bab2400000",
  	"0xc934becaf71f225f8b4a4bf7b197f4ac9630345c": "0x43c33c1937564800000",
  	"0xc93fbde8d46d2bcc0fa9b33bd8ba7f8042125565": "0x4be4e7267b6ae00000",
  	"0xc94089553ae4c22ca09fbc98f57075cf2ec59504": "0xd8d726b7177a800000",
  	"0xc94110e71afe578aa218e4fc286403b0330ace8d": "0x6c6b935b8bbd400000",
  	"0xc946d5acc1346eba0a7279a0ac1d465c996d827e": "0x3783d545fdf0aa40000",
  	"0xc94a28fb3230a9ddfa964e770f2ce3c253a7be4f": "0xad78ebc5ac6200000",
  	"0xc94a585203da7bbafd93e15884e660d4b1ead854": "0x17b7883c06916600000",
  	"0xc94f7c35c027d47df8ef4f9df85a9248a17dd23b": "0x19f8e7559924c0000",
  	"0xc951900c341abbb3bafbf7ee2029377071dbc36a": "0x11c25d004d01f80000",
  	"0xc953f934c0eb2d0f144bdab00483fd8194865ce7": "0x6c6b935b8bbd400000",
  	"0xc96626728aaa4c4fb3d31c26df3af310081710d1": "0xb50fcfafebecb00000",
  	"0xc96751656c0a8ef4357b7344322134b983504aca": "0x6c6b935b8bbd400000",
  	"0xc98048687f2bfcc9bd90ed18736c57edd352b65d": "0x3635c9adc5dea00000",
  	"0xc981d312d287d558871edd973abb76b979e5c35e": "0x6acb3df27e1f880000",
  	"0xc982586d63b0d74c201b1af8418372e30c7616be": "0x56bc75e2d63100000",
  	"0xc989434f825aaf9c552f685eba7c11db4a5fc73a": "0x1b28c58d9696b40000",
  	"0xc989eec307e8839b9d7237cfda08822962abe487": "0x15af1d78b58c400000",
  	"0xc992be59c6721caf4e028f9e8f05c25c55515bd4": "0x1158e460913d00000",
  	"0xc9957ba94c1b29e5277ec36622704904c63dc023": "0x683efc6782642c0000",
  	"0xc99a9cd6c9c1be3534eecd92ecc22f5c38e9515b": "0x105593b3a169d770000",
  	"0xc9ac01c3fb0929033f0ccc7e1acfeaaba7945d47": "0x2a36a9e9ca4d2038000",
  	"0xc9b698e898d20d4d4f408e4e4d061922aa856307": "0x22b1c8c1227a00000",
  	"0xc9b6b686111691ee6aa197c7231a88dc60bd295d": "0x1b1ae4d6e2ef500000",
  	"0xc9c7ac0bdd9342b5ead4360923f68c72a6ba633a": "0x1b1ae4d6e2ef500000",
  	"0xc9c80dc12e7bab86e949d01e4c3ed35f2b9bba5f": "0x6c6b935b8bbd400000",
  	"0xc9d76446d5aadff80b68b91b08cd9bc8f5551ac1": "0x26b4bd9110dce80000",
  	"0xc9dcbb056f4db7d9da39936202c5bd8230b3b477": "0x43c33c1937564800000",
  	"0xc9e02608066828848aeb28c73672a12925181f4d": "0x1b1b6bd7af64c70000",
  	"0xca0432cb157b5179f02ebba5c9d1b54fec4d88ca": "0x3635c9adc5dea00000",
  	"0xca122cf0f2948896b74843f49afed0ba1618eed7": "0x1e5b8fa8fe2ac00000",
  	"0xca22cda3606da5cad013b8074706d7e9e721a50c": "0x17181c6fa3981940000",
  	"0xca23f62dff0d6460036c62e840aec5577e0befd2": "0x7a1fe160277000000",
  	"0xca25ff34934c1942e22a4e7bd56f14021a1af088": "0xaadec983fcff40000",
  	"0xca373fe3c906b8c6559ee49ccd07f37cd4fb5266": "0x61093d7c2c6d380000",
  	"0xca41ccac30172052d522cd2f2f957d248153409f": "0x6acb3df27e1f880000",
  	"0xca4288014eddc5632f5facb5e38517a8f8bc5d98": "0x126e72a69a50d00000",
  	"0xca428863a5ca30369892d612183ef9fb1a04bcea": "0x52663ccab1e1c00000",
  	"0xca49a5f58adbefae23ee59eea241cf0482622eaa": "0x4d853c8f8908980000",
  	"0xca4ca9e4779d530ecbacd47e6a8058cfde65d98f": "0x2b5e3af16b18800000",
  	"0xca657ec06fe5bc09cf23e52af7f80cc3689e6ede": "0x30ca024f987b900000",
  	"0xca66b2280fa282c5b67631ce552b62ee55ad8474": "0x6ac422f53492880000",
  	"0xca6c818befd251361e02744068be99d8aa60b84a": "0x14542ba12a337c00000",
  	"0xca70f4ddbf069d2143bd6bbc7f696b52789b32e7": "0xa2a15d09519be00000",
  	"0xca747576446a4c8f30b08340fee198de63ec92cf": "0x17c8e1206722a300000",
  	"0xca7ba3ff536c7e5f0e153800bd383db8312998e0": "0x931ac3d6bb2400000",
  	"0xca8276c477b4a07b80107b843594189607b53bec": "0x14542ba12a337c00000",
  	"0xca8409083e01b397cf12928a05b68455ce6201df": "0x56bc75e2d631000000",
  	"0xca98c7988efa08e925ef9c9945520326e9f43b99": "0xd8d726b7177a800000",
  	"0xca9a042a6a806ffc92179500d24429e8ab528117": "0x3ba1910bf341b00000",
  	"0xca9dec02841adf5cc920576a5187edd2bd434a18": "0x1b1ae4d6e2ef500000",
  	"0xca9faa17542fafbb388eab21bc4c94e8a7b34788": "0x6c6b8fce0d18798000",
  	"0xcaaa68ee6cdf0d34454a769b0da148a1faaa1865": "0x1872e1de7fe52c00000",
  	"0xcaad9dc20d589ce428d8fda3a9d53a607b7988b5": "0xd8d726b7177a800000",
  	"0xcab0d32cf3767fa6b3537c84328baa9f50458136": "0x1e5b8fa8fe2ac000000",
  	"0xcab9a301e6bd46e940355028eccd40ce4d5a1ac3": "0x15af1d78b58c400000",
  	"0xcab9a97ada065c87816e6860a8f1426fe6b3d775": "0x3635c9adc5dea00000",
  	"0xcabab6274ed15089737e287be878b757934864e2": "0x43c33c1937564800000",
  	"0xcabdaf354f4720a466a764a528d60e3a482a393c": "0x3635c9adc5dea00000",
  	"0xcacb675e0996235404efafbb2ecb8152271b55e0": "0x25f273933db5700000",
  	"0xcad14f9ebba76680eb836b079c7f7baaf481ed6d": "0xcef3d7bd7d0340000",
  	"0xcae3a253bcb2cf4e13ba80c298ab0402da7c2aa0": "0x124bc0ddd92e5600000",
  	"0xcaef027b1ab504c73f41f2a10979b474f97e309f": "0xad78ebc5ac6200000",
  	"0xcaf4481d9db78dc4f25f7b4ac8bd3b1ca0106b31": "0x10f0cf064dd59200000",
  	"0xcafde855864c2598da3cafc05ad98df2898e8048": "0x300a8ed96ff4a940000",
  	"0xcb0dd7cf4e5d8661f6028943a4b9b75c914436a7": "0x1969368974c05b000000",
  	"0xcb1bb6f1da5eb10d4899f7e61d06c1b00fdfb52d": "0x384524cc70b7780000",
  	"0xcb3d766c983f192bcecac70f4ee03dd9ff714d51": "0x56bc75e2d63100000",
  	"0xcb42b44eb5fd60b5837e4f9eb47267523d1a229c": "0x2ee449550898e40000",
  	"0xcb47bd30cfa8ec5468aaa6a94642ced9c819c8d4": "0xd8d726b7177a800000",
  	"0xcb48fe8265d9af55eb7006bc335645b0a3a183be": "0xa2a15d09519be00000",
  	"0xcb4a914d2bb029f32e5fef5c234c4fec2d2dd577": "0x6194049f30f7200000",
  	"0xcb4abfc282aed76e5d57affda542c1f382fcacf4": "0x1b90f11c3183faa0000",
  	"0xcb4ad0c723da46ab56d526da0c1d25c73daff10a": "0x1ba5abf9e779380000",
  	"0xcb4bb1c623ba28dc42bdaaa6e74e1d2aa1256c2a": "0x6c6acc67d7b1d40000",
  	"0xcb50587412822304ebcba07dab3a0f09fffee486": "0x4a4491bd6dcd280000",
  	"0xcb58990bcd90cfbf6d8f0986f6fa600276b94e2d": "0x3634bf39ab98788000",
  	"0xcb68ae5abe02dcf8cbc5aa719c25814651af8b85": "0x1b1ae4d6e2ef500000",
  	"0xcb7479109b43b26657f4465f4d18c6f974be5f42": "0x62a992e53a0af00000",
  	"0xcb7d2b8089e9312cc9aeaa2773f35308ec6c2a7b": "0x21e19e0c9bab2400000",
  	"0xcb86edbc8bbb1f9131022be649565ebdb09e32a1": "0x6c6b935b8bbd400000",
  	"0xcb93199b9c90bc4915bd859e3d42866dc8c18749": "0xc90df07def78c0000",
  	"0xcb94e76febe208116733e76e805d48d112ec9fca": "0x3635c9adc5dea00000",
  	"0xcb9b5103e4ce89af4f64916150bff9eecb9faa5c": "0x1b1ae4d6e2ef500000",
  	"0xcba25c7a503cc8e0d04971ca05c762f9b762b48b": "0x1b1ae4d6e2ef500000",
  	"0xcba288cd3c1eb4d59ddb06a6421c14c345a47b24": "0xd8d726b7177a800000",
  	"0xcbb3189e4bd7f45f178b1c30c76e26314d4a4b0a": "0xffe0b677c65a98000",
  	"0xcbb7be17953f2ccc93e1bc99805bf45511434e4c": "0xaae5b9df56d2f200000",
  	"0xcbc04b4d8b82caf670996f160c362940d66fcf1a": "0x14542ba12a337c00000",
  	"0xcbde9734b8e6aa538c291d6d7facedb0f338f857": "0x6c6b935b8bbd400000",
  	"0xcbe1b948864d8474e765145858fca4550f784b92": "0x21e19e0c9bab2400000",
  	"0xcbe52fc533d7dd608c92a260b37c3f45deb4eb33": "0x3635c9adc5dea00000",
  	"0xcbe810fe0fecc964474a1db97728bc87e973fcbd": "0x21e19e0c9bab2400000",
  	"0xcbf16a0fe2745258cd52db2bf21954c975fc6a15": "0x1043561a8829300000",
  	"0xcbf37ff854a2f1ce53934494777892d3ec655782": "0x21e19e0c9bab2400000",
  	"0xcbfa6af6c283b046e2772c6063b0b21553c40106": "0x6c6b935b8bbd400000",
  	"0xcbfa76db04ce38fb205d37b8d377cf1380da0317": "0x4d853c8f8908980000",
  	"0xcc034985d3f28c2d39b1a34bced4d3b2b6ca234e": "0x9ddc1e3b901180000",
  	"0xcc043c4388d345f884c6855e71142a9f41fd6935": "0x1158e460913d00000",
  	"0xcc1d6ead01aada3e8dc7b95dca25df26eefa639d": "0x6c6b935b8bbd400000",
  	"0xcc2b5f448f3528d3fe41cc7d1fa9c0dc76f1b776": "0x340aad21b3b700000",
  	"0xcc2d04f0a4017189b340ca77198641dcf6456b91": "0xd5967be4fc3f100000",
  	"0xcc419fd9912b85135659e77a93bc3df182d45115": "0x21e19e0c9bab2400000",
  	"0xcc45fb3a555bad807b388a0357c855205f7c75e8": "0x2ee449550898e40000",
  	"0xcc48414d2ac4d42a5962f29eee4497092f431352": "0x8ba52e6fc45e40000",
  	"0xcc4a2f2cf86cf3e43375f360a4734691195f1490": "0x4915053bd129098000",
  	"0xcc4f0ff2aeb67d54ce3bc8c6510b9ae83e9d328b": "0x15af1d78b58c400000",
  	"0xcc4faac00be6628f92ef6b8cb1b1e76aac81fa18": "0xb22a2eab0f0fd0000",
  	"0xcc4feb72df98ff35a138e01761d1203f9b7edf0a": "0x17b7883c06916600000",
  	"0xcc606f511397a38fc7872bd3b0bd03c71bbd768b": "0x3635c9adc5dea00000",
  	"0xcc60f836acdef3548a1fefcca13ec6a937db44a0": "0x4b06dbbb40f4a0000",
  	"0xcc6c03bd603e09de54e9c4d5ac6d41cbce715724": "0x556f64c1fe7fa0000",
  	"0xcc6c2df00e86eca40f21ffda1a67a1690f477c65": "0xab4dcf399a3a600000",
  	"0xcc6d7b12061bc96d104d606d65ffa32b0036eb07": "0x21e19e0c9bab2400000",
  	"0xcc73dd356b4979b579b401d4cc7a31a268ddce5a": "0x1b1ae4d6e2ef500000",
  	"0xcc758d071d25a6320af68c5dc9c4f6955ba94520": "0x14542ba12a337c00000",
  	"0xcc7b0481cc32e6faef2386a07022bcb6d2c3b4fc": "0xab4dcf399a3a600000",
  	"0xcc943be1222cd1400a2399dd1b459445cf6d54a9": "0x2a740ae6536fc880000",
  	"0xcc9519d1f3985f6b255eaded12d5624a972721e1": "0x3635c9adc5dea00000",
  	"0xcc9ac715cd6f2610c52b58676456884297018b29": "0xb98bc829a6f90000",
  	"0xcca07bb794571d4acf041dad87f0d1ef3185b319": "0x6c6b935b8bbd400000",
  	"0xccabc6048a53464424fcf76eeb9e6e1801fa23d4": "0x2ab7b260ff3fd0000",
  	"0xccae0d3d852a7da3860f0636154c0a6ca31628d4": "0x5c6d12b6bc1a00000",
  	"0xccca24d8c56d6e2c07db086ec07e585be267ac8d": "0xad78ebc5ac6200000",
  	"0xccd521132d986cb96869842622a7dda26c3ed057": "0x6c6b935b8bbd400000",
  	"0xccf43975b76bfe735fec3cb7d4dd24f805ba0962": "0x340aad21b3b700000",
  	"0xccf62a663f1353ba2ef8e6521dc1ecb673ec8ef7": "0x83d6c7aab63600000",
  	"0xccf7110d1bd9a74bfd1d7d7d2d9d55607e7b837d": "0x30ca024f987b900000",
  	"0xccfd725760a68823ff1e062f4cc97e1360e8d997": "0x15ac56edc4d12c0000",
  	"0xcd020f8edfcf524798a9b73a640334bbf72f80a5": "0x73f75d1a085ba0000",
  	"0xcd06f8c1b5cdbd28e2d96b6346c3e85a0483ba24": "0x3635c9adc5dea00000",
  	"0xcd072e6e1833137995196d7bb1725fef8761f655": "0x14542ba12a337c00000",
  	"0xcd0a161bc367ae0927a92aac9cf6e5086714efca": "0x6c6b935b8bbd400000",
  	"0xcd0af3474e22f069ec3407870dd770443d5b12b0": "0x8e5eb4ee77b2ef0000",
  	"0xcd0b0257e783a3d2c2e3ba9d6e79b75ef98024d4": "0x9fad06241279160000",
  	"0xcd102cd6db3df14ad6af0f87c72479861bfc3d24": "0x6c6b935b8bbd400000",
  	"0xcd1e66ed539dd92fc40bbaa1fa16de8c02c14d45": "0xc77e4256863d80000",
  	"0xcd1ed263fbf6f6f7b48aef8f733d329d4382c7c7": "0x100bd33fb98ba0000",
  	"0xcd2a36d753e9e0ed012a584d716807587b41d56a": "0xe2ba75b0b1f1c0000",
  	"0xcd32a4a8a27f1cc63954aa634f7857057334c7a3": "0x3ad166576c72d40000",
  	"0xcd35ff010ec501a721a1b2f07a9ca5877dfcf95a": "0xd96fce90cfabcc0000",
  	"0xcd4306d7f6947ac1744d4e13b8ef32cb657e1c00": "0x1b1ab319f5ec750000",
  	"0xcd43258b7392a930839a51b2ef8ad23412f75a9f": "0x6c6b935b8bbd400000",
  	"0xcd49bf185e70d04507999f92a4de4455312827d0": "0x3635c9adc5dea00000",
  	"0xcd5510a242dfb0183de925fba866e312fabc1657": "0x821ab0d44149800000",
  	"0xcd566ad7b883f01fd3998a9a58a9dee4724ddca5": "0x330ae1835be300000",
  	"0xcd59f3dde77e09940befb6ee58031965cae7a336": "0x21e19e0c9bab2400000",
  	"0xcd725d70be97e677e3c8e85c0b26ef31e9955045": "0x487a9a304539440000",
  	"0xcd7e47909464d871b9a6dc76a8e9195db3485e7a": "0x215f835bc769da80000",
  	"0xcd7ece086b4b619b3b369352ee38b71ddb06439a": "0xad78ebc5ac6200000",
  	"0xcd7f09d7ed66d0c38bc5ad4e32b7f2b08dc1b30d": "0x3e3bb34da2a4700000",
  	"0xcd9529492b5c29e475acb941402b3d3ba50686b0": "0x6acb3df27e1f880000",
  	"0xcd95fa423d6fc120274aacde19f4eeb766f10420": "0xad78ebc5ac6200000",
  	"0xcd9b4cef73390c83a8fd71d7b540a7f9cf8b8c92": "0x4e1003b28d9280000",
  	"0xcda1741109c0265b3fb2bf8d5ec9c2b8a3346b63": "0x1158e460913d00000",
  	"0xcda1b886e3a795c9ba77914e0a2fe5676f0f5ccf": "0x5bf60ea42c2040000",
  	"0xcda4530f4b9bc50905b79d17c28fc46f95349bdf": "0x3310e04911f1f80000",
  	"0xcdab46a5902080646fbf954204204ae88404822b": "0x1d8a96e5c606eb0000",
  	"0xcdb597299030183f6e2d238533f4642aa58754b6": "0x15af1d78b58c400000",
  	"0xcdd5d881a7362c9070073bdfbc75e72453ac510e": "0x2da518eae48ee80000",
  	"0xcdd60d73efaad873c9bbfb178ca1b7105a81a681": "0x1bc16d674ec800000",
  	"0xcdd9efac4d6d60bd71d95585dce5d59705c13564": "0x56bc75e2d63100000",
  	"0xcde36d81d128c59da145652193eec2bfd96586ef": "0xd8d726b7177a800000",
  	"0xcdea386f9d0fd804d02818f237b7d9fa7646d35e": "0xa349d36d80ec578000",
  	"0xcdecf5675433cdb0c2e55a68db5d8bbe78419dd2": "0x1158e460913d00000",
  	"0xcdfd8217339725d7ebac11a63655f265eff1cc3d": "0x10f0c696410e3a90000",
  	"0xce079f51887774d8021cb3b575f58f18e9acf984": "0x9c2007651b2500000",
  	"0xce1884ddbbb8e10e4dba6e44feeec2a7e5f92f05": "0xd8d726b7177a800000",
  	"0xce1b0cb46aaecfd79b880cad0f2dda8a8dedd0b1": "0x1158e460913d00000",
  	"0xce26f9a5305f8381094354dbfc92664e84f902b5": "0xc7aaab0591eec0000",
  	"0xce2deab51c0a9ae09cd212c4fa4cc52b53cc0dec": "0x6c6b935b8bbd400000",
  	"0xce2e0da8934699bb1a553e55a0b85c169435bea3": "0x10f0c696410e3a90000",
  	"0xce3a61f0461b00935e85fa1ead82c45e5a64d488": "0x1b1ae4d6e2ef500000",
  	"0xce4b065dbcb23047203262fb48c1188364977470": "0x1b1ae4d6e2ef500000",
  	"0xce53c8cdd74296aca987b2bc19c2b875a48749d0": "0xa2a15d09519be00000",
  	"0xce5e04f0184369bcfa06aca66ffa91bf59fa0fb9": "0x22b1c8c1227a00000",
  	"0xce5eb63a7bf4fbc2f6e4baa0c68ab1cb4cf98fb4": "0x6c6b935b8bbd400000",
  	"0xce62125adec3370ac52110953a4e760be9451e3b": "0x83d6c7aab63600000",
  	"0xce71086d4c602554b82dcbfce88d20634d53cc4d": "0x92896529baddc880000",
  	"0xce8a6b6d5033b1498b1ffeb41a41550405fa03a2": "0xd8d726b7177a800000",
  	"0xce9786d3712fa200e9f68537eeaa1a06a6f45a4b": "0x61093d7c2c6d380000",
  	"0xce9d21c692cd3c01f2011f505f870036fa8f6cd2": "0x15af1d78b58c400000",
  	"0xcea2896623f4910287a2bdc5be83aea3f2e6de08": "0x1fb5a3751e490dc0000",
  	"0xcea34a4dd93dd9aefd399002a97d997a1b4b89cd": "0x5150ae84a8cdf00000",
  	"0xcea43f7075816b60bbfce68b993af0881270f6c4": "0x6c6b935b8bbd400000",
  	"0xcea8743341533cb2f0b9c6efb8fda80d77162825": "0x56bc75e2d63100000",
  	"0xceb089ec8a78337e8ef88de11b49e3dd910f748f": "0x3635c9adc5dea00000",
  	"0xceb33d78e7547a9da2e87d51aec5f3441c87923a": "0x1158e460913d00000",
  	"0xceb389381d48a8ae4ffc483ad0bb5e204cfdb1ec": "0x2827e6e4dd62ba8000",
  	"0xcec6fc65853f9cce5f8e844676362e1579015f02": "0x6c6b935b8bbd400000",
  	"0xced3c7be8de7585140952aeb501dc1f876ecafb0": "0xd8d726b7177a800000",
  	"0xced81ec3533ff1bfebf3e3843ee740ad11758d3e": "0x6acb3df27e1f880000",
  	"0xcedcb3a1d6843fb6bef643617deaf38f8e98dd5f": "0x19e2a4c818b9060000",
  	"0xcee699c0707a7836252b292f047ce8ad289b2f55": "0x119a1e21aa69560000",
  	"0xceed47ca5b899fd1623f21e9bd4db65a10e5b09d": "0x73877404c1eee0000",
  	"0xcef77451dfa2c643e00b156d6c6ff84e2373eb66": "0xa31062beeed700000",
  	"0xcf1169041c1745e45b172435a2fc99b49ace2b00": "0x1bb88baab2d7c0000",
  	"0xcf157612764e0fd696c8cb5fba85df4c0ddc3cb0": "0x65a4da25d3016c00000",
  	"0xcf1bdb799b2ea63ce134668bdc198b54840f180b": "0xfc936392801c0000",
  	"0xcf2288ef4ebf88e86db13d8a0e0bf52a056582c3": "0x89506fbf9740740000",
  	"0xcf264e6925130906c4d7c18591aa41b2a67f6f58": "0x6c6b935b8bbd400000",
  	"0xcf26b47bd034bc508e6c4bcfd6c7d30034925761": "0x6194049f30f7200000",
  	"0xcf2e2ad635e9861ae95cb9bafcca036b5281f5ce": "0x77432217e6836000000",
  	"0xcf2e734042a355d05ffb2e3915b16811f45a695e": "0x6c6b935b8bbd400000",
  	"0xcf348f2fe47b7e413c077a7baf3a75fbf8428692": "0x6c6b935b8bbd400000",
  	"0xcf3f9128b07203a3e10d7d5755c0c4abc6e2cac2": "0x10f0cf064dd59200000",
  	"0xcf3fbfa1fd32d7a6e0e6f8ef4eab57be34025c4c": "0x39a1c0f7594d480000",
  	"0xcf4166746e1d3bc1f8d0714b01f17e8a62df1464": "0x3677036edf0af60000",
  	"0xcf4f1138f1bd6bf5b6d485cce4c1017fcb85f07d": "0x2fd0bc77c32bff0000",
  	"0xcf5a6f9df75579c644f794711215b30d77a0ce40": "0x6c6b935b8bbd400000",
  	"0xcf5e0eacd1b39d0655f2f77535ef6608eb950ba0": "0x6c6b935b8bbd400000",
  	"0xcf684dfb8304729355b58315e8019b1aa2ad1bac": "0x177224aa844c720000",
  	"0xcf694081c76d18c64ca71382be5cd63b3cb476f8": "0x3635c9adc5dea00000",
  	"0xcf6e52e6b77480b1867efec6446d9fc3cc3577e8": "0xc0901f6bd98790000",
  	"0xcf883a20329667ea226a1e3c765dbb6bab32219f": "0xa4be3564d616660000",
  	"0xcf8882359c0fb23387f5674074d8b17ade512f98": "0x14542ba12a337c00000",
  	"0xcf89f7460ba3dfe83c5a1d3a019ee1250f242f0f": "0x356813cdcefd028000",
  	"0xcf923a5d8fbc3d01aa079d1cfe4b43ce071b1611": "0x6c6b935b8bbd400000",
  	"0xcf9be9b9ab86c66b59968e67b8d4dcff46b1814a": "0x23c757072b8dd00000",
  	"0xcfa8b37127149bdbfee25c34d878510951ea10eb": "0x6c6b935b8bbd400000",
  	"0xcfac2e1bf33205b05533691a02267ee19cd81836": "0x3635c9adc5dea00000",
  	"0xcfbb32b7d024350e3321fa20c9a914035372ffc6": "0x15be6174e1912e0000",
  	"0xcfc4e6f7f8b011414bfba42f23adfaa78d4ecc5e": "0x6449e84e47a8a80000",
  	"0xcfd2728dfb8bdbf3bf73598a6e13eaf43052ea2b": "0x93739534d28680000",
  	"0xcfd47493c9f89fe680bda5754dd7c9cfe7cb5bbe": "0x2f473513448fe0000",
  	"0xcfde0fc75d6f16c443c3038217372d99f5d907f7": "0x83225e6396b5ec0000",
  	"0xcfe2caaf3cec97061d0939748739bffe684ae91f": "0x21e19e0c9bab2400000",
  	"0xcfeacaaed57285e0ac7268ce6a4e35ecfdb242d7": "0x3ae4d4240190600000",
  	"0xcfecbea07c27002f65fe534bb8842d0925c78402": "0xd8d726b7177a800000",
  	"0xcfee05c69d1f29e7714684c88de5a16098e91399": "0x6acb3df27e1f880000",
  	"0xcff6a6fe3e9a922a12f21faa038156918c4fcb9c": "0x44591d67fecc80000",
  	"0xcff7f89a4d4219a38295251331568210ffc1c134": "0x5f68e8131ecf800000",
  	"0xcff8d06b00e3f50c191099ad56ba6ae26571cd88": "0x3635c9adc5dea00000",
  	"0xcffc49c1787eebb2b56cabe92404b636147d4558": "0x133e0308f40a3da8000",
  	"0xd008513b27604a89ba1763b6f84ce688b346945b": "0x3635c9adc5dea00000",
  	"0xd00f067286c0fbd082f9f4a61083ec76deb3cee6": "0x3635c9adc5dea00000",
  	"0xd015f6fcb84df7bb410e8c8f04894a881dcac237": "0x384524cc70b7780000",
  	"0xd01af9134faf5257174e8b79186f42ee354e642d": "0x3635c9adc5dea00000",
  	"0xd02108d2ae3cab10cbcf1657af223e027c8210f6": "0x6c6d84bccdd9ce0000",
  	"0xd02afecf8e2ec2b62ac8ad204161fd1fae771d0e": "0x6c6b935b8bbd400000",
  	"0xd0319139fbab2e8e2accc1d924d4b11df6696c5a": "0xad78ebc5ac6200000",
  	"0xd037d215d11d1df3d54fbd321cd295c5465e273b": "0x4be4e7267b6ae00000",
  	"0xd03a2da41e868ed3fef5745b96f5eca462ff6fda": "0xa2a15d09519be00000",
  	"0xd03fc165576aaed525e5502c8e140f8b2e869639": "0x17356d8b32501c80000",
  	"0xd043a011ec4270ee7ec8b968737515e503f83028": "0x1b1ae4d6e2ef500000",
  	"0xd04b861b3d9acc563a901689941ab1e1861161a2": "0x1158e460913d00000",
  	"0xd05a447c911dbb275bfb2e5a37e5a703a56f9997": "0xad78ebc5ac6200000",
  	"0xd05ffb2b74f867204fe531653b0248e21c13544e": "0x3635c9adc5dea00000",
  	"0xd062588171cf99bbeb58f126b870f9a3728d61ec": "0xf3f20b8dfa69d00000",
  	"0xd0638ea57189a6a699024ad78c71d939c1c2ff8c": "0x8eae566710fc200000",
  	"0xd0648a581b3508e135a2935d12c9657045d871ca": "0x1b2df9d219f57980000",
  	"0xd071192966eb69c3520fca3aa4dd04297ea04b4e": "0x5f68e8131ecf80000",
  	"0xd0718520eae0a4d62d70de1be0ca431c5eea2482": "0x6c6b935b8bbd400000",
  	"0xd0775dba2af4c30a3a78365939cd71c2f9de95d2": "0x692ae8897081d00000",
  	"0xd07be0f90997caf903c8ac1d53cde904fb190741": "0x36389038b699b40000",
  	"0xd07e511864b1cf9969e3560602829e32fc4e71f5": "0x2b5e3af16b1880000",
  	"0xd0809498c548047a1e2a2aa6a29cd61a0ee268bd": "0x6c6b935b8bbd400000",
  	"0xd082275f745a2cac0276fbdb02d4b2a3ab1711fe": "0x1a055690d9db80000",
  	"0xd08fc09a0030fd0928cd321198580182a76aae9f": "0x3635c9adc5dea00000",
  	"0xd093e829819fd2e25b973800bb3d5841dd152d05": "0xd8d726b7177a800000",
  	"0xd0944aa185a1337061ae20dc9dd96c83b2ba4602": "0xad78ebc5ac6200000",
  	"0xd096565b7c7407d06536580355fdd6d239144aa1": "0xd8d726b7177a80000",
  	"0xd09cb2e6082d693a13e8d2f68dd1dd8461f55840": "0x3635c9adc5dea00000",
  	"0xd0a6c6f9e9c4b383d716b31de78d56414de8fa91": "0x1043561a8829300000",
  	"0xd0a7209b80cf60db62f57d0a5d7d521a69606655": "0x8ac7230489e800000",
  	"0xd0a8abd80a199b54b08b65f01d209c27fef0115b": "0x161c626dc61a2ef8000",
  	"0xd0abcc70c0420e0e172f97d43b87d5e80c336ea9": "0x21e19e0c9bab2400000",
  	"0xd0ae735d915e946866e1fea77e5ea466b5cadd16": "0x6c6b935b8bbd400000",
  	"0xd0b11d6f2bce945e0c6a5020c3b52753f803f9d1": "0xad78ebc5ac6200000",
  	"0xd0c101fd1f01c63f6b1d19bc920d9f932314b136": "0x43c33c1937564800000",
  	"0xd0c55abf976fdc3db2afe9be99d499484d576c02": "0x3635c9adc5dea00000",
  	"0xd0d0a2ad45f59a9dccc695d85f25ca46ed31a5a3": "0x2d89577d7d40200000",
  	"0xd0d62c47ea60fb90a3639209bbfdd4d933991cc6": "0xa844a7424d9c80000",
  	"0xd0db456178206f5c4430fe005063903c3d7a49a7": "0x26491e45a753c08000",
  	"0xd0e194f34b1db609288509ccd2e73b6131a2538b": "0x36356633ebd8ea0000",
  	"0xd0e35e047646e759f4517093d6408642517f084d": "0xd58fa46818eccb8000",
  	"0xd0ee4d02cf24382c3090d3e99560de3678735cdf": "0x821ab0d44149800000",
  	"0xd0f04f52109aebec9a7b1e9332761e9fe2b97bb5": "0xd8d726b7177a800000",
  	"0xd0f9597811b0b992bb7d3757aa25b4c2561d32e2": "0x1b1ae4d6e2ef500000",
  	"0xd10302faa1929a326904d376bf0b8dc93ad04c4c": "0x61093d7c2c6d380000",
  	"0xd1100dd00fe2ddf18163ad964d0b69f1f2e9658a": "0x143120955b2506b0000",
  	"0xd116f3dcd5db744bd008887687aa0ec9fd7292aa": "0x3635c9adc5dea00000",
  	"0xd119417c46732cf34d1a1afb79c3e7e2cd8eece4": "0x6c6b935b8bbd400000",
  	"0xd12d77ae01a92d35117bac705aacd982d02e74c1": "0x3635c9adc5dea00000",
  	"0xd135794b149a18e147d16e621a6931f0a40a969a": "0x43c33c1937564800000",
  	"0xd1432538e35b7664956ae495a32abdf041a7a21c": "0x42bf06b78ed3b500000",
  	"0xd1438267231704fc7280d563adf4763844a80722": "0xad78ebc5ac6200000",
  	"0xd1538e9a87e59ca9ec8e5826a5b793f99f96c4c3": "0x3635c9adc5dea00000",
  	"0xd1648503b1ccc5b8be03fa1ec4f3ee267e6adf7b": "0x13befbf51eec0900000",
  	"0xd1682c2159018dc3d07f08240a8c606daf65f8e1": "0x2a5a058fc295ed000000",
  	"0xd171c3f2258aef35e599c7da1aa07300234da9a6": "0x6c6b935b8bbd400000",
  	"0xd1778c13fbd968bc083cb7d1024ffe1f49d02caa": "0xd9ecb4fd208e500000",
  	"0xd17fbe22d90462ed37280670a2ea0b3086a0d6d6": "0xad6eedd17cf3b8000",
  	"0xd1811c55976980f083901d8a0db269222dfb5cfe": "0x54069233bf7f780000",
  	"0xd18eb9e1d285dabe93e5d4bae76beefe43b521e8": "0x243d4d18229ca20000",
  	"0xd193e583d6070563e7b862b9614a47e99489f3e5": "0x36356633ebd8ea0000",
  	"0xd1978f2e34407fab1dc2183d95cfda6260b35982": "0x2ab7b260ff3fd00000",
  	"0xd19caf39bb377fdf2cf19bd4fb52591c2631a63c": "0x3635c9adc5dea00000",
  	"0xd1a396dcdab2c7494130b3fd307820340dfd8c1f": "0xf92250e2dfd00000",
  	"0xd1a71b2d0858e83270085d95a3b1549650035e23": "0x327bb09d06aa8500000",
  	"0xd1acb5adc1183973258d6b8524ffa28ffeb23de3": "0xd8d726b7177a800000",
  	"0xd1b37f03cb107424e9c4dd575ccd4f4cee57e6cd": "0x6c6b935b8bbd400000",
  	"0xd1b5a454ac3405bb4179208c6c84de006bcb9be9": "0x1b1ae4d6e2ef500000",
  	"0xd1c45954a62b911ad701ff2e90131e8ceb89c95c": "0x4b91a2de457e880000",
  	"0xd1c96e70f05ae0e6cd6021b2083750a7717cde56": "0x1b1ae4d6e2ef500000",
  	"0xd1d5b17ffe2d7bbb79cc7d7930bcb2e518fb1bbf": "0xa2a15d09519be00000",
  	"0xd1da0c8fb7c210e0f2ec618f85bdae7d3e734b1c": "0x6acb3df27e1f880000",
  	"0xd1dd79fb158160e5b4e8e23f312e6a907fbc4d4e": "0x1b1ae4d6e2ef500000",
  	"0xd1de5aad3a5fd803f1b1aeb6103cb8e14fe723b7": "0x1158e460913d00000",
  	"0xd1e1f2b9c16c309874dee7fac32675aff129c398": "0x3f24d8e4a00700000",
  	"0xd1e5e234a9f44266a4a6241a84d7a1a55ad5a7fe": "0x43c33c1937564800000",
  	"0xd1ea4d72a67b5b3e0f315559f52bd0614d713069": "0x6c6b935b8bbd400000",
  	"0xd1ee905957fe7cc70ec8f2868b43fe47b13febff": "0x2629f66e0c5300000",
  	"0xd1f1694d22671b5aad6a94995c369fbe6133676f": "0x3635c9adc5dea00000",
  	"0xd1f4dc1ddb8abb8848a8b14e25f3b55a8591c266": "0xd8d726b7177a80000",
  	"0xd1fed0aee6f5dfd7e25769254c3cfad15adeccaa": "0x2792c8fc4b53280000",
  	"0xd2051cb3cb6704f0548cc890ab0a19db3415b42a": "0x121b2e5e6464780000",
  	"0xd206aaddb336d45e7972e93cb075471d15897b5d": "0x2086ac351052600000",
  	"0xd209482bb549abc4777bea6d7f650062c9c57a1c": "0x11651ac3e7a7580000",
  	"0xd20dcb0b78682b94bc3000281448d557a20bfc83": "0x30849ebe16369c0000",
  	"0xd2107b353726c3a2b46566eaa7d9f80b5d21dbe3": "0x1158e460913d00000",
  	"0xd211b21f1b12b5096181590de07ef81a89537ead": "0x6c6b935b8bbd400000",
  	"0xd218efb4db981cdd6a797f4bd48c7c26293ceb40": "0xa1466b31c6431c0000",
  	"0xd21a7341eb84fd151054e5e387bb25d36e499c09": "0x2f6f10780d22cc00000",
  	"0xd224f880f9479a89d32f09e52be990b288135cef": "0x3a9d5baa4abf1d00000",
  	"0xd22f0ca4cd479e661775053bcc49e390f670dd8a": "0x3635c9adc5dea00000",
  	"0xd231929735132102471ba59007b6644cc0c1de3e": "0x3637096c4bcc690000",
  	"0xd235d15cb5eceebb61299e0e827fa82748911d89": "0xd8d726b7177a800000",
  	"0xd23a24d7f9468343c143a41d73b88f7cbe63be5e": "0xad78ebc5ac6200000",
  	"0xd23d7affacdc3e9f3dae7afcb4006f58f8a44600": "0xc328093e61ee400000",
  	"0xd243184c801e5d79d2063f3578dbae81e7b3a9cb": "0x6bdca2681e1aba0000",
  	"0xd24b6644f439c8051dfc64d381b8c86c75c17538": "0x6c6b935b8bbd400000",
  	"0xd24bf12d2ddf457decb17874efde2052b65cbb49": "0x2f6f10780d22cc00000",
  	"0xd251f903ae18727259eee841a189a1f569a5fd76": "0x21e19e0c9bab2400000",
  	"0xd252960b0bf6b2848fdead80136db5f507f8be02": "0x6c6b935b8bbd400000",
  	"0xd2581a55ce23ab10d8ad8c44378f59079bd6f658": "0x1dd0c885f9a0d800000",
  	"0xd25aecd7eb8bd6345b063b5dbd271c77d3514494": "0x62a992e53a0af00000",
  	"0xd27c234ff7accace3d996708f8f9b04970f97d36": "0x487a9a304539440000",
  	"0xd28298524df5ec4b24b0ffb9df85170a145a9eb5": "0xf98a3b9b337e20000",
  	"0xd283b8edb10a25528a4404de1c65e7410dbcaa67": "0x28a857425466f800000",
  	"0xd284a50382f83a616d39b8a9c0f396e0ebbfa95d": "0x3636c25e66ece70000",
  	"0xd288e7cb7ba9f620ab0f7452e508633d1c5aa276": "0xd8d726b7177a800000",
  	"0xd29dc08efbb3d72e263f78ab7610d0226de76b00": "0x28a857425466f800000",
  	"0xd2a030ac8952325f9e1db378a71485a24e1b07b2": "0x6c6b935b8bbd400000",
  	"0xd2a479404347c5543aab292ae1bb4a6f158357fa": "0xd8d726b7177a800000",
  	"0xd2a5a024230a57ccc666760b89b0e26cafd189c7": "0xa96595a5c6e8a3f8000",
  	"0xd2a80327cbe55c4c7bd51ff9dde4ca648f9eb3f8": "0x2b5e3af16b1880000",
  	"0xd2a84f75675c62d80c88756c428eee2bcb185421": "0x410d586a20a4c00000",
  	"0xd2abd84a181093e5e229136f42d835e8235de109": "0x56be03ca3e47d8000",
  	"0xd2ac0d3a58605e1d0f0eb3de25b2cad129ed6058": "0xd8d726b7177a800000",
  	"0xd2bf67a7f3c6ce56b7be41675dbbadfe7ea93a33": "0x15af1d78b58c400000",
  	"0xd2dbebe89b0357aea98bbe8e496338debb28e805": "0xd8d726b7177a800000",
  	"0xd2e21ed56868fab28e0947927adaf29f23ebad6c": "0x6c184f1355d0e80000",
  	"0xd2e817738abf1fb486583f80c350318bed860c80": "0xd02cecf5f5d810000",
  	"0xd2edd1ddd6d86dc005baeb541d22b640d5c7cae5": "0x1158e460913d00000",
  	"0xd2f1998e1cb1580cec4f6c047dcd3dcec54cf73c": "0xad78ebc5ac6200000",
  	"0xd2f241255dd7c3f73c07043071ec08ddd9c5cde5": "0x1b1ae4d6e2ef500000",
  	"0xd2ff672016f63b2f85398f4a6fedbb60a50d3cce": "0x1291246f5b734a0000",
  	"0xd30d4c43adcf55b2cb53d68323264134498d89ce": "0x3635c9adc5dea00000",
  	"0xd30ee9a12b4d68abace6baca9ad7bf5cd1faf91c": "0x514fcb24ff9c500000",
  	"0xd3118ea3c83505a9d893bb67e2de142d537a3ee7": "0x1158e460913d00000",
  	"0xd311bcd7aa4e9b4f383ff3d0d6b6e07e21e3705d": "0xad78ebc5ac6200000",
  	"0xd315deea1d8c1271f9d1311263ab47c007afb6f5": "0x3c81d4e654b400000",
  	"0xd32b2c79c36478c5431901f6d700b04dbe9b8810": "0x15779a9de6eeb00000",
  	"0xd32b45564614516c91b07fa9f72dcf787cce4e1c": "0xfc66fae3746ac0000",
  	"0xd330728131fe8e3a15487a34573c93457e2afe95": "0xd8d726b7177a800000",
  	"0xd331c823825a9e5263d052d8915d4dcde07a5c37": "0x1e931283ccc8500000",
  	"0xd333627445f2d787901ef33bb2a8a3675e27ffec": "0x15af1d78b58c400000",
  	"0xd33cf82bf14c592640a08608914c237079d5be34": "0x6c6b935b8bbd400000",
  	"0xd34d708d7398024533a5a2b2309b19d3c55171bb": "0x15af1d78b58c400000",
  	"0xd34e03d36a2bd4d19a5fa16218d1d61e3ffa0b15": "0x1158e460913d000000",
  	"0xd35075ca61fe59d123969c36a82d1ab2d918aa38": "0x90f534608a72880000",
  	"0xd367009ab658263b62c2333a1c9e4140498e1389": "0x6c6b935b8bbd400000",
  	"0xd3679a47df2d99a49b01c98d1c3e0c987ce1e158": "0xf2dc7d47f15600000",
  	"0xd38fa2c4cc147ad06ad5a2f75579281f22a7cc1f": "0x43c33c1937564800000",
  	"0xd39a5da460392b940b3c69bc03757bf3f2e82489": "0x17c83a97d6b6ca50000",
  	"0xd39b7cbc94003fc948f0cde27b100db8ccd6e063": "0x15af1d78b58c400000",
  	"0xd3a10ec7a5c9324999dd9e9b6bde7c911e584bda": "0x2086ac351052600000",
  	"0xd3a941c961e8ca8b1070f23c6d6d0d2a758a4444": "0xad78ebc5ac6200000",
  	"0xd3bb59fa31258be62f8ed232f1a7d47b4a0b41ee": "0x56bc75e2d63100000",
  	"0xd3bc730937fa75d8452616ad1ef1fe7fffe0d0e7": "0x484e4ded2eae38000",
  	"0xd3c24d4b3a5e0ff8a4622d518edd73f16ab28610": "0x1158e460913d00000",
  	"0xd3c6f1e0f50ec3d2a67e6bcd193ec7ae38f1657f": "0x166c5480889db770000",
  	"0xd3d6e9fb82542fd29ed9ea3609891e151396b6f7": "0xb6f588aa7bcf5c00000",
  	"0xd3dad1b6d08d4581ccae65a8732db6ac69f0c69e": "0x14542ba12a337c00000",
  	"0xd3df3b53cb3b4755de54e180451cc44c9e8ae0aa": "0x23c49409b977828000",
  	"0xd3f873bd9956135789ab00ebc195b922e94b259d": "0x6c6b935b8bbd400000",
  	"0xd402b4f6a099ebe716cb14df4f79c0cd01c6071b": "0x6c6b935b8bbd400000",
  	"0xd40d0055fd9a38488aff923fd03d35ec46d711b3": "0x10f08eda8e555098000",
  	"0xd40ed66ab3ceff24ca05ecd471efb492c15f5ffa": "0x1b1ae4d6e2ef500000",
  	"0xd418870bc2e4fa7b8a6121ae0872d55247b62501": "0x55a6e79ccd1d300000",
  	"0xd41d7fb49fe701baac257170426cc9b38ca3a9b2": "0x98a7d9b8314c00000",
  	"0xd4205592844055b3c7a1f80cefe3b8eb509bcde7": "0x9b3bfd342a9fc8000",
  	"0xd42b20bd0311608b66f8a6d15b2a95e6de27c5bf": "0x6c6b935b8bbd400000",
  	"0xd4344f7d5cad65d17e5c2d0e7323943d6f62fe92": "0xe7eeba3410b740000",
  	"0xd43ee438d83de9a37562bb4e286cb1bd19f4964d": "0x3635c9adc5dea00000",
  	"0xd44334b4e23a169a0c16bd21e866bba52d970587": "0x8cf23f909c0fa00000",
  	"0xd44d81e18f46e2cfb5c1fcf5041bc8569767d100": "0x7b442e684f65aa40000",
  	"0xd44f4ac5fad76bdc1537a3b3af6472319b410d9d": "0x56bc75e2d631000000",
  	"0xd44f5edf2bcf2433f211dadd0cc450db1b008e14": "0xe7eeba3410b740000",
  	"0xd44f6ac3923b5fd731a4c45944ec4f7ec52a6ae4": "0x21e19e0c9bab2400000",
  	"0xd45b3341e8f15c80329320c3977e3b90e7826a7e": "0x1b1ae4d6e2ef500000",
  	"0xd45d5daa138dd1d374c71b9019916811f4b20a4e": "0x1f399b1438a1000000",
  	"0xd460a4b908dd2b056759b488850b66a838fc77a8": "0x6acb3df27e1f880000",
  	"0xd467cf064c0871989b90d8b2eb14ccc63b360823": "0xad78ebc5ac6200000",
  	"0xd46bae61b027e5bb422e83a3f9c93f3c8fc77d27": "0x6c6b935b8bbd400000",
  	"0xd46f8223452982a1eea019a8816efc2d6fc00768": "0x76d41c62494840000",
  	"0xd475477fa56390d33017518d6711027f05f28dbf": "0x6b111333d4fd4c0000",
  	"0xd47c242edffea091bc54d57df5d1fdb93101476c": "0x9df7dfa8f760480000",
  	"0xd47d8685faee147c520fd986709175bf2f886bef": "0x6c6b935b8bbd400000",
  	"0xd47f50df89a1cff96513bef1b2ae3a2971accf2c": "0x2d89577d7d40200000",
  	"0xd482e7f68e41f238fe517829de15477fe0f6dd1d": "0x1b1ae4d6e2ef500000",
  	"0xd4879fd12b1f3a27f7e109761b23ca343c48e3d8": "0x241a9b4f617a280000",
  	"0xd48e3f9357e303513841b3f84bda83fc89727587": "0x3635c9adc5dea00000",
  	"0xd49a75bb933fca1fca9aa1303a64b6cb44ea30e1": "0x21e19e0c9bab2400000",
  	"0xd4b085fb086f3d0d68bf12926b1cc3142cae8770": "0xc893d09c8f51500000",
  	"0xd4b2ff3bae1993ffea4d3b180231da439f7502a2": "0x6c6b935b8bbd400000",
  	"0xd4b38a5fdb63e01714e9801db47bc990bd509183": "0x14534d95bef905c0000",
  	"0xd4b8bdf3df9a51b0b91d16abbea05bb4783c8661": "0x3635c9adc5dea00000",
  	"0xd4c4d1a7c3c74984f6857b2f5f07e8face68056d": "0x6c6b935b8bbd400000",
  	"0xd4c6ac742e7c857d4a05a04c33d4d05c1467571d": "0xad78ebc5ac6200000",
  	"0xd4cb21e590c5a0e06801366aff342c7d7db16424": "0x1ac7a08ead02f80000",
  	"0xd4d92c62b280e00f626d8657f1b86166cb1f740f": "0xad7f23634cbd60000",
  	"0xd4ebb1929a23871cf77fe049ab9602be08be0a73": "0x678a932062e4180000",
  	"0xd4ee4919fb37f2bb970c3fff54aaf1f3dda6c03f": "0x878678326eac9000000",
  	"0xd4feed99e8917c5c5458635f3603ecb7e817a7d0": "0x1043c43cde1d398000",
  	"0xd4ff46203efa23064b1caf00516e28704a82a4f8": "0x487a9a304539440000",
  	"0xd500e4d1c9824ba9f5b635cfa3a8c2c38bbd4ced": "0x15af1d78b58c400000",
  	"0xd508d39c70916f6abc4cc7f999f011f077105802": "0x5724d24afe77f0000",
  	"0xd50f7fa03e389876d3908b60a537a6706304fb56": "0x56bc75e2d63100000",
  	"0xd513a45080ff2febe62cd5854abe29ee4467f996": "0x84e13bc4fc5d80000",
  	"0xd5276f0cd5ffd5ffb63f98b5703d5594ede0838b": "0x15af1d78b58c400000",
  	"0xd5294b666242303b6df0b1c88d37429bc8c965aa": "0x104d0d00d2b7f60000",
  	"0xd52aecc6493938a28ca1c367b701c21598b6a02e": "0x3ba1910bf341b00000",
  	"0xd53c567f0c3ff2e08b7d59e2b5c73485437fc58d": "0x2086ac351052600000",
  	"0xd541ac187ad7e090522de6da3213e9a7f4439673": "0x6c6b935b8bbd400000",
  	"0xd54ba2d85681dc130e5b9b02c4e8c851391fd9b9": "0xd5967be4fc3f100000",
  	"0xd55508adbbbe9be81b80f97a6ea89add68da674f": "0x6c6b935b8bbd400000",
  	"0xd5550caaf743b037c56fd2558a1c8ed235130750": "0x121e4d49036255b0000",
  	"0xd5586da4e59583c8d86cccf71a86197f17996749": "0x6c6b935b8bbd400000",
  	"0xd55c1c8dfbe1e02cacbca60fdbdd405b09f0b75f": "0x6c6b935b8bbd400000",
  	"0xd561cbbc05515de73ab8cf9eae1357341e7dfdf4": "0x14542ba12a337c00000",
  	"0xd56a144d7af0ae8df649abae535a15983aa04d02": "0x10f0cf064dd59200000",
  	"0xd572309169b1402ec8131a17a6aac3222f89e6eb": "0x2ec1978c47766a00000",
  	"0xd5787668c2c5175b01a8ee1ac3ecc9c8b2aba95a": "0x6c6acc67d7b1d40000",
  	"0xd588c3a5df228185d98ee7e60748255cdea68b01": "0xd8d726b7177a800000",
  	"0xd58a52e078a805596b0d56ea4ae1335af01c66eb": "0xe7eeba3410b740000",
  	"0xd5903e9978ee20a38c3f498d63d57f31a39f6a06": "0x232b36ffc672ab00000",
  	"0xd59638d3c5faa7711bf085745f9d5bdc23d498d8": "0x6c6b935b8bbd400000",
  	"0xd59d92d2c8701980cc073c375d720af064743c0c": "0x405fdf7e5af85e00000",
  	"0xd5a7bec332adde18b3104b5792546aa59b879b52": "0x6c6b935b8bbd400000",
  	"0xd5b117ec116eb846418961eb7edb629cd0dd697f": "0xa2a15d09519be00000",
  	"0xd5b284040130abf7c1d163712371cc7e28ad66da": "0x6acb3df27e1f880000",
  	"0xd5b9d277d8aad20697a51f76e20978996bffe055": "0x7c3fe3c076ab50000",
  	"0xd5bd5e8455c130169357c471e3e681b7996a7276": "0x2d9e288f8abb360000",
  	"0xd5cba5b26bea5d73fabb1abafacdef85def368cc": "0xad78ebc5ac6200000",
  	"0xd5ce55d1b62f59433c2126bcec09bafc9dfaa514": "0xaadec983fcff40000",
  	"0xd5e55100fbd1956bbed2ca518d4b1fa376032b0b": "0x56bc75e2d63100000",
  	"0xd5e5c135d0c4c3303934711993d0d16ff9e7baa0": "0x6c6b935b8bbd400000",
  	"0xd5e656a1b916f9bf45afb07dd8afaf73b4c56f41": "0x542253a126ce40000",
  	"0xd5ea472cb9466018110af00c37495b5c2c713112": "0x10eee686c854f440000",
  	"0xd5f07552b5c693c20067b378b809cee853b8f136": "0x1b67c6df88c6fa0000",
  	"0xd5f7c41e07729dfa6dfc64c4423160a22c609fd3": "0x61093d7c2c6d380000",
  	"0xd604abce4330842e3d396ca73ddb5519ed3ec03f": "0x8e31fe1689d8a0000",
  	"0xd60651e393783423e5cc1bc5f889e44ef7ea243e": "0x159e76371129c80000",
  	"0xd609bf4f146eea6b0dc8e06ddcf4448a1fccc9fa": "0x6c6b935b8bbd400000",
  	"0xd609ec0be70d0ad26f6e67c9d4762b52ee51122c": "0x3635c9adc5dea00000",
  	"0xd60a52580728520df7546bc1e283291788dbae0c": "0x363489ef3ff0d70000",
  	"0xd60b247321a32a5affb96b1e279927cc584de943": "0x7ad020d6ddd7760000",
  	"0xd6110276cfe31e42825a577f6b435dbcc10cf764": "0x3635c9adc5dea00000",
  	"0xd612597bc31743c78633f633f239b1e9426bd925": "0x1017f7df96be17800000",
  	"0xd6234aaf45c6f22e66a225ffb93add629b4ef80f": "0x3635c9adc5dea00000",
  	"0xd62edb96fce2969aaf6c545e967cf1c0bc805205": "0x4a565536a5ada8000",
  	"0xd6300b3215b11de762ecde4b70b7927d01291582": "0x6c6b935b8bbd400000",
  	"0xd6395db5a4bb66e60f4cfbcdf0057bb4d97862e2": "0x3154c9729d05780000",
  	"0xd64a2d50f8858537188a24e0f50df1681ab07ed7": "0x8375a2abcca24400000",
  	"0xd6580ab5ed4c7dfa506fa6fe64ad5ce129707732": "0xd8d726b7177a800000",
  	"0xd6598b1386e93c5ccb9602ff4bbbecdbd3701dc4": "0xc25f4ecb041f00000",
  	"0xd6644d40e90bc97fe7dfe7cabd3269fd579ba4b3": "0x89e917994f71c0000",
  	"0xd6670c036df754be43dadd8f50feea289d061fd6": "0x144a2903448cef78000",
  	"0xd668523a90f0293d65c538d2dd6c57673710196e": "0x2242c30b853ee0000",
  	"0xd66ab79294074c8b627d842dab41e17dd70c5de5": "0x3635c9adc5dea00000",
  	"0xd66acc0d11b689cea6d9ea5ff4014c224a5dc7c4": "0xfc936392801c0000",
  	"0xd66ddf1159cf22fd8c7a4bc8d5807756d433c43e": "0x77432217e683600000",
  	"0xd687cec0059087fdc713d4d2d65e77daefedc15f": "0x340aad21b3b700000",
  	"0xd688e785c98f00f84b3aa1533355c7a258e87948": "0x1b1ae4d6e2ef500000",
  	"0xd6a22e598dabd38ea6e958bd79d48ddd9604f4df": "0x3635c9adc5dea00000",
  	"0xd6a7ac4de7b510f0e8de519d973fa4c01ba83400": "0x65ea3db75546600000",
  	"0xd6acc220ba2e51dfcf21d443361eea765cbd35d8": "0x1158e460913d00000",
  	"0xd6acffd0bfd99c382e7bd56ff0e6144a9e52b08e": "0x8ac7230489e800000",
  	"0xd6c0d0bc93a62e257174700e10f024c8b23f1f87": "0x6c6b935b8bbd400000",
  	"0xd6cf5c1bcf9da662bcea2255905099f9d6e84dcc": "0x1c49e420157d9c20000",
  	"0xd6d03572a45245dbd4368c4f82c95714bd2167e2": "0x3f00c3d66686fc0000",
  	"0xd6d6776958ee23143a81adadeb08382009e996c2": "0xa2a15d09519be00000",
  	"0xd6d9e30f0842012a7176a917d9d2048ca0738759": "0xd8d726b7177a800000",
  	"0xd6e09e98fe1300332104c1ca34fbfac554364ed9": "0x6c6b935b8bbd400000",
  	"0xd6e8e97ae9839b9ee507eedb28edfb7477031439": "0x6c6b935b8bbd400000",
  	"0xd6eea898d4ae2b718027a19ce9a5eb7300abe3ca": "0x17d4aceee63db8000",
  	"0xd6f1e55b1694089ebcb4fe7d7882aa66c8976176": "0x43c23bdbe929db30000",
  	"0xd6f4a7d04e8faf20e8c6eb859cf7f78dd23d7a15": "0x724ded1c748140000",
  	"0xd6fc0446c6a8d40ae3551db7e701d1fa876e4a49": "0x6c6b935b8bbd400000",
  	"0xd703c6a4f11d60194579d58c2766a7ef16c30a29": "0x6c6b935b8bbd400000",
  	"0xd7052519756af42590f15391b723a03fa564a951": "0xfa3631480d01fd8000",
  	"0xd70a612bd6dda9eab0dddcff4aaf4122d38feae4": "0x1d460162f516f00000",
  	"0xd70ad2c4e9eebfa637ef56bd486ad2a1e5bce093": "0xad78ebc5ac6200000",
  	"0xd7140c8e5a4307fab0cc27badd9295018bf87970": "0x5f1016b5076d00000",
  	"0xd7164aa261c09ad9b2b5068d453ed8eb6aa13083": "0xa2a15d09519be00000",
  	"0xd71e43a45177ad51cbe0f72184a5cb503917285a": "0xad78ebc5ac6200000",
  	"0xd71fb130f0150c565269e00efb43902b52a455a6": "0xad78ebc5ac6200000",
  	"0xd7225738dcf3578438f8e7c8b3837e42e04a262f": "0x182b8cebbb83aa0000",
  	"0xd7274d50804d9c77da93fa480156efe57ba501de": "0x692ae8897081d00000",
  	"0xd731bb6b5f3c37395e09ceaccd14a918a6060789": "0xd5967be4fc3f100000",
  	"0xd73ed2d985b5f21b55b274643bc6da031d8edd8d": "0xa6dd90cae5114480000",
  	"0xd744ac7e5310be696a63b003c40bd039370561c6": "0x5a87e7d7f5f6580000",
  	"0xd74a6e8d6aab34ce85976814c1327bd6ea0784d2": "0x152d02c7e14af6800000",
  	"0xd75a502a5b677287470f65c5aa51b87c10150572": "0x3130b4646385740000",
  	"0xd76dbaebc30d4ef67b03e6e6ecc6d84e004d502d": "0x6d76b9188e13850000",
  	"0xd771d9e0ca8a08a113775731434eb3270599c40d": "0x1158e460913d00000",
  	"0xd7788ef28658aa06cc53e1f3f0de58e5c371be78": "0x16a6502f15a1e540000",
  	"0xd77892e2273b235d7689e430e7aeed9cbce8a1f3": "0x6c6b935b8bbd400000",
  	"0xd781f7fc09184611568570b4986e2c72872b7ed0": "0x1159561065d5d0000",
  	"0xd785a8f18c38b9bc4ffb9b8fa8c7727bd642ee1c": "0x3635c9adc5dea00000",
  	"0xd78ecd25adc86bc2051d96f65364866b42a426b7": "0xd23058bf2f26120000",
  	"0xd78f84e38944a0e0255faece48ba4950d4bd39d2": "0x10f0cf064dd59200000",
  	"0xd79483f6a8444f2549d611afe02c432d15e11051": "0x1158e460913d00000",
  	"0xd79835e404fb86bf845fba090d6ba25e0c8866a6": "0x821ab0d44149800000",
  	"0xd79aff13ba2da75d46240cac0a2467c656949823": "0x5dc892aa1131c80000",
  	"0xd79db5ab43621a7a3da795e58929f3dd25af67d9": "0x6c6acc67d7b1d40000",
  	"0xd7a1431ee453d1e49a0550d1256879b4f5d10201": "0x5a87e7d7f5f6580000",
  	"0xd7ad09c6d32657685355b5c6ec8e9f57b4ebb982": "0x6acb3df27e1f880000",
  	"0xd7b740dff8c457668fdf74f6a266bfc1dcb723f9": "0x1158e460913d00000",
  	"0xd7c2803ed7b0e0837351411a8e6637d168bc5b05": "0x641daf5c91bd9358000",
  	"0xd7c6265dea11876c903b718e4cd8ab24fe265bde": "0x6c6b935b8bbd400000",
  	"0xd7ca7fdcfebe4588eff5421d1522b61328df7bf3": "0xd8e6001e6c302b0000",
  	"0xd7cdbd41fff20df727c70b6255c1ba7606055468": "0xad78ebc5ac6200000",
  	"0xd7d157e4c0a96437a6d285741dd23ec4361fa36b": "0x6c6b935b8bbd400000",
  	"0xd7d2c6fca8ad1f75395210b57de5dfd673933909": "0x126e72a69a50d00000",
  	"0xd7d3c75920590438b82c3e9515be2eb6ed7a8b1a": "0xcb49b44ba602d800000",
  	"0xd7d7f2caa462a41b3b30a34aeb3ba61010e2626f": "0x6c6b935b8bbd400000",
  	"0xd7e74afdbad55e96cebc5a374f2c8b768680f2b0": "0x55de6a779bbac0000",
  	"0xd7eb903162271c1afa35fe69e37322c8a4d29b11": "0x21e19e0c9bab2400000",
  	"0xd7ebddb9f93987779b680155375438db65afcb6a": "0x5741afeff944c0000",
  	"0xd7ef340e66b0d7afcce20a19cb7bfc81da33d94e": "0xa2a15d09519be00000",
  	"0xd7f370d4bed9d57c6f49c999de729ee569d3f4e4": "0xad78ebc5ac6200000",
  	"0xd7fa5ffb6048f96fb1aba09ef87b1c11dd7005e4": "0x3635c9adc5dea00000",
  	"0xd8069f84b521493f4715037f3226b25f33b60586": "0x678a932062e4180000",
  	"0xd815e1d9f4e2b5e57e34826b7cfd8881b8546890": "0xf015f25736420000",
  	"0xd81bd54ba2c44a6f6beb1561d68b80b5444e6dc6": "0x3f170d7ee43c430000",
  	"0xd82251456dc1380f8f5692f962828640ab9f2a03": "0x1088b53b2c202be0000",
  	"0xd82c6fedbdac98af2eed10b00f32b00056ca5a6d": "0xad78ebc5ac6200000",
  	"0xd82fd9fdf6996bedad2843159c06f37e0924337d": "0x5b8ccedc5aa7b00000",
  	"0xd83ad260e9a6f432fb6ea28743299b4a09ad658c": "0x6c6b935b8bbd400000",
  	"0xd843ee0863ce933e22f89c802d31287b9671e81c": "0xb98bc829a6f90000",
  	"0xd84b922f7841fc5774f00e14604ae0df42c8551e": "0xd96fce90cfabcc0000",
  	"0xd855b03ccb029a7747b1f07303e0a664793539c8": "0x6c6b935b8bbd400000",
  	"0xd85fdeaf2a61f95db902f9b5a53c9b8f9266c3ac": "0x6cf65a7e9047280000",
  	"0xd8715ef9176f850b2e30eb8e382707f777a6fbe9": "0x6c6b935b8bbd400000",
  	"0xd874b9dfae456a929ba3b1a27e572c9b2cecdfb3": "0x93739534d28680000",
  	"0xd8930a39c77357c30ad3a060f00b06046331fd62": "0x2c73c937742c500000",
  	"0xd89bc271b27ba3ab6962c94a559006ae38d5f56a": "0x6c6b935b8bbd400000",
  	"0xd8b77db9b81bbe90427b62f702b201ffc29ff618": "0x326d1e4396d45c0000",
  	"0xd8cd64e0284eec53aa4639afc4750810b97fab56": "0x1158e460913d00000",
  	"0xd8d64384249b776794063b569878d5e3b530a4b2": "0x9a043d0b2f9568000",
  	"0xd8d65420c18c2327cc5af97425f857e4a9fd51b3": "0x5f68e8131ecf800000",
  	"0xd8e5c9675ef4deed266b86956fc4590ea7d4a27d": "0x3635c9adc5dea00000",
  	"0xd8e8474292e7a051604ca164c0707783bb2885e8": "0x2d4ca05e2b43ca80000",
  	"0xd8eb78503ec31a54a90136781ae109004c743257": "0x3635c9adc5dea00000",
  	"0xd8eef4cf4beb01ee20d111748b61cb4d3f641a01": "0x9489237adb9a500000",
  	"0xd8f4bae6f84d910d6d7d5ac914b1e68372f94135": "0x56bc75e2d63100000",
  	"0xd8f62036f03b7635b858f1103f8a1d9019a892b6": "0x2b5e3af16b1880000",
  	"0xd8f665fd8cd5c2bcc6ddc0a8ae521e4dc6aa6060": "0x5c283d410394100000",
  	"0xd8f9240c55cff035523c6d5bd300d370dc8f0c95": "0xf732b66015a540000",
  	"0xd8f94579496725b5cb53d7985c989749aff849c0": "0x39992648a23c8a00000",
  	"0xd8fdf546674738c984d8fab857880b3e4280c09e": "0x1158e460913d00000",
  	"0xd8fe088fffce948f5137ee23b01d959e84ac4223": "0xc5b54a94fc0170000",
  	"0xd90f3009db437e4e11c780bec8896f738d65ef0d": "0xd8d726b7177a800000",
  	"0xd9103bb6b67a55a7fece2d1af62d457c2178946d": "0x3635c9adc5dea00000",
  	"0xd913f0771949753c4726acaa2bd3619c5c20ff77": "0xa2a15d09519be00000",
  	"0xd91d889164479ce436ece51763e22cda19b22d6b": "0xb66d88126800880000",
  	"0xd929c65d69d5bbaea59762662ef418bc21ad924a": "0x3635c9adc5dea00000",
  	"0xd930b27a78876485d0f48b70dd5336549679ca8f": "0x22b1c8c1227a00000",
  	"0xd931ac2668ba6a84481ab139735aec14b7bfbabf": "0x6c6b935b8bbd400000",
  	"0xd9383d4b6d17b3f9cd426e10fb944015c0d44bfb": "0x2b5e3af16b18800000",
  	"0xd942de4784f7a48716c0fd4b9d54a6e54c5f2f3e": "0x43c33c1937564800000",
  	"0xd944c8a69ff2ca1249690c1229c7192f36251062": "0x6acb3df27e1f880000",
  	"0xd94a57882a52739bbe2a0647c80c24f58a2b4f1c": "0x48b54e2adbe12b0000",
  	"0xd95342953c8a21e8b635eefac7819bea30f17047": "0x13f06c7ffef05d400000",
  	"0xd95c90ffbe5484864780b867494a83c89256d6e4": "0x58e7926ee858a00000",
  	"0xd96711540e2e998343d4f590b6fc8fac3bb8b31d": "0x5f5a4068b71cb00000",
  	"0xd96ac2507409c7a383ab2eee1822a5d738b36b56": "0xad78ebc5ac6200000",
  	"0xd96db33b7b5a950c3efa2dc31b10ba10a532ef87": "0x6c6b935b8bbd400000",
  	"0xd9775965b716476675a8d513eb14bbf7b07cd14a": "0x1132e6d2d23c5e40000",
  	"0xd97bc84abd47c05bbf457b2ef659d61ca5e5e48f": "0x69d17119dc5a80000",
  	"0xd97f4526dea9b163f8e8e33a6bcf92fb907de6ec": "0xf654aaf4db2f00000",
  	"0xd97fe6f53f2a58f6d76d752adf74a8a2c18e9074": "0x10cdf9b69a43570000",
  	"0xd99999a2490d9494a530cae4daf38554f4dd633e": "0x68155a43676e00000",
  	"0xd99df7421b9382e42c89b006c7f087702a0757c0": "0x1a055690d9db800000",
  	"0xd9b783d31d32adc50fa3eacaa15d92b568eaeb47": "0x733af90374c1b280000",
  	"0xd9d370fec63576ab15b318bf9e58364dc2a3552a": "0x56bc75e2d63100000",
  	"0xd9d42fd13ebd4bf69cac5e9c7e82483ab46dd7e9": "0x121ea68c114e5100000",
  	"0xd9e27eb07dfc71a706060c7f079238ca93e88539": "0x3635c9adc5dea00000",
  	"0xd9e3857efd1e202a441770a777a49dcc45e2e0d3": "0xc1daf81d8a3ce0000",
  	"0xd9ec2efe99ff5cf00d03a8317b92a24aef441f7e": "0x6c6b935b8bbd400000",
  	"0xd9ec8fe69b7716c0865af888a11b2b12f720ed33": "0xd8d726b7177a800000",
  	"0xd9f1b26408f0ec67ad1d0d6fe22e8515e1740624": "0x14d1120d7b1600000",
  	"0xd9f547f2c1de0ed98a53d161df57635dd21a00bd": "0x556f64c1fe7fa0000",
  	"0xd9ff115d01266c9f73b063c1c238ef3565e63b36": "0x24dce54d34a1a00000",
  	"0xda06044e293c652c467fe74146bf185b21338a1c": "0x3635c9adc5dea00000",
  	"0xda0b48e489d302b4b7bf204f957c1c9be383b0df": "0x6c6b935b8bbd400000",
  	"0xda0d4b7ef91fb55ad265f251142067f10376ced6": "0x43c33c1937564800000",
  	"0xda10978a39a46ff0bb848cf65dd9c77509a6d70e": "0x6c6b935b8bbd400000",
  	"0xda16dd5c3d1a2714358fe3752cae53dbab2be98c": "0x41bad155e6512200000",
  	"0xda214c023e2326ff696c00393168ce46ffac39ec": "0x3635c9adc5dea00000",
  	"0xda2a14f9724015d79014ed8e5909681d596148f1": "0x2a10f0f8a91ab8000",
  	"0xda2ad58e77deddede2187646c465945a8dc3f641": "0x23c757072b8dd00000",
  	"0xda3017c150dd0dce7fcf881b0a48d0d1c756c4c7": "0x56bf91b1a65eb0000",
  	"0xda34b2eae30bafe8daeccde819a794cd89e09549": "0x6c6b935b8bbd400000",
  	"0xda4a5f557f3bab390a92f49b9b900af30c46ae80": "0x21e19e0c9bab2400000",
  	"0xda505537537ffb33c415fec64e69bae090c5f60f": "0x8ac7230489e800000",
  	"0xda698d64c65c7f2b2c7253059cd3d181d899b6b7": "0x1004e2e45fb7ee0000",
  	"0xda7732f02f2e272eaf28df972ecc0ddeed9cf498": "0xb20bfbf6967890000",
  	"0xda7ad025ebde25d22243cb830ea1d3f64a566323": "0x1b1ae4d6e2ef500000",
  	"0xda855d53477f505ec4c8d5e8bb9180d38681119c": "0x12f939c99edab800000",
  	"0xda875e4e2f3cabe4f37e0eaed7d1f6dcc6ffef43": "0x6c6b935b8bbd400000",
  	"0xda8bbee182e455d2098acb338a6d45b4b17ed8b6": "0x6c6b935b8bbd400000",
  	"0xda982e9643ffece723075a40fe776e5ace04b29b": "0x8b8b6c9999bf20000",
  	"0xda9f55460946d7bfb570ddec757ca5773b58429a": "0x1b845d769eb4480000",
  	"0xdaa1bd7a9148fb865cd612dd35f162861d0f3bdc": "0xa638ab72d92c138000",
  	"0xdaa63cbda45dd487a3f1cd4a746a01bb5e060b90": "0x10416d9b02a89240000",
  	"0xdaa776a6754469d7b9267a89b86725e740da0fa0": "0x6acb3df27e1f880000",
  	"0xdaac91c1e859d5e57ed3084b50200f9766e2c52b": "0x15af1d78b58c400000",
  	"0xdaacdaf42226d15cb1cf98fa15048c7f4ceefe69": "0x1043561a8829300000",
  	"0xdab6bcdb83cf24a0ae1cb21b3b5b83c2f3824927": "0xa968163f0a57b400000",
  	"0xdabb0889fc042926b05ef57b2520910abc4b4149": "0x6c6b935b8bbd400000",
  	"0xdabc225042a6592cfa13ebe54efa41040878a5a2": "0xe11fad5d85ca30000",
  	"0xdac0c177f11c5c3e3e78f2efd663d13221488574": "0x3635c9adc5dea00000",
  	"0xdad136b88178b4837a6c780feba226b98569a94c": "0xad78ebc5ac6200000",
  	"0xdadbfafd8b62b92a24efd75256dd83abdbd7bbdb": "0x11164759ffb320000",
  	"0xdadc00ab7927603c2fcf31cee352f80e6c4d6351": "0x6c66e9a55378b80000",
  	"0xdae0d33eaa341569fa9ff5982684854a4a328a6e": "0x3635c9adc5dea00000",
  	"0xdae7201eab8c063302930d693929d07f95e71962": "0x91aec028b419810000",
  	"0xdaedd4ad107b271e89486cbf80ebd621dd974578": "0x6c6b935b8bbd400000",
  	"0xdb04fad9c49f9e880beb8fcf1d3a3890e4b3846f": "0x435ae6cc0c58e50000",
  	"0xdb0cc78f74d9827bdc8a6473276eb84fdc976212": "0x6c6b935b8bbd400000",
  	"0xdb1293a506e90cad2a59e1b8561f5e66961a6788": "0x6c6b935b8bbd400000",
  	"0xdb19a3982230368f0177219cb10cb259cdb2257c": "0x6c6b935b8bbd400000",
  	"0xdb23a6fef1af7b581e772cf91882deb2516fc0a7": "0xad78ebc5ac6200000",
  	"0xdb244f97d9c44b158a40ed9606d9f7bd38913331": "0x58788cb94b1d80000",
  	"0xdb288f80ffe232c2ba47cc94c763cf6fc9b82b0d": "0x49b9ca9a694340000",
  	"0xdb2a0c9ab64df58ddfb1dbacf8ba0d89c85b31b4": "0xd8d726b7177a800000",
  	"0xdb34745ede8576b499db01beb7c1ecda85cf4abe": "0x4563918244f400000",
  	"0xdb3f258ab2a3c2cf339c4499f75a4bd1d3472e9e": "0x5150ae84a8cdf00000",
  	"0xdb4bc83b0e6baadb1156c5cf06e0f721808c52c7": "0x2fb474098f67c00000",
  	"0xdb63122de7037da4971531fae9af85867886c692": "0xf0425b0641f340000",
  	"0xdb6c2a73dac7424ab0d031b66761122566c01043": "0xa2a15d09519be00000",
  	"0xdb6e560c9bc620d4bea3a94d47f7880bf47f2d5f": "0x4da0fdfcf05760000",
  	"0xdb6ff71b3db0928f839e05a7323bfb57d29c87aa": "0x3154c9729d05780000",
  	"0xdb73460b59d8e85045d5e752e62559875e42502e": "0x36330322d5238c0000",
  	"0xdb77b88dcb712fd17ee91a5b94748d720c90a994": "0x6c6b935b8bbd400000",
  	"0xdb7d4037081f6c65f9476b0687d97f1e044d0a1d": "0x23c757072b8dd00000",
  	"0xdb882eacedd0eff263511b312adbbc59c6b8b25b": "0x1ed4fde7a2236b00000",
  	"0xdb9371b30c4c844e59e03e924be606a938d1d310": "0x6c6b935b8bbd400000",
  	"0xdba4796d0ceb4d3a836b84c96f910afc103f5ba0": "0x908f493f737410000",
  	"0xdbadc61ed5f0460a7f18e51b2fb2614d9264a0e0": "0x22b1c8c1227a00000",
  	"0xdbb6ac484027041642bbfd8d80f9d0c1cf33c1eb": "0x6c6b935b8bbd400000",
  	"0xdbbcbb79bf479a42ad71dbcab77b5adfaa872c58": "0x5dc892aa1131c80000",
  	"0xdbc1ce0e49b1a705d22e2037aec878ee0d75c703": "0xd8d726b7177a80000",
  	"0xdbc1d0ee2bab531140de137722cd36bdb4e47194": "0xad78ebc5ac6200000",
  	"0xdbc59ed88973dead310884223af49763c05030f1": "0x1158e460913d00000",
  	"0xdbc66965e426ff1ac87ad6eb78c1d95271158f9f": "0xfc936392801c0000",
  	"0xdbcbcd7a57ea9db2349b878af34b1ad642a7f1d1": "0xad78ebc5ac6200000",
  	"0xdbd51cdf2c3bfacdff106221de2e19ad6d420414": "0x5f68e8131ecf800000",
  	"0xdbd71efa4b93c889e76593de609c3b04cbafbe08": "0x1158e460913d00000",
  	"0xdbf5f061a0f48e5e69618739a77d2ec19768d201": "0x83d6c7aab63600000",
  	"0xdbf8b13967f55125272de0562536c450ba5655a0": "0x6ef578f06e0ccb0000",
  	"0xdbfb1bb464b8a58e500d2ed8de972c45f5f1c0fb": "0x56bc75e2d631000000",
  	"0xdc067ed3e12d711ed475f5156ef7e71a80d934b9": "0x205b4dfa1ee74780000",
  	"0xdc087f9390fb9e976ac23ab689544a0942ec2021": "0x62a992e53a0af00000",
  	"0xdc1eb9b6e64351f56424509645f83e79eee76cf4": "0xd8d726b7177a800000",
  	"0xdc1f1979615f082140b8bb78c67b27a1942713b1": "0x340aad21b3b700000",
  	"0xdc23b260fcc26e7d10f4bd044af794579460d9da": "0x1b1b6bd7af64c70000",
  	"0xdc29119745d2337320da51e19100c948d980b915": "0x8ac7230489e800000",
  	"0xdc2d15a69f6bb33b246aef40450751c2f6756ad2": "0x6c341080bd1fb00000",
  	"0xdc3dae59ed0fe18b58511e6fe2fb69b219689423": "0x56bc75e2d63100000",
  	"0xdc3f0e7672f71fe7525ba30b9755183a20b9166a": "0x2089cf57b5b3e968000",
  	"0xdc4345d6812e870ae90c568c67d2c567cfb4f03c": "0x16b352da5e0ed300000",
  	"0xdc44275b1715baea1b0345735a29ac42c9f51b4f": "0x3f19beb8dd1ab00000",
  	"0xdc46c13325cd8edf0230d068896486f007bf4ef1": "0x487a9a304539440000",
  	"0xdc51b2dc9d247a1d0e5bc36ca3156f7af21ff9f6": "0x3635c9adc5dea00000",
  	"0xdc5305b4020a06b49d657c7ca34c35c91c5f2c56": "0x17df6c10dbeba970000",
  	"0xdc57345b38e0f067c9a31d9deac5275a10949321": "0xad78ebc5ac6200000",
  	"0xdc57477dafa42f705c7fe40eae9c81756e0225f1": "0x1b1b8128a7416e0000",
  	"0xdc5f5ad663a6f263327d64cac9cb133d2c960597": "0x6c6b935b8bbd400000",
  	"0xdc703a5f3794c84d6cb3544918cae14a35c3bd4f": "0x6449e84e47a8a80000",
  	"0xdc738fb217cead2f69594c08170de1af10c419e3": "0x152d02c7e14af6800000",
  	"0xdc76e85ba50b9b31ec1e2620bce6e7c8058c0eaf": "0x1158e460913d00000",
  	"0xdc83b6fd0d512131204707eaf72ea0c8c9bef976": "0x6c6b935b8bbd400000",
  	"0xdc8c2912f084a6d184aa73638513ccbc326e0102": "0x4633bc36cbc2dc0000",
  	"0xdc911cf7dc5dd0813656670528e9338e67034786": "0x6c6b935b8bbd400000",
  	"0xdcb03bfa6c1131234e56b7ea7c4f721487546b7a": "0x487a9a304539440000",
  	"0xdcb64df43758c7cf974fa660484fbb718f8c67c1": "0x43c33c1937564800000",
  	"0xdcc52d8f8d9fc742a8b82767f0555387c563efff": "0x1b1ae4d6e2ef500000",
  	"0xdccb370ed68aa922283043ef7cad1b9d403fc34a": "0xd8d726b7177a800000",
  	"0xdccca42045ec3e16508b603fd936e7fd7de5f36a": "0x11164759ffb320000",
  	"0xdcd10c55bb854f754434f1219c2c9a98ace79f03": "0xd8d8583fa2d52f0000",
  	"0xdcd5bca2005395b675fde5035659b26bfefc49ee": "0xaadec983fcff40000",
  	"0xdcdbbd4e2604e40e1710cc6730289dccfad3892d": "0xf95dd2ec27cce00000",
  	"0xdce30c31f3ca66721ecb213c809aab561d9b52e4": "0x6c6b935b8bbd400000",
  	"0xdcf33965531380163168fc11f67e89c6f1bc178a": "0x122776853406b08000",
  	"0xdcf6b657266e91a4dae6033ddac15332dd8d2b34": "0x5f68e8131ecf800000",
  	"0xdcf9719be87c6f46756db4891db9b611d2469c50": "0x3635c9adc5dea00000",
  	"0xdcfff3e8d23c2a34b56bd1b3bd45c79374432239": "0x10f0cf064dd59200000",
  	"0xdd04eee74e0bf30c3f8d6c2c7f52e0519210df93": "0x4563918244f400000",
  	"0xdd26b429fd43d84ec179825324bad5bfb916b360": "0x116bf95bc8432980000",
  	"0xdd2a233adede66fe1126d6c16823b62a021feddb": "0x6c6b935b8bbd400000",
  	"0xdd2bdfa917c1f310e6fa35aa8af16939c233cd7d": "0x15af1d78b58c400000",
  	"0xdd35cfdbcb993395537aecc9f59085a8d5ddb6f5": "0x3635c9adc5dea00000",
  	"0xdd47189a3e64397167f0620e484565b762bfbbf4": "0x6449e84e47a8a80000",
  	"0xdd4dd6d36033b0636fcc8d0938609f4dd64f4a86": "0x340aad21b3b700000",
  	"0xdd4f5fa2111db68f6bde3589b63029395b69a92d": "0x8963dd8c2c5e00000",
  	"0xdd63042f25ed32884ad26e3ad959eb94ea36bf67": "0x484d7fde7d593f00000",
  	"0xdd65f6e17163b5d203641f51cc7b24b00f02c8fb": "0xad78ebc5ac6200000",
  	"0xdd6c062193eac23d2fdbf997d5063a346bb3b470": "0x1158e460913d00000",
  	"0xdd7bcda65924aaa49b80984ae173750258b92847": "0x21e19e0c9bab2400000",
  	"0xdd7ff441ba6ffe3671f3c0dabbff1823a5043370": "0x6c6b935b8bbd400000",
  	"0xdd8254121a6e942fc90828f2431f511dad7f32e6": "0xa39b29e1f360e80000",
  	"0xdd8af9e7765223f4446f44d3d509819a3d3db411": "0x21e19e0c9bab2400000",
  	"0xdd95dbe30f1f1877c5dd7684aeef302ab6885192": "0x1c5d8d6eb3e32500000",
  	"0xdd967c4c5f8ae47e266fb416aad1964ee3e7e8c3": "0x1a420db02bd7d580000",
  	"0xdd9b485a3b1cd33a6a9c62f1e5bee92701856d25": "0xc3383ed031b7e8000",
  	"0xdda371e600d30688d4710e088e02fdf2b9524d5f": "0x177224aa844c7200000",
  	"0xdda4ed2a58a8dd20a73275347b580d71b95bf99a": "0x15a13cc201e4dc0000",
  	"0xdda4ff7de491c687df4574dd1b17ff8f246ba3d1": "0x42684a41abfd8400000",
  	"0xddab6b51a9030b40fb95cf0b748a059c2417bec7": "0x6c6b935b8bbd400000",
  	"0xddab75fb2ff9fecb88f89476688e2b00e367ebf9": "0x41bad155e6512200000",
  	"0xddabf13c3c8ea4e3d73d78ec717afafa430e5479": "0x8cf23f909c0fa000000",
  	"0xddac312a9655426a9c0c9efa3fd82559ef4505bf": "0x15be6174e1912e0000",
  	"0xddac6bf4bbdd7d597d9c686d0695593bedccc7fa": "0x2ee449550898e40000",
  	"0xddbd2b932c763ba5b1b7ae3b362eac3e8d40121a": "0x21e19e0c9bab2400000",
  	"0xddbddd1bbd38ffade0305d30f02028d92e9f3aa8": "0x6c6b935b8bbd400000",
  	"0xddbee6f094eae63420b003fb4757142aea6cd0fd": "0x6c6b935b8bbd400000",
  	"0xddd69c5b9bf5eb5a39cee7c3341a120d973fdb34": "0x6bc14b8f8e1b350000",
  	"0xdddd7b9e6eab409b92263ac272da801b664f8a57": "0x69e10de76676d0800000",
  	"0xdde670d01639667576a22dd05d3246d61f06e083": "0x1731790534df20000",
  	"0xdde77a4740ba08e7f73fbe3a1674912931742eeb": "0x434fe4d4382f1d48000",
  	"0xdde8f0c31b7415511dced1cd7d46323e4bd12232": "0x57473d05dabae80000",
  	"0xdde969aef34ea87ac299b7597e292b4a0155cc8a": "0x1032f2594a01738000",
  	"0xddf0cce1fe996d917635f00712f4052091dff9ea": "0x6c6b935b8bbd400000",
  	"0xddf3ad76353810be6a89d731b787f6f17188612b": "0x43c33c1937564800000",
  	"0xddf5810a0eb2fb2e32323bb2c99509ab320f24ac": "0x3ca5c66d9bc44300000",
  	"0xddf95c1e99ce2f9f5698057c19d5c94027ee4a6e": "0x14542ba12a337c00000",
  	"0xddfafdbc7c90f1320e54b98f374617fbd01d109f": "0xb98bc829a6f90000",
  	"0xddfcca13f934f0cfbe231da13039d70475e6a1d0": "0x3638221660a5aa8000",
  	"0xde027efbb38503226ed871099cb30bdb02af1335": "0x3635c9adc5dea00000",
  	"0xde06d5ea777a4eb1475e605dbcbf43444e8037ea": "0xa968163f0a57b400000",
  	"0xde07fb5b7a464e3ba7fbe09e9acb271af5338c58": "0x2b5e3af16b1880000",
  	"0xde1121829c9a08284087a43fbd2fc1142a3233b4": "0x3635c9adc5dea00000",
  	"0xde176b5284bcee3a838ba24f67fc7cbf67d78ef6": "0x209ce08c962b00000",
  	"0xde212293f8f1d231fa10e609470d512cb8ffc512": "0x6c6b935b8bbd400000",
  	"0xde30e49e5ab313214d2f01dcabce8940b81b1c76": "0xaadec983fcff40000",
  	"0xde33d708a3b89e909eaf653b30fdc3a5d5ccb4b3": "0x99c88229fd4c20000",
  	"0xde374299c1d07d79537385190f442ef9ca24061f": "0x73f75d1a085ba0000",
  	"0xde42fcd24ce4239383304367595f068f0c610740": "0x2722a70f1a9a00000",
  	"0xde50868eb7e3c71937ec73fa89dd8b9ee10d45aa": "0x3635c9adc5dea00000",
  	"0xde55de0458f850b37e4d78a641dd2eb2dd8f38ce": "0xd8d726b7177a800000",
  	"0xde5b005fe8daae8d1f05de3eda042066c6c4691c": "0x3ba1910bf341b00000",
  	"0xde612d0724e84ea4a7feaa3d2142bd5ee82d3201": "0x1158e460913d00000",
  	"0xde6d363106cc6238d2f092f0f0372136d1cd50c6": "0x121ea68c114e5100000",
  	"0xde7dee220f0457a7187d56c1c41f2eb00ac56021": "0x2225f39c85052a0000",
  	"0xde82cc8d4a1bb1d9434392965b3e80bad3c03d4f": "0x50186e75de97a60000",
  	"0xde97f4330700b48c496d437c91ca1de9c4b01ba4": "0x9dcc0515b56e0c0000",
  	"0xde9eff4c798811d968dccb460d9b069cf30278e0": "0x15af1d78b58c400000",
  	"0xdeb1bc34d86d4a4dde2580d8beaf074eb0e1a244": "0x55a6e79ccd1d300000",
  	"0xdeb2495d6aca7b2a6a2d138b6e1a42e2dc311fdd": "0x6c6b935b8bbd400000",
  	"0xdeb97254474c0d2f5a7970dcdb2f52fb1098b896": "0x3635c9adc5dea00000",
  	"0xdeb9a49a43873020f0759185e20bbb4cf381bb8f": "0xb78edb0bf2e5e0000",
  	"0xdebbdd831e0f20ae6e378252decdf92f7cf0c658": "0x6c6b935b8bbd400000",
  	"0xdec3eec2640a752c466e2b7e7ee685afe9ac41f4": "0x47c99753596b288000",
  	"0xdec82373ade8ebcf2acb6f8bc2414dd7abb70d77": "0xad78ebc5ac6200000",
  	"0xdec8a1a898f1b895d8301fe64ab3ad5de941f689": "0x2ab4f67e8a730f8000",
  	"0xdec99e972fca7177508c8e1a47ac22d768acab7c": "0x6c6b935b8bbd400000",
  	"0xded877378407b94e781c4ef4af7cfc5bc220b516": "0x143179d86911020000",
  	"0xdee942d5caf5fac11421d86b010b458e5c392990": "0xd8d726b7177a800000",
  	"0xdeee2689fa9006b59cf285237de53b3a7fd01438": "0x186579f29e20250000",
  	"0xdefddfd59b8d2c154eecf5c7c167bf0ba2905d3e": "0x512cb5e2647420000",
  	"0xdefe9141f4704599159d7b223de42bffd80496b3": "0x56bc75e2d63100000",
  	"0xdf098f5e4e3dffa51af237bda8652c4f73ed9ca6": "0x1b36a6444a3e180000",
  	"0xdf0d08617bd252a911df8bd41a39b83ddf809673": "0x21e19e0c9bab2400000",
  	"0xdf0ff1f3d27a8ec9fb8f6b0cb254a63bba8224a5": "0xecc5202945d0020000",
  	"0xdf1fa2e20e31985ebe2c0f0c93b54c0fb67a264b": "0xad78ebc5ac6200000",
  	"0xdf211cd21288d6c56fae66c3ff54625dd4b15427": "0x8786cd764e1f2c0000",
  	"0xdf236bf6abf4f3293795bf0c28718f93e3b1b36b": "0x487a9a304539440000",
  	"0xdf31025f5649d2c6eea41ed3bdd3471a790f759a": "0x1158e460913d00000",
  	"0xdf37c22e603aedb60a627253c47d8ba866f6d972": "0x5150ae84a8cdf000000",
  	"0xdf3b72c5bd71d4814e88a62321a93d4011e3578b": "0xd8d726b7177a800000",
  	"0xdf3f57b8ee6434d047223def74b20f63f9e4f955": "0xd9462c6cb4b5a0000",
  	"0xdf44c47fc303ac76e74f97194cca67b5bb3c023f": "0x2009c5c8bf6fdc0000",
  	"0xdf47a61b72535193c561cccc75c3f3ce0804a20e": "0x15935c0b4e3d780000",
  	"0xdf47a8ef95f2f49f8e6f58184154145d11f72797": "0x678a932062e4180000",
  	"0xdf53003346d65c5e7a646bc034f2b7d32fcbe56a": "0x6c6b935b8bbd400000",
  	"0xdf57353aaff2aadb0a04f9014e8da7884e86589c": "0x84886a66e4fb00000",
  	"0xdf60f18c812a11ed4e2776e7a80ecf5e5305b3d6": "0x30ca024f987b900000",
  	"0xdf6485c4297ac152b289b19dde32c77ec417f47d": "0x3635c9adc5dea00000",
  	"0xdf660a91dab9f730f6190d50c8390561500756ca": "0x6c6b935b8bbd400000",
  	"0xdf6ed6006a6abe886ed33d95a4de28fc12183927": "0x3154c9729d05780000",
  	"0xdf8510793eee811c2dab1c93c6f4473f30fbef5b": "0x3635c9adc5dea00000",
  	"0xdf8d48b1eb07b3c217790e6c2df04dc319e7e848": "0x1b1ae4d6e2ef500000",
  	"0xdfa6b8b8ad3184e357da282951d79161cfb089bc": "0x15af1d78b58c400000",
  	"0xdfaf31e622c03d9e18a0ddb8be60fbe3e661be0a": "0x21e171a3ec9f72c0000",
  	"0xdfb1626ef48a1d7d7552a5e0298f1fc23a3b482d": "0x5ce895dd949efa0000",
  	"0xdfb4d4ade52fcc818acc7a2c6bb2b00224658f78": "0x1a420db02bd7d580000",
  	"0xdfbd4232c17c407a980db87ffbcda03630e5c459": "0x1dfc7f924923530000",
  	"0xdfcbdf09454e1a5e4a40d3eef7c5cf1cd3de9486": "0xd8d726b7177a800000",
  	"0xdfdbcec1014b96da2158ca513e9c8d3b9af1c3d0": "0x6c6b935b8bbd400000",
  	"0xdfded2574b27d1613a7d98b715159b0d00baab28": "0x43c33c1937564800000",
  	"0xdfdf43393c649caebe1bb18059decb39f09fb4e8": "0x15af1d78b58c400000",
  	"0xdfe3c52a92c30396a4e33a50170dc900fcf8c9cf": "0x2b5e3af16b1880000",
  	"0xdfe549fe8430e552c6d07cc3b92ccd43b12fb50f": "0x48875eaf6562a0000",
  	"0xdfe929a61c1b38eddbe82c25c2d6753cb1e12d68": "0x15d1cf4176aeba0000",
  	"0xdff1b220de3d8e9ca4c1b5be34a799bcded4f61c": "0x14e4e353ea39420000",
  	"0xdff4007931786593b229efe5959f3a4e219e51af": "0x10afc1ade3b4ed40000",
  	"0xdffcea5421ec15900c6ecfc777184e140e209e24": "0x115473824344e0000",
  	"0xe001aba77c02e172086c1950fffbcaa30b83488f": "0x6acb3df27e1f880000",
  	"0xe00484788db50fc6a48e379d123e508b0f6e5ab1": "0x3635c9adc5dea00000",
  	"0xe0060462c47ff9679baef07159cae08c29f274a9": "0x6c6b935b8bbd400000",
  	"0xe00d153b10369143f97f54b8d4ca229eb3e8f324": "0x83d6c7aab63600000",
  	"0xe012db453827a58e16c1365608d36ed658720507": "0x6c6b935b8bbd400000",
  	"0xe01547ba42fcafaf93938becf7699f74290af74f": "0x6c6b935b8bbd400000",
  	"0xe016dc138e25815b90be3fe9eee8ffb2e105624f": "0x1b1ae4d6e2ef500000",
  	"0xe01859f242f1a0ec602fa8a3b0b57640ec89075e": "0x1e162c177be5cc0000",
  	"0xe020e86362b487752836a6de0bc02cd8d89a8b6a": "0x14542ba12a337c00000",
  	"0xe023f09b2887612c7c9cf1988e3a3a602b3394c9": "0x6c6b935b8bbd400000",
  	"0xe0272213e8d2fd3e96bd6217b24b4ba01b617079": "0x1158e460913d00000",
  	"0xe02b74a47628be315b1f76b315054ad44ae9716f": "0xd8d726b7177a800000",
  	"0xe03220c697bcd28f26ef0b74404a8beb06b2ba7b": "0x1b1ae4d6e2ef5000000",
  	"0xe0352fdf819ba265f14c06a6315c4ac1fe131b2e": "0x3635c9adc5dea00000",
  	"0xe0388aeddd3fe2ad56f85748e80e710a34b7c92e": "0x1b1ae4d6e2ef500000",
  	"0xe03c00d00388ecbf4f263d0ac778bb41a57a40d9": "0x3636c9796436740000",
  	"0xe04920dc6ecc1d6ecc084f88aa0af5db97bf893a": "0x9ddc1e3b901180000",
  	"0xe04972a83ca4112bc871c72d4ae1616c2f0728db": "0xe81c77f29a32f0000",
  	"0xe04ff5e5a7e2af995d8857ce0290b53a2b0eda5d": "0x3635c9adc5dea00000",
  	"0xe05029aceb0778675bef1741ab2cd2931ef7c84b": "0x10f0dbae61009528000",
  	"0xe056bf3ff41c26256fef51716612b9d39ade999c": "0x56be757a12e0a8000",
  	"0xe061a4f2fc77b296d19ada238e49a5cb8ecbfa70": "0xd8d726b7177a800000",
  	"0xe0663e8cd66792a641f56e5003660147880f018e": "0x6c6b935b8bbd400000",
  	"0xe0668fa82c14d6e8d93a53113ef2862fa81581bc": "0x2f2f39fc6c54000000",
  	"0xe069c0173352b10bf6834719db5bed01adf97bbc": "0x10634f8e5323b0000",
  	"0xe06c29a81517e0d487b67fb0b6aabc4f57368388": "0x15be6174e1912e0000",
  	"0xe06cb6294704eea7437c2fc3d30773b7bf38889a": "0x116dc3a8994b30000",
  	"0xe07137ae0d116d033533c4eab496f8a9fb09569c": "0x4be4e7267b6ae00000",
  	"0xe076db30ab486f79194ebbc45d8fab9a9242f654": "0x106607e3494baa00000",
  	"0xe07ebbc7f4da416e42c8d4f842aba16233c12580": "0x6c6b935b8bbd400000",
  	"0xe081ca1f4882db6043d5a9190703fde0ab3bf56d": "0x15af1d78b58c400000",
  	"0xe083d34863e0e17f926b7928edff317e998e9c4b": "0x15af1d78b58c400000",
  	"0xe08b9aba6bd9d28bc2056779d2fbf0f2855a3d9d": "0x6c6b935b8bbd400000",
  	"0xe08bc29c2b48b169ff2bdc16714c586e6cb85ccf": "0x1158e460913d00000",
  	"0xe08c60313106e3f9334fe6f7e7624d211130c077": "0x22b1c8c1227a00000",
  	"0xe09c68e61998d9c81b14e4ee802ba7adf6d74cdb": "0xd8d726b7177a800000",
  	"0xe09fea755aee1a44c0a89f03b5deb762ba33006f": "0x3ba289bc944ff70000",
  	"0xe0a254ac09b9725bebc8e460431dd0732ebcabbf": "0x14542ba12a337c00000",
  	"0xe0aa69365555b73f282333d1e30c1bbd072854e8": "0x17b7883c06916600000",
  	"0xe0bad98eee9698dbf6d76085b7923de5754e906d": "0x90d972f32323c0000",
  	"0xe0c4ab9072b4e6e3654a49f8a8db026a4b3386a9": "0x6c6b935b8bbd400000",
  	"0xe0ce80a461b648a501fd0b824690c8868b0e4de8": "0x1b1ae4d6e2ef500000",
  	"0xe0cf698a053327ebd16b7d7700092fe2e8542446": "0x52a34cbb61f578000",
  	"0xe0d231e144ec9107386c7c9b02f1702ceaa4f700": "0x10f0dbae61009528000",
  	"0xe0d76b7166b1f3a12b4091ee2b29de8caa7d07db": "0x6c6b935b8bbd400000",
  	"0xe0e0b2e29dde73af75987ee4446c829a189c95bc": "0x813ca56906d340000",
  	"0xe0e978753d982f7f9d1d238a18bd4889aefe451b": "0x20dd68aaf3289100000",
  	"0xe0f372347c96b55f7d4306034beb83266fd90966": "0x15af1d78b58c400000",
  	"0xe0f903c1e48ac421ab48528f3d4a2648080fe043": "0x3708baed3d68900000",
  	"0xe0ff0bd9154439c4a5b7233e291d7d868af53f33": "0x1579216a51bbfb0000",
  	"0xe10ac19c546fc2547c61c139f5d1f45a6666d5b0": "0x102da6fd0f73a3c0000",
  	"0xe10c540088113fa6ec00b4b2c8824f8796e96ec4": "0x320f4509ab1ec7c00000",
  	"0xe1173a247d29d8238df0922f4df25a05f2af77c3": "0x878c95d560f30478000",
  	"0xe1203eb3a723e99c2220117ca6afeb66fa424f61": "0x200ef929e3256fe0000",
  	"0xe131f87efc5ef07e43f0f2f4a747b551d750d9e6": "0x43c25e0dcc1bd1c0000",
  	"0xe1334e998379dfe983177062791b90f80ee22d8d": "0x1b1ae4d6e2ef500000",
  	"0xe13540ecee11b212e8b775dc8e71f374aae9b3f8": "0x6c6b935b8bbd400000",
  	"0xe13b3d2bbfdcbc8772a23315724c1425167c5688": "0x37f379141ed04b8000",
  	"0xe1443dbd95cc41237f613a48456988a04f683282": "0xd8d8583fa2d52f0000",
  	"0xe14617f6022501e97e7b3e2d8836aa61f0ff2dba": "0xad78ebc5ac6200000",
  	"0xe149b5726caf6d5eb5bf2acc41d4e2dc328de182": "0x692ae8897081d00000",
  	"0xe154daeadb545838cbc6aa0c55751902f528682a": "0x10afc1ade3b4ed40000",
  	"0xe16ce35961cd74bd590d04c4ad4a1989e05691c6": "0x7ea28327577080000",
  	"0xe172dfc8f80cd1f8cd8539dc26082014f5a8e3e8": "0xa2a15d09519be00000",
  	"0xe177e0c201d335ba3956929c571588b51c5223ae": "0x6c6b935b8bbd400000",
  	"0xe17812f66c5e65941e186c46922b6e7b2f0eeb46": "0x62a992e53a0af00000",
  	"0xe180de9e86f57bafacd7904f9826b6b4b26337a3": "0x2d041d705a2c600000",
  	"0xe192489b85a982c1883246d915b229cb13207f38": "0x10f0cf064dd59200000",
  	"0xe1953c6e975814c571311c34c0f6a99cdf48ab82": "0x2b5e3af16b1880000",
  	"0xe1ae029b17e373cde3de5a9152201a14cac4e119": "0x56b55ae58ca400000",
  	"0xe1b2aca154b8e0766c4eba30bc10c7f35036f368": "0x115473824344e0000",
  	"0xe1b39b88d9900dbc4a6cdc481e1060080a8aec3c": "0x6c6b935b8bbd400000",
  	"0xe1b63201fae1f129f95c7a116bd9dde5159c6cda": "0x4d60573a2f0c9ef0000",
  	"0xe1bfaa5a45c504428923c4a61192a55b1400b45d": "0x90f534608a72880000",
  	"0xe1c607c0a8a060da8f02a8eb38a013ea8cda5b8c": "0x2ba39e82ed5d740000",
  	"0xe1cb83ec5eb6f1eeb85e99b2fc63812fde957184": "0x43c33c1937564800000",
  	"0xe1d91b0954cede221d6f24c7985fc59965fb98b8": "0x6c6b935b8bbd400000",
  	"0xe1dfb5cc890ee8b2877e885d267c256187d019e6": "0x56bc75e2d63100000",
  	"0xe1e8c50b80a352b240ce7342bbfdf5690cc8cb14": "0x155bd9307f9fe80000",
  	"0xe1f63ebbc62c7b7444040eb99623964f7667b376": "0x1158e460913d00000",
  	"0xe206fb7324e9deb79e19903496d6961b9be56603": "0x56bc75e2d63100000",
  	"0xe207578e1f4ddb8ff6d5867b39582d71b9812ac5": "0xd255d112e103a00000",
  	"0xe208812a684098f3da4efe6aba256256adfe3fe6": "0x6c6b935b8bbd400000",
  	"0xe20954d0f4108c82d4dcb2148d26bbd924f6dd24": "0x21e19e0c9bab2400000",
  	"0xe20bb9f3966419e14bbbaaaa6789e92496cfa479": "0xbbd825030752760000",
  	"0xe20d1bcb71286dc7128a9fc7c6ed7f733892eef5": "0x3664f8e7c24af40000",
  	"0xe2191215983f33fd33e22cd4a2490054da53fddc": "0xdb44e049bb2c0000",
  	"0xe2198c8ca1b399f7521561fd5384a7132fba486b": "0x3708baed3d68900000",
  	"0xe21c778ef2a0d7f751ea8c074d1f812243863e4e": "0x11fc70e2c8c8ae18000",
  	"0xe229e746a83f2ce253b0b03eb1472411b57e5700": "0x1369fb96128ac480000",
  	"0xe22b20c77894463baf774cc256d5bddbbf7ddd09": "0x3635c9adc5dea00000",
  	"0xe230fe1bff03186d0219f15d4c481b7d59be286a": "0x1fd741e8088970000",
  	"0xe237baa4dbc9926e32a3d85d1264402d54db012f": "0x6c6b935b8bbd400000",
  	"0xe24109be2f513d87498e926a286499754f9ed49e": "0x300ea8ad1f27ca0000",
  	"0xe246683cc99db7c4a52bcbacaab0b32f6bfc93d7": "0x6c6b935b8bbd400000",
  	"0xe25a167b031e84616d0f013f31bda95dcc6350b9": "0x23c757072b8dd000000",
  	"0xe25b9f76b8ad023f057eb11ad94257a0862e4e8c": "0x6c6b935b8bbd400000",
  	"0xe26657f0ed201ea2392c9222b80a7003608ddf30": "0x22b1c8c1227a00000",
  	"0xe26bf322774e18288769d67e3107deb7447707b8": "0x6c6b935b8bbd400000",
  	"0xe2728a3e8c2aaac983d05dc6877374a8f446eee9": "0xab640391201300000",
  	"0xe28b062259e96eeb3c8d4104943f9eb325893cf5": "0x487a9a304539440000",
  	"0xe28dbc8efd5e416a762ec0e018864bb9aa83287b": "0x531f200ab3e030a8000",
  	"0xe2904b1aefa056398b6234cb35811288d736db67": "0x22b1c8c1227a00000",
  	"0xe29d8ae452dcf3b6ac645e630409385551faae0a": "0x45a0da4adf5420000",
  	"0xe2bbf84641e3541f6c33e6ed683a635a70bde2ec": "0x1b413cfcbf59b78000",
  	"0xe2cf360aa2329eb79d2bf7ca04a27a17c532e4d8": "0x58788cb94b1d80000",
  	"0xe2df23f6ea04becf4ab701748dc0963184555cdb": "0x6c6b935b8bbd400000",
  	"0xe2e15c60dd381e3a4be25071ab249a4c5c5264da": "0x7f6bc49b81b5370000",
  	"0xe2e26e4e1dcf30d048cc6ecf9d51ec1205a4e926": "0xd8d726b7177a800000",
  	"0xe2ee691f237ee6529b6557f2fcdd3dcf0c59ec63": "0x127729c14687c200000",
  	"0xe2efa5fca79538ce6068bf31d2c516d4d53c08e5": "0x71cc408df63400000",
  	"0xe2efd0a9bc407ece03d67e8ec8e9d283f48d2a49": "0x299b33bf9c584e00000",
  	"0xe2f40d358f5e3fe7463ec70480bd2ed398a7063b": "0x1158e460913d00000",
  	"0xe2f9383d5810ea7b43182b8704b62b27f5925d39": "0x15af1d78b58c400000",
  	"0xe2ff9ee4b6ecc14141cc74ca52a9e7a2ee14d908": "0x4be4e7267b6ae00000",
  	"0xe30212b2011bb56bdbf1bc35690f3a4e0fd905ea": "0x1b2df9d219f57980000",
  	"0xe303167f3d4960fe881b32800a2b4aeff1b088d4": "0x6c6b935b8bbd400000",
  	"0xe304a32f05a83762744a9542976ff9b723fa31ea": "0x5572f240a346200000",
  	"0xe308435204793764f5fcbe65eb510f5a744a655a": "0xad78ebc5ac6200000",
  	"0xe309974ce39d60aadf2e69673251bf0e04760a10": "0xdc55fdb17647b0000",
  	"0xe31b4eef184c24ab098e36c802714bd4743dd0d4": "0xad78ebc5ac6200000",
  	"0xe321bb4a946adafdade4571fb15c0043d39ee35f": "0x556475382b4c9e0000",
  	"0xe3263ce8af6db3e467584502ed7109125eae22a5": "0x6c6b935b8bbd400000",
  	"0xe32b1c4725a1875449e98f970eb3e54062d15800": "0xad78ebc5ac6200000",
  	"0xe32f95766d57b5cd4b173289d6876f9e64558194": "0x56bc75e2d63100000",
  	"0xe33840d8bca7da98a6f3d096d83de78b70b71ef8": "0x6c6b935b8bbd400000",
  	"0xe338e859fe2e8c15554848b75caecda877a0e832": "0x61acff81a78ad40000",
  	"0xe33d980220fab259af6a1f4b38cf0ef3c6e2ea1a": "0x6c6b935b8bbd400000",
  	"0xe33df4ce80ccb62a76b12bcdfcecc46289973aa9": "0x14542ba12a337c00000",
  	"0xe33ff987541dde5cdee0a8a96dcc3f33c3f24cc2": "0x2a5a058fc295ed000000",
  	"0xe3410bb7557cf91d79fa69d0dfea0aa075402651": "0x6c6b935b8bbd400000",
  	"0xe341642d40d2afce2e9107c67079ac7a2660086c": "0x15af1d78b58c400000",
  	"0xe35453eef2cc3c7a044d0ac134ba615908fa82ee": "0x7ff1ccb7561df0000",
  	"0xe36a8ea87f1e99e8a2dc1b2608d166667c9dfa01": "0x56bc75e2d63100000",
  	"0xe3712701619ca7623c55db3a0ad30e867db0168b": "0x1158e460913d00000",
  	"0xe37f5fdc6ec97d2f866a1cfd0d3a4da4387b22b5": "0x21e19e0c9bab2400000",
  	"0xe3878f91ca86053fced5444686a330e09cc388fb": "0xa844a7424d9c80000",
  	"0xe38b91b35190b6d9deed021c30af094b953fdcaa": "0x1ceaf795b6b860000",
  	"0xe38ef28a5ed984a7db24a1ae782dfb87f397dfc6": "0x7c0860e5a80dc0000",
  	"0xe3925509c8d0b2a6738c5f6a72f35314491248ce": "0x36e9a8669a44768000",
  	"0xe3933d61b77dcdc716407f8250bc91e4ffaeb09d": "0x1256986c95891c200000",
  	"0xe3951de5aefaf0458768d774c254f7157735e505": "0x56c95de8e8ca1d0000",
  	"0xe399c81a1d701b44f0b66f3399e66b275aaaf8c1": "0x3635c9adc5dea00000",
  	"0xe39b11a8ab1ff5e22e5ae6517214f73c5b9b55dc": "0x6c6b935b8bbd400000",
  	"0xe39e46e15d22ce56e0c32f1877b7d1a264cf94f3": "0x43c33c1937564800000",
  	"0xe3a4621b66004588e31206f718cb00a319889cf0": "0x6c6b935b8bbd400000",
  	"0xe3a4f83c39f85af9c8b1b312bfe5fc3423afa634": "0x18d993f34aef10000",
  	"0xe3a89a1927cc4e2d43fbcda1e414d324a7d9e057": "0xb23e2a936dec60000",
  	"0xe3ab3ca9b870e3f548517306bba4de2591afafc2": "0x410e34aecc8cd30000",
  	"0xe3b3d2c9bf570be6a2f72adca1862c310936a43c": "0x56d2aa3a5c09a0000",
  	"0xe3c0c128327a9ad80148139e269773428e638cb0": "0x6c6b935b8bbd400000",
  	"0xe3c812737ac606baf7522ad817428a36050e7a34": "0x692ae8897081d00000",
  	"0xe3cffe239c64e7e20388e622117391301b298696": "0x1b1ae4d6e2ef500000",
  	"0xe3d3eaa299887865569e88be219be507189be1c9": "0x18ba6fa92e93160000",
  	"0xe3d8bf4efe84b1616d1b89e427ddc6c8830685ae": "0x6c6b935b8bbd400000",
  	"0xe3d915eda3b825d6ee4af9328d32ac18ada35497": "0x1b1ae4d6e2ef500000",
  	"0xe3da4f3240844c9b6323b4996921207122454399": "0x27190a952df4be58000",
  	"0xe3eb2c0a132a524f72ccc0d60fee8b41685d39e2": "0x6acb3df27e1f880000",
  	"0xe3ec18a74ed43855409a26ade7830de8e42685ef": "0x11164759ffb320000",
  	"0xe3ece1f632711d13bfffa1f8f6840871ee58fb27": "0xd8d726b7177a800000",
  	"0xe3f80b40fb83fb97bb0d5230af4f6ed59b1c7cc8": "0x487a9a304539440000",
  	"0xe3ffb02cb7d9ea5243701689afd5d417d7ed2ece": "0x43a77aabd00780000",
  	"0xe400d651bb3f2d23d5f849e6f92d9c5795c43a8a": "0x90f534608a72880000",
  	"0xe406f5dd72cab66d8a6ecbd6bfb494a7b6b09afe": "0x56bc75e2d63100000",
  	"0xe408aa99835307eea4a6c5eb801fe694117f707d": "0x1b1ae4d6e2ef500000",
  	"0xe408fceaa1b98f3c640f48fcba39f056066d6308": "0x21e19e0c9bab2400000",
  	"0xe40a7c82e157540a0b00901dbb86c716e1a062da": "0x2b31d2425f6740000",
  	"0xe41aea250b877d423a63ba2bce2f3a61c0248d56": "0xe18398e7601900000",
  	"0xe430c0024fdbf73a82e21fccf8cbd09138421c21": "0xd8d726b7177a800000",
  	"0xe4324912d64ea3aef76b3c2ff9df82c7e13ae991": "0x6c6b935b8bbd400000",
  	"0xe4368bc1420b35efda95fafbc73090521916aa34": "0xd8d726b7177a800000",
  	"0xe437acbe0f6227b0e36f36e4bcf7cf613335fb68": "0xad78ebc5ac6200000",
  	"0xe44b7264dd836bee8e87970340ed2b9aed8ed0a5": "0x138e7faa01a803a0000",
  	"0xe44ea51063405154aae736be2bf1ee3b9be639ae": "0xd8d726b7177a800000",
  	"0xe4625501f52b7af52b19ed612e9d54fdd006b492": "0xb5a905a56ddd00000",
  	"0xe4715956f52f15306ee9506bf82bccc406b3895e": "0xee79d4f48c5000000",
  	"0xe47fbaed99fc209962604ebd20e240f74f4591f1": "0x6c6b935b8bbd400000",
  	"0xe482d255ede56b04c3e8df151f56e9ca62aaa8c2": "0x1b1ae4d6e2ef500000",
  	"0xe48e65125421880d42bdf1018ab9778d96928f3f": "0xe3aeb5737240a00000",
  	"0xe492818aa684e5a676561b725d42f3cc56ae5198": "0x2b5e3af16b18800000",
  	"0xe49936a92a8ccf710eaac342bc454b9b14ebecb1": "0x6c6b935b8bbd400000",
  	"0xe49af4f34adaa2330b0e49dc74ec18ab2f92f827": "0x6c6b935b8bbd400000",
  	"0xe49ba0cd96816c4607773cf8a5970bb5bc16a1e6": "0x5a87e7d7f5f6580000",
  	"0xe4a47e3933246c3fd62979a1ea19ffdf8c72ef37": "0x809b383ea7d7e8000",
  	"0xe4b6ae22c7735f5b89f34dd77ad0975f0acc9181": "0x3635c9adc5dea00000",
  	"0xe4ca0a5238564dfc91e8bf22bade2901619a1cd4": "0x3635c9adc5dea00000",
  	"0xe4cafb727fb5c6b70bb27533b8a9ccc9ef6888e1": "0x10497bf4af4caf8000",
  	"0xe4dc22ed595bf0a337c01e03cc6be744255fc9e8": "0xa5aa85009e39c0000",
  	"0xe4fb26d1ca1eecba3d8298d9d148119ac2bbf580": "0x15af1d78b58c400000",
  	"0xe4fc13cfcbac1b17ce7783acd423a845943f6b3a": "0x1158e460913d00000",
  	"0xe50b464ac9de35a5618b7cbf254674182b81b97e": "0xde42ee1544dd900000",
  	"0xe5102c3b711b810344197419b1cd8a7059f13e32": "0x1043528d0984698000",
  	"0xe510d6797fba3d6693835a844ea2ad540691971b": "0x3ae39d47383e8740000",
  	"0xe51421f8ee2210c71ed870fe618276c8954afbe9": "0x487a9a304539440000",
  	"0xe51eb87e7fb7311f5228c479b48ec9878831ac4c": "0x6c6b935b8bbd400000",
  	"0xe5215631b14248d45a255296bed1fbfa0330ff35": "0x4703e6eb5291b80000",
  	"0xe528a0e5a267d667e9393a6584e19b34dc9be973": "0x12f939c99edab800000",
  	"0xe53425d8df1f11c341ff58ae5f1438abf1ca53cf": "0x1174a5cdf88bc80000",
  	"0xe53c68796212033e4e6f9cff56e19c461eb454f9": "0x3635c9adc5dea00000",
  	"0xe54102534de8f23effb093b31242ad3b233facfd": "0xd8d726b7177a800000",
  	"0xe545ee84ea48e564161e9482d59bcf406a602ca2": "0x6449e84e47a8a80000",
  	"0xe5481a7fed42b901bbed20789bd4ade50d5f83b9": "0x6c6b935b8bbd400000",
  	"0xe559b5fd337b9c5572a9bf9e0f2521f7d446dbe4": "0xad78ebc5ac6200000",
  	"0xe55c80520a1b0f755b9a2cd3ce214f7625653e8a": "0x6c6b935b8bbd400000",
  	"0xe56d431324c92911a1749df292709c14b77a65cd": "0x1bc85dc2a89bb200000",
  	"0xe57d2995b0ebdf3f3ca6c015eb04260dbb98b7c6": "0x6c6b935b8bbd400000",
  	"0xe587b16abc8a74081e3613e14342c03375bf0847": "0x6c6b935b8bbd400000",
  	"0xe589fa76984db5ec4004b46ee8a59492c30744ce": "0x97c9ce4cf6d5c00000",
  	"0xe58dd23238ee6ea7c2138d385df500c325f376be": "0x62a992e53a0af00000",
  	"0xe5953fea497104ef9ad2d4e5841c271f073519c2": "0x2629f66e0c53000000",
  	"0xe5968797468ef767101b761d431fce14abffdbb4": "0x1b3d969fa411ca00000",
  	"0xe597f083a469c4591c3d2b1d2c772787befe27b2": "0xf2dc7d47f15600000",
  	"0xe59b3bd300893f97233ef947c46f7217e392f7e9": "0x3635c9adc5dea00000",
  	"0xe5a365343cc4eb1e770368e1f1144a77b832d7e0": "0x1158e460913d00000",
  	"0xe5a3d7eb13b15c100177236d1beb30d17ee15420": "0x6c6b935b8bbd400000",
  	"0xe5aa0b833bb916dc19a8dd683f0ede241d988eba": "0xa2a15d09519be00000",
  	"0xe5b7af146986c0ff8f85d22e6cc334077d84e824": "0x6c6b935b8bbd400000",
  	"0xe5b826196c0e1bc1119b021cf6d259a610c99670": "0xad78ebc5ac6200000",
  	"0xe5b96fc9ac03d448c1613ac91d15978145dbdfd1": "0xad78ebc5ac6200000",
  	"0xe5b980d28eece2c06fca6c9473068b37d4a6d6e9": "0x25afd68cac2b900000",
  	"0xe5bab4f0afd8a9d1a381b45761aa18f3d3cce105": "0x51bfd7c13878d10000",
  	"0xe5bcc88c3b256f6ed5fe550e4a18198b943356ad": "0x6c6b935b8bbd400000",
  	"0xe5bdf34f4ccc483e4ca530cc7cf2bb18febe92b3": "0x6d835a10bbcd20000",
  	"0xe5dc9349cb52e161196122cf87a38936e2c57f34": "0x6c6b935b8bbd400000",
  	"0xe5e33800a1b2e96bde1031630a959aa007f26e51": "0x487a9a304539440000",
  	"0xe5e37e19408f2cfbec83349dd48153a4a795a08f": "0xe3aeb5737240a00000",
  	"0xe5edc73e626f5d3441a45539b5f7a398c593edf6": "0x2ee449550898e40000",
  	"0xe5edf8123f2403ce1a0299becf7aac744d075f23": "0xada55474b81340000",
  	"0xe5f8ef6d970636b0dcaa4f200ffdc9e75af1741c": "0x6c6b935b8bbd400000",
  	"0xe5fb31a5caee6a96de393bdbf89fbe65fe125bb3": "0x3635c9adc5dea00000",
  	"0xe5fbe34984b637196f331c679d0c0c47d83410e1": "0x6c6c44fe47ec050000",
  	"0xe60955dc0bc156f6c41849f6bd776ba44b0ef0a1": "0x10431627a0933b0000",
  	"0xe60a55f2df996dc3aedb696c08dde039b2641de8": "0x6c6b935b8bbd400000",
  	"0xe6115b13f9795f7e956502d5074567dab945ce6b": "0x152d02c7e14af6800000",
  	"0xe61f280915c774a31d223cf80c069266e5adf19b": "0x2fb474098f67c00000",
  	"0xe62f98650712eb158753d82972b8e99ca3f61877": "0x6c6b935b8bbd400000",
  	"0xe62f9d7c64e8e2635aeb883dd73ba684ee7c1079": "0x1b1ae4d6e2ef5000000",
  	"0xe63e787414b9048478a50733359ecdd7e3647aa6": "0x55a6e79ccd1d300000",
  	"0xe646665872e40b0d7aa2ff82729caaba5bc3e89e": "0x15af1d78b58c400000",
  	"0xe64ef012658d54f8e8609c4e9023c09fe865c83b": "0x18493fba64ef00000",
  	"0xe64f6e1d6401b56c076b64a1b0867d0b2f310d4e": "0x2cbad71c53ae50000",
  	"0xe667f652f957c28c0e66d0b63417c80c8c9db878": "0x209d922f5259c50000",
  	"0xe677c31fd9cb720075dca49f1abccd59ec33f734": "0x1a6d6beb1d42ee00000",
  	"0xe67c2c1665c88338688187629f49e99b60b2d3ba": "0xad78ebc5ac6200000",
  	"0xe69a6cdb3a8a7db8e1f30c8b84cd73bae02bc0f8": "0x394fdc2e452f6718000",
  	"0xe69d1c378b771e0feff051db69d966ac6779f4ed": "0x1dfa6aaa1497040000",
  	"0xe69fcc26ed225f7b2e379834c524d70c1735e5bc": "0x6c6b935b8bbd400000",
  	"0xe6a3010f0201bc94ff67a2f699dfc206f9e76742": "0x2fa7cbf66464980000",
  	"0xe6a6f6dd6f70a456f4ec15ef7ad5e5dbb68bd7dc": "0xad78ebc5ac6200000",
  	"0xe6b20f980ad853ad04cbfc887ce6601c6be0b24c": "0xd8d726b7177a800000",
  	"0xe6b3ac3f5d4da5a8857d0b3f30fc4b2b692b77d7": "0x4f2591f896a6500000",
  	"0xe6b9545f7ed086e552924639f9a9edbbd5540b3e": "0xcbd47b6eaa8cc00000",
  	"0xe6bcd30a8fa138c5d9e5f6c7d2da806992812dcd": "0x370ea0d47cf61a800000",
  	"0xe6c81ffcecb47ecdc55c0b71e4855f3e5e97fc1e": "0x121ea68c114e510000",
  	"0xe6cb260b716d4c0ab726eeeb07c8707204e276ae": "0x3635c9adc5dea00000",
  	"0xe6cb3f3124c9c9cc3834b1274bc3336456a38bac": "0x172b1de0a213ff0000",
  	"0xe6d22209ffd0b87509ade3a8e2ef429879cb89b5": "0x3a7aa9e1899ca300000",
  	"0xe6d49f86c228f47367a35e886caacb271e539429": "0x165ec09da7a1980000",
  	"0xe6e621eaab01f20ef0836b7cad47464cb5fd3c96": "0x11219342afa24b0000",
  	"0xe6e886317b6a66a5b4f81bf164c538c264351765": "0x6c6b935b8bbd400000",
  	"0xe6e9a39d750fe994394eb68286e5ea62a6997882": "0x2086ac351052600000",
  	"0xe6ec5cf0c49b9c317e1e706315ef9eb7c0bf11a7": "0x3a469f3467e8ec00000",
  	"0xe6f5eb649afb99599c414b27a9c9c855357fa878": "0x90f534608a72880000",
  	"0xe6fe0afb9dcedd37b2e22c451ba6feab67348033": "0x21e19e0c9bab2400000",
  	"0xe710dcd09b8101f9437bd97db90a73ef993d0bf4": "0x14ee36c05ac2520000",
  	"0xe727e67ef911b81f6cf9c73fcbfebc2b02b5bfc6": "0x6c6b935b8bbd400000",
  	"0xe72e1d335cc29a96b9b1c02f003a16d971e90b9d": "0x55a6e79ccd1d300000",
  	"0xe7311c9533f0092c7248c9739b5b2c864a34b1ce": "0x97f97d6cc26dfe0000",
  	"0xe73bfeada6f0fd016fbc843ebcf6e370a65be70c": "0x6acb3df27e1f880000",
  	"0xe73ccf436725c151e255ccf5210cfce5a43f13e3": "0x1154e53217ddb0000",
  	"0xe742b1e6069a8ffc3c4767235defb0d49cbed222": "0x2b5e3af16b18800000",
  	"0xe74608f506866ada6bfbfdf20fea440be76989ef": "0x6c6acc67d7b1d40000",
  	"0xe7533e270cc61fa164ac1553455c105d04887e14": "0x696d8590020bb0000",
  	"0xe75c1fb177089f3e58b1067935a6596ef1737fb5": "0x56a879fa775470000",
  	"0xe75c3b38a58a3f33d55690a5a59766be185e0284": "0x1b1ae4d6e2ef500000",
  	"0xe761d27fa3502cc76bb1a608740e1403cf9dfc69": "0xf2dc7d47f15600000",
  	"0xe766f34ff16f3cfcc97321721f43ddf5a38b0cf4": "0x54069233bf7f780000",
  	"0xe76d945aa89df1e457aa342b31028a5e9130b2ce": "0x3708baed3d68900000",
  	"0xe7735ec76518fc6aa92da8715a9ee3f625788f13": "0x6c4d160bafa1b78000",
  	"0xe77a89bd45dc04eeb4e41d7b596b707e6e51e74c": "0x28a857425466f800000",
  	"0xe77d7deab296c8b4fa07ca3be184163d5a6d606c": "0x5043904b671190000",
  	"0xe77febabdf080f0f5dca1d3f5766f2a79c0ffa7c": "0x4b229d28a843680000",
  	"0xe780a56306ba1e6bb331952c22539b858af9f77d": "0xa968163f0a57b400000",
  	"0xe781ec732d401202bb9bd13860910dd6c29ac0b6": "0x433874f632cc600000",
  	"0xe784dcc873aa8c1513ec26ff36bc92eac6d4c968": "0xad78ebc5ac6200000",
  	"0xe7912d4cf4562c573ddc5b71e37310e378ef86c9": "0x155bd9307f9fe80000",
  	"0xe791d585b89936b25d298f9d35f9f9edc25a2932": "0x6c6b935b8bbd400000",
  	"0xe792349ce9f6f14f81d0674096befa1f9221cdea": "0x5b5d234a0db4388000",
  	"0xe796fd4e839b4c95d7510fb7c5c72b83c6c3e3c7": "0x1bc433f23f83140000",
  	"0xe7a42f59fee074e4fb13ea9e57ecf1cc48282249": "0x43c33c1937564800000",
  	"0xe7a4560c84b20e0fb54c49670c2903b0a96c42a4": "0x206aeac7a903980000",
  	"0xe7a8e471eafb798f4554cc6e526730fd56e62c7d": "0x3635c9adc5dea00000",
  	"0xe7be82c6593c1eeddd2ae0b15001ff201ab57b2f": "0x10910d4cdc9f60000",
  	"0xe7c6b5fc05fc748e5b4381726449a1c0ad0fb0f1": "0x6c6b935b8bbd400000",
  	"0xe7d17524d00bad82497c0f27156a647ff51d2792": "0x1158e460913d00000",
  	"0xe7d213947fcb904ad738480b1eed2f5c329f27e8": "0x103c3b1d3e9c30000",
  	"0xe7d6240620f42c5edbb2ede6aec43da4ed9b5757": "0x3635c9adc5dea00000",
  	"0xe7da609d40cde80f00ce5b4ffb6aa9d0b03494fc": "0x3635c9adc5dea00000",
  	"0xe7f06f699be31c440b43b4db0501ec0e25261644": "0x1b1ae4d6e2ef500000",
  	"0xe7f4d7fe6f561f7fa1da3005fd365451ad89df89": "0xad78ebc5ac6200000",
  	"0xe7fd8fd959aed2767ea7fa960ce1db53af802573": "0x3635c9adc5dea00000",
  	"0xe80e7fef18a5db15b01473f3ad6b78b2a2f8acd9": "0x1b1ae4d6e2ef500000",
  	"0xe8137fc1b2ec7cc7103af921899b4a39e1d959a1": "0x50c5e761a444080000",
  	"0xe81c2d346c0adf4cc56708f6394ba6c8c8a64a1e": "0x6c6b935b8bbd400000",
  	"0xe82c58c579431b673546b53a86459acaf1de9b93": "0x3635c9adc5dea00000",
  	"0xe834c64318205ca7dd4a21abcb08266cb21ff02c": "0x3635c6204739d98000",
  	"0xe83604e4ff6be7f96f6018d3ec3072ec525dff6b": "0x9ddc1e3b901180000",
  	"0xe845e387c4cbdf982280f6aa01c40e4be958ddb2": "0x54b40b1f852bda00000",
  	"0xe848ca7ebff5c24f9b9c316797a43bf7c356292d": "0x62e115c008a880000",
  	"0xe84b55b525f1039e744b918cb3332492e45eca7a": "0xad78ebc5ac6200000",
  	"0xe84f8076a0f2969ecd333eef8de41042986291f2": "0x176b344f2a78c00000",
  	"0xe864fec07ed1214a65311e11e329de040d04f0fd": "0x59ca83f5c404968000",
  	"0xe87dbac636a37721df54b08a32ef4959b5e4ff82": "0x6c6b935b8bbd400000",
  	"0xe87e9bbfbbb71c1a740c74c723426df55d063dd9": "0x1b1928c00c7a6380000",
  	"0xe87eac6d602b4109c9671bf57b950c2cfdb99d55": "0x2b4f21972ecce0000",
  	"0xe881bbbe69722d81efecaa48d1952a10a2bfac8f": "0x3635c9adc5dea000000",
  	"0xe89249738b7eced7cb666a663c49cbf6de8343ea": "0x6c6b935b8bbd400000",
  	"0xe89c22f1a4e1d4746ecfaa59ed386fee12d51e37": "0x26f8e87f0a7da0000",
  	"0xe89da96e06beaf6bd880b378f0680c43fd2e9d30": "0x209a1a01a56fec0000",
  	"0xe8a91da6cf1b9d65c74a02ec1f96eecb6dd241f3": "0x692ae8897081d00000",
  	"0xe8a9a41740f44f54c3688b53e1ddd42e43c9fe94": "0xd8d726b7177a800000",
  	"0xe8b28acda971725769db8f563d28666d41ddab6c": "0x21e19e0c9bab2400000",
  	"0xe8be24f289443ee473bc76822f55098d89b91cc5": "0x6c6b935b8bbd400000",
  	"0xe8c3d3b0e17f97d1e756e684f94e1470f99c95a1": "0x15af1d78b58c400000",
  	"0xe8c3f045bb7d38c9d2f395b0ba8492b253230901": "0x1e7e4171bf4d3a00000",
  	"0xe8cc43bc4f8acf39bff04ebfbf42aac06a328470": "0x15af1d78b58c400000",
  	"0xe8d942d82f175ecb1c16a405b10143b3f46b963a": "0x1ed2e8ff6d971c0000",
  	"0xe8ddbed732ebfe754096fde9086b8ea4a4cdc616": "0x6c6b935b8bbd400000",
  	"0xe8de725eca5def805ff7941d31ac1c2e342dfe95": "0x857e0d6f1da76a0000",
  	"0xe8e9850586e94f5299ab494bb821a5f40c00bd04": "0xcf152640c5c8300000",
  	"0xe8ead1bb90ccc3aea2b0dcc5b58056554655d1d5": "0x1a4aba225c207400000",
  	"0xe8eaf12944092dc3599b3953fa7cb1c9761cc246": "0x6194049f30f7200000",
  	"0xe8ed51bbb3ace69e06024b33f86844c47348db9e": "0x22f9ea89f4a7d6c40000",
  	"0xe8ef100d7ce0895832f2678df72d4acf8c28b8e3": "0x1b1b6bd7af64c70000",
  	"0xe8f29969e75c65e01ce3d86154207d0a9e7c76f2": "0xa22fa9a73a27198000",
  	"0xe8fc36b0131ec120ac9e85afc10ce70b56d8b6ba": "0xad78ebc5ac6200000",
  	"0xe90a354cec04d69e5d96ddc0c5138d3d33150aa0": "0x1b1a7dcf8a44d38000",
  	"0xe9133e7d31845d5f2b66a2618792e869311acf66": "0x517c0cbf9a390880000",
  	"0xe91dac0195b19e37b59b53f7c017c0b2395ba44c": "0x65ea3db75546600000",
  	"0xe91fa0badaddb9a97e88d3f4db7c55d6bb7430fe": "0x14620c57dddae00000",
  	"0xe923c06177b3427ea448c0a6ff019b54cc548d95": "0x1f780014667f28000",
  	"0xe93d47a8ca885d540c4e526f25d5c6f2c108c4b8": "0x17da3a04c7b3e0000000",
  	"0xe9458f68bb272cb5673a04f781b403556fd3a387": "0x34e8b88cee2d40000",
  	"0xe94941b6036019b4016a30c1037d5a6903babaad": "0x2a48acab6204b00000",
  	"0xe9495ba5842728c0ed97be37d0e422b98d69202c": "0x6c6b935b8bbd400000",
  	"0xe94ded99dcb572b9bb1dcba32f6dee91e057984e": "0x155bd9307f9fe80000",
  	"0xe95179527deca5916ca9a38f215c1e9ce737b4c9": "0x21e19e0c9bab2400000",
  	"0xe9559185f166fc9513cc71116144ce2deb0f1d4b": "0x43c33c1937564800000",
  	"0xe95e92bbc6de07bf3a660ebf5feb1c8a3527e1c5": "0xfc936392801c0000",
  	"0xe965daa34039f7f0df62375a37e5ab8a72b301e7": "0x103fddecdb3f5700000",
  	"0xe969ea1595edc5c4a707cfde380929633251a2b0": "0xad78ebc5ac6200000",
  	"0xe96b184e1f0f54924ac874f60bbf44707446b72b": "0x9dcc0515b56e0c0000",
  	"0xe96d7d4cdd15553a4e4d316d6d6480ca3cea1e38": "0x2955d02e1a135a00000",
  	"0xe96e2d3813efd1165f12f602f97f4a62909d3c66": "0x7caee97613e6700000",
  	"0xe97fde0b67716325cf0ecce8a191a3761b2c791d": "0x3677036edf0af60000",
  	"0xe982e6f28c548f5f96f45e63f7ab708724f53fa1": "0x157ae829a41f3b0000",
  	"0xe9864c1afc8eaad37f3ba56fcb7477cc622009b7": "0x448586170a7dc0000",
  	"0xe987e6139e6146a717fef96bc24934a5447fe05d": "0x6c6b935b8bbd400000",
  	"0xe989733ca1d58d9e7b5029ba5d444858bec03172": "0x1f87408313df4f8000",
  	"0xe98c91cadd924c92579e11b41217b282956cdaa1": "0x75c9a8480320c0000",
  	"0xe99aece90541cae224b87da673965e0aeb296afd": "0x31df9095a18f600000",
  	"0xe99de258a4173ce9ac38ede26c0b3bea3c0973d5": "0x59d0b805e5bb300000",
  	"0xe9a2b4914e8553bf0d7c00ca532369b879f931bf": "0x6c6b935b8bbd400000",
  	"0xe9a39a8bac0f01c349c64cedb69897f633234ed2": "0xd7c198710e66b00000",
  	"0xe9a5ae3c9e05977dd1069e9fd9d3aefbae04b8df": "0x6acb3df27e1f880000",
  	"0xe9ac36376efa06109d40726307dd1a57e213eaa9": "0xa844a7424d9c80000",
  	"0xe9b1f1fca3fa47269f21b061c353b7f5e96d905a": "0x1b1ae4d6e2ef500000",
  	"0xe9b36fe9b51412ddca1a521d6e94bc901213dda8": "0x21e19e0c9bab2400000",
  	"0xe9b4a4853577a9dbcc2e795be0310d1bed28641a": "0x3635c9adc5dea00000",
  	"0xe9b6a790009bc16642c8d820b7cde0e9fd16d8f5": "0xc55325ca7415e00000",
  	"0xe9b9a2747510e310241d2ece98f56b3301d757e0": "0x6c6b935b8bbd400000",
  	"0xe9c35c913ca1fceab461582fe1a5815164b4fd21": "0x1b1ae4d6e2ef5000000",
  	"0xe9c6dfae97f7099fc5f4e94b784db802923a1419": "0x2a53c6d724f100000",
  	"0xe9c758f8da41e3346e4350e5ac3976345c6c1082": "0x68a0d3092826ad0000",
  	"0xe9caf827be9d607915b365c83f0d3b7ea8c79b50": "0xa2a15d09519be00000",
  	"0xe9cafe41a5e8bbd90ba02d9e06585b4eb546c57f": "0x6c6b935b8bbd400000",
  	"0xe9d599456b2543e6db80ea9b210e908026e2146e": "0xad78ebc5ac6200000",
  	"0xe9e1f7cb00a110edd0ebf8b377ef8a7bb856117f": "0xad78ebc5ac6200000",
  	"0xea14bfda0a6e76668f8788321f07df37824ec5df": "0x2a5a058fc295ed000000",
  	"0xea1ea0c599afb9cd36caacbbb52b5bbb97597377": "0x39fbae8d042dd00000",
  	"0xea1efb3ce789bedec3d67c3e1b3bc0e9aa227f90": "0x27ca4bd719f0b80000",
  	"0xea2c197d26e98b0da83e1b72c787618c979d3db0": "0x11164759ffb320000",
  	"0xea3779d14a13f6c78566bcde403591413a6239db": "0x29b76432b94451200000",
  	"0xea4e809e266ae5f13cdbe38f9d0456e6386d1274": "0xf3f20b8dfa69d00000",
  	"0xea53c954f4ed97fd4810111bdab69ef981ef25b9": "0x3a9d5baa4abf1d00000",
  	"0xea53d26564859d9e90bb0e53b7abf560e0162c38": "0x15af1d78b58c400000",
  	"0xea60436912de6bf187d3a472ff8f5333a0f7ed06": "0x11164759ffb320000",
  	"0xea60549ec7553f511d2149f2d4666cbd9243d93c": "0x6c6b935b8bbd400000",
  	"0xea66e7b84dcdbf36eea3e75b85382a75f1a15d96": "0x5dbc9191266f118000",
  	"0xea686c5057093c171c66db99e01b0ececb308683": "0x14dda85d2ce1478000",
  	"0xea6afe2cc928ac8391eb1e165fc40040e37421e7": "0xa27fa063b2e2e68000",
  	"0xea79057dabef5e64e7b44f7f18648e7e533718d2": "0xad78ebc5ac6200000",
  	"0xea7c4d6dc729cd6b157c03ad237ca19a209346c3": "0x6c6b935b8bbd400000",
  	"0xea8168fbf225e786459ca6bb18d963d26b505309": "0x1b1ae4d6e2ef500000",
  	"0xea81ca8638540cd9d4d73d060f2cebf2241ffc3e": "0x6acb3df27e1f880000",
  	"0xea8317197959424041d9d7c67a3ece1dbb78bb55": "0x155bd9307f9fe80000",
  	"0xea8527febfa1ade29e26419329d393b940bbb7dc": "0x6c6acc67d7b1d40000",
  	"0xea8f30b6e4c5e65290fb9864259bc5990fa8ee8a": "0x1158e460913d00000",
  	"0xea94f32808a2ef8a9bf0861d1d2404f7b7be258a": "0x1158e460913d00000",
  	"0xeaa45cea02d87d2cc8fda9434e2d985bd4031584": "0x681fc2cc6e2b8b0000",
  	"0xeab0bd148309186cf8cbd13b7232d8095acb833a": "0x2439a881c6a717c0000",
  	"0xeabb90d37989aab31feae547e0e6f3999ce6a35d": "0x6c6b935b8bbd400000",
  	"0xeac0827eff0c6e3ff28a7d4a54f65cb7689d7b99": "0x9ad9e69f9d47520000",
  	"0xeac1482826acb6111e19d340a45fb851576bed60": "0x1be8bab04d9be8000",
  	"0xeac17b81ed5191fb0802aa54337313834107aaa4": "0x1b1ae4d6e2ef5000000",
  	"0xeac3af5784927fe9a598fc4eec38b8102f37bc58": "0x3635c9adc5dea00000",
  	"0xeac6b98842542ea10bb74f26d7c7488f698b6452": "0x43c33c1937564800000",
  	"0xeac768bf14b8f9432e69eaa82a99fbeb94cd0c9c": "0x14dbb2195ca228900000",
  	"0xead21c1deccfbf1c5cd96688a2476b69ba07ce4a": "0x3f24d8e4a00700000",
  	"0xead4d2eefb76abae5533961edd11400406b298fc": "0xd255d112e103a00000",
  	"0xead65262ed5d122df2b2751410f98c32d1238f51": "0x58317ed46b9b80000",
  	"0xead75016e3a0815072b6b108bcc1b799acf0383e": "0x6c6b935b8bbd400000",
  	"0xeaea23aa057200e7c9c15e8ff190d0e66c0c0e83": "0x6c6b935b8bbd400000",
  	"0xeaed16eaf5daab5bf0295e5e077f59fb8255900b": "0xd8d726b7177a800000",
  	"0xeaedcc6b8b6962d5d9288c156c579d47c0a9fcff": "0x49b9ca9a694340000",
  	"0xeaf52388546ec35aca6f6c6393d8d609de3a4bf3": "0x1158e460913d00000",
  	"0xeb10458daca79e4a6b24b29a8a8ada711b7f2eb6": "0xd8bb6549b02bb80000",
  	"0xeb1cea7b45d1bd4d0e2a007bd3bfb354759e2c16": "0xabbcd4ef377580000",
  	"0xeb25481fcd9c221f1ac7e5fd1ecd9307a16215b8": "0xaadec983fcff40000",
  	"0xeb2ef3d38fe652403cd4c9d85ed7f0682cd7c2de": "0x90f534608a728800000",
  	"0xeb3bdd59dcdda5a9bb2ac1641fd02180f5f36560": "0x165c96647b38a200000",
  	"0xeb3ce7fc381c51db7d5fbd692f8f9e058a4c703d": "0xad78ebc5ac6200000",
  	"0xeb453f5a3adddd8ab56750fadb0fe7f94d9c89e7": "0x1158e460913d00000",
  	"0xeb4f00e28336ea09942588eeac921811c522143c": "0x6c6b935b8bbd400000",
  	"0xeb52ab10553492329c1c54833ae610f398a65b9d": "0x83d6c7aab63600000",
  	"0xeb570dba975227b1c42d6e8dea2c56c9ad960670": "0x6c6b935b8bbd400000",
  	"0xeb6394a7bfa4d28911d5a5b23e93f35e340c2294": "0x43a77aabd00780000",
  	"0xeb6810691d1ae0d19e47bd22cebee0b3ba27f88a": "0x87856315d878150000",
  	"0xeb76424c0fd597d3e341a9642ad1ee118b2b579d": "0xd8d726b7177a800000",
  	"0xeb7c202b462b7cc5855d7484755f6e26ef43a115": "0x6c6b935b8bbd400000",
  	"0xeb835c1a911817878a33d167569ea3cdd387f328": "0x3635c9adc5dea00000",
  	"0xeb89a882670909cf377e9e78286ee97ba78d46c2": "0x2b7cc2e9c3225c0000",
  	"0xeb90c793b3539761e1c814a29671148692193eb4": "0x28a857425466f800000",
  	"0xeb9cc9fe0869d2dab52cc7aae8fd57adb35f9feb": "0x6a93bb17af81f80000",
  	"0xeba388b0da27c87b1cc0eac6c57b2c5a0b459c1a": "0x170a0f5040e50400000",
  	"0xebaa216de9cc5a43031707d36fe6d5bedc05bdf0": "0x6ac5c62d9486070000",
  	"0xebac2b4408ef5431a13b8508e86250982114e145": "0xd8d726b7177a800000",
  	"0xebb62cf8e22c884b1b28c6fa88fbbc17938aa787": "0x2b42798403c9b80000",
  	"0xebb7d2e11bc6b58f0a8d45c2f6de3010570ac891": "0x1731790534df20000",
  	"0xebbb4f2c3da8be3eb62d1ffb1f950261cf98ecda": "0x6c6b935b8bbd400000",
  	"0xebbd4db9019952d68b1b0f6d8cf0683c00387bb5": "0x120401563d7d910000",
  	"0xebbeeb259184a6e01cccfc2207bbd883785ac90a": "0x219bc1b04783d30000",
  	"0xebd356156a383123343d48843bffed6103e866b3": "0x6acb3df27e1f880000",
  	"0xebd37b256563e30c6f9289a8e2702f0852880833": "0x6c6acc67d7b1d40000",
  	"0xebe46cc3c34c32f5add6c3195bb486c4713eb918": "0x3635c9adc5dea00000",
  	"0xebff84bbef423071e604c361bba677f5593def4e": "0x21e19e0c9bab2400000",
  	"0xec0927bac7dc36669c28354ab1be83d7eec30934": "0x6c6b935b8bbd400000",
  	"0xec0e18a01dc4dc5daae567c3fa4c7f8f9b590205": "0x111ffe404a41e60000",
  	"0xec11362cec810985d0ebbd7b73451444985b369f": "0x65a4e49577057318000",
  	"0xec2cb8b9378dff31aec3c22e0e6dadff314ab5dd": "0x6c6b935b8bbd400000",
  	"0xec30addd895b82ee319e54fb04cb2bb03971f36b": "0x6c6b935b8bbd400000",
  	"0xec3b8b58a12703e581ce5ffd7e21c57d1e5c663f": "0x5c283d410394100000",
  	"0xec4867d2175ab5b9469361595546554684cda460": "0xa2a15d09519be00000",
  	"0xec4d08aa2e47496dca87225de33f2b40a8a5b36f": "0x890b0c2e14fb80000",
  	"0xec58bc0d0c20d8f49465664153c5c196fe59e6be": "0x15af1d78b58c400000",
  	"0xec5b198a00cfb55a97b5d53644cffa8a04d2ab45": "0x6c6b935b8bbd400000",
  	"0xec5df227bfa85d7ad76b426e1cee963bc7f519dd": "0x3635c9adc5dea00000",
  	"0xec5feafe210c12bfc9a5d05925a123f1e73fbef8": "0x608fcf3d88748d000000",
  	"0xec6904bae1f69790591709b0609783733f2573e3": "0x1b1ae4d6e2ef500000",
  	"0xec73114c5e406fdbbe09b4fa621bd70ed54ea1ef": "0x53025cd216fce500000",
  	"0xec73833de4b810bb027810fc8f69f544e83c12d1": "0x3635c9adc5dea00000",
  	"0xec75b4a47513120ba5f86039814f1998e3817ac3": "0x9b0bce2e8fdba0000",
  	"0xec76f12e57a65504033f2c0bce6fc03bd7fa0ac4": "0xc2127af858da700000",
  	"0xec8014efc7cbe5b0ce50f3562cf4e67f8593cd32": "0xf015f25736420000",
  	"0xec82f50d06475f684df1b392e00da341aa145444": "0x6c6b935b8bbd400000",
  	"0xec83e798c396b7a55e2a2224abcd834b27ea459c": "0x28a857425466f800000",
  	"0xec89f2b678a1a15b9134ec5eb70c6a62071fbaf9": "0xad78ebc5ac6200000",
  	"0xec8c1d7b6aaccd429db3a91ee4c9eb1ca4f6f73c": "0xe664992288f2280000",
  	"0xec9851bd917270610267d60518b54d3ca2b35b17": "0x878678326eac9000000",
  	"0xec99e95dece46ffffb175eb6400fbebb08ee9b95": "0x56bc75e2d63100000",
  	"0xeca5f58792b8c62d2af556717ee3ee3028be4dce": "0x6c6b935b8bbd400000",
  	"0xecab5aba5b828de1705381f38bc744b32ba1b437": "0x32f51edbaaa3300000",
  	"0xecaf3350b7ce144d068b186010852c84dd0ce0f0": "0x6c6b935b8bbd400000",
  	"0xecb94c568bfe59ade650645f4f26306c736cace4": "0xe7eeba3410b740000",
  	"0xecbe425e670d39094e20fb5643a9d818eed236de": "0x10f0cf064dd59200000",
  	"0xecbe5e1c9ad2b1dccf0a305fc9522f4669dd3ae7": "0x10f0cf064dd59200000",
  	"0xeccf7a0457b566b346ca673a180f444130216ac3": "0x56bc75e2d63100000",
  	"0xecd1a62802351a41568d23033004acc6c005a5d3": "0x2b5e3af16b1880000",
  	"0xecd276af64c79d1bd9a92b86b5e88d9a95eb88f8": "0x1158e460913d00000",
  	"0xecd486fc196791b92cf612d348614f9156488b7e": "0x28a857425466f800000",
  	"0xecdaf93229b45ee672f65db506fb5eca00f7fce6": "0x5701f96dcc40ee8000",
  	"0xece111670b563ccdbebca52384290ecd68fe5c92": "0x1158e460913d00000",
  	"0xece1152682b7598fe2d1e21ec15533885435ac85": "0xd8d726b7177a800000",
  	"0xece1290877b583e361a2d41b009346e6274e2538": "0x1043561a8829300000",
  	"0xecf05d07ea026e7ebf4941002335baf2fed0f002": "0xad78ebc5ac6200000",
  	"0xecf24cdd7c22928c441e694de4aa31b0fab59778": "0x2086ac351052600000",
  	"0xecfd004d02f36cd4d8b4a8c1a9533b6af85cd716": "0x10f41acb4bb3b9c0000",
  	"0xed0206cb23315128f8caff26f6a30b985467d022": "0x878678326eac9000000",
  	"0xed1065dbcf9d73c04ffc7908870d881468c1e132": "0x6c6b935b8bbd400000",
  	"0xed1276513b6fc68628a74185c2e20cbbca7817bf": "0xa5aa85009e39c0000",
  	"0xed12a1ba1fb8adfcb20dfa19582e525aa3b74524": "0x16a6502f15a1e540000",
  	"0xed16ce39feef3bd7f5d162045e0f67c0f00046bb": "0x1158e460913d00000",
  	"0xed1a5c43c574d4e934299b24f1472cdc9fd6f010": "0xad78ebc5ac6200000",
  	"0xed1b24b6912d51b334ac0de6e771c7c0454695ea": "0x22b1c8c1227a00000",
  	"0xed1f1e115a0d60ce02fb25df014d289e3a0cbe7d": "0x1b1ae4d6e2ef500000",
  	"0xed31305c319f9273d3936d8f5b2f71e9b1b22963": "0x56bc75e2d63100000",
  	"0xed327a14d5cfadd98103fc0999718d7ed70528ea": "0x4e1003b28d92800000",
  	"0xed3cbc3782cebd67989b305c4133b2cde32211eb": "0x15af1d78b58c400000",
  	"0xed4014538cee664a2fbcb6dc669f7ab16d0ba57c": "0xad78ebc5ac6200000",
  	"0xed41e1a28f5caa843880ef4e8b08bd6c33141edf": "0x2ad5ddfa7a8d830000",
  	"0xed4be04a052d7accb3dcce90319dba4020ab2c68": "0x7f37a70eaf362178000",
  	"0xed52a2cc0869dc9e9f842bd0957c47a8e9b0c9ff": "0x205b4dfa1ee74780000",
  	"0xed5b4c41e762d942404373caf21ed4615d25e6c1": "0x6d2d4f3d9525b40000",
  	"0xed60c4ab6e540206317e35947a63a9ca6b03e2cb": "0x31ad9ad0b467f8000",
  	"0xed641e06368fb0efaa1703e01fe48f4a685309eb": "0xad78ebc5ac6200000",
  	"0xed6643c0e8884b2d3211853785a08bf8f33ed29f": "0x487a9a304539440000",
  	"0xed70a37cdd1cbda9746d939658ae2a6181288578": "0x2086ac3510526000000",
  	"0xed7346766e1a676d0d06ec821867a276a083bf31": "0xd98a0931cc2d490000",
  	"0xed862616fcbfb3becb7406f73c5cbff00c940755": "0x5c283d410394100000",
  	"0xed9e030ca75cb1d29ea01d0d4cdfdccd3844b6e4": "0x1acc116cfafb18000",
  	"0xed9ebccba42f9815e78233266dd6e835b6afc31b": "0x14542ba12a337c00000",
  	"0xed9fb1f5af2fbf7ffc5029cee42b70ff5c275bf5": "0xf2dc7d47f15600000",
  	"0xeda4b2fa59d684b27a810df8978a73df308a63c2": "0xd8d726b7177a800000",
  	"0xedb473353979a206879de144c10a3c51d7d7081a": "0x14542ba12a337c00000",
  	"0xedb71ec41bda7dce86e766e6e8c3e9907723a69b": "0x1158e460913d00000",
  	"0xedbac9527b54d6df7ae2e000cca3613ba015cae3": "0x6acb3df27e1f880000",
  	"0xedc22fb92c638e1e21ff5cf039daa6e734dafb29": "0x102794ad20da680000",
  	"0xeddacd94ec89a2ef968fcf977a08f1fae2757869": "0x1b1ae4d6e2ef5000000",
  	"0xeddbaafbc21be8f25562f1ed6d05d6afb58f02c2": "0x6c6b935b8bbd400000",
  	"0xede0147ec032c3618310c1ff25690bf172193dac": "0x6c6b935b8bbd400000",
  	"0xede5de7c7fb7eee0f36e64530a41440edfbefacf": "0x21755ee1ef2b180000",
  	"0xede79ae1ff4f1606d59270216fa46ab2ddd4ecaa": "0x7ea28327577080000",
  	"0xede8c2cb876fbe8a4cca8290361a7ea01a69fdf8": "0x1a78c6b44f841838000",
  	"0xedeb4894aadd0081bbddd3e8846804b583d19f27": "0x6c6b935b8bbd400000",
  	"0xedf603890228d7d5de9309942b5cad4219ef9ad7": "0x10f0cf064dd59200000",
  	"0xedf8a3e1d40f13b79ec8e3e1ecf262fd92116263": "0x890b0c2e14fb80000",
  	"0xedfda2d5db98f9380714664d54b4ee971a1cae03": "0x22bb8ddd679be0000",
  	"0xee0007b0960d00908a94432a737557876aac7c31": "0x2e0421e69c4cc8000",
  	"0xee049af005974dd1c7b3a9ca8d9aa77175ba53aa": "0x1211ecb56d13488000",
  	"0xee25b9a7032679b113588ed52c137d1a053a1e94": "0xad50f3f4eea8e0000",
  	"0xee31167f9cc93b3c6465609d79db0cde90e8484c": "0x6c6b935b8bbd400000",
  	"0xee34c7e7995db9f187cff156918cfb6f13f6e003": "0x6a4076cf7995a00000",
  	"0xee3564f5f1ba0f94ec7bac164bddbf31c6888b55": "0x56bc75e2d63100000",
  	"0xee58fb3db29070d0130188ce472be0a172b89055": "0x21f42dcdc58e39c0000",
  	"0xee655bb4ee0e8d5478526fb9f15e4064e09ff3dd": "0xad78ebc5ac6200000",
  	"0xee6959de2b67967b71948c891ab00d8c8f38c7dc": "0x6685ac1bfe32c0000",
  	"0xee6c03429969ca1262cb3f0a4a54afa7d348d7f5": "0xde219f91fc18a0000",
  	"0xee71793e3acf12a7274f563961f537529d89c7de": "0x6c6b935b8bbd400000",
  	"0xee7288d91086d9e2eb910014d9ab90a02d78c2a0": "0x6c6b935b8bbd400000",
  	"0xee7c3ded7c28f459c92fe13b4d95bafbab02367d": "0x25f273933db5700000",
  	"0xee867d20916bd2e9c9ece08aa04385db667c912e": "0xa968163f0a57b400000",
  	"0xee899b02cbcb3939cd61de1342d50482abb68532": "0x5f68e8131ecf800000",
  	"0xee906d7d5f1748258174be4cbc38930302ab7b42": "0xad78ebc5ac6200000",
  	"0xee97aa8ac69edf7a987d6d70979f8ec1fbca7a94": "0x14620c57dddae00000",
  	"0xeea1e97988de75d821cd28ad6822b22cce988b31": "0x1c30731cec03200000",
  	"0xeed28c3f068e094a304b853c950a6809ebcb03e0": "0x3a9d5baa4abf1d00000",
  	"0xeed384ef2d41d9d203974e57c12328ea760e08ea": "0x3635c9adc5dea00000",
  	"0xeedf6c4280e6eb05b934ace428e11d4231b5905b": "0xad78ebc5ac6200000",
  	"0xeee761847e33fd61d99387ee14628694d1bfd525": "0x6c6b935b8bbd400000",
  	"0xeee9d0526eda01e43116a395322dda8970578f39": "0x21e1999bbd5d2be0000",
  	"0xeef1bbb1e5a83fde8248f88ee3018afa2d1332eb": "0xad78ebc5ac6200000",
  	"0xeefba12dfc996742db790464ca7d273be6e81b3e": "0x3635c9adc5dea00000",
  	"0xeefd05b0e3c417d55b3343060486cdd5e92aa7a6": "0x4d853c8f8908980000",
  	"0xef0dc7dd7a53d612728bcbd2b27c19dd4d7d666f": "0x26411c5b35f05a0000",
  	"0xef115252b1b845cd857f002d630f1b6fa37a4e50": "0x6acb3df27e1f880000",
  	"0xef1c0477f1184d60accab374d374557a0a3e10f3": "0x83d6c7aab63600000",
  	"0xef2c34bb487d3762c3cca782ccdd7a8fbb0a9931": "0x9c2007651b2500000",
  	"0xef35f6d4b1075e6aa139151c974b2f4658f70538": "0x3c3bc33f94e50d8000",
  	"0xef39ca9173df15531d73e6b72a684b51ba0f2bb4": "0x56a0b4756ee2380000",
  	"0xef463c2679fb279164e20c3d2691358773a0ad95": "0x6c6b935b8bbd400000",
  	"0xef47cf073e36f271d522d7fa4e7120ad5007a0bc": "0x878678326eac900000",
  	"0xef61155ba009dcdebef10b28d9da3d1bc6c9ced4": "0x3342d60dff1960000",
  	"0xef69781f32ffce33346f2c9ae3f08493f3e82f89": "0xfc936392801c0000",
  	"0xef76a4cd8febcbc9b818f17828f8d93473f3f3cb": "0xd8d726b7177a800000",
  	"0xef93818f684db0c3675ec81332b3183ecc28a495": "0x54069233bf7f780000",
  	"0xef9f59aeda418c1494682d941aab4924b5f4929a": "0x152d02c7e14af6800000",
  	"0xefa6b1f0db603537826891b8b4bc163984bb40cd": "0x35659ef93f0fc40000",
  	"0xefbd52f97da5fd3a673a46cbf330447b7e8aad5c": "0x56c3c9b80a0a68000",
  	"0xefc8cf1963c9a95267b228c086239889f4dfd467": "0x21e19e0c9bab2400000",
  	"0xefcaae9ff64d2cd95b5249dcffe7faa0a0c0e44d": "0x15be6174e1912e0000",
  	"0xefcce06bd6089d0e458ef561f5a689480afe7000": "0x2086ac351052600000",
  	"0xefe0675da98a5dda70cd96196b87f4e726b43348": "0x3f19beb8dd1ab00000",
  	"0xefe8ff87fc260e0767638dd5d02fc4672e0ec06d": "0x6c6b935b8bbd400000",
  	"0xefeb1997aad277cc33430e6111ed0943594048b8": "0x6c6b935b8bbd400000",
  	"0xefeea010756f81da4ba25b721787f058170befbd": "0x1c29c9cf770ef0000",
  	"0xeff51d72adfae143edf3a42b1aec55a2ccdd0b90": "0x1043561a8829300000",
  	"0xeff86b5123bcdc17ed4ce8e05b7e12e51393a1f7": "0x1b1ae4d6e2ef500000",
  	"0xeffc15e487b1beda0a8d1325bdb4172240dc540a": "0x3853939eee1de0000",
  	"0xf01195d657ef3c942e6cb83949e5a20b5cfa8b1e": "0x57473d05dabae800000",
  	"0xf02796295101674288c1d93467053d042219b794": "0x281d901f4fdd100000",
  	"0xf039683d7b3d225bc7d8dfadef63163441be41e2": "0x1dd1e4bd8d1ee0000",
  	"0xf04a6a379708b9428d722aa2b06b77e88935cf89": "0x1043561a8829300000",
  	"0xf04d2c91efb6e9c45ffbe74b434c8c5f2b028f1f": "0x3635c9adc5dea00000",
  	"0xf057aa66ca767ede124a1c5b9cc5fc94ef0b0137": "0x70a24bcab6f45d0000",
  	"0xf05ba8d7b68539d933300bc9289c3d9474d0419e": "0x6da27024dd9600000",
  	"0xf05ceeab65410564709951773c8445ad9f4ec797": "0x10431627a0933b0000",
  	"0xf05fcd4c0d73aa167e5553c8c0d6d4f2faa39757": "0x2d2d66c3170b2980000",
  	"0xf067e1f1d683556a4cc4fd0c0313239f32c4cfd8": "0x3635c9adc5dea00000",
  	"0xf067fb10dfb293e998abe564c055e3348f9fbf1e": "0x6c6b935b8bbd400000",
  	"0xf068dfe95d15cd3a7f98ffa688b4346842be2690": "0x440ad819e0974c0000",
  	"0xf06a854a3c5dc36d1c49f4c87d6db333b57e4add": "0x21e19e0c9bab2400000",
  	"0xf079e1b1265f50e8c8a98ec0c7815eb3aeac9eb4": "0x116dc3a8994b30000",
  	"0xf07bd0e5c2ce69c7c4a724bd26bbfa9d2a17ca03": "0x14061b9d77a5e980000",
  	"0xf0832a6bb25503eeca435be31b0bf905ca1fcf57": "0x16a6502f15a1e540000",
  	"0xf09b3e87f913ddfd57ae8049c731dba9b636dfc3": "0x20f5b1eaad8d800000",
  	"0xf0b1340b996f6f0bf0d9561c849caf7f4430befa": "0x56bc75e2d63100000",
  	"0xf0b1f9e27832c6de6914d70afc238c749995ace4": "0x6c6b935b8bbd400000",
  	"0xf0b469eae89d400ce7d5d66a9695037036b88903": "0x43c33c1937564800000",
  	"0xf0b9d683cea12ba600baace219b0b3c97e8c00e4": "0x56bc75e2d63100000",
  	"0xf0be0faf4d7923fc444622d1980cf2d990aab307": "0x6c6b935b8bbd400000",
  	"0xf0c081da52a9ae36642adf5e08205f05c54168a6": "0x6046f37e5945c0000",
  	"0xf0c70d0d6dab7663aa9ed9ceea567ee2c6b02765": "0x71438ac5a791a08000",
  	"0xf0cbef84e169630098d4e301b20208ef05846ac9": "0xe0b8345506b4e0000",
  	"0xf0d21663d8b0176e05fde1b90ef31f8530fda95f": "0x6c6acc67d7b1d40000",
  	"0xf0d5c31ccb6cbe30c7c9ea19f268d159851f8c9c": "0x3894f0e6f9b9f700000",
  	"0xf0d64cf9df09741133d170485fd24b005011d520": "0x1b089341e14fcc0000",
  	"0xf0d858105e1b648101ac3f85a0f8222bf4f81d6a": "0x2086ac351052600000",
  	"0xf0dc43f205619127507b2b1c1cfdf32d28310920": "0x105eb79b9417088000",
  	"0xf0e1dfa42adeac2f17f6fdf584c94862fd563393": "0x1b1ae4d6e2ef500000",
  	"0xf0e2649c7e6a3f2c5dfe33bbfbd927ca3c350a58": "0x6c6b935b8bbd400000",
  	"0xf0e7fb9e420a5340d536f40408344feaefc06aef": "0x3635c9adc5dea00000",
  	"0xf10462e58fcc07f39584a187639451167e859201": "0x934dd5d33bc970000",
  	"0xf10661ff94140f203e7a482572437938bec9c3f7": "0x43c33c1937564800000",
  	"0xf114ff0d0f24eff896edde5471dea484824a99b3": "0xbe202d6a0eda0000",
  	"0xf116b0b4680f53ab72c968ba802e10aa1be11dc8": "0x1158e460913d00000",
  	"0xf11cf5d363746fee6864d3ca336dd80679bb87ae": "0x878678326eac9000000",
  	"0xf11e01c7a9d12499005f4dae7716095a34176277": "0x15af1d78b58c400000",
  	"0xf13b083093ba564e2dc631568cf7540d9a0ec719": "0x6c6acc67d7b1d40000",
  	"0xf14f0eb86db0eb68753f16918e5d4b807437bd3e": "0xad78ebc5ac6200000",
  	"0xf15178ffc43aa8070ece327e930f809ab1a54f9d": "0xab640391201300000",
  	"0xf156dc0b2a981e5b55d3f2f03b8134e331dbadb7": "0x56bc75e2d63100000",
  	"0xf15d9d5a21b1929e790371a17f16d95f0c69655c": "0x6c6b935b8bbd400000",
  	"0xf15e182c4fbbad79bd93342242d4dccf2be58925": "0x692ae8897081d00000",
  	"0xf1624d980b65336feac5a6d54125005cfcf2aacb": "0x6c6b935b8bbd400000",
  	"0xf167f5868dcf4233a7830609682caf2df4b1b807": "0x81e542e1a7383f0000",
  	"0xf16de1891d8196461395f9b136265b3b9546f6ef": "0x1b28e1f98bbce8000",
  	"0xf17a92e0361dbacecdc5de0d1894955af6a9b606": "0x6c6b935b8bbd400000",
  	"0xf17adb740f45cbbde3094e7e13716f8103f563bd": "0x6c6b935b8bbd400000",
  	"0xf18b14cbf6694336d0fe12ac1f25df2da0c05dbb": "0xd8d4602c26bf6c0000",
  	"0xf19b39389d47b11b8a2c3f1da9124decffbefaf7": "0x6c6b935b8bbd400000",
  	"0xf19f193508393e4d2a127b20b2031f39c82581c6": "0xbdbd7a83bd2f6c0000",
  	"0xf1a1f320407964fd3c8f2e2cc8a4580da94f01ea": "0x6c6c2177557c440000",
  	"0xf1b4ecc63525f7432c3d834ffe2b970fbeb87212": "0xa2a24068facd800000",
  	"0xf1b58faffa8794f50af8e88309c7a6265455d51a": "0x36330322d5238c0000",
  	"0xf1c8c4a941b4628c0d6c30fda56452d99c7e1b64": "0x4e8cea1ede75040000",
  	"0xf1da40736f99d5df3b068a5d745fafc6463fc9b1": "0x696ca23058da10000",
  	"0xf1dc8ac81042c67a9c3c6792b230c46ac016ca10": "0xad78ebc5ac6200000",
  	"0xf1df55dcc34a051012b575cb968bc9c458ea09c9": "0xd8d726b7177a800000",
  	"0xf1e980c559a1a8e5e50a47f8fffdc773b7e06a54": "0x65ffbcdea04b7480000",
  	"0xf1f391ca92808817b755a8b8f4e2ca08d1fd1108": "0x14542ba12a337c00000",
  	"0xf1f766b0e46d73fcd4d52e7a72e1b9190cc632b3": "0x1b1ae4d6e2ef5000000",
  	"0xf2049532fd458a83ca1bff2eebacb6d5ca63f4a4": "0xc48c991dc1545c8000",
  	"0xf206d328e471d0117b246d2a4619827709e96df3": "0xa2af3dc00543440000",
  	"0xf20c9a99b74759d782f25c1ceca802a27e0b436c": "0x5a87e7d7f5f6580000",
  	"0xf2127d54188fedef0f338a5f38c7ff73ad9f6f42": "0x43c33c1937564800000",
  	"0xf2133431d1d9a37ba2f0762bc40c5acc8aa6978e": "0x6c6b935b8bbd400000",
  	"0xf21549bdd1487912f900a7523db5f7626121bba3": "0x21e19e0c9bab2400000",
  	"0xf218bd848ee7f9d38bfdd1c4eb2ed2496ae4305f": "0x1b1ae4d6e2ef500000",
  	"0xf224eb900b37b4490eee6a0b6420d85c947d8733": "0x34957444b840e80000",
  	"0xf2294adbb6f0dcc76e632ebef48ab49f124dbba4": "0x4e43393600a7b10000",
  	"0xf22f4078febbbaa8b0e78e642c8a42f35d433905": "0x6c6acc67d7b1d40000",
  	"0xf237ef05261c34d79cc22b860de0f17f793c3860": "0xad78ebc5ac6200000",
  	"0xf23c7b0cb8cd59b82bd890644a57daf40c85e278": "0x2b66aafe326ff0000",
  	"0xf23d01589eb12d439f7448ff54307529f191858d": "0x6c6b935b8bbd400000",
  	"0xf23e5c633221a8f7363e65870c9f287424d2a960": "0x4acf58e07257100000",
  	"0xf242da845d42d4bf779a00f295b40750fe49ea13": "0x3635c9adc5dea00000",
  	"0xf25259a5c939cd25966c9b6303d3731c53ddbc4c": "0xad78ebc5ac6200000",
  	"0xf25e4c70bc465632c89e5625a832a7722f6bffab": "0xf34b82fd8e91200000",
  	"0xf26bcedce3feadcea3bc3e96eb1040dfd8ffe1a0": "0x2a034919dfbfbc0000",
  	"0xf270792576f05d514493ffd1f5e84bec4b2df810": "0x3635c9adc5dea00000",
  	"0xf2732cf2c13b8bb8e7492a988f5f89e38273ddc8": "0x2086ac351052600000",
  	"0xf2742e6859c569d5f2108351e0bf4dca352a48a8": "0x21e19e0c9bab2400000",
  	"0xf2813a64c5265d020235cb9c319b6c96f906c41e": "0x12f939c99edab80000",
  	"0xf287ff52f461117adb3e1daa71932d1493c65f2e": "0xc55325ca7415e00000",
  	"0xf2ab1161750244d0ecd048ee0d3e51abb143a2fd": "0x42fe2b907373bc0000",
  	"0xf2b4ab2c9427a9015ef6eefff5edb60139b719d1": "0x26db992a3b18000000",
  	"0xf2c03e2a38998c21648760f1e5ae7ea3077d8522": "0x8f3f7193ab079c0000",
  	"0xf2c2904e9fa664a11ee25656d8fd2cc0d9a522a0": "0xb98bc829a6f90000",
  	"0xf2c362b0ef991bc82fb36e66ff75932ae8dd8225": "0x402f4cfee62e80000",
  	"0xf2d0e986d814ea13c8f466a0538c53dc922651f0": "0x4acf58e07257100000",
  	"0xf2d1b7357724ec4c03185b879b63f57e26589153": "0x14542ba12a337c00000",
  	"0xf2d5763ce073127e2cedde6faba786c73ca94141": "0x1ac4286100191f00000",
  	"0xf2d59c8923759073d6f415aaf8eb065ff2f3b685": "0x1ab2cf7c9f87e200000",
  	"0xf2e99f5cbb836b7ad36247571a302cbe4b481c69": "0x6acb3df27e1f880000",
  	"0xf2ed3e77254acb83231dc0860e1a11242ba627db": "0x6b56051582a9700000",
  	"0xf2edde37f9a8c39ddea24d79f4015757d06bf786": "0x152d02c7e14af6800000",
  	"0xf2efe96560c9d97b72bd36447843885c1d90c231": "0x6c6b935b8bbd400000",
  	"0xf2fbb6d887f8b8cc3a869aba847f3d1f643c53d6": "0xd8c9460063d31c0000",
  	"0xf3034367f87d24d3077fa9a2e38a8b0ccb1104ef": "0x3635c9adc5dea00000",
  	"0xf303d5a816affd97e83d9e4dac2f79072bb0098f": "0x340aad21b3b7000000",
  	"0xf3159866c2bc86bba40f9d73bb99f1eee57bb9d7": "0x3635c9adc5dea00000",
  	"0xf316ef1df2ff4d6c1808dba663ec8093697968e0": "0x61464d6cdc80f00000",
  	"0xf32d25eb0ea2b8b3028a4c7a155dc1aae865784d": "0x13593a9297fdad60000",
  	"0xf332c0f3e05a27d9126fd0b641a8c2d4060608fd": "0x10f1b62c4d9644e8000",
  	"0xf338459f32a159b23db30ac335769ab2351aa63c": "0x65a4da25d3016c00000",
  	"0xf33efc6397aa65fb53a8f07a0f893aae30e8bcee": "0x7cf2381f619f150000",
  	"0xf34083ecea385017aa40bdd35ef7effb4ce7762d": "0x15af1d78b58c400000",
  	"0xf346d7de92741c08fc58a64db55b062dde012d14": "0xfff6b1f761e6d0000",
  	"0xf355d3ec0cfb907d8dbb1bf3464e458128190bac": "0x10b046e7f0d80100000",
  	"0xf36df02fbd89607347afce2969b9c4236a58a506": "0x6c6b935b8bbd400000",
  	"0xf373e9daac0c8675f53b797a160f6fc034ae6b23": "0x56bc75e2d63100000",
  	"0xf37b426547a1642d8033324814f0ede3114fc212": "0x15be6174e1912e0000",
  	"0xf37bf78c5875154711cb640d37ea6d28cfcb1259": "0xad78ebc5ac6200000",
  	"0xf382df583155d8548f3f93440cd5f68cb79d6026": "0x38757d027fc1fd5c0000",
  	"0xf382e4c20410b951089e19ba96a2fee3d91cce7e": "0x111fa56eec2a8380000",
  	"0xf38a6ca80168537e974d14e1c3d13990a44c2c1b": "0x14542ba12a337c00000",
  	"0xf39a9d7aa3581df07ee4279ae6c312ef21033658": "0xd8d726b7177a800000",
  	"0xf3b668b3f14d920ebc379092db98031b67b219b3": "0xad6eedd17cf3b8000",
  	"0xf3be99b9103ce7550aa74ff1db18e09dfe32e005": "0x6c6b935b8bbd400000",
  	"0xf3c1abd29dc57b41dc192d0e384d021df0b4f6d4": "0x97ae0cdf8f86f80000",
  	"0xf3c4716d1ee5279a86d0163a14618181e16136c7": "0x3635c9adc5dea00000",
  	"0xf3cc8bcb559465f81bfe583bd7ab0a2306453b9e": "0x43c33c1937564800000",
  	"0xf3d688f06bbdbf50f9932c4145cbe48ecdf68904": "0x1158e460913d00000",
  	"0xf3dbcf135acb9dee1a489c593c024f03c2bbaece": "0x6c6b935b8bbd400000",
  	"0xf3de5f26ef6aded6f06d3b911346ee70401da4a0": "0x133ab37d9f9d030000",
  	"0xf3df63a97199933330383b3ed7570b96c4812334": "0x6c6b935b8bbd400000",
  	"0xf3e74f470c7d3a3f0033780f76a89f3ef691e6cb": "0xa3cfe631d143640000",
  	"0xf3eb1948b951e22df1617829bf3b8d8680ec6b68": "0xd8d726b7177a800000",
  	"0xf3f1fa3918ca34e2cf7e84670b1f4d8eca160db3": "0x24dce54d34a1a00000",
  	"0xf3f24fc29e20403fc0e8f5ebbb553426f78270a2": "0x56bc75e2d63100000",
  	"0xf3fa723552a5d0512e2b62f48dca7b2b8105305b": "0x76d41c62494840000",
  	"0xf3fe51fde34413c73318b9c85437fe7e820f561a": "0x3662325cd18fe00000",
  	"0xf400f93d5f5c7e3fc303129ac8fb0c2f786407fa": "0x6c6b935b8bbd400000",
  	"0xf40b134fea22c6b29c8457f49f000f9cda789adb": "0x2086ac351052600000",
  	"0xf41557dfdfb1a1bdcefefe2eba1e21fe0a4a9942": "0x6acb3df27e1f880000",
  	"0xf4177a0d85d48b0e264211ce2aa2efd3f1b47f08": "0xc2ccca26b7e80e8000",
  	"0xf42f905231c770f0a406f2b768877fb49eee0f21": "0xaadec983fcff40000",
  	"0xf432b9dbaf11bdbd73b6519fc0a904198771aac6": "0x83d6c7aab63600000",
  	"0xf43da3a4e3f5fab104ca9bc1a0f7f3bb4a56f351": "0x6c6acc67d7b1d40000",
  	"0xf447108b98df64b57e871033885c1ad71db1a3f9": "0x176f49ead3483508000",
  	"0xf44f8551ace933720712c5c491cdb6f2f951736c": "0xd8d726b7177a800000",
  	"0xf456055a11ab91ff668e2ec922961f2a23e3db25": "0xfc936392801c0000",
  	"0xf456a75bb99655a7412ce97da081816dfdb2b1f2": "0xad78ebc5ac6200000",
  	"0xf45b1dcb2e41dc27ffa024daadf619c11175c087": "0x11164759ffb320000",
  	"0xf463a90cb3f13e1f0643423636beab84c123b06d": "0x22b1c8c1227a00000",
  	"0xf468906e7edf664ab0d8be3d83eb7ab3f7ffdc78": "0x5c283d410394100000",
  	"0xf46980e3a4a9d29a6a6e90604537a3114bcb2897": "0x1b1ae4d6e2ef500000",
  	"0xf46b6b9c7cb552829c1d3dfd8ffb11aabae782f6": "0x1236efcbcbb340000",
  	"0xf476e1267f86247cc908816f2e7ad5388c952db0": "0xd8d726b7177a800000",
  	"0xf476f2cb7208a32e051fd94ea8662992638287a2": "0x56bc75e2d63100000",
  	"0xf47bb134da30a812d003af8dccb888f44bbf5724": "0x11959b7fe3395580000",
  	"0xf483f607a21fcc28100a018c568ffbe140380410": "0x3635c9adc5dea00000",
  	"0xf48e1f13f6af4d84b371d7de4b273d03a263278e": "0x2086ac351052600000",
  	"0xf49c47b3efd86b6e6a5bc9418d1f9fec814b69ef": "0x43c33c1937564800000",
  	"0xf49f6f9baabc018c8f8e119e0115f491fc92a8a4": "0x21e19e0c9bab2400000",
  	"0xf4a367b166d2991a2bfda9f56463a09f252c1b1d": "0x6acb3df27e1f880000",
  	"0xf4a51fce4a1d5b94b0718389ba4e7814139ca738": "0x1043561a8829300000",
  	"0xf4a9d00cefa97b7a58ef9417fc6267a5069039ee": "0x12e89287fa7840000",
  	"0xf4aaa3a6163e3706577b49c0767e948a681e16ee": "0x6c6b935b8bbd400000",
  	"0xf4b1626e24f30bcad9273c527fcc714b5d007b8f": "0xad78ebc5ac6200000",
  	"0xf4b49100757772f33c177b9a76ba95226c8f3dd8": "0x16b352da5e0ed300000",
  	"0xf4b6cdcfcb24230b337d770df6034dfbd4e1503f": "0x405fdf7e5af85e00000",
  	"0xf4b759cc8a1c75f80849ebbcda878dc8f0d66de4": "0x15af1d78b58c400000",
  	"0xf4ba6a46d55140c439cbcf076cc657136262f4f8": "0x6c6b935b8bbd400000",
  	"0xf4d67a9044b435b66e8977ff39a28dc4bd53729a": "0xad78ebc5ac6200000",
  	"0xf4d97664cc4eec9edbe7fa09f4750a663b507d79": "0xd8d726b7177a800000",
  	"0xf4dc7ba85480bbb3f535c09568aaa3af6f3721c6": "0x1871fb6307e35e50000",
  	"0xf4ebf50bc7e54f82e9b9bd24baef29438e259ce6": "0x21e19e0c9bab2400000",
  	"0xf4ec8e97a20aa5f8dd206f55207e06b813df2cc0": "0xad78ebc5ac6200000",
  	"0xf4ed848ec961739c2c7e352f435ba70a7cd5db38": "0x6acb3df27e1f880000",
  	"0xf4fc4d39bc0c2c4068a36de50e4ab4d4db7e340a": "0x16037df87ef6a0000",
  	"0xf504943aaf16796e0b341bbcdf21d11cc586cdd1": "0x1e7e4171bf4d3a00000",
  	"0xf5061ee2e5ee26b815503677130e1de07a52db07": "0x56bc75e2d63100000",
  	"0xf509557e90183fbf0f0651a786487bcc428ba175": "0xa844a7424d9c80000",
  	"0xf50abbd4aa45d3eb88515465a8ba0b310fd9b521": "0x16a6502f15a1e540000",
  	"0xf50ae7fab4cfb5a646ee04ceadf9bf9dd5a8e540": "0xd8d67c2f5895480000",
  	"0xf50cbafd397edd556c0678988cb2af5c2617e0a2": "0x26d07efe782bb00000",
  	"0xf51fded80acb502890e87369741f3722514cefff": "0x43c3456ca3c6d110000",
  	"0xf52a5882e8927d944b359b26366ba2b9cacfbae8": "0x54b41ce2fe63ba80000",
  	"0xf52c0a7877345fe0c233bb0f04fd6ab18b6f14ba": "0x54cbe55989f38de00000",
  	"0xf5437e158090b2a2d68f82b54a5864b95dd6dbea": "0xd96c16703b2bfe0000",
  	"0xf54c19d9ef3873bfd1f7a622d02d86249a328f06": "0x960ae127af32fb28000",
  	"0xf5500178cb998f126417831a08c2d7abfff6ab5f": "0x46f4f4a5875a9f8000",
  	"0xf5534815dc635efa5cc84b2ac734723e21b29372": "0x55a6e79ccd1d300000",
  	"0xf555a27bb1e2fd4e2cc784caee92939fc06e2fc9": "0x6c6b935b8bbd400000",
  	"0xf558a2b2dd26dd9593aae04531fd3c3cc3854b67": "0xabbcd4ef377580000",
  	"0xf56048dd2181d4a36f64fcecc6215481e42abc15": "0xad78ebc5ac6200000",
  	"0xf56442f60e21691395d0bffaa9194dcaff12e2b7": "0xe18398e7601900000",
  	"0xf579714a45eb8f52c3d57bbdefd2c15b2e2f11df": "0x54915956c409600000",
  	"0xf593c65285ee6bbd6637f3be8f89ad40d489f655": "0xa2a15d09519be00000",
  	"0xf598db2e09a8a5ee7d720d2b5c43bb126d11ecc2": "0xad78ebc5ac6200000",
  	"0xf59dab1bf8df11327e61f9b7a14b563a96ec3554": "0x14542ba12a337c00000",
  	"0xf59f9f02bbc98efe097eabb78210979021898bfd": "0x21e171a3ec9f72c0000",
  	"0xf5a5459fcdd5e5b273830df88eea4cb77ddadfb9": "0x409e52b48369a0000",
  	"0xf5a7676ad148ae9c1ef8b6f5e5a0c2c473be850b": "0xad78ebc5ac6200000",
  	"0xf5b068989df29c253577d0405ade6e0e7528f89e": "0x57473d05dabae80000",
  	"0xf5b6e9061a4eb096160777e26762cf48bdd8b55d": "0xdc55fdb17647b0000",
  	"0xf5cffbba624e7eb321bc83c60ca68199b4e36671": "0x6c6b935b8bbd400000",
  	"0xf5d14552b1dce0d6dc1f320da6ffc8a331cd6f0c": "0x487a9a304539440000",
  	"0xf5d61ac4ca95475e5b7bffd5f2f690b316759615": "0x692ae8897081d000000",
  	"0xf5d9cf00d658dd45517a48a9d3f5f633541a533d": "0x64f5fdf494f780000",
  	"0xf5eadcd2d1b8657a121f33c458a8b13e76b65526": "0xd8b0f5a5ac24a0000",
  	"0xf607c2150d3e1b99f24fa1c7d540add35c4ebe1e": "0xa7f1aa07fc8faa0000",
  	"0xf60bd735543e6bfd2ea6f11bff627340bc035a23": "0x6c6b935b8bbd400000",
  	"0xf60c1b45f164b9580e20275a5c39e1d71e35f891": "0x6c6b935b8bbd400000",
  	"0xf60f62d73937953fef35169e11d872d2ea317eec": "0x121ea68c114e5100000",
  	"0xf61283b4bd8504058ca360e993999b62cbc8cd67": "0xdd2d5fcf3bc9c0000",
  	"0xf617b967b9bd485f7695d2ef51fb7792d898f500": "0x1b1ae4d6e2ef500000",
  	"0xf618d9b104411480a863e623fc55232d1a4f48aa": "0xe689e6d44b1668000",
  	"0xf622e584a6623eaaf99f2be49e5380c5cbcf5cd8": "0xad78ebc5ac6200000",
  	"0xf632adff490da4b72d1236d04b510f74d2faa3cd": "0x4be4e7267b6ae00000",
  	"0xf639ac31da9f67271bd10402b7654e5ce763bd47": "0x15af0f42baf9260000",
  	"0xf63a579bc3eac2a9490410128dbcebe6d9de8243": "0x50c5e761a444080000",
  	"0xf645dd7c890093e8e4c8aa92a6bb353522d3dc98": "0x7439fa2099e580000",
  	"0xf648ea89c27525710172944e79edff847803b775": "0x152d02c7e14af6800000",
  	"0xf64a4ac8d540a9289c68d960d5fb7cc45a77831c": "0x6c6b935b8bbd400000",
  	"0xf64ecf2117931c6d535a311e4ffeaef9d49405b8": "0x90f534608a72880000",
  	"0xf64fe0939a8d1eea2a0ecd9a9730fd7958e33109": "0x11de1e6db450c0000",
  	"0xf65616be9c8b797e7415227c9138faa0891742d7": "0x2ad373ce668e980000",
  	"0xf657fcbe682eb4e8db152ecf892456000b513d15": "0x692ae8897081d00000",
  	"0xf65819ac4cc14c137f05dd7977c7dae08d1a4ab5": "0x58788cb94b1d80000",
  	"0xf67bb8e2118bbcd59027666eedf6943ec9f880a5": "0xd8d726b7177a800000",
  	"0xf68464bf64f2411356e4d3250efefe5c50a5f65b": "0x1158e460913d00000",
  	"0xf686785b89720b61145fea80978d6acc8e0bc196": "0xd8d726b7177a800000",
  	"0xf68c5e33fa97139df5b2e63886ce34ebf3e4979c": "0xb3fa4169e2d8e00000",
  	"0xf6a8635757c5e8c134d20d028cf778cf8609e46a": "0x4f1d772faec17c0000",
  	"0xf6b782f4dcd745a6c0e2e030600e04a24b25e542": "0x15af1d78b58c400000",
  	"0xf6bc37b1d2a3788d589b6de212dc1713b2f6e78e": "0x10f0cf064dd59200000",
  	"0xf6c3c48a1ac0a34799f04db86ec7a975fe7768f3": "0x6acb3df27e1f880000",
  	"0xf6d25d3f3d846d239f525fa8cac97bc43578dbac": "0x30927f74c9de000000",
  	"0xf6eaac7032d492ef17fd6095afc11d634f56b382": "0x1b1b6bd7af64c70000",
  	"0xf6ead67dbf5b7eb13358e10f36189d53e643cfcf": "0x878678326eac9000000",
  	"0xf6f1a44309051c6b25e47dff909b179bb9ab591c": "0x692ae8897081d00000",
  	"0xf70328ef97625fe745faa49ee0f9d4aa3b0dfb69": "0x3635c9adc5dea00000",
  	"0xf70a998a717b338d1dd99854409b1a338deea4b0": "0x6c6b935b8bbd400000",
  	"0xf70d637a845c06db6cdc91e6371ce7c4388a628e": "0x1158e460913d00000",
  	"0xf7155213449892744bc60f2e04400788bd041fdd": "0x39fbae8d042dd0000",
  	"0xf71b4534f286e43093b1e15efea749e7597b8b57": "0x161c13d3341c87280000",
  	"0xf734ec03724ddee5bb5279aa1afcf61b0cb448a1": "0xe5bf2cc9b097800000",
  	"0xf736dc96760012388fe88b66c06efe57e0d7cf0a": "0x71d75ab9b920500000",
  	"0xf73ac46c203be1538111b151ec8220c786d84144": "0xff7377817b82b8000",
  	"0xf73dd9c142b71bce11d06e30e7e7d032f2ec9c9e": "0x6acb3df27e1f880000",
  	"0xf7418aa0e713d248228776b2e7434222ae75e3a5": "0x6c6b935b8bbd400000",
  	"0xf74e6e145382b4db821fe0f2d98388f45609c69f": "0x56bc75e2d63100000",
  	"0xf7500c166f8bea2f82347606e5024be9e4f4ce99": "0x1158e460913d00000",
  	"0xf757fc8720d3c4fa5277075e60bd5c411aebd977": "0x6c6b935b8bbd400000",
  	"0xf75bb39c799779ebc04a336d260da63146ed98d0": "0x15af1d78b58c40000",
  	"0xf768f321fd6433d96b4f354d3cc1652c1732f57f": "0x21e19e0c9bab2400000",
  	"0xf76f69cee4faa0a63b30ae1e7881f4f715657010": "0xad78ebc5ac6200000",
  	"0xf777361a3dd8ab62e5f1b9b047568cc0b555704c": "0x3635c9adc5dea00000",
  	"0xf77c7b845149efba19e261bc7c75157908afa990": "0x6c6b935b8bbd400000",
  	"0xf77f9587ff7a2d7295f1f571c886bd33926a527c": "0x6c68ccd09b022c0000",
  	"0xf78258c12481bcdddbb72a8ca0c043097261c6c5": "0x1158e460913d00000",
  	"0xf798d16da4e460c460cd485fae0fa0599708eb82": "0x3635c9adc5dea00000",
  	"0xf7a1ade2d0f529123d1055f19b17919f56214e67": "0x1b1ae4d6e2ef500000",
  	"0xf7acff934b84da0969dc37a8fcf643b7d7fbed41": "0x6c6acc67d7b1d40000",
  	"0xf7b151cc5e571c17c76539dbe9964cbb6fe5de79": "0x74717cfb6883100000",
  	"0xf7b29b82195c882dab7897c2ae95e77710f57875": "0x7735416132dbfc0000",
  	"0xf7bc4c44910d5aedd66ed2355538a6b193c361ec": "0x541de2c2d8d620000",
  	"0xf7c00cdb1f020310d5acab7b496aaa44b779085e": "0x5a87e7d7f5f6580000",
  	"0xf7c1b443968b117b5dd9b755572fcd39ca5ec04b": "0x18b968c292f1b50000",
  	"0xf7c50f922ad16b61c6d1baa045ed816815bac48f": "0x2a9396a9784ad7d0000",
  	"0xf7c708015071d4fb0a3a2a09a45d156396e3349e": "0xa2a15d09519be00000",
  	"0xf7cbdba6be6cfe68dbc23c2b0ff530ee05226f84": "0x1158e460913d00000",
  	"0xf7d0d310acea18406138baaabbfe0571e80de85f": "0x487a9a304539440000",
  	"0xf7d7af204c56f31fd94398e40df1964bd8bf123c": "0x821d221b5291f8000",
  	"0xf7dc251196fbcbb77c947d7c1946b0ff65021cea": "0x3635c9adc5dea00000",
  	"0xf7e45a12aa711c709acefe95f33b78612d2ad22a": "0xe0655e2f26bc9180000",
  	"0xf7f4898c4c526d955f21f055cb6e47b915e51964": "0x7c0860e5a80dc00000",
  	"0xf7f91e7acb5b8129a306877ce3168e6f438b66a1": "0x98a7d9b8314c00000",
  	"0xf7fc45abf76f5088e2e5b5a8d132f28a4d4ec1c0": "0x6c6b935b8bbd400000",
  	"0xf8063af4cc1dd9619ab5d8bff3fcd1faa8488221": "0x6c6b935b8bbd400000",
  	"0xf8086e42661ea929d2dda1ab6c748ce3055d111e": "0x3635c9adc5dea00000",
  	"0xf8087786b42da04ed6d1e0fe26f6c0eefe1e9f5a": "0x21e19e0c9bab2400000",
  	"0xf80d3619702fa5838c48391859a839fb9ce7160f": "0x6c07a7d1b16e700000",
  	"0xf814799f6ddf4dcb29c7ee870e75f9cc2d35326d": "0x3635c9adc5dea00000",
  	"0xf815c10a032d13c34b8976fa6e3bd2c9131a8ba9": "0x487a9a304539440000",
  	"0xf81622e55757daea6675975dd93538da7d16991e": "0x6c6b935b8bbd400000",
  	"0xf824ee331e4ac3cc587693395b57ecf625a6c0c2": "0x56c95de8e8ca1d0000",
  	"0xf827d56ed2d32720d4abf103d6d0ef4d3bcd559b": "0x16c80065791a28000",
  	"0xf8298591523e50b103f0b701d623cbf0f74556f6": "0xad78ebc5ac6200000",
  	"0xf848fce9ab611c7d99206e23fac69ad488b94fe1": "0x2a1129d0936720000",
  	"0xf84f090adf3f8db7e194b350fbb77500699f66fd": "0x6acb3df27e1f880000",
  	"0xf851b010f633c40af1a8f06a73ebbaab65077ab5": "0xee86442fcd06c00000",
  	"0xf858171a04d357a13b4941c16e7e55ddd4941329": "0x246a5218f2a000000",
  	"0xf85bab1cb3710fc05fa19ffac22e67521a0ba21d": "0x6c95357fa6b36c0000",
  	"0xf86a3ea8071f7095c7db8a05ae507a8929dbb876": "0x1236efcbcbb3400000",
  	"0xf8704c16d2fd5ba3a2c01d0eb20484e6ecfa3109": "0xad78ebc5ac6200000",
  	"0xf870995fe1e522321d754337a45c0c9d7b38951c": "0x1158e460913d00000",
  	"0xf873e57a65c93b6e18cb75f0dc077d5b8933dc5c": "0xaadec983fcff40000",
  	"0xf875619d8a23e45d8998d184d480c0748970822a": "0xd8d726b7177a800000",
  	"0xf87bb07b289df7301e54c0efda6a2cf291e89200": "0x4be4e7267b6ae00000",
  	"0xf88900db737955b1519b1a7d170a18864ce590eb": "0xfc936392801c0000",
  	"0xf88b58db37420b464c0be88b45ee2b95290f8cfa": "0x22b1c8c1227a00000",
  	"0xf8962b75db5d24c7e8b7cef1068c3e67cebb30a5": "0xf2dc7d47f15600000",
  	"0xf8a065f287d91d77cd626af38ffa220d9b552a2b": "0x678a932062e4180000",
  	"0xf8a49ca2390c1f6d5c0e62513b079571743f7cc6": "0xa2a15d09519be00000",
  	"0xf8a50cee2e688ceee3aca4d4a29725d4072cc483": "0x6c6b935b8bbd400000",
  	"0xf8ac4a39b53c11307820973b441365cffe596f66": "0x6c6b935b8bbd400000",
  	"0xf8ae857b67a4a2893a3fbe7c7a87ff1c01c6a6e7": "0xd8d726b7177a800000",
  	"0xf8bf9c04874e5a77f38f4c38527e80c676f7b887": "0x6c6b935b8bbd400000",
  	"0xf8c7f34a38b31801da43063477b12b27d0f203ff": "0x1ad2baba6fef480000",
  	"0xf8ca336c8e91bd20e314c20b2dd4608b9c8b9459": "0x2ddc9bc5b32c780000",
  	"0xf8d17424c767bea31205739a2b57a7277214eebe": "0x246ddf97976680000",
  	"0xf8d52dcc5f96cc28007b3ecbb409f7e22a646caa": "0x81690e18128480000",
  	"0xf8dce867f0a39c5bef9eeba609229efa02678b6c": "0x6c6b935b8bbd400000",
  	"0xf8f226142a428434ab17a1864a2597f64aab2f06": "0x9598b2fb2e9f28000",
  	"0xf8f6645e0dee644b3dad81d571ef9baf840021ad": "0x6c6b935b8bbd400000",
  	"0xf901c00fc1db88b69c4bc3252b5ca70ea6ee5cf6": "0x15af1d78b58c400000",
  	"0xf93d5bcb0644b0cce5fcdda343f5168ffab2877d": "0xb6207b67d26f90000",
  	"0xf9570e924c95debb7061369792cf2efec2a82d5e": "0x1158e460913d00000",
  	"0xf9642086b1fbae61a6804dbe5fb15ec2d2b537f4": "0x6c6b935b8bbd400000",
  	"0xf96488698590dc3b2c555642b871348dfa067ad5": "0x1b1ae4d6e2ef500000",
  	"0xf964d98d281730ba35b2e3a314796e7b42fedf67": "0x53b0876098d80c0000",
  	"0xf9650d6989f199ab1cc479636ded30f241021f65": "0x2e141ea081ca080000",
  	"0xf96883582459908c827627e86f28e646f9c7fc7a": "0x1c4a78737cdcfb80000",
  	"0xf96b4c00766f53736a8574f822e6474c2f21da2d": "0x15af1d78b58c400000",
  	"0xf9729d48282c9e87166d5eef2d01eda9dbf78821": "0x56b83ddc728548000",
  	"0xf9767e4ecb4a5980527508d7bec3d45e4c649c13": "0x678a932062e4180000",
  	"0xf978b025b64233555cc3c19ada7f4199c9348bf7": "0x54b40b1f852bda000000",
  	"0xf97b56ebd5b77abc9fbacbabd494b9d2c221cd03": "0x6acb3df27e1f880000",
  	"0xf9811fa19dadbf029f8bfe569adb18228c80481a": "0xad78ebc5ac6200000",
  	"0xf98250730c4c61c57f129835f2680894794542f3": "0xd8d726b7177a800000",
  	"0xf989346772995ec1906faffeba2a7fe7de9c6bab": "0x16a6502f15a1e540000",
  	"0xf998ca3411730a6cd10e7455b0410fb0f6d3ff80": "0x6c6b935b8bbd400000",
  	"0xf99aee444b5783c093cfffd1c4632cf93c6f050c": "0x15af1d78b58c400000",
  	"0xf99eeece39fa7ef5076d855061384009792cf2e0": "0x1b1ae4d6e2ef500000",
  	"0xf9a59c3cc5ffacbcb67be0fc7256f64c9b127cb4": "0x6c6b935b8bbd400000",
  	"0xf9a94bd56198da245ed01d1e6430b24b2708dcc0": "0x28a77afda87ee50000",
  	"0xf9b37825f03073d31e249378c30c795c33f83af2": "0xad9aabf8c9bfc0000",
  	"0xf9b617f752edecae3e909fbb911d2f8192f84209": "0x90f534608a72880000",
  	"0xf9bfb59d538afc4874d4f5941b08c9730e38e24b": "0x22b1c8c1227a00000",
  	"0xf9dd239008182fb519fb30eedd2093fed1639be8": "0x1b1ae4d6e2ef500000",
  	"0xf9debaecb5f339beea4894e5204bfa340d067f25": "0x5a42844673b1640000",
  	"0xf9e37447406c412197b2e2aebc001d6e30c98c60": "0x1c479bb4349c0ee0000",
  	"0xf9e7222faaf0f4da40c1c4a40630373a09bed7b6": "0x9b4fdcb09456240000",
  	"0xf9ece022bccd2c92346911e79dd50303c01e0188": "0x3635c9adc5dea00000",
  	"0xfa00c376e89c05e887817a9dd0748d96f341aa89": "0x104d0d00d2b7f60000",
  	"0xfa0c1a988c8a17ad3528eb28b3409daa58225f26": "0xad78ebc5ac6200000",
  	"0xfa105f1a11b6e4b1f56012a27922e2ac2da4812f": "0x205b4dfa1ee74780000",
  	"0xfa142fe47eda97e6503b386b18a2bedd73ccb5b1": "0x2e153ad81548100000",
  	"0xfa14b566234abee73042c31d21717182cba14aa1": "0x11c7ea162e78200000",
  	"0xfa19d6f7a50f4f079893d167bf14e21d0073d196": "0x1cbb3a3ff08d080000",
  	"0xfa1f1971a775c3504fef5079f640c2c4bce7ac05": "0x6c6b935b8bbd400000",
  	"0xfa279bfd8767f956bf7fa0bd5660168da75686bd": "0x90f534608a72880000",
  	"0xfa27cc49d00b6c987336a875ae39da58fb041b2e": "0x21e19e0c9bab2400000",
  	"0xfa283299603d8758e8cab082125d2c8f7d445429": "0x15bcacb1e0501ae8000",
  	"0xfa2bbca15d3fe39f8a328e91f90da14f7ac6253d": "0xad78ebc5ac6200000",
  	"0xfa2fd29d03fee9a07893df3a269f56b72f2e1e64": "0x21e19e0c9bab2400000",
  	"0xfa33553285a973719a0d5f956ff861b2d89ed304": "0x1158e460913d00000",
  	"0xfa3a0c4b903f6ea52ea7ab7b8863b6a616ad6650": "0x1158e460913d00000",
  	"0xfa3a1aa4488b351aa7560cf5ee630a2fd45c3222": "0x2fa47e6aa7340d0000",
  	"0xfa410971ad229c3036f41acf852f2ac999281950": "0xd8b311a8ddfa7c0000",
  	"0xfa44a855e404c86d0ca8ef3324251dfb349c539e": "0x542253a126ce400000",
  	"0xfa5201fe1342af11307b9142a041243ca92e2f09": "0x2038116a3ac043980000",
  	"0xfa60868aafd4ff4c5c57914b8ed58b425773dfa9": "0x1cfe5c808f39fbc0000",
  	"0xfa67b67b4f37a0150915110ede073b05b853bda2": "0x2319ba947371ad0000",
  	"0xfa68e0cb3edf51f0a6f211c9b2cb5e073c9bffe6": "0xfc936392801c00000",
  	"0xfa6a37f018e97967937fc5e8617ba1d786dd5f77": "0x43c30fb0884a96c0000",
  	"0xfa7606435b356cee257bd2fcd3d9eacb3cd1c4e1": "0x56bc75e2d63100000",
  	"0xfa7adf660b8d99ce15933d7c5f072f3cbeb99d33": "0x14061b9d77a5e980000",
  	"0xfa86ca27bf2854d98870837fb6f6dfe4bf6453fc": "0x11757e8525cf148000",
  	"0xfa8cf4e627698c5d5788abb7880417e750231399": "0xe61a3696eef6100000",
  	"0xfa8e3b1f13433900737daaf1f6299c4887f85b5f": "0x26c29e47c4844c0000",
  	"0xfa9ec8efe08686fa58c181335872ba698560ecab": "0x6c6acc67d7b1d40000",
  	"0xfaad905d847c7b23418aeecbe3addb8dd3f8924a": "0x6acb3df27e1f880000",
  	"0xfaaeba8fc0bbda553ca72e30ef3d732e26e82041": "0x488d282aafc9f68000",
  	"0xfab487500df20fb83ebed916791d561772adbebf": "0x6c6b4c4da6ddbe0000",
  	"0xfac5ca94758078fbfccd19db3558da7ee8a0a768": "0x3728a62b0dcff60000",
  	"0xfad96ab6ac768ad5099452ac4777bd1a47edc48f": "0x56bc75e2d63100000",
  	"0xfae76719d97eac41870428e940279d97dd57b2f6": "0x14dbb2195ca228900000",
  	"0xfae881937047895a660cf229760f27e66828d643": "0x9ddc1e3b901180000",
  	"0xfae92c1370e9e1859a5df83b56d0f586aa3b404c": "0x5c5b4f3d843980000",
  	"0xfaf5f0b7b6d558f5090d9ea1fb2d42259c586078": "0x15affb8420c6b640000",
  	"0xfb126f0ec769f49dcefca2f200286451583084b8": "0x10fcbc2350396bf0000",
  	"0xfb135eb15a8bac72b69915342a60bbc06b7e077c": "0x43c33c1937564800000",
  	"0xfb223c1e22eac1269b32ee156a5385922ed36fb8": "0x6c6b935b8bbd400000",
  	"0xfb37cf6b4f81a9e222fba22e9bd24b5098b733cf": "0x21a754a6dc5280000",
  	"0xfb3860f4121c432ebdc8ec6a0331b1b709792e90": "0x208c394af1c8880000",
  	"0xfb39189af876e762c71d6c3e741893df226cedd6": "0xd8d726b7177a800000",
  	"0xfb3a0b0d6b6a718f6fc0292a825dc9247a90a5d0": "0xad6dd199e975b0000",
  	"0xfb3fa1ac08aba9cc3bf0fe9d483820688f65b410": "0x65a4da25d3016c00000",
  	"0xfb3fe09bb836861529d7518da27635f538505615": "0x4be39216fda0700000",
  	"0xfb5125bf0f5eb0b6f020e56bfc2fdf3d402c097e": "0x14061b9d77a5e980000",
  	"0xfb5518714cefc36d04865de5915ef0ff47dfe743": "0x6c6b935b8bbd400000",
  	"0xfb5ffaa0f7615726357891475818939d2037cf96": "0x1158e460913d00000",
  	"0xfb685c15e439965ef626bf0d834cd1a89f2b5695": "0xd5967be4fc3f100000",
  	"0xfb744b951d094b310262c8f986c860df9ab1de65": "0x2d1c515f1cb4a8000",
  	"0xfb79abdb925c55b9f98efeef64cfc9eb61f51bb1": "0x6140c056fb0ac80000",
  	"0xfb8113f94d9173eefd5a3073f516803a10b286ae": "0x4563918244f400000",
  	"0xfb842ca2c5ef133917a236a0d4ac40690110b038": "0x10969a62be15880000",
  	"0xfb91fb1a695553f0c68e21276decf0b83909b86d": "0x56c003617af780000",
  	"0xfb9473cf7712350a1fa0395273fc80560752e4fb": "0x6af2198ba85aa0000",
  	"0xfb949c647fdcfd2514c7d58e31f28a532d8c5833": "0x43c33c1937564800000",
  	"0xfba5486d53c6e240494241abf87e43c7600d413a": "0x6bbf61494948340000",
  	"0xfbb161fe875f09290a4b262bc60110848f0d2226": "0x6c6b935b8bbd400000",
  	"0xfbbbebcfbe235e57dd2306ad1a9ec581c7f9f48f": "0x22b1c8c1227a00000",
  	"0xfbc01db54e47cdc3c438694ab717a856c23fe6e9": "0x1ca7150ab174f470000",
  	"0xfbcfcc4a7b0f26cf26e9f3332132e2fc6a230766": "0x1b1ae4d6e2ef5000000",
  	"0xfbe71622bcbd31c1a36976e7e5f670c07ffe16de": "0x15af1d78b58c400000",
  	"0xfbede32c349f3300ef4cd33b4de7dc18e443d326": "0xab4dcf399a3a600000",
  	"0xfbf204c813f836d83962c7870c7808ca347fd33e": "0x1158e460913d00000",
  	"0xfbf75933e01b75b154ef0669076be87f62dffae1": "0x10846372f249d4c00000",
  	"0xfc0096b21e95acb8d619d176a4a1d8d529badbef": "0x14d9693bcbec028000",
  	"0xfc00a420a36107dfd5f495128a5fe5abb2db0f34": "0x143179d869110200000",
  	"0xfc018a690ad6746dbe3acf9712ddca52b6250039": "0x21e19e0c9bab2400000",
  	"0xfc02734033e57f70517e0afc7ee62461f06fad8e": "0x155bd9307f9fe80000",
  	"0xfc0ee6f7c2b3714ae9916c45566605b656f32441": "0x5f68e8131ecf800000",
  	"0xfc10b7a67b3268d5331bfb6a14def5ea4a162ca3": "0xad78ebc5ac6200000",
  	"0xfc15cb99a8d1030b12770add033a79ee0d0c908c": "0x12fa00bd52e6240000",
  	"0xfc2952b4c49fedd0bc0528a308495e6d6a1c71d6": "0x6c6b935b8bbd400000",
  	"0xfc2c1f88961d019c3e9ea33009152e0693fbf88a": "0x1b1ae4d6e2ef5000000",
  	"0xfc361105dd90f9ede566499d69e9130395f12ac8": "0x53a4fe2f204e80e00000",
  	"0xfc372ff6927cb396d9cf29803500110da632bc52": "0x6c6b935b8bbd400000",
  	"0xfc39be41094b1997d2169e8264c2c3baa6c99bc4": "0x6c6b935b8bbd400000",
  	"0xfc3d226bb36a58f526568857b0bb12d109ec9301": "0x6c6b935b8bbd400000",
  	"0xfc43829ac787ff88aaf183ba352aadbf5a15b193": "0xd6ac0a2b0552e00000",
  	"0xfc49c1439a41d6b3cf26bb67e0365224e5e38f5f": "0x3636d7af5ec98e0000",
  	"0xfc5500825105cf712a318a5e9c3bfc69c89d0c12": "0xd8d726b7177a800000",
  	"0xfc66faba277f4b5de64ad45eb19c31e00ced3ed5": "0x131beb925ffd3200000",
  	"0xfc7e22a503ec5abe9b08c50bd14999f520fa4884": "0x15a477dfbe1ea148000",
  	"0xfc8215a0a69913f62a43bf1c8590b9ddcd0d8ddb": "0x6c6b935b8bbd400000",
  	"0xfc989cb487bf1a7d17e4c1b7c4b7aafdda6b0a8d": "0x1158e460913d00000",
  	"0xfc9b347464b2f9929d807e039dae48d3d98de379": "0x2f6f10780d22cc00000",
  	"0xfca43bbc23a0d321ba9e46b929735ce7d8ef0c18": "0x1158e460913d00000",
  	"0xfca73eff8771c0103ba3cc1a9c259448c72abf0b": "0x3635c9adc5dea00000",
  	"0xfcada300283f6bcc134a91456760b0d77de410e0": "0x6c6b935b8bbd400000",
  	"0xfcbc5c71ace79741450b012cf6b8d3f17db68a70": "0x205b4dfa1ee74780000",
  	"0xfcbd85feea6a754fcf3449449e37ff9784f7773c": "0xa74ada69abd7780000",
  	"0xfcc9d4a4262e7a027ab7519110d802c495ceea39": "0x1595182224b26480000",
  	"0xfccd0d1ecee27addea95f6857aeec8c7a04b28ee": "0x21e19e0c9bab2400000",
  	"0xfcd0b4827cd208ffbf5e759dba8c3cc61d8c2c3c": "0x1b1ae4d6e2ef5000000",
  	"0xfce089635ce97abac06b44819be5bb0a3e2e0b37": "0x503920a7630a78000",
  	"0xfcf199f8b854222f182e4e1d099d4e323e2aae01": "0x3635c9adc5dea00000",
  	"0xfcfc3a5004d678613f0b36a642269a7f371c3f6a": "0x3635c9adc5dea00000",
  	"0xfd191a35157d781373fb411bf9f25290047c5eef": "0x3635c9adc5dea00000",
  	"0xfd1faa347b0fcc804c2da86c36d5f1d18b7087bb": "0x2d6eb247a96f60000",
  	"0xfd1fb5a89a89a721b8797068fbc47f3e9d52e149": "0xcd0b5837fc6580000",
  	"0xfd204f4f4aba2525ba728afdf78792cbdeb735ae": "0x6c6b935b8bbd400000",
  	"0xfd2757cc3551a095878d97875615fe0c6a32aa8a": "0x206db15299beac0000",
  	"0xfd2872d19e57853cfa16effe93d0b1d47b4f93fb": "0xd8d726b7177a800000",
  	"0xfd2929271e9d2095a264767e7b0df52ea0d1d400": "0xa2a1eb251b5ae40000",
  	"0xfd377a385272900cb436a3bb7962cdffe93f5dad": "0x6c6b935b8bbd400000",
  	"0xfd40242bb34a70855ef0fd90f3802dec2136b327": "0x68a875073e29240000",
  	"0xfd452c3969ece3801c542020f1cdcaa1c71ed23d": "0x152d02c7e14af6800000",
  	"0xfd4b551f6fdbcda6c511b5bb372250a6b783e534": "0x11de1e6db450c0000",
  	"0xfd4b989558ae11be0c3b36e2d6f2a54a9343ca2e": "0x6c6b935b8bbd400000",
  	"0xfd4de8e3748a289cf7d060517d9d38388db01fb8": "0xd8d726b7177a80000",
  	"0xfd5a63157f914fd398eab19c137dd9550bb7715c": "0x56bc75e2d63100000",
  	"0xfd60d2b5af3d35f7aaf0c393052e79c4d823d985": "0x30eb50d2e14080000",
  	"0xfd686de53fa97f99639e2568549720bc588c9efc": "0x6ac5c62d9486070000",
  	"0xfd7ede8f5240a06541eb699d782c2f9afb2170f6": "0x487a9a304539440000",
  	"0xfd812bc69fb170ef57e2327e80affd14f8e4b6d2": "0x6c6b935b8bbd400000",
  	"0xfd88d114220f081cb3d5e15be8152ab07366576a": "0x1043561a8829300000",
  	"0xfd918536a8efa6f6cefe1fa1153995fef5e33d3b": "0x1b1ae4d6e2ef500000",
  	"0xfd920f722682afb5af451b0544d4f41b3b9d5742": "0x7e52056a123f3c0000",
  	"0xfd9579f119bbc819a02b61e38d8803c942f24d32": "0x5b97e9081d9400000",
  	"0xfda0ce15330707f10bce3201172d2018b9ddea74": "0x2d041d705a2c60000",
  	"0xfda3042819af3e662900e1b92b4358eda6e92590": "0x1907a284d58f63e00000",
  	"0xfda6810ea5ac985d6ffbf1c511f1c142edcfddf7": "0xd8d726b7177a800000",
  	"0xfdb33944f2360615e5be239577c8a19ba52d9887": "0x209d922f5259c50000",
  	"0xfdba5359f7ec3bc770ac49975d844ec9716256f1": "0x3635c9adc5dea00000",
  	"0xfdc4d4765a942f5bf96931a9e8cc7ab8b757ff4c": "0x126c478a0e3ea8600000",
  	"0xfdcd5d80b105897a57abc47865768b2900524295": "0x15af1d78b58c4000000",
  	"0xfdd1195f797d4f35717d15e6f9810a9a3ff55460": "0xfc936392801c0000",
  	"0xfdd502a74e813bcfa355ceda3c176f6a6871af7f": "0x15af1d78b58c400000",
  	"0xfde395bc0b6d5cbb4c1d8fea3e0b4bff635e9db7": "0x6c6b935b8bbd400000",
  	"0xfdeaac2acf1d138e19f2fc3f9fb74592e3ed818a": "0x243d4d18229ca20000",
  	"0xfdecc82ddfc56192e26f563c3d68cb544a96bfed": "0x17da3a04c7b3e00000",
  	"0xfdf42343019b0b0c6bf260b173afab7e45b9d621": "0x6c6acc67d7b1d40000",
  	"0xfdf449f108c6fb4f5a2b081eed7e45e6919e4d25": "0x6c6b935b8bbd400000",
  	"0xfdfd6134c04a8ab7eb16f00643f8fed7daaaecb2": "0x15af1d78b58c400000",
  	"0xfe00bf439911a553982db638039245bcf032dbdc": "0x155bd9307f9fe80000",
  	"0xfe016ec17ec5f10e3bb98ff4a1eda045157682ab": "0x145f5402e7b2e60000",
  	"0xfe0e30e214290d743dd30eb082f1f0a5225ade61": "0xad78ebc5ac6200000",
  	"0xfe210b8f04dc6d4f76216acfcbd59ba83be9b630": "0x1158e460913d00000",
  	"0xfe22a0b388668d1ae2643e771dacf38a434223cc": "0xd8db5ebd7b26380000",
  	"0xfe362688845fa244cc807e4b1130eb3741a8051e": "0x3635c9adc5dea00000",
  	"0xfe3827d57630cf8761d512797b0b858e478bbd12": "0x1158e460913d00000",
  	"0xfe418b421a9c6d373602790475d2303e11a75930": "0x3708baed3d68900000",
  	"0xfe4249127950e2f896ec0e7e2e3d055aab10550f": "0x243d4d18229ca20000",
  	"0xfe4d8403216fd571572bf1bdb01d00578978d688": "0x215f835bc769da80000",
  	"0xfe53b94989d89964da2061539526bbe979dd2ea9": "0x68a875073e29240000",
  	"0xfe549bbfe64740189892932538daaf46d2b61d4f": "0x22b1c8c1227a00000",
  	"0xfe615d975c0887e0c9113ec7298420a793af8b96": "0x1b1ae4d6e2ef5000000",
  	"0xfe65c4188d7922576909642044fdc52395560165": "0xd8d726b7177a800000",
  	"0xfe697ff22ca547bfc95e33d960da605c6763f35b": "0x47d4119fd960940000",
  	"0xfe6a895b795cb4bf85903d3ce09c5aa43953d3bf": "0xb8507a820728200000",
  	"0xfe6f5f42b6193b1ad16206e4afb5239d4d7db45e": "0x5dc892aa1131c80000",
  	"0xfe7011b698bf3371132d7445b19eb5b094356aee": "0x6c6b935b8bbd400000",
  	"0xfe80e9232deaff19baf99869883a4bdf0004e53c": "0x2e62f20a69be400000",
  	"0xfe8e6e3665570dff7a1bda697aa589c0b4e9024a": "0x6c6b935b8bbd400000",
  	"0xfe8f1fdcab7fbec9a6a3fcc507619600505c36a3": "0x11164759ffb320000",
  	"0xfe91eccf2bd566afa11696c5049fa84c69630a52": "0x692ae8897081d00000",
  	"0xfe96c4cd381562401aa32a86e65b9d52fa8aee27": "0x8f1d5c1cae37400000",
  	"0xfe98c664c3e447a95e69bd582171b7176ea2a685": "0xd8d726b7177a800000",
  	"0xfe9ad12ef05d6d90261f96c8340a0381974df477": "0x6c6b935b8bbd400000",
  	"0xfe9c0fffefb803081256c0cf4d6659e6d33eb4fb": "0x52d542804f1ce00000",
  	"0xfe9cfc3bb293ddb285e625f3582f74a6b0a5a6cd": "0x6acb3df27e1f880000",
  	"0xfe9e1197d7974a7648dcc7a03112a88edbc9045d": "0x10afc1ade3b4ed40000",
  	"0xfeaca2ac74624bf348dac9985143cfd652a4be55": "0x5897fcbb02914088000",
  	"0xfead1803e5e737a68e18472d9ac715f0994cc2be": "0x1b1ae4d6e2ef500000",
  	"0xfeb8b8e2af716ae41fc7c04bcf29540156461e6b": "0x545174a528a77a0000",
  	"0xfeb92d30bf01ff9a1901666c5573532bfa07eeec": "0x3635c9adc5dea00000",
  	"0xfebc3173bc9072136354002b7b4fb3bfc53f22f1": "0x140ec80fa7ee880000",
  	"0xfebd48d0ffdbd5656cd5e686363a61145228f279": "0x97c9ce4cf6d5c00000",
  	"0xfebd9f81cf78bd5fb6c4b9a24bd414bb9bfa4c4e": "0x6be10fb8ed6e138000",
  	"0xfec06fe27b44c784b2396ec92f7b923ad17e9077": "0x6c6b935b8bbd400000",
  	"0xfec14e5485de2b3eef5e74c46146db8e454e0335": "0x9b41fbf9e0aec0000",
  	"0xfed8476d10d584b38bfa6737600ef19d35c41ed8": "0x62a992e53a0af00000",
  	"0xfeef3b6eabc94affd3310c1c4d0e65375e131119": "0x1158e460913d00000",
  	"0xfef09d70243f39ed8cd800bf9651479e8f4aca3c": "0xad78ebc5ac6200000",
  	"0xfef3b3dead1a6926d49aa32b12c22af54d9ff985": "0x3635c9adc5dea00000",
  	"0xff0b7cb71da9d4c1ea6ecc28ebda504c63f82fd1": "0x388a885df2fc6c0000",
  	"0xff0c3c7798e8733dd2668152891bab80a8be955c": "0x45946b0f9e9d60000",
  	"0xff0cb06c42e3d88948e45bd7b0d4e291aefeea51": "0x678a932062e4180000",
  	"0xff0cc8dac824fa24fc3caa2169e6e057cf638ad6": "0xd8d726b7177a800000",
  	"0xff0e2fec304207467e1e3307f64cbf30af8fd9cd": "0x6c6b935b8bbd400000",
  	"0xff128f4b355be1dc4a6f94fa510d7f15d53c2aff": "0x93739534d286800000",
  	"0xff12e49d8e06aa20f886293c0b98ed7eff788805": "0xd8d726b7177a800000",
  	"0xff207308ced238a6c01ad0213ca9eb4465d42590": "0x6c6acc67d7b1d40000",
  	"0xff26138330274df4e0a3081e6df7dd983ec6e78f": "0x6c6b935b8bbd400000",
  	"0xff2726294148b86c78a9372497e459898ed3fee3": "0x6acb3df27e1f880000",
  	"0xff3ded7a40d3aff0d7a8c45fa6136aa0433db457": "0x6c68ccd09b022c0000",
  	"0xff3eee57c34d6dae970d8b311117c53586cd3502": "0x5c283d410394100000",
  	"0xff3ef6ba151c21b59986ae64f6e8228bc9a2c733": "0x6c6b935b8bbd400000",
  	"0xff41d9e1b4effe18d8b0d1f63fc4255fb4e06c3d": "0x487a9a304539440000",
  	"0xff45cb34c928364d9cc9d8bb00373474618f06f3": "0x56bc75e2d63100000",
  	"0xff49a775814ec00051a795a875de24592ea400d4": "0x2a5a058fc295ed000000",
  	"0xff4a408f50e9e72146a28ce4fc8d90271f116e84": "0x6acb3df27e1f880000",
  	"0xff4d9c8484c43c42ff2c5ab759996498d323994d": "0xd8d726b7177a800000",
  	"0xff4fc66069046c525658c337a917f2d4b832b409": "0x6c6b935b8bbd400000",
  	"0xff5162f2354dc492c75fd6e3a107268660eecb47": "0x5c283d410394100000",
  	"0xff545bbb66fbd00eb5e6373ff4e326f5feb5fe12": "0x1158e460913d00000",
  	"0xff5e7ee7d5114821e159dca5e81f18f1bfffbff9": "0x6c6b935b8bbd400000",
  	"0xff61c9c1b7a3d8b53bba20b34466544b7b216644": "0x6c6b935b8bbd400000",
  	"0xff65511cada259260c1ddc41974ecaecd32d6357": "0x5f68e8131ecf800000",
  	"0xff7843c7010aa7e61519b762dfe49124a76b0e4e": "0xc5b17924412b9bb00000",
  	"0xff78541756ab2b706e0d70b18adb700fc4f1643d": "0x92896529baddc880000",
  	"0xff83855051ee8ffb70b4817dba3211ed2355869d": "0x15af1d78b58c400000",
  	"0xff850e3be1eb6a4d726c08fa73aad358f39706da": "0x692ae8897081d00000",
  	"0xff86e5e8e15b53909600e41308dab75f0e24e46b": "0x30eb50d2e140800000",
  	"0xff88ebacc41b3687f39e4b59e159599b80cba33f": "0x15af1d78b58c400000",
  	"0xff8a2ca5a81333f19998255f203256e1a819c0aa": "0xc249fdd3277800000",
  	"0xff8eb07de3d49d9d52bbe8e5b26dbe1d160fa834": "0xd814dcb94453080000",
  	"0xffa4aff1a37f984b0a67272149273ae9bd41e3bc": "0x21e19e0c9bab2400000",
  	"0xffa696ecbd787e66abae4fe87b635f07ca57d848": "0x487a9a304539440000",
  	"0xffac3db879a6c7158e8dec603b407463ba0d31cf": "0x6acb3df27e1f880000",
  	"0xffad3dd74e2c1f796ac640de56dc99b4c792a402": "0x10f0cf064dd59200000",
  	"0xffb04726dfa41afdc819168418610472970d7bfc": "0xd8d726b7177a800000",
  	"0xffb3bcc3196a8c3cb834cec94c34fed35b3e1054": "0x48a43c54602f700000",
  	"0xffb974673367f5c07be5fd270dc4b7138b074d57": "0x85ebc8bdb9066d8000",
  	"0xffb9c7217e66743031eb377af65c77db7359dcda": "0x22b1c8c1227a00000",
  	"0xffbc3da0381ec339c1c049eb1ed9ee34fdcea6ca": "0xd8d726b7177a800000",
  	"0xffc5fc4b7e8a0293ff39a3a0f7d60d2646d37a74": "0x6c6b935b8bbd400000",
  	"0xffc9cc3094b041ad0e076f968a0de3b167255866": "0x1770c1650beee80000",
  	"0xffd5170fd1a8118d558e7511e364b24906c4f6b3": "0x341d8cd27f1588000",
  	"0xffd6da958eecbc016bab91058440d39b41c7be83": "0x43c33c1937564800000",
  	"0xffe0e997f1977a615f5a315af413fd4869343ba0": "0x56cd55fc64dfe0000",
  	"0xffe28db53c9044b4ecd4053fd1b4b10d7056c688": "0x56bc75e2d63100000",
  	"0xffe2e28c3fb74749d7e780dc8a5d422538e6e451": "0xdbb81e05bc12d8000",
  	"0xffe8cbc1681e5e9db74a0f93f8ed25897519120f": "0x51b1d3839261ac0000",
  	"0xffeac0305ede3a915295ec8e61c7f881006f4474": "0x556f64c1fe7fa0000",
  	"0xffec0913c635baca2f5e57a37aa9fb7b6c9b6e26": "0x2ba39e82ed5d740000",
  	"0xfff33a3bd36abdbd412707b8e310d6011454a7ae": "0x1b1ae4d6e2ef5000000",
  	"0xfff4bad596633479a2a29f9a8b3f78eefd07e6ee": "0x56bc75e2d63100000",
  	"0xfff7ac99c8e4feb60c9750054bdc14ce1857f181": "0x3635c9adc5dea00000"
  };

  var require$$11 = {
  	"0x0000000000000000000000000000000000000000": "0x1",
  	"0x0000000000000000000000000000000000000001": "0x1",
  	"0x0000000000000000000000000000000000000002": "0x1",
  	"0x0000000000000000000000000000000000000003": "0x1",
  	"0x0000000000000000000000000000000000000004": "0x1",
  	"0x0000000000000000000000000000000000000005": "0x1",
  	"0x0000000000000000000000000000000000000006": "0x1",
  	"0x0000000000000000000000000000000000000007": "0x1",
  	"0x0000000000000000000000000000000000000008": "0x1",
  	"0x0000000000000000000000000000000000000009": "0x1",
  	"0x000000000000000000000000000000000000000a": "0x0",
  	"0x000000000000000000000000000000000000000b": "0x0",
  	"0x000000000000000000000000000000000000000c": "0x0",
  	"0x000000000000000000000000000000000000000d": "0x0",
  	"0x000000000000000000000000000000000000000e": "0x0",
  	"0x000000000000000000000000000000000000000f": "0x0",
  	"0x0000000000000000000000000000000000000010": "0x0",
  	"0x0000000000000000000000000000000000000011": "0x0",
  	"0x0000000000000000000000000000000000000012": "0x0",
  	"0x0000000000000000000000000000000000000013": "0x0",
  	"0x0000000000000000000000000000000000000014": "0x0",
  	"0x0000000000000000000000000000000000000015": "0x0",
  	"0x0000000000000000000000000000000000000016": "0x0",
  	"0x0000000000000000000000000000000000000017": "0x0",
  	"0x0000000000000000000000000000000000000018": "0x0",
  	"0x0000000000000000000000000000000000000019": "0x0",
  	"0x000000000000000000000000000000000000001a": "0x0",
  	"0x000000000000000000000000000000000000001b": "0x0",
  	"0x000000000000000000000000000000000000001c": "0x0",
  	"0x000000000000000000000000000000000000001d": "0x0",
  	"0x000000000000000000000000000000000000001e": "0x0",
  	"0x000000000000000000000000000000000000001f": "0x0",
  	"0x0000000000000000000000000000000000000020": "0x0",
  	"0x0000000000000000000000000000000000000021": "0x0",
  	"0x0000000000000000000000000000000000000022": "0x0",
  	"0x0000000000000000000000000000000000000023": "0x0",
  	"0x0000000000000000000000000000000000000024": "0x0",
  	"0x0000000000000000000000000000000000000025": "0x0",
  	"0x0000000000000000000000000000000000000026": "0x0",
  	"0x0000000000000000000000000000000000000027": "0x0",
  	"0x0000000000000000000000000000000000000028": "0x0",
  	"0x0000000000000000000000000000000000000029": "0x0",
  	"0x000000000000000000000000000000000000002a": "0x0",
  	"0x000000000000000000000000000000000000002b": "0x0",
  	"0x000000000000000000000000000000000000002c": "0x0",
  	"0x000000000000000000000000000000000000002d": "0x0",
  	"0x000000000000000000000000000000000000002e": "0x0",
  	"0x000000000000000000000000000000000000002f": "0x0",
  	"0x0000000000000000000000000000000000000030": "0x0",
  	"0x0000000000000000000000000000000000000031": "0x0",
  	"0x0000000000000000000000000000000000000032": "0x0",
  	"0x0000000000000000000000000000000000000033": "0x0",
  	"0x0000000000000000000000000000000000000034": "0x0",
  	"0x0000000000000000000000000000000000000035": "0x0",
  	"0x0000000000000000000000000000000000000036": "0x0",
  	"0x0000000000000000000000000000000000000037": "0x0",
  	"0x0000000000000000000000000000000000000038": "0x0",
  	"0x0000000000000000000000000000000000000039": "0x0",
  	"0x000000000000000000000000000000000000003a": "0x0",
  	"0x000000000000000000000000000000000000003b": "0x0",
  	"0x000000000000000000000000000000000000003c": "0x0",
  	"0x000000000000000000000000000000000000003d": "0x0",
  	"0x000000000000000000000000000000000000003e": "0x0",
  	"0x000000000000000000000000000000000000003f": "0x0",
  	"0x0000000000000000000000000000000000000040": "0x0",
  	"0x0000000000000000000000000000000000000041": "0x0",
  	"0x0000000000000000000000000000000000000042": "0x0",
  	"0x0000000000000000000000000000000000000043": "0x0",
  	"0x0000000000000000000000000000000000000044": "0x0",
  	"0x0000000000000000000000000000000000000045": "0x0",
  	"0x0000000000000000000000000000000000000046": "0x0",
  	"0x0000000000000000000000000000000000000047": "0x0",
  	"0x0000000000000000000000000000000000000048": "0x0",
  	"0x0000000000000000000000000000000000000049": "0x0",
  	"0x000000000000000000000000000000000000004a": "0x0",
  	"0x000000000000000000000000000000000000004b": "0x0",
  	"0x000000000000000000000000000000000000004c": "0x0",
  	"0x000000000000000000000000000000000000004d": "0x0",
  	"0x000000000000000000000000000000000000004e": "0x0",
  	"0x000000000000000000000000000000000000004f": "0x0",
  	"0x0000000000000000000000000000000000000050": "0x0",
  	"0x0000000000000000000000000000000000000051": "0x0",
  	"0x0000000000000000000000000000000000000052": "0x0",
  	"0x0000000000000000000000000000000000000053": "0x0",
  	"0x0000000000000000000000000000000000000054": "0x0",
  	"0x0000000000000000000000000000000000000055": "0x0",
  	"0x0000000000000000000000000000000000000056": "0x0",
  	"0x0000000000000000000000000000000000000057": "0x0",
  	"0x0000000000000000000000000000000000000058": "0x0",
  	"0x0000000000000000000000000000000000000059": "0x0",
  	"0x000000000000000000000000000000000000005a": "0x0",
  	"0x000000000000000000000000000000000000005b": "0x0",
  	"0x000000000000000000000000000000000000005c": "0x0",
  	"0x000000000000000000000000000000000000005d": "0x0",
  	"0x000000000000000000000000000000000000005e": "0x0",
  	"0x000000000000000000000000000000000000005f": "0x0",
  	"0x0000000000000000000000000000000000000060": "0x0",
  	"0x0000000000000000000000000000000000000061": "0x0",
  	"0x0000000000000000000000000000000000000062": "0x0",
  	"0x0000000000000000000000000000000000000063": "0x0",
  	"0x0000000000000000000000000000000000000064": "0x0",
  	"0x0000000000000000000000000000000000000065": "0x0",
  	"0x0000000000000000000000000000000000000066": "0x0",
  	"0x0000000000000000000000000000000000000067": "0x0",
  	"0x0000000000000000000000000000000000000068": "0x0",
  	"0x0000000000000000000000000000000000000069": "0x0",
  	"0x000000000000000000000000000000000000006a": "0x0",
  	"0x000000000000000000000000000000000000006b": "0x0",
  	"0x000000000000000000000000000000000000006c": "0x0",
  	"0x000000000000000000000000000000000000006d": "0x0",
  	"0x000000000000000000000000000000000000006e": "0x0",
  	"0x000000000000000000000000000000000000006f": "0x0",
  	"0x0000000000000000000000000000000000000070": "0x0",
  	"0x0000000000000000000000000000000000000071": "0x0",
  	"0x0000000000000000000000000000000000000072": "0x0",
  	"0x0000000000000000000000000000000000000073": "0x0",
  	"0x0000000000000000000000000000000000000074": "0x0",
  	"0x0000000000000000000000000000000000000075": "0x0",
  	"0x0000000000000000000000000000000000000076": "0x0",
  	"0x0000000000000000000000000000000000000077": "0x0",
  	"0x0000000000000000000000000000000000000078": "0x0",
  	"0x0000000000000000000000000000000000000079": "0x0",
  	"0x000000000000000000000000000000000000007a": "0x0",
  	"0x000000000000000000000000000000000000007b": "0x0",
  	"0x000000000000000000000000000000000000007c": "0x0",
  	"0x000000000000000000000000000000000000007d": "0x0",
  	"0x000000000000000000000000000000000000007e": "0x0",
  	"0x000000000000000000000000000000000000007f": "0x0",
  	"0x0000000000000000000000000000000000000080": "0x0",
  	"0x0000000000000000000000000000000000000081": "0x0",
  	"0x0000000000000000000000000000000000000082": "0x0",
  	"0x0000000000000000000000000000000000000083": "0x0",
  	"0x0000000000000000000000000000000000000084": "0x0",
  	"0x0000000000000000000000000000000000000085": "0x0",
  	"0x0000000000000000000000000000000000000086": "0x0",
  	"0x0000000000000000000000000000000000000087": "0x0",
  	"0x0000000000000000000000000000000000000088": "0x0",
  	"0x0000000000000000000000000000000000000089": "0x0",
  	"0x000000000000000000000000000000000000008a": "0x0",
  	"0x000000000000000000000000000000000000008b": "0x0",
  	"0x000000000000000000000000000000000000008c": "0x0",
  	"0x000000000000000000000000000000000000008d": "0x0",
  	"0x000000000000000000000000000000000000008e": "0x0",
  	"0x000000000000000000000000000000000000008f": "0x0",
  	"0x0000000000000000000000000000000000000090": "0x0",
  	"0x0000000000000000000000000000000000000091": "0x0",
  	"0x0000000000000000000000000000000000000092": "0x0",
  	"0x0000000000000000000000000000000000000093": "0x0",
  	"0x0000000000000000000000000000000000000094": "0x0",
  	"0x0000000000000000000000000000000000000095": "0x0",
  	"0x0000000000000000000000000000000000000096": "0x0",
  	"0x0000000000000000000000000000000000000097": "0x0",
  	"0x0000000000000000000000000000000000000098": "0x0",
  	"0x0000000000000000000000000000000000000099": "0x0",
  	"0x000000000000000000000000000000000000009a": "0x0",
  	"0x000000000000000000000000000000000000009b": "0x0",
  	"0x000000000000000000000000000000000000009c": "0x0",
  	"0x000000000000000000000000000000000000009d": "0x0",
  	"0x000000000000000000000000000000000000009e": "0x0",
  	"0x000000000000000000000000000000000000009f": "0x0",
  	"0x00000000000000000000000000000000000000a0": "0x0",
  	"0x00000000000000000000000000000000000000a1": "0x0",
  	"0x00000000000000000000000000000000000000a2": "0x0",
  	"0x00000000000000000000000000000000000000a3": "0x0",
  	"0x00000000000000000000000000000000000000a4": "0x0",
  	"0x00000000000000000000000000000000000000a5": "0x0",
  	"0x00000000000000000000000000000000000000a6": "0x0",
  	"0x00000000000000000000000000000000000000a7": "0x0",
  	"0x00000000000000000000000000000000000000a8": "0x0",
  	"0x00000000000000000000000000000000000000a9": "0x0",
  	"0x00000000000000000000000000000000000000aa": "0x0",
  	"0x00000000000000000000000000000000000000ab": "0x0",
  	"0x00000000000000000000000000000000000000ac": "0x0",
  	"0x00000000000000000000000000000000000000ad": "0x0",
  	"0x00000000000000000000000000000000000000ae": "0x0",
  	"0x00000000000000000000000000000000000000af": "0x0",
  	"0x00000000000000000000000000000000000000b0": "0x0",
  	"0x00000000000000000000000000000000000000b1": "0x0",
  	"0x00000000000000000000000000000000000000b2": "0x0",
  	"0x00000000000000000000000000000000000000b3": "0x0",
  	"0x00000000000000000000000000000000000000b4": "0x0",
  	"0x00000000000000000000000000000000000000b5": "0x0",
  	"0x00000000000000000000000000000000000000b6": "0x0",
  	"0x00000000000000000000000000000000000000b7": "0x0",
  	"0x00000000000000000000000000000000000000b8": "0x0",
  	"0x00000000000000000000000000000000000000b9": "0x0",
  	"0x00000000000000000000000000000000000000ba": "0x0",
  	"0x00000000000000000000000000000000000000bb": "0x0",
  	"0x00000000000000000000000000000000000000bc": "0x0",
  	"0x00000000000000000000000000000000000000bd": "0x0",
  	"0x00000000000000000000000000000000000000be": "0x0",
  	"0x00000000000000000000000000000000000000bf": "0x0",
  	"0x00000000000000000000000000000000000000c0": "0x0",
  	"0x00000000000000000000000000000000000000c1": "0x0",
  	"0x00000000000000000000000000000000000000c2": "0x0",
  	"0x00000000000000000000000000000000000000c3": "0x0",
  	"0x00000000000000000000000000000000000000c4": "0x0",
  	"0x00000000000000000000000000000000000000c5": "0x0",
  	"0x00000000000000000000000000000000000000c6": "0x0",
  	"0x00000000000000000000000000000000000000c7": "0x0",
  	"0x00000000000000000000000000000000000000c8": "0x0",
  	"0x00000000000000000000000000000000000000c9": "0x0",
  	"0x00000000000000000000000000000000000000ca": "0x0",
  	"0x00000000000000000000000000000000000000cb": "0x0",
  	"0x00000000000000000000000000000000000000cc": "0x0",
  	"0x00000000000000000000000000000000000000cd": "0x0",
  	"0x00000000000000000000000000000000000000ce": "0x0",
  	"0x00000000000000000000000000000000000000cf": "0x0",
  	"0x00000000000000000000000000000000000000d0": "0x0",
  	"0x00000000000000000000000000000000000000d1": "0x0",
  	"0x00000000000000000000000000000000000000d2": "0x0",
  	"0x00000000000000000000000000000000000000d3": "0x0",
  	"0x00000000000000000000000000000000000000d4": "0x0",
  	"0x00000000000000000000000000000000000000d5": "0x0",
  	"0x00000000000000000000000000000000000000d6": "0x0",
  	"0x00000000000000000000000000000000000000d7": "0x0",
  	"0x00000000000000000000000000000000000000d8": "0x0",
  	"0x00000000000000000000000000000000000000d9": "0x0",
  	"0x00000000000000000000000000000000000000da": "0x0",
  	"0x00000000000000000000000000000000000000db": "0x0",
  	"0x00000000000000000000000000000000000000dc": "0x0",
  	"0x00000000000000000000000000000000000000dd": "0x0",
  	"0x00000000000000000000000000000000000000de": "0x0",
  	"0x00000000000000000000000000000000000000df": "0x0",
  	"0x00000000000000000000000000000000000000e0": "0x0",
  	"0x00000000000000000000000000000000000000e1": "0x0",
  	"0x00000000000000000000000000000000000000e2": "0x0",
  	"0x00000000000000000000000000000000000000e3": "0x0",
  	"0x00000000000000000000000000000000000000e4": "0x0",
  	"0x00000000000000000000000000000000000000e5": "0x0",
  	"0x00000000000000000000000000000000000000e6": "0x0",
  	"0x00000000000000000000000000000000000000e7": "0x0",
  	"0x00000000000000000000000000000000000000e8": "0x0",
  	"0x00000000000000000000000000000000000000e9": "0x0",
  	"0x00000000000000000000000000000000000000ea": "0x0",
  	"0x00000000000000000000000000000000000000eb": "0x0",
  	"0x00000000000000000000000000000000000000ec": "0x0",
  	"0x00000000000000000000000000000000000000ed": "0x0",
  	"0x00000000000000000000000000000000000000ee": "0x0",
  	"0x00000000000000000000000000000000000000ef": "0x0",
  	"0x00000000000000000000000000000000000000f0": "0x0",
  	"0x00000000000000000000000000000000000000f1": "0x0",
  	"0x00000000000000000000000000000000000000f2": "0x0",
  	"0x00000000000000000000000000000000000000f3": "0x0",
  	"0x00000000000000000000000000000000000000f4": "0x0",
  	"0x00000000000000000000000000000000000000f5": "0x0",
  	"0x00000000000000000000000000000000000000f6": "0x0",
  	"0x00000000000000000000000000000000000000f7": "0x0",
  	"0x00000000000000000000000000000000000000f8": "0x0",
  	"0x00000000000000000000000000000000000000f9": "0x0",
  	"0x00000000000000000000000000000000000000fa": "0x0",
  	"0x00000000000000000000000000000000000000fb": "0x0",
  	"0x00000000000000000000000000000000000000fc": "0x0",
  	"0x00000000000000000000000000000000000000fd": "0x0",
  	"0x00000000000000000000000000000000000000fe": "0x0",
  	"0x00000000000000000000000000000000000000ff": "0x0",
  	"0x874b54a8bd152966d63f706bae1ffeb0411921e5": "0xc9f2c9cd04674edea40000000"
  };

  var require$$12 = {
  	"0x0000000000000000000000000000000000000000": "0x1",
  	"0x0000000000000000000000000000000000000001": "0x1",
  	"0x0000000000000000000000000000000000000002": "0x1",
  	"0x0000000000000000000000000000000000000003": "0x1",
  	"0x0000000000000000000000000000000000000004": "0x1",
  	"0x0000000000000000000000000000000000000005": "0x1",
  	"0x0000000000000000000000000000000000000006": "0x1",
  	"0x0000000000000000000000000000000000000007": "0x1",
  	"0x0000000000000000000000000000000000000008": "0x1",
  	"0x0000000000000000000000000000000000000009": "0x1",
  	"0x000000000000000000000000000000000000000a": "0x1",
  	"0x000000000000000000000000000000000000000b": "0x1",
  	"0x000000000000000000000000000000000000000c": "0x1",
  	"0x000000000000000000000000000000000000000d": "0x1",
  	"0x000000000000000000000000000000000000000e": "0x1",
  	"0x000000000000000000000000000000000000000f": "0x1",
  	"0x0000000000000000000000000000000000000010": "0x1",
  	"0x0000000000000000000000000000000000000011": "0x1",
  	"0x0000000000000000000000000000000000000012": "0x1",
  	"0x0000000000000000000000000000000000000013": "0x1",
  	"0x0000000000000000000000000000000000000014": "0x1",
  	"0x0000000000000000000000000000000000000015": "0x1",
  	"0x0000000000000000000000000000000000000016": "0x1",
  	"0x0000000000000000000000000000000000000017": "0x1",
  	"0x0000000000000000000000000000000000000018": "0x1",
  	"0x0000000000000000000000000000000000000019": "0x1",
  	"0x000000000000000000000000000000000000001a": "0x1",
  	"0x000000000000000000000000000000000000001b": "0x1",
  	"0x000000000000000000000000000000000000001c": "0x1",
  	"0x000000000000000000000000000000000000001d": "0x1",
  	"0x000000000000000000000000000000000000001e": "0x1",
  	"0x000000000000000000000000000000000000001f": "0x1",
  	"0x0000000000000000000000000000000000000020": "0x1",
  	"0x0000000000000000000000000000000000000021": "0x1",
  	"0x0000000000000000000000000000000000000022": "0x1",
  	"0x0000000000000000000000000000000000000023": "0x1",
  	"0x0000000000000000000000000000000000000024": "0x1",
  	"0x0000000000000000000000000000000000000025": "0x1",
  	"0x0000000000000000000000000000000000000026": "0x1",
  	"0x0000000000000000000000000000000000000027": "0x1",
  	"0x0000000000000000000000000000000000000028": "0x1",
  	"0x0000000000000000000000000000000000000029": "0x1",
  	"0x000000000000000000000000000000000000002a": "0x1",
  	"0x000000000000000000000000000000000000002b": "0x1",
  	"0x000000000000000000000000000000000000002c": "0x1",
  	"0x000000000000000000000000000000000000002d": "0x1",
  	"0x000000000000000000000000000000000000002e": "0x1",
  	"0x000000000000000000000000000000000000002f": "0x1",
  	"0x0000000000000000000000000000000000000030": "0x1",
  	"0x0000000000000000000000000000000000000031": "0x1",
  	"0x0000000000000000000000000000000000000032": "0x1",
  	"0x0000000000000000000000000000000000000033": "0x1",
  	"0x0000000000000000000000000000000000000034": "0x1",
  	"0x0000000000000000000000000000000000000035": "0x1",
  	"0x0000000000000000000000000000000000000036": "0x1",
  	"0x0000000000000000000000000000000000000037": "0x1",
  	"0x0000000000000000000000000000000000000038": "0x1",
  	"0x0000000000000000000000000000000000000039": "0x1",
  	"0x000000000000000000000000000000000000003a": "0x1",
  	"0x000000000000000000000000000000000000003b": "0x1",
  	"0x000000000000000000000000000000000000003c": "0x1",
  	"0x000000000000000000000000000000000000003d": "0x1",
  	"0x000000000000000000000000000000000000003e": "0x1",
  	"0x000000000000000000000000000000000000003f": "0x1",
  	"0x0000000000000000000000000000000000000040": "0x1",
  	"0x0000000000000000000000000000000000000041": "0x1",
  	"0x0000000000000000000000000000000000000042": "0x1",
  	"0x0000000000000000000000000000000000000043": "0x1",
  	"0x0000000000000000000000000000000000000044": "0x1",
  	"0x0000000000000000000000000000000000000045": "0x1",
  	"0x0000000000000000000000000000000000000046": "0x1",
  	"0x0000000000000000000000000000000000000047": "0x1",
  	"0x0000000000000000000000000000000000000048": "0x1",
  	"0x0000000000000000000000000000000000000049": "0x1",
  	"0x000000000000000000000000000000000000004a": "0x1",
  	"0x000000000000000000000000000000000000004b": "0x1",
  	"0x000000000000000000000000000000000000004c": "0x1",
  	"0x000000000000000000000000000000000000004d": "0x1",
  	"0x000000000000000000000000000000000000004e": "0x1",
  	"0x000000000000000000000000000000000000004f": "0x1",
  	"0x0000000000000000000000000000000000000050": "0x1",
  	"0x0000000000000000000000000000000000000051": "0x1",
  	"0x0000000000000000000000000000000000000052": "0x1",
  	"0x0000000000000000000000000000000000000053": "0x1",
  	"0x0000000000000000000000000000000000000054": "0x1",
  	"0x0000000000000000000000000000000000000055": "0x1",
  	"0x0000000000000000000000000000000000000056": "0x1",
  	"0x0000000000000000000000000000000000000057": "0x1",
  	"0x0000000000000000000000000000000000000058": "0x1",
  	"0x0000000000000000000000000000000000000059": "0x1",
  	"0x000000000000000000000000000000000000005a": "0x1",
  	"0x000000000000000000000000000000000000005b": "0x1",
  	"0x000000000000000000000000000000000000005c": "0x1",
  	"0x000000000000000000000000000000000000005d": "0x1",
  	"0x000000000000000000000000000000000000005e": "0x1",
  	"0x000000000000000000000000000000000000005f": "0x1",
  	"0x0000000000000000000000000000000000000060": "0x1",
  	"0x0000000000000000000000000000000000000061": "0x1",
  	"0x0000000000000000000000000000000000000062": "0x1",
  	"0x0000000000000000000000000000000000000063": "0x1",
  	"0x0000000000000000000000000000000000000064": "0x1",
  	"0x0000000000000000000000000000000000000065": "0x1",
  	"0x0000000000000000000000000000000000000066": "0x1",
  	"0x0000000000000000000000000000000000000067": "0x1",
  	"0x0000000000000000000000000000000000000068": "0x1",
  	"0x0000000000000000000000000000000000000069": "0x1",
  	"0x000000000000000000000000000000000000006a": "0x1",
  	"0x000000000000000000000000000000000000006b": "0x1",
  	"0x000000000000000000000000000000000000006c": "0x1",
  	"0x000000000000000000000000000000000000006d": "0x1",
  	"0x000000000000000000000000000000000000006e": "0x1",
  	"0x000000000000000000000000000000000000006f": "0x1",
  	"0x0000000000000000000000000000000000000070": "0x1",
  	"0x0000000000000000000000000000000000000071": "0x1",
  	"0x0000000000000000000000000000000000000072": "0x1",
  	"0x0000000000000000000000000000000000000073": "0x1",
  	"0x0000000000000000000000000000000000000074": "0x1",
  	"0x0000000000000000000000000000000000000075": "0x1",
  	"0x0000000000000000000000000000000000000076": "0x1",
  	"0x0000000000000000000000000000000000000077": "0x1",
  	"0x0000000000000000000000000000000000000078": "0x1",
  	"0x0000000000000000000000000000000000000079": "0x1",
  	"0x000000000000000000000000000000000000007a": "0x1",
  	"0x000000000000000000000000000000000000007b": "0x1",
  	"0x000000000000000000000000000000000000007c": "0x1",
  	"0x000000000000000000000000000000000000007d": "0x1",
  	"0x000000000000000000000000000000000000007e": "0x1",
  	"0x000000000000000000000000000000000000007f": "0x1",
  	"0x0000000000000000000000000000000000000080": "0x1",
  	"0x0000000000000000000000000000000000000081": "0x1",
  	"0x0000000000000000000000000000000000000082": "0x1",
  	"0x0000000000000000000000000000000000000083": "0x1",
  	"0x0000000000000000000000000000000000000084": "0x1",
  	"0x0000000000000000000000000000000000000085": "0x1",
  	"0x0000000000000000000000000000000000000086": "0x1",
  	"0x0000000000000000000000000000000000000087": "0x1",
  	"0x0000000000000000000000000000000000000088": "0x1",
  	"0x0000000000000000000000000000000000000089": "0x1",
  	"0x000000000000000000000000000000000000008a": "0x1",
  	"0x000000000000000000000000000000000000008b": "0x1",
  	"0x000000000000000000000000000000000000008c": "0x1",
  	"0x000000000000000000000000000000000000008d": "0x1",
  	"0x000000000000000000000000000000000000008e": "0x1",
  	"0x000000000000000000000000000000000000008f": "0x1",
  	"0x0000000000000000000000000000000000000090": "0x1",
  	"0x0000000000000000000000000000000000000091": "0x1",
  	"0x0000000000000000000000000000000000000092": "0x1",
  	"0x0000000000000000000000000000000000000093": "0x1",
  	"0x0000000000000000000000000000000000000094": "0x1",
  	"0x0000000000000000000000000000000000000095": "0x1",
  	"0x0000000000000000000000000000000000000096": "0x1",
  	"0x0000000000000000000000000000000000000097": "0x1",
  	"0x0000000000000000000000000000000000000098": "0x1",
  	"0x0000000000000000000000000000000000000099": "0x1",
  	"0x000000000000000000000000000000000000009a": "0x1",
  	"0x000000000000000000000000000000000000009b": "0x1",
  	"0x000000000000000000000000000000000000009c": "0x1",
  	"0x000000000000000000000000000000000000009d": "0x1",
  	"0x000000000000000000000000000000000000009e": "0x1",
  	"0x000000000000000000000000000000000000009f": "0x1",
  	"0x00000000000000000000000000000000000000a0": "0x1",
  	"0x00000000000000000000000000000000000000a1": "0x1",
  	"0x00000000000000000000000000000000000000a2": "0x1",
  	"0x00000000000000000000000000000000000000a3": "0x1",
  	"0x00000000000000000000000000000000000000a4": "0x1",
  	"0x00000000000000000000000000000000000000a5": "0x1",
  	"0x00000000000000000000000000000000000000a6": "0x1",
  	"0x00000000000000000000000000000000000000a7": "0x1",
  	"0x00000000000000000000000000000000000000a8": "0x1",
  	"0x00000000000000000000000000000000000000a9": "0x1",
  	"0x00000000000000000000000000000000000000aa": "0x1",
  	"0x00000000000000000000000000000000000000ab": "0x1",
  	"0x00000000000000000000000000000000000000ac": "0x1",
  	"0x00000000000000000000000000000000000000ad": "0x1",
  	"0x00000000000000000000000000000000000000ae": "0x1",
  	"0x00000000000000000000000000000000000000af": "0x1",
  	"0x00000000000000000000000000000000000000b0": "0x1",
  	"0x00000000000000000000000000000000000000b1": "0x1",
  	"0x00000000000000000000000000000000000000b2": "0x1",
  	"0x00000000000000000000000000000000000000b3": "0x1",
  	"0x00000000000000000000000000000000000000b4": "0x1",
  	"0x00000000000000000000000000000000000000b5": "0x1",
  	"0x00000000000000000000000000000000000000b6": "0x1",
  	"0x00000000000000000000000000000000000000b7": "0x1",
  	"0x00000000000000000000000000000000000000b8": "0x1",
  	"0x00000000000000000000000000000000000000b9": "0x1",
  	"0x00000000000000000000000000000000000000ba": "0x1",
  	"0x00000000000000000000000000000000000000bb": "0x1",
  	"0x00000000000000000000000000000000000000bc": "0x1",
  	"0x00000000000000000000000000000000000000bd": "0x1",
  	"0x00000000000000000000000000000000000000be": "0x1",
  	"0x00000000000000000000000000000000000000bf": "0x1",
  	"0x00000000000000000000000000000000000000c0": "0x1",
  	"0x00000000000000000000000000000000000000c1": "0x1",
  	"0x00000000000000000000000000000000000000c2": "0x1",
  	"0x00000000000000000000000000000000000000c3": "0x1",
  	"0x00000000000000000000000000000000000000c4": "0x1",
  	"0x00000000000000000000000000000000000000c5": "0x1",
  	"0x00000000000000000000000000000000000000c6": "0x1",
  	"0x00000000000000000000000000000000000000c7": "0x1",
  	"0x00000000000000000000000000000000000000c8": "0x1",
  	"0x00000000000000000000000000000000000000c9": "0x1",
  	"0x00000000000000000000000000000000000000ca": "0x1",
  	"0x00000000000000000000000000000000000000cb": "0x1",
  	"0x00000000000000000000000000000000000000cc": "0x1",
  	"0x00000000000000000000000000000000000000cd": "0x1",
  	"0x00000000000000000000000000000000000000ce": "0x1",
  	"0x00000000000000000000000000000000000000cf": "0x1",
  	"0x00000000000000000000000000000000000000d0": "0x1",
  	"0x00000000000000000000000000000000000000d1": "0x1",
  	"0x00000000000000000000000000000000000000d2": "0x1",
  	"0x00000000000000000000000000000000000000d3": "0x1",
  	"0x00000000000000000000000000000000000000d4": "0x1",
  	"0x00000000000000000000000000000000000000d5": "0x1",
  	"0x00000000000000000000000000000000000000d6": "0x1",
  	"0x00000000000000000000000000000000000000d7": "0x1",
  	"0x00000000000000000000000000000000000000d8": "0x1",
  	"0x00000000000000000000000000000000000000d9": "0x1",
  	"0x00000000000000000000000000000000000000da": "0x1",
  	"0x00000000000000000000000000000000000000db": "0x1",
  	"0x00000000000000000000000000000000000000dc": "0x1",
  	"0x00000000000000000000000000000000000000dd": "0x1",
  	"0x00000000000000000000000000000000000000de": "0x1",
  	"0x00000000000000000000000000000000000000df": "0x1",
  	"0x00000000000000000000000000000000000000e0": "0x1",
  	"0x00000000000000000000000000000000000000e1": "0x1",
  	"0x00000000000000000000000000000000000000e2": "0x1",
  	"0x00000000000000000000000000000000000000e3": "0x1",
  	"0x00000000000000000000000000000000000000e4": "0x1",
  	"0x00000000000000000000000000000000000000e5": "0x1",
  	"0x00000000000000000000000000000000000000e6": "0x1",
  	"0x00000000000000000000000000000000000000e7": "0x1",
  	"0x00000000000000000000000000000000000000e8": "0x1",
  	"0x00000000000000000000000000000000000000e9": "0x1",
  	"0x00000000000000000000000000000000000000ea": "0x1",
  	"0x00000000000000000000000000000000000000eb": "0x1",
  	"0x00000000000000000000000000000000000000ec": "0x1",
  	"0x00000000000000000000000000000000000000ed": "0x1",
  	"0x00000000000000000000000000000000000000ee": "0x1",
  	"0x00000000000000000000000000000000000000ef": "0x1",
  	"0x00000000000000000000000000000000000000f0": "0x1",
  	"0x00000000000000000000000000000000000000f1": "0x1",
  	"0x00000000000000000000000000000000000000f2": "0x1",
  	"0x00000000000000000000000000000000000000f3": "0x1",
  	"0x00000000000000000000000000000000000000f4": "0x1",
  	"0x00000000000000000000000000000000000000f5": "0x1",
  	"0x00000000000000000000000000000000000000f6": "0x1",
  	"0x00000000000000000000000000000000000000f7": "0x1",
  	"0x00000000000000000000000000000000000000f8": "0x1",
  	"0x00000000000000000000000000000000000000f9": "0x1",
  	"0x00000000000000000000000000000000000000fa": "0x1",
  	"0x00000000000000000000000000000000000000fb": "0x1",
  	"0x00000000000000000000000000000000000000fc": "0x1",
  	"0x00000000000000000000000000000000000000fd": "0x1",
  	"0x00000000000000000000000000000000000000fe": "0x1",
  	"0x00000000000000000000000000000000000000ff": "0x1",
  	"0x31b98d14007bdee637298086988a0bbd31184523": "0x200000000000000000000000000000000000000000000000000000000000000"
  };

  var require$$13 = {
  	"0x0000000000000000000000000000000000000001": "0x1",
  	"0x0000000000000000000000000000000000000002": "0x1",
  	"0x0000000000000000000000000000000000000003": "0x1",
  	"0x0000000000000000000000000000000000000004": "0x1",
  	"0x00521965e7bd230323c423d96c657db5b79d099f": "0x100000000000000000000000000000000000000000000000000"
  };

  var require$$14 = {
  	"0x0000000000000000000000000000000000000000": "0x1",
  	"0x0000000000000000000000000000000000000001": "0x1",
  	"0x0000000000000000000000000000000000000002": "0x1",
  	"0x0000000000000000000000000000000000000003": "0x1",
  	"0x0000000000000000000000000000000000000004": "0x1",
  	"0x0000000000000000000000000000000000000005": "0x1",
  	"0x0000000000000000000000000000000000000006": "0x1",
  	"0x0000000000000000000000000000000000000007": "0x1",
  	"0x0000000000000000000000000000000000000008": "0x1",
  	"0x0000000000000000000000000000000000000009": "0x1",
  	"0x000000000000000000000000000000000000000a": "0x1",
  	"0x000000000000000000000000000000000000000b": "0x1",
  	"0x000000000000000000000000000000000000000c": "0x1",
  	"0x000000000000000000000000000000000000000d": "0x1",
  	"0x000000000000000000000000000000000000000e": "0x1",
  	"0x000000000000000000000000000000000000000f": "0x1",
  	"0x0000000000000000000000000000000000000010": "0x1",
  	"0x0000000000000000000000000000000000000011": "0x1",
  	"0x0000000000000000000000000000000000000012": "0x1",
  	"0x0000000000000000000000000000000000000013": "0x1",
  	"0x0000000000000000000000000000000000000014": "0x1",
  	"0x0000000000000000000000000000000000000015": "0x1",
  	"0x0000000000000000000000000000000000000016": "0x1",
  	"0x0000000000000000000000000000000000000017": "0x1",
  	"0x0000000000000000000000000000000000000018": "0x1",
  	"0x0000000000000000000000000000000000000019": "0x1",
  	"0x000000000000000000000000000000000000001a": "0x1",
  	"0x000000000000000000000000000000000000001b": "0x1",
  	"0x000000000000000000000000000000000000001c": "0x1",
  	"0x000000000000000000000000000000000000001d": "0x1",
  	"0x000000000000000000000000000000000000001e": "0x1",
  	"0x000000000000000000000000000000000000001f": "0x1",
  	"0x0000000000000000000000000000000000000020": "0x1",
  	"0x0000000000000000000000000000000000000021": "0x1",
  	"0x0000000000000000000000000000000000000022": "0x1",
  	"0x0000000000000000000000000000000000000023": "0x1",
  	"0x0000000000000000000000000000000000000024": "0x1",
  	"0x0000000000000000000000000000000000000025": "0x1",
  	"0x0000000000000000000000000000000000000026": "0x1",
  	"0x0000000000000000000000000000000000000027": "0x1",
  	"0x0000000000000000000000000000000000000028": "0x1",
  	"0x0000000000000000000000000000000000000029": "0x1",
  	"0x000000000000000000000000000000000000002a": "0x1",
  	"0x000000000000000000000000000000000000002b": "0x1",
  	"0x000000000000000000000000000000000000002c": "0x1",
  	"0x000000000000000000000000000000000000002d": "0x1",
  	"0x000000000000000000000000000000000000002e": "0x1",
  	"0x000000000000000000000000000000000000002f": "0x1",
  	"0x0000000000000000000000000000000000000030": "0x1",
  	"0x0000000000000000000000000000000000000031": "0x1",
  	"0x0000000000000000000000000000000000000032": "0x1",
  	"0x0000000000000000000000000000000000000033": "0x1",
  	"0x0000000000000000000000000000000000000034": "0x1",
  	"0x0000000000000000000000000000000000000035": "0x1",
  	"0x0000000000000000000000000000000000000036": "0x1",
  	"0x0000000000000000000000000000000000000037": "0x1",
  	"0x0000000000000000000000000000000000000038": "0x1",
  	"0x0000000000000000000000000000000000000039": "0x1",
  	"0x000000000000000000000000000000000000003a": "0x1",
  	"0x000000000000000000000000000000000000003b": "0x1",
  	"0x000000000000000000000000000000000000003c": "0x1",
  	"0x000000000000000000000000000000000000003d": "0x1",
  	"0x000000000000000000000000000000000000003e": "0x1",
  	"0x000000000000000000000000000000000000003f": "0x1",
  	"0x0000000000000000000000000000000000000040": "0x1",
  	"0x0000000000000000000000000000000000000041": "0x1",
  	"0x0000000000000000000000000000000000000042": "0x1",
  	"0x0000000000000000000000000000000000000043": "0x1",
  	"0x0000000000000000000000000000000000000044": "0x1",
  	"0x0000000000000000000000000000000000000045": "0x1",
  	"0x0000000000000000000000000000000000000046": "0x1",
  	"0x0000000000000000000000000000000000000047": "0x1",
  	"0x0000000000000000000000000000000000000048": "0x1",
  	"0x0000000000000000000000000000000000000049": "0x1",
  	"0x000000000000000000000000000000000000004a": "0x1",
  	"0x000000000000000000000000000000000000004b": "0x1",
  	"0x000000000000000000000000000000000000004c": "0x1",
  	"0x000000000000000000000000000000000000004d": "0x1",
  	"0x000000000000000000000000000000000000004e": "0x1",
  	"0x000000000000000000000000000000000000004f": "0x1",
  	"0x0000000000000000000000000000000000000050": "0x1",
  	"0x0000000000000000000000000000000000000051": "0x1",
  	"0x0000000000000000000000000000000000000052": "0x1",
  	"0x0000000000000000000000000000000000000053": "0x1",
  	"0x0000000000000000000000000000000000000054": "0x1",
  	"0x0000000000000000000000000000000000000055": "0x1",
  	"0x0000000000000000000000000000000000000056": "0x1",
  	"0x0000000000000000000000000000000000000057": "0x1",
  	"0x0000000000000000000000000000000000000058": "0x1",
  	"0x0000000000000000000000000000000000000059": "0x1",
  	"0x000000000000000000000000000000000000005a": "0x1",
  	"0x000000000000000000000000000000000000005b": "0x1",
  	"0x000000000000000000000000000000000000005c": "0x1",
  	"0x000000000000000000000000000000000000005d": "0x1",
  	"0x000000000000000000000000000000000000005e": "0x1",
  	"0x000000000000000000000000000000000000005f": "0x1",
  	"0x0000000000000000000000000000000000000060": "0x1",
  	"0x0000000000000000000000000000000000000061": "0x1",
  	"0x0000000000000000000000000000000000000062": "0x1",
  	"0x0000000000000000000000000000000000000063": "0x1",
  	"0x0000000000000000000000000000000000000064": "0x1",
  	"0x0000000000000000000000000000000000000065": "0x1",
  	"0x0000000000000000000000000000000000000066": "0x1",
  	"0x0000000000000000000000000000000000000067": "0x1",
  	"0x0000000000000000000000000000000000000068": "0x1",
  	"0x0000000000000000000000000000000000000069": "0x1",
  	"0x000000000000000000000000000000000000006a": "0x1",
  	"0x000000000000000000000000000000000000006b": "0x1",
  	"0x000000000000000000000000000000000000006c": "0x1",
  	"0x000000000000000000000000000000000000006d": "0x1",
  	"0x000000000000000000000000000000000000006e": "0x1",
  	"0x000000000000000000000000000000000000006f": "0x1",
  	"0x0000000000000000000000000000000000000070": "0x1",
  	"0x0000000000000000000000000000000000000071": "0x1",
  	"0x0000000000000000000000000000000000000072": "0x1",
  	"0x0000000000000000000000000000000000000073": "0x1",
  	"0x0000000000000000000000000000000000000074": "0x1",
  	"0x0000000000000000000000000000000000000075": "0x1",
  	"0x0000000000000000000000000000000000000076": "0x1",
  	"0x0000000000000000000000000000000000000077": "0x1",
  	"0x0000000000000000000000000000000000000078": "0x1",
  	"0x0000000000000000000000000000000000000079": "0x1",
  	"0x000000000000000000000000000000000000007a": "0x1",
  	"0x000000000000000000000000000000000000007b": "0x1",
  	"0x000000000000000000000000000000000000007c": "0x1",
  	"0x000000000000000000000000000000000000007d": "0x1",
  	"0x000000000000000000000000000000000000007e": "0x1",
  	"0x000000000000000000000000000000000000007f": "0x1",
  	"0x0000000000000000000000000000000000000080": "0x1",
  	"0x0000000000000000000000000000000000000081": "0x1",
  	"0x0000000000000000000000000000000000000082": "0x1",
  	"0x0000000000000000000000000000000000000083": "0x1",
  	"0x0000000000000000000000000000000000000084": "0x1",
  	"0x0000000000000000000000000000000000000085": "0x1",
  	"0x0000000000000000000000000000000000000086": "0x1",
  	"0x0000000000000000000000000000000000000087": "0x1",
  	"0x0000000000000000000000000000000000000088": "0x1",
  	"0x0000000000000000000000000000000000000089": "0x1",
  	"0x000000000000000000000000000000000000008a": "0x1",
  	"0x000000000000000000000000000000000000008b": "0x1",
  	"0x000000000000000000000000000000000000008c": "0x1",
  	"0x000000000000000000000000000000000000008d": "0x1",
  	"0x000000000000000000000000000000000000008e": "0x1",
  	"0x000000000000000000000000000000000000008f": "0x1",
  	"0x0000000000000000000000000000000000000090": "0x1",
  	"0x0000000000000000000000000000000000000091": "0x1",
  	"0x0000000000000000000000000000000000000092": "0x1",
  	"0x0000000000000000000000000000000000000093": "0x1",
  	"0x0000000000000000000000000000000000000094": "0x1",
  	"0x0000000000000000000000000000000000000095": "0x1",
  	"0x0000000000000000000000000000000000000096": "0x1",
  	"0x0000000000000000000000000000000000000097": "0x1",
  	"0x0000000000000000000000000000000000000098": "0x1",
  	"0x0000000000000000000000000000000000000099": "0x1",
  	"0x000000000000000000000000000000000000009a": "0x1",
  	"0x000000000000000000000000000000000000009b": "0x1",
  	"0x000000000000000000000000000000000000009c": "0x1",
  	"0x000000000000000000000000000000000000009d": "0x1",
  	"0x000000000000000000000000000000000000009e": "0x1",
  	"0x000000000000000000000000000000000000009f": "0x1",
  	"0x00000000000000000000000000000000000000a0": "0x1",
  	"0x00000000000000000000000000000000000000a1": "0x1",
  	"0x00000000000000000000000000000000000000a2": "0x1",
  	"0x00000000000000000000000000000000000000a3": "0x1",
  	"0x00000000000000000000000000000000000000a4": "0x1",
  	"0x00000000000000000000000000000000000000a5": "0x1",
  	"0x00000000000000000000000000000000000000a6": "0x1",
  	"0x00000000000000000000000000000000000000a7": "0x1",
  	"0x00000000000000000000000000000000000000a8": "0x1",
  	"0x00000000000000000000000000000000000000a9": "0x1",
  	"0x00000000000000000000000000000000000000aa": "0x1",
  	"0x00000000000000000000000000000000000000ab": "0x1",
  	"0x00000000000000000000000000000000000000ac": "0x1",
  	"0x00000000000000000000000000000000000000ad": "0x1",
  	"0x00000000000000000000000000000000000000ae": "0x1",
  	"0x00000000000000000000000000000000000000af": "0x1",
  	"0x00000000000000000000000000000000000000b0": "0x1",
  	"0x00000000000000000000000000000000000000b1": "0x1",
  	"0x00000000000000000000000000000000000000b2": "0x1",
  	"0x00000000000000000000000000000000000000b3": "0x1",
  	"0x00000000000000000000000000000000000000b4": "0x1",
  	"0x00000000000000000000000000000000000000b5": "0x1",
  	"0x00000000000000000000000000000000000000b6": "0x1",
  	"0x00000000000000000000000000000000000000b7": "0x1",
  	"0x00000000000000000000000000000000000000b8": "0x1",
  	"0x00000000000000000000000000000000000000b9": "0x1",
  	"0x00000000000000000000000000000000000000ba": "0x1",
  	"0x00000000000000000000000000000000000000bb": "0x1",
  	"0x00000000000000000000000000000000000000bc": "0x1",
  	"0x00000000000000000000000000000000000000bd": "0x1",
  	"0x00000000000000000000000000000000000000be": "0x1",
  	"0x00000000000000000000000000000000000000bf": "0x1",
  	"0x00000000000000000000000000000000000000c0": "0x1",
  	"0x00000000000000000000000000000000000000c1": "0x1",
  	"0x00000000000000000000000000000000000000c2": "0x1",
  	"0x00000000000000000000000000000000000000c3": "0x1",
  	"0x00000000000000000000000000000000000000c4": "0x1",
  	"0x00000000000000000000000000000000000000c5": "0x1",
  	"0x00000000000000000000000000000000000000c6": "0x1",
  	"0x00000000000000000000000000000000000000c7": "0x1",
  	"0x00000000000000000000000000000000000000c8": "0x1",
  	"0x00000000000000000000000000000000000000c9": "0x1",
  	"0x00000000000000000000000000000000000000ca": "0x1",
  	"0x00000000000000000000000000000000000000cb": "0x1",
  	"0x00000000000000000000000000000000000000cc": "0x1",
  	"0x00000000000000000000000000000000000000cd": "0x1",
  	"0x00000000000000000000000000000000000000ce": "0x1",
  	"0x00000000000000000000000000000000000000cf": "0x1",
  	"0x00000000000000000000000000000000000000d0": "0x1",
  	"0x00000000000000000000000000000000000000d1": "0x1",
  	"0x00000000000000000000000000000000000000d2": "0x1",
  	"0x00000000000000000000000000000000000000d3": "0x1",
  	"0x00000000000000000000000000000000000000d4": "0x1",
  	"0x00000000000000000000000000000000000000d5": "0x1",
  	"0x00000000000000000000000000000000000000d6": "0x1",
  	"0x00000000000000000000000000000000000000d7": "0x1",
  	"0x00000000000000000000000000000000000000d8": "0x1",
  	"0x00000000000000000000000000000000000000d9": "0x1",
  	"0x00000000000000000000000000000000000000da": "0x1",
  	"0x00000000000000000000000000000000000000db": "0x1",
  	"0x00000000000000000000000000000000000000dc": "0x1",
  	"0x00000000000000000000000000000000000000dd": "0x1",
  	"0x00000000000000000000000000000000000000de": "0x1",
  	"0x00000000000000000000000000000000000000df": "0x1",
  	"0x00000000000000000000000000000000000000e0": "0x1",
  	"0x00000000000000000000000000000000000000e1": "0x1",
  	"0x00000000000000000000000000000000000000e2": "0x1",
  	"0x00000000000000000000000000000000000000e3": "0x1",
  	"0x00000000000000000000000000000000000000e4": "0x1",
  	"0x00000000000000000000000000000000000000e5": "0x1",
  	"0x00000000000000000000000000000000000000e6": "0x1",
  	"0x00000000000000000000000000000000000000e7": "0x1",
  	"0x00000000000000000000000000000000000000e8": "0x1",
  	"0x00000000000000000000000000000000000000e9": "0x1",
  	"0x00000000000000000000000000000000000000ea": "0x1",
  	"0x00000000000000000000000000000000000000eb": "0x1",
  	"0x00000000000000000000000000000000000000ec": "0x1",
  	"0x00000000000000000000000000000000000000ed": "0x1",
  	"0x00000000000000000000000000000000000000ee": "0x1",
  	"0x00000000000000000000000000000000000000ef": "0x1",
  	"0x00000000000000000000000000000000000000f0": "0x1",
  	"0x00000000000000000000000000000000000000f1": "0x1",
  	"0x00000000000000000000000000000000000000f2": "0x1",
  	"0x00000000000000000000000000000000000000f3": "0x1",
  	"0x00000000000000000000000000000000000000f4": "0x1",
  	"0x00000000000000000000000000000000000000f5": "0x1",
  	"0x00000000000000000000000000000000000000f6": "0x1",
  	"0x00000000000000000000000000000000000000f7": "0x1",
  	"0x00000000000000000000000000000000000000f8": "0x1",
  	"0x00000000000000000000000000000000000000f9": "0x1",
  	"0x00000000000000000000000000000000000000fa": "0x1",
  	"0x00000000000000000000000000000000000000fb": "0x1",
  	"0x00000000000000000000000000000000000000fc": "0x1",
  	"0x00000000000000000000000000000000000000fd": "0x1",
  	"0x00000000000000000000000000000000000000fe": "0x1",
  	"0x00000000000000000000000000000000000000ff": "0x1",
  	"0x4c2ae482593505f0163cdefc073e81c63cda4107": "0x152d02c7e14af6800000",
  	"0xa8e8f14732658e4b51e8711931053a8a69baf2b1": "0x152d02c7e14af6800000",
  	"0xd9a5179f091d85051d3c982785efd1455cec8699": "0x84595161401484a000000",
  	"0xe0a2bd4258d2768837baa26a28fe71dc079f84c7": "0x4a47e3c12448f4ad000000"
  };

  var require$$15 = {
  	"0xa2A6d93439144FFE4D27c9E088dCD8b783946263": "0xD3C21BCECCEDA1000000",
  	"0xBc11295936Aa79d594139de1B2e12629414F3BDB": "0xD3C21BCECCEDA1000000",
  	"0x7cF5b79bfe291A67AB02b393E456cCc4c266F753": "0xD3C21BCECCEDA1000000",
  	"0xaaec86394441f915bce3e6ab399977e9906f3b69": "0xD3C21BCECCEDA1000000",
  	"0xF47CaE1CF79ca6758Bfc787dbD21E6bdBe7112B8": "0xD3C21BCECCEDA1000000",
  	"0xd7eDDB78ED295B3C9629240E8924fb8D8874ddD8": "0xD3C21BCECCEDA1000000",
  	"0x8b7F0977Bb4f0fBE7076FA22bC24acA043583F5e": "0xD3C21BCECCEDA1000000",
  	"0xe2e2659028143784d557bcec6ff3a0721048880a": "0xD3C21BCECCEDA1000000",
  	"0xd9a5179f091d85051d3c982785efd1455cec8699": "0xD3C21BCECCEDA1000000",
  	"0xbeef32ca5b9a198d27B4e02F4c70439fE60356Cf": "0xD3C21BCECCEDA1000000",
  	"0x0000006916a87b82333f4245046623b23794c65c": "0x84595161401484A000000",
  	"0xb21c33de1fab3fa15499c62b59fe0cc3250020d1": "0x52B7D2DCC80CD2E4000000",
  	"0x10F5d45854e038071485AC9e402308cF80D2d2fE": "0x52B7D2DCC80CD2E4000000",
  	"0xd7d76c58b3a519e9fA6Cc4D22dC017259BC49F1E": "0x52B7D2DCC80CD2E4000000",
  	"0x799D329e5f583419167cD722962485926E338F4a": "0xDE0B6B3A7640000"
  };

  Object.defineProperty(blockchain, "__esModule", { value: true });
  blockchain.Blockchain = void 0;
  const block_1$3 = dist$6;
  const common_1$5 = dist$8;
  const util_1$6 = dist$a;
  const memory_level_1 = memoryLevel;
  const semaphore_async_await_1 = dist$4;
  const consensus_1 = consensus;
  const helpers_1 = helpers;
  const manager_1 = manager;
  const operation_1 = operation;
  const genesisStates_1 = genesisStates;
  /**
   * This class stores and interacts with blocks.
   */
  class Blockchain {
      /**
       * Creates new Blockchain object.
       *
       * @deprecated The direct usage of this constructor is discouraged since
       * non-finalized async initialization might lead to side effects. Please
       * use the async {@link Blockchain.create} constructor instead (same API).
       *
       * @param opts An object with the options that this constructor takes. See
       * {@link BlockchainOptions}.
       */
      constructor(opts = {}) {
          this._isInitialized = false;
          if (opts.common) {
              this._common = opts.common;
          }
          else {
              const DEFAULT_CHAIN = common_1$5.Chain.Mainnet;
              const DEFAULT_HARDFORK = common_1$5.Hardfork.Chainstart;
              this._common = new common_1$5.Common({
                  chain: DEFAULT_CHAIN,
                  hardfork: DEFAULT_HARDFORK,
              });
          }
          this._hardforkByHeadBlockNumber = opts.hardforkByHeadBlockNumber ?? false;
          this._validateConsensus = opts.validateConsensus ?? true;
          this._validateBlocks = opts.validateBlocks ?? true;
          this._customGenesisState = opts.genesisState;
          this.db = opts.db ? opts.db : new memory_level_1.MemoryLevel();
          this.dbManager = new manager_1.DBManager(this.db, this._common);
          if (opts.consensus) {
              this.consensus = opts.consensus;
          }
          else {
              switch (this._common.consensusAlgorithm()) {
                  case common_1$5.ConsensusAlgorithm.Casper:
                      this.consensus = new consensus_1.CasperConsensus();
                      break;
                  case common_1$5.ConsensusAlgorithm.Clique:
                      this.consensus = new consensus_1.CliqueConsensus();
                      break;
                  case common_1$5.ConsensusAlgorithm.Ethash:
                      this.consensus = new consensus_1.EthashConsensus();
                      break;
                  default:
                      throw new Error(`consensus algorithm ${this._common.consensusAlgorithm()} not supported`);
              }
          }
          if (this._validateConsensus) {
              if (this._common.consensusType() === common_1$5.ConsensusType.ProofOfWork) {
                  if (this._common.consensusAlgorithm() !== common_1$5.ConsensusAlgorithm.Ethash) {
                      throw new Error('consensus validation only supported for pow ethash algorithm');
                  }
              }
              if (this._common.consensusType() === common_1$5.ConsensusType.ProofOfAuthority) {
                  if (this._common.consensusAlgorithm() !== common_1$5.ConsensusAlgorithm.Clique) {
                      throw new Error('consensus (signature) validation only supported for poa clique algorithm');
                  }
              }
          }
          this._heads = {};
          this._lock = new semaphore_async_await_1.default(1);
          if (opts.genesisBlock && !opts.genesisBlock.isGenesis()) {
              throw 'supplied block is not a genesis block';
          }
      }
      /**
       * Safe creation of a new Blockchain object awaiting the initialization function,
       * encouraged method to use when creating a blockchain object.
       *
       * @param opts Constructor options, see {@link BlockchainOptions}
       */
      static async create(opts = {}) {
          const blockchain = new Blockchain(opts);
          await blockchain._init(opts.genesisBlock);
          return blockchain;
      }
      /**
       * Creates a blockchain from a list of block objects,
       * objects must be readable by {@link Block.fromBlockData}
       *
       * @param blockData List of block objects
       * @param opts Constructor options, see {@link BlockchainOptions}
       */
      static async fromBlocksData(blocksData, opts = {}) {
          const blockchain = await Blockchain.create(opts);
          for (const blockData of blocksData) {
              const block = block_1$3.Block.fromBlockData(blockData, {
                  common: blockchain._common,
                  hardforkByBlockNumber: true,
              });
              await blockchain.putBlock(block);
          }
          return blockchain;
      }
      /**
       * Returns a deep copy of this {@link Blockchain} instance.
       *
       * Note: this does not make a copy of the underlying db
       * since it is unknown if the source is on disk or in memory.
       * This should not be a significant issue in most usage since
       * the queries will only reflect the instance's known data.
       * If you would like this copied blockchain to use another db
       * set the {@link db} of this returned instance to a copy of
       * the original.
       */
      copy() {
          const copiedBlockchain = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
          copiedBlockchain._common = this._common.copy();
          return copiedBlockchain;
      }
      /**
       * This method is called in {@link Blockchain.create} and either sets up the DB or reads
       * values from the DB and makes these available to the consumers of
       * Blockchain.
       *
       * @hidden
       */
      async _init(genesisBlock) {
          await this.consensus.setup({ blockchain: this });
          if (this._isInitialized)
              return;
          let dbGenesisBlock;
          try {
              const genesisHash = await this.dbManager.numberToHash(BigInt(0));
              dbGenesisBlock = await this.dbManager.getBlock(genesisHash);
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
          }
          if (!genesisBlock) {
              let stateRoot;
              if (this._common.chainId() === BigInt(1) && this._customGenesisState === undefined) {
                  // For mainnet use the known genesis stateRoot to quicken setup
                  stateRoot = Buffer$8.from('d7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544', 'hex');
              }
              else {
                  stateRoot = await (0, genesisStates_1.genesisStateRoot)(this.genesisState());
              }
              genesisBlock = this.createGenesisBlock(stateRoot);
          }
          // If the DB has a genesis block, then verify that the genesis block in the
          // DB is indeed the Genesis block generated or assigned.
          if (dbGenesisBlock && !genesisBlock.hash().equals(dbGenesisBlock.hash())) {
              throw new Error('The genesis block in the DB has a different hash than the provided genesis block.');
          }
          const genesisHash = genesisBlock.hash();
          if (!dbGenesisBlock) {
              // If there is no genesis block put the genesis block in the DB.
              // For that TD, the BlockOrHeader, and the Lookups have to be saved.
              const dbOps = [];
              dbOps.push((0, helpers_1.DBSetTD)(genesisBlock.header.difficulty, BigInt(0), genesisHash));
              (0, helpers_1.DBSetBlockOrHeader)(genesisBlock).map((op) => dbOps.push(op));
              (0, helpers_1.DBSaveLookups)(genesisHash, BigInt(0)).map((op) => dbOps.push(op));
              await this.dbManager.batch(dbOps);
              await this.consensus.genesisInit(genesisBlock);
          }
          // At this point, we can safely set the genesis:
          // it is either the one we put in the DB, or it is equal to the one
          // which we read from the DB.
          this._genesisBlock = genesisBlock;
          // load verified iterator heads
          try {
              const heads = await this.dbManager.getHeads();
              this._heads = heads;
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
              this._heads = {};
          }
          // load headerchain head
          try {
              const hash = await this.dbManager.getHeadHeader();
              this._headHeaderHash = hash;
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
              this._headHeaderHash = genesisHash;
          }
          // load blockchain head
          try {
              const hash = await this.dbManager.getHeadBlock();
              this._headBlockHash = hash;
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
              this._headBlockHash = genesisHash;
          }
          if (this._hardforkByHeadBlockNumber) {
              const latestHeader = await this._getHeader(this._headHeaderHash);
              const td = await this.getTotalDifficulty(this._headHeaderHash);
              this.checkAndTransitionHardForkByNumber(latestHeader.number, td);
          }
          this._isInitialized = true;
      }
      /**
       * Run a function after acquiring a lock. It is implied that we have already
       * initialized the module (or we are calling this from the init function, like
       * `_setCanonicalGenesisBlock`)
       * @param action - function to run after acquiring a lock
       * @hidden
       */
      async runWithLock(action) {
          try {
              await this._lock.acquire();
              const value = await action();
              return value;
          }
          finally {
              this._lock.release();
          }
      }
      /**
       * Returns the specified iterator head.
       *
       * This function replaces the old {@link Blockchain.getHead} method. Note that
       * the function deviates from the old behavior and returns the
       * genesis hash instead of the current head block if an iterator
       * has not been run. This matches the behavior of {@link Blockchain.iterator}.
       *
       * @param name - Optional name of the iterator head (default: 'vm')
       */
      async getIteratorHead(name = 'vm') {
          return await this.runWithLock(async () => {
              // if the head is not found return the genesis hash
              const hash = this._heads[name] ?? this.genesisBlock.hash();
              const block = await this._getBlock(hash);
              return block;
          });
      }
      /**
       * Returns the specified iterator head.
       *
       * @param name - Optional name of the iterator head (default: 'vm')
       *
       * @deprecated use {@link Blockchain.getIteratorHead} instead.
       * Note that {@link Blockchain.getIteratorHead} doesn't return
       * the `headHeader` but the genesis hash as an initial iterator
       * head value (now matching the behavior of {@link Blockchain.iterator}
       * on a first run)
       */
      async getHead(name = 'vm') {
          return await this.runWithLock(async () => {
              // if the head is not found return the headHeader
              const hash = this._heads[name] ?? this._headBlockHash;
              if ((0, util_1$6.isFalsy)(hash))
                  throw new Error('No head found.');
              const block = await this._getBlock(hash);
              return block;
          });
      }
      /**
       * Returns the latest header in the canonical chain.
       */
      async getCanonicalHeadHeader() {
          return await this.runWithLock(async () => {
              if (!this._headHeaderHash)
                  throw new Error('No head header set');
              const block = await this._getBlock(this._headHeaderHash);
              return block.header;
          });
      }
      /**
       * Returns the latest full block in the canonical chain.
       */
      async getCanonicalHeadBlock() {
          return this.runWithLock(async () => {
              if (!this._headBlockHash)
                  throw new Error('No head block set');
              const block = this._getBlock(this._headBlockHash);
              return block;
          });
      }
      /**
       * Adds blocks to the blockchain.
       *
       * If an invalid block is met the function will throw, blocks before will
       * nevertheless remain in the DB. If any of the saved blocks has a higher
       * total difficulty than the current max total difficulty the canonical
       * chain is rebuilt and any stale heads/hashes are overwritten.
       * @param blocks - The blocks to be added to the blockchain
       */
      async putBlocks(blocks) {
          for (let i = 0; i < blocks.length; i++) {
              await this.putBlock(blocks[i]);
          }
      }
      /**
       * Adds a block to the blockchain.
       *
       * If the block is valid and has a higher total difficulty than the current
       * max total difficulty, the canonical chain is rebuilt and any stale
       * heads/hashes are overwritten.
       * @param block - The block to be added to the blockchain
       */
      async putBlock(block) {
          await this._putBlockOrHeader(block);
      }
      /**
       * Adds many headers to the blockchain.
       *
       * If an invalid header is met the function will throw, headers before will
       * nevertheless remain in the DB. If any of the saved headers has a higher
       * total difficulty than the current max total difficulty the canonical
       * chain is rebuilt and any stale heads/hashes are overwritten.
       * @param headers - The headers to be added to the blockchain
       */
      async putHeaders(headers) {
          for (let i = 0; i < headers.length; i++) {
              await this.putHeader(headers[i]);
          }
      }
      /**
       * Adds a header to the blockchain.
       *
       * If this header is valid and it has a higher total difficulty than the current
       * max total difficulty, the canonical chain is rebuilt and any stale
       * heads/hashes are overwritten.
       * @param header - The header to be added to the blockchain
       */
      async putHeader(header) {
          await this._putBlockOrHeader(header);
      }
      /**
       * Entrypoint for putting any block or block header. Verifies this block,
       * checks the total TD: if this TD is higher than the current highest TD, we
       * have thus found a new canonical block and have to rewrite the canonical
       * chain. This also updates the head block hashes. If any of the older known
       * canonical chains just became stale, then we also reset every _heads header
       * which points to a stale header to the last verified header which was in the
       * old canonical chain, but also in the new canonical chain. This thus rolls
       * back these headers so that these can be updated to the "new" canonical
       * header using the iterator method.
       * @hidden
       */
      async _putBlockOrHeader(item) {
          await this.runWithLock(async () => {
              const block = item instanceof block_1$3.BlockHeader
                  ? new block_1$3.Block(item, undefined, undefined, {
                      common: item._common,
                  })
                  : item;
              const isGenesis = block.isGenesis();
              // we cannot overwrite the Genesis block after initializing the Blockchain
              if (isGenesis) {
                  throw new Error('Cannot put a genesis block: create a new Blockchain');
              }
              const { header } = block;
              const blockHash = header.hash();
              const blockNumber = header.number;
              let td = header.difficulty;
              const currentTd = { header: BigInt(0), block: BigInt(0) };
              let dbOps = [];
              if (block._common.chainId() !== this._common.chainId()) {
                  throw new Error('Chain mismatch while trying to put block or header');
              }
              if (this._validateBlocks && !isGenesis) {
                  // this calls into `getBlock`, which is why we cannot lock yet
                  await this.validateBlock(block);
              }
              if (this._validateConsensus) {
                  await this.consensus.validateConsensus(block);
              }
              // set total difficulty in the current context scope
              if (this._headHeaderHash) {
                  currentTd.header = await this.getTotalDifficulty(this._headHeaderHash);
              }
              if (this._headBlockHash) {
                  currentTd.block = await this.getTotalDifficulty(this._headBlockHash);
              }
              // calculate the total difficulty of the new block
              let parentTd = BigInt(0);
              if (!block.isGenesis()) {
                  parentTd = await this.getTotalDifficulty(header.parentHash, blockNumber - BigInt(1));
              }
              td += parentTd;
              // save total difficulty to the database
              dbOps = dbOps.concat((0, helpers_1.DBSetTD)(td, blockNumber, blockHash));
              // save header/block to the database
              dbOps = dbOps.concat((0, helpers_1.DBSetBlockOrHeader)(block));
              let commonAncestor;
              let ancestorHeaders;
              // if total difficulty is higher than current, add it to canonical chain
              if (block.isGenesis() ||
                  (block._common.consensusType() !== common_1$5.ConsensusType.ProofOfStake && td > currentTd.header) ||
                  block._common.consensusType() === common_1$5.ConsensusType.ProofOfStake) {
                  const foundCommon = await this.findCommonAncestor(header);
                  commonAncestor = foundCommon.commonAncestor;
                  ancestorHeaders = foundCommon.ancestorHeaders;
                  this._headHeaderHash = blockHash;
                  if (item instanceof block_1$3.Block) {
                      this._headBlockHash = blockHash;
                  }
                  if (this._hardforkByHeadBlockNumber) {
                      this.checkAndTransitionHardForkByNumber(blockNumber, td);
                  }
                  // delete higher number assignments and overwrite stale canonical chain
                  await this._deleteCanonicalChainReferences(blockNumber + BigInt(1), blockHash, dbOps);
                  // from the current header block, check the blockchain in reverse (i.e.
                  // traverse `parentHash`) until `numberToHash` matches the current
                  // number/hash in the canonical chain also: overwrite any heads if these
                  // heads are stale in `_heads` and `_headBlockHash`
                  await this._rebuildCanonical(header, dbOps);
              }
              else {
                  // the TD is lower than the current highest TD so we will add the block
                  // to the DB, but will not mark it as the canonical chain.
                  if (td > currentTd.block && item instanceof block_1$3.Block) {
                      this._headBlockHash = blockHash;
                  }
                  // save hash to number lookup info even if rebuild not needed
                  dbOps.push((0, helpers_1.DBSetHashToNumber)(blockHash, blockNumber));
              }
              const ops = dbOps.concat(this._saveHeadOps());
              await this.dbManager.batch(ops);
              await this.consensus.newBlock(block, commonAncestor, ancestorHeaders);
          });
      }
      /**
       * Validates a block header, throwing if invalid. It is being validated against the reported `parentHash`.
       * It verifies the current block against the `parentHash`:
       * - The `parentHash` is part of the blockchain (it is a valid header)
       * - Current block number is parent block number + 1
       * - Current block has a strictly higher timestamp
       * - Additional PoW checks ->
       *   - Current block has valid difficulty and gas limit
       *   - In case that the header is an uncle header, it should not be too old or young in the chain.
       * - Additional PoA clique checks ->
       *   - Checks on coinbase and mixHash
       *   - Current block has a timestamp diff greater or equal to PERIOD
       *   - Current block has difficulty correctly marked as INTURN or NOTURN
       * @param header - header to be validated
       * @param height - If this is an uncle header, this is the height of the block that is including it
       */
      async validateHeader(header, height) {
          if (header.isGenesis()) {
              return;
          }
          const parentHeader = (await this.getBlock(header.parentHash)).header;
          if ((0, util_1$6.isFalsy)(parentHeader)) {
              throw new Error(`could not find parent header ${header.errorStr()}`);
          }
          const { number } = header;
          if (number !== parentHeader.number + BigInt(1)) {
              throw new Error(`invalid number ${header.errorStr()}`);
          }
          if (header.timestamp <= parentHeader.timestamp) {
              throw new Error(`invalid timestamp ${header.errorStr()}`);
          }
          if (!(header._common.consensusType() === 'pos'))
              await this.consensus.validateDifficulty(header);
          if (this._common.consensusAlgorithm() === common_1$5.ConsensusAlgorithm.Clique) {
              const period = this._common.consensusConfig().period;
              // Timestamp diff between blocks is lower than PERIOD (clique)
              if (parentHeader.timestamp + BigInt(period) > header.timestamp) {
                  throw new Error(`invalid timestamp diff (lower than period) ${header.errorStr()}`);
              }
          }
          header.validateGasLimit(parentHeader);
          if ((0, util_1$6.isTruthy)(height)) {
              const dif = height - parentHeader.number;
              if (!(dif < BigInt(8) && dif > BigInt(1))) {
                  throw new Error(`uncle block has a parent that is too old or too young ${header.errorStr()}`);
              }
          }
          // check blockchain dependent EIP1559 values
          if (header._common.isActivatedEIP(1559) === true) {
              // check if the base fee is correct
              let expectedBaseFee;
              const londonHfBlock = this._common.hardforkBlock(common_1$5.Hardfork.London);
              const isInitialEIP1559Block = number === londonHfBlock;
              if (isInitialEIP1559Block) {
                  expectedBaseFee = header._common.param('gasConfig', 'initialBaseFee');
              }
              else {
                  expectedBaseFee = parentHeader.calcNextBaseFee();
              }
              if (header.baseFeePerGas !== expectedBaseFee) {
                  throw new Error(`Invalid block: base fee not correct ${header.errorStr()}`);
              }
          }
      }
      /**
       * Validates a block, by validating the header against the current chain, any uncle headers, and then
       * whether the block is internally consistent
       * @param block block to be validated
       */
      async validateBlock(block) {
          await this.validateHeader(block.header);
          await this._validateUncleHeaders(block);
          await block.validateData(false);
      }
      /**
       * The following rules are checked in this method:
       * Uncle Header is a valid header.
       * Uncle Header is an orphan, i.e. it is not one of the headers of the canonical chain.
       * Uncle Header has a parentHash which points to the canonical chain. This parentHash is within the last 7 blocks.
       * Uncle Header is not already included as uncle in another block.
       * @param block - block for which uncles are being validated
       */
      async _validateUncleHeaders(block) {
          const uncleHeaders = block.uncleHeaders;
          if (uncleHeaders.length == 0) {
              return;
          }
          // Each Uncle Header is a valid header
          await Promise.all(uncleHeaders.map((uh) => this.validateHeader(uh, block.header.number)));
          let lowestUncleNumber = block.header.number;
          uncleHeaders.map((header) => {
              if (header.number < lowestUncleNumber) {
                  lowestUncleNumber = header.number;
              }
          });
          // Helper variable: set hash to `true` if hash is part of the canonical chain
          const canonicalChainHashes = {};
          // Helper variable: set hash to `true` if uncle hash is included in any canonical block
          const includedUncles = {};
          // Due to the header validation check above, we know that `getBlocks` is between 1 and 8 inclusive.
          const getBlocks = Number(block.header.number - lowestUncleNumber + BigInt(1));
          // See Geth: https://github.com/ethereum/go-ethereum/blob/b63bffe8202d46ea10ac8c4f441c582642193ac8/consensus/ethash/consensus.go#L207
          // Here we get the necessary blocks from the chain.
          let parentHash = block.header.parentHash;
          for (let i = 0; i < getBlocks; i++) {
              const parentBlock = await this.getBlock(parentHash);
              if ((0, util_1$6.isFalsy)(parentBlock)) {
                  throw new Error(`could not find parent block ${block.errorStr()}`);
              }
              // mark block hash as part of the canonical chain
              canonicalChainHashes[parentBlock.hash().toString('hex')] = true;
              // for each of the uncles, mark the uncle as included
              parentBlock.uncleHeaders.map((uh) => {
                  includedUncles[uh.hash().toString('hex')] = true;
              });
              parentHash = parentBlock.header.parentHash;
          }
          // Here we check:
          // Uncle Header is an orphan, i.e. it is not one of the headers of the canonical chain.
          // Uncle Header is not already included as uncle in another block.
          // Uncle Header has a parentHash which points to the canonical chain.
          uncleHeaders.map((uh) => {
              const uncleHash = uh.hash().toString('hex');
              const parentHash = uh.parentHash.toString('hex');
              if (!canonicalChainHashes[parentHash]) {
                  throw new Error(`The parent hash of the uncle header is not part of the canonical chain ${block.errorStr()}`);
              }
              if (includedUncles[uncleHash]) {
                  throw new Error(`The uncle is already included in the canonical chain ${block.errorStr()}`);
              }
              if (canonicalChainHashes[uncleHash]) {
                  throw new Error(`The uncle is a canonical block ${block.errorStr()}`);
              }
          });
      }
      /**
       * Gets a block by its hash.
       *
       * @param blockId - The block's hash or number. If a hash is provided, then
       * this will be immediately looked up, otherwise it will wait until we have
       * unlocked the DB
       */
      async getBlock(blockId) {
          // cannot wait for a lock here: it is used both in `validate` of `Block`
          // (calls `getBlock` to get `parentHash`) it is also called from `runBlock`
          // in the `VM` if we encounter a `BLOCKHASH` opcode: then a bigint is used we
          // need to then read the block from the canonical chain Q: is this safe? We
          // know it is OK if we call it from the iterator... (runBlock)
          return await this._getBlock(blockId);
      }
      /**
       * @hidden
       */
      async _getBlock(blockId) {
          return this.dbManager.getBlock(blockId);
      }
      /**
       * Gets total difficulty for a block specified by hash and number
       */
      async getTotalDifficulty(hash, number) {
          if (number === undefined) {
              number = await this.dbManager.hashToNumber(hash);
          }
          return this.dbManager.getTotalDifficulty(hash, number);
      }
      /**
       * Looks up many blocks relative to blockId Note: due to `GetBlockHeaders
       * (0x03)` (ETH wire protocol) we have to support skip/reverse as well.
       * @param blockId - The block's hash or number
       * @param maxBlocks - Max number of blocks to return
       * @param skip - Number of blocks to skip apart
       * @param reverse - Fetch blocks in reverse
       */
      async getBlocks(blockId, maxBlocks, skip, reverse) {
          return await this.runWithLock(async () => {
              const blocks = [];
              let i = -1;
              const nextBlock = async (blockId) => {
                  let block;
                  try {
                      block = await this._getBlock(blockId);
                  }
                  catch (error) {
                      if (error.code !== 'LEVEL_NOT_FOUND') {
                          throw error;
                      }
                      return;
                  }
                  i++;
                  const nextBlockNumber = block.header.number + BigInt(reverse ? -1 : 1);
                  if (i !== 0 && skip && i % (skip + 1) !== 0) {
                      return await nextBlock(nextBlockNumber);
                  }
                  blocks.push(block);
                  if (blocks.length < maxBlocks) {
                      await nextBlock(nextBlockNumber);
                  }
              };
              await nextBlock(blockId);
              return blocks;
          });
      }
      /**
       * Given an ordered array, returns an array of hashes that are not in the
       * blockchain yet. Uses binary search to find out what hashes are missing.
       * Therefore, the array needs to be ordered upon number.
       * @param hashes - Ordered array of hashes (ordered on `number`).
       */
      async selectNeededHashes(hashes) {
          return await this.runWithLock(async () => {
              let max;
              let mid;
              let min;
              max = hashes.length - 1;
              mid = min = 0;
              while (max >= min) {
                  let number;
                  try {
                      number = await this.dbManager.hashToNumber(hashes[mid]);
                  }
                  catch (error) {
                      if (error.code !== 'LEVEL_NOT_FOUND') {
                          throw error;
                      }
                  }
                  if (number !== undefined) {
                      min = mid + 1;
                  }
                  else {
                      max = mid - 1;
                  }
                  mid = Math.floor((min + max) / 2);
              }
              return hashes.slice(min);
          });
      }
      /**
       * Completely deletes a block from the blockchain including any references to
       * this block. If this block was in the canonical chain, then also each child
       * block of this block is deleted Also, if this was a canonical block, each
       * head header which is part of this now stale chain will be set to the
       * parentHeader of this block An example reason to execute is when running the
       * block in the VM invalidates this block: this will then reset the canonical
       * head to the past block (which has been validated in the past by the VM, so
       * we can be sure it is correct).
       * @param blockHash - The hash of the block to be deleted
       */
      async delBlock(blockHash) {
          // Q: is it safe to make this not wait for a lock? this is called from
          // `BlockchainTestsRunner` in case `runBlock` throws (i.e. the block is invalid).
          // But is this the way to go? If we know this is called from the
          // iterator we are safe, but if this is called from anywhere
          // else then this might lead to a concurrency problem?
          await this._delBlock(blockHash);
      }
      /**
       * @hidden
       */
      async _delBlock(blockHash) {
          const dbOps = [];
          // get header
          const header = await this._getHeader(blockHash);
          const blockHeader = header;
          const blockNumber = blockHeader.number;
          const parentHash = blockHeader.parentHash;
          // check if block is in the canonical chain
          const canonicalHash = await this.safeNumberToHash(blockNumber);
          const inCanonical = (0, util_1$6.isTruthy)(canonicalHash) && canonicalHash.equals(blockHash);
          // delete the block, and if block is in the canonical chain, delete all
          // children as well
          await this._delChild(blockHash, blockNumber, inCanonical ? parentHash : null, dbOps);
          // delete all number to hash mappings for deleted block number and above
          if (inCanonical) {
              await this._deleteCanonicalChainReferences(blockNumber, parentHash, dbOps);
          }
          await this.dbManager.batch(dbOps);
      }
      /**
       * Updates the `DatabaseOperation` list to delete a block from the DB,
       * identified by `blockHash` and `blockNumber`. Deletes fields from `Header`,
       * `Body`, `HashToNumber` and `TotalDifficulty` tables. If child blocks of
       * this current block are in the canonical chain, delete these as well. Does
       * not actually commit these changes to the DB. Sets `_headHeaderHash` and
       * `_headBlockHash` to `headHash` if any of these matches the current child to
       * be deleted.
       * @param blockHash - the block hash to delete
       * @param blockNumber - the number corresponding to the block hash
       * @param headHash - the current head of the chain (if null, do not update
       * `_headHeaderHash` and `_headBlockHash`)
       * @param ops - the `DatabaseOperation` list to add the delete operations to
       * @hidden
       */
      async _delChild(blockHash, blockNumber, headHash, ops) {
          // delete header, body, hash to number mapping and td
          ops.push(helpers_1.DBOp.del(operation_1.DBTarget.Header, { blockHash, blockNumber }));
          ops.push(helpers_1.DBOp.del(operation_1.DBTarget.Body, { blockHash, blockNumber }));
          ops.push(helpers_1.DBOp.del(operation_1.DBTarget.HashToNumber, { blockHash }));
          ops.push(helpers_1.DBOp.del(operation_1.DBTarget.TotalDifficulty, { blockHash, blockNumber }));
          if (!headHash) {
              return;
          }
          if (this._headHeaderHash?.equals(blockHash) === true) {
              this._headHeaderHash = headHash;
          }
          if (this._headBlockHash?.equals(blockHash) === true) {
              this._headBlockHash = headHash;
          }
          try {
              const childHeader = await this.getCanonicalHeader(blockNumber + BigInt(1));
              await this._delChild(childHeader.hash(), childHeader.number, headHash, ops);
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
          }
      }
      /**
       * Iterates through blocks starting at the specified iterator head and calls
       * the onBlock function on each block. The current location of an iterator
       * head can be retrieved using {@link Blockchain.getIteratorHead}.
       *
       * @param name - Name of the state root head
       * @param onBlock - Function called on each block with params (block, reorg)
       * @param maxBlocks - How many blocks to run. By default, run all unprocessed blocks in the canonical chain.
       * @returns number of blocks actually iterated
       */
      async iterator(name, onBlock, maxBlocks) {
          return this._iterator(name, onBlock, maxBlocks);
      }
      /**
       * @hidden
       */
      async _iterator(name, onBlock, maxBlocks) {
          return await this.runWithLock(async () => {
              const headHash = this._heads[name] ?? this.genesisBlock.hash();
              if ((0, util_1$6.isTruthy)(maxBlocks) && maxBlocks < 0) {
                  throw 'If maxBlocks is provided, it has to be a non-negative number';
              }
              const headBlockNumber = await this.dbManager.hashToNumber(headHash);
              let nextBlockNumber = headBlockNumber + BigInt(1);
              let blocksRanCounter = 0;
              let lastBlock;
              while (maxBlocks !== blocksRanCounter) {
                  try {
                      const nextBlock = await this._getBlock(nextBlockNumber);
                      this._heads[name] = nextBlock.hash();
                      const reorg = lastBlock ? lastBlock.hash().equals(nextBlock.header.parentHash) : false;
                      lastBlock = nextBlock;
                      await onBlock(nextBlock, reorg);
                      nextBlockNumber++;
                      blocksRanCounter++;
                  }
                  catch (error) {
                      if (error.code === 'LEVEL_NOT_FOUND') {
                          break;
                      }
                      else {
                          throw error;
                      }
                  }
              }
              await this._saveHeads();
              return blocksRanCounter;
          });
      }
      /**
       * Set header hash of a certain `tag`.
       * When calling the iterator, the iterator will start running the first child block after the header hash currently stored.
       * @param tag - The tag to save the headHash to
       * @param headHash - The head hash to save
       */
      async setIteratorHead(tag, headHash) {
          await this.runWithLock(async () => {
              this._heads[tag] = headHash;
              await this._saveHeads();
          });
      }
      /* Methods regarding reorg operations */
      /**
       * Find the common ancestor of the new block and the old block.
       * @param newHeader - the new block header
       */
      async findCommonAncestor(newHeader) {
          if (!this._headHeaderHash)
              throw new Error('No head header set');
          const ancestorHeaders = new Set();
          let { header } = await this._getBlock(this._headHeaderHash);
          if (header.number > newHeader.number) {
              header = await this.getCanonicalHeader(newHeader.number);
              ancestorHeaders.add(header);
          }
          else {
              while (header.number !== newHeader.number && newHeader.number > BigInt(0)) {
                  newHeader = await this._getHeader(newHeader.parentHash, newHeader.number - BigInt(1));
                  ancestorHeaders.add(newHeader);
              }
          }
          if (header.number !== newHeader.number) {
              throw new Error('Failed to find ancient header');
          }
          while (!header.hash().equals(newHeader.hash()) && header.number > BigInt(0)) {
              header = await this.getCanonicalHeader(header.number - BigInt(1));
              ancestorHeaders.add(header);
              newHeader = await this._getHeader(newHeader.parentHash, newHeader.number - BigInt(1));
              ancestorHeaders.add(newHeader);
          }
          if (!header.hash().equals(newHeader.hash())) {
              throw new Error('Failed to find ancient header');
          }
          return {
              commonAncestor: header,
              ancestorHeaders: Array.from(ancestorHeaders),
          };
      }
      /**
       * Pushes DB operations to delete canonical number assignments for specified
       * block number and above This only deletes `NumberToHash` references, and not
       * the blocks themselves. Note: this does not write to the DB but only pushes
       * to a DB operations list.
       * @param blockNumber - the block number from which we start deleting
       * canonical chain assignments (including this block)
       * @param headHash - the hash of the current canonical chain head. The _heads
       * reference matching any hash of any of the deleted blocks will be set to
       * this
       * @param ops - the DatabaseOperation list to write DatabaseOperations to
       * @hidden
       */
      async _deleteCanonicalChainReferences(blockNumber, headHash, ops) {
          let hash;
          hash = await this.safeNumberToHash(blockNumber);
          while ((0, util_1$6.isTruthy)(hash)) {
              ops.push(helpers_1.DBOp.del(operation_1.DBTarget.NumberToHash, { blockNumber }));
              // reset stale iterator heads to current canonical head this can, for
              // instance, make the VM run "older" (i.e. lower number blocks than last
              // executed block) blocks to verify the chain up to the current, actual,
              // head.
              for (const name of Object.keys(this._heads)) {
                  if (this._heads[name].equals(hash)) {
                      // explicitly cast as Buffer: it is not possible that `hash` is false
                      // here, but TypeScript does not understand this.
                      this._heads[name] = headHash;
                  }
              }
              // reset stale headBlock to current canonical
              if (this._headBlockHash?.equals(hash) === true) {
                  this._headBlockHash = headHash;
              }
              blockNumber++;
              hash = await this.safeNumberToHash(blockNumber);
          }
      }
      /**
       * Given a `header`, put all operations to change the canonical chain directly
       * into `ops`. This walks the supplied `header` backwards. It is thus assumed
       * that this header should be canonical header. For each header the
       * corresponding hash corresponding to the current canonical chain in the DB
       * is checked If the number => hash reference does not correspond to the
       * reference in the DB, we overwrite this reference with the implied number =>
       * hash reference Also, each `_heads` member is checked; if these point to a
       * stale hash, then the hash which we terminate the loop (i.e. the first hash
       * which matches the number => hash of the implied chain) is put as this stale
       * head hash The same happens to _headBlockHash
       * @param header - The canonical header.
       * @param ops - The database operations list.
       * @hidden
       */
      async _rebuildCanonical(header, ops) {
          let currentNumber = header.number;
          let currentCanonicalHash = header.hash();
          // track the staleHash: this is the hash currently in the DB which matches
          // the block number of the provided header.
          let staleHash = false;
          let staleHeads = [];
          let staleHeadBlock = false;
          const loopCondition = async () => {
              staleHash = await this.safeNumberToHash(currentNumber);
              currentCanonicalHash = header.hash();
              return (0, util_1$6.isFalsy)(staleHash) || !currentCanonicalHash.equals(staleHash);
          };
          while (await loopCondition()) {
              // handle genesis block
              const blockHash = header.hash();
              const blockNumber = header.number;
              if (blockNumber === BigInt(0)) {
                  break;
              }
              (0, helpers_1.DBSaveLookups)(blockHash, blockNumber).map((op) => {
                  ops.push(op);
              });
              // mark each key `_heads` which is currently set to the hash in the DB as
              // stale to overwrite this later.
              for (const name of Object.keys(this._heads)) {
                  if (staleHash && this._heads[name].equals(staleHash)) {
                      staleHeads.push(name);
                  }
              }
              // flag stale headBlock for reset
              if (staleHash && this._headBlockHash?.equals(staleHash) === true) {
                  staleHeadBlock = true;
              }
              try {
                  header = await this._getHeader(header.parentHash, --currentNumber);
              }
              catch (error) {
                  staleHeads = [];
                  if (error.code !== 'LEVEL_NOT_FOUND') {
                      throw error;
                  }
                  break;
              }
          }
          // the stale hash is equal to the blockHash set stale heads to last
          // previously valid canonical block
          for (const name of staleHeads) {
              this._heads[name] = currentCanonicalHash;
          }
          // set stale headBlock to last previously valid canonical block
          if (staleHeadBlock) {
              this._headBlockHash = currentCanonicalHash;
          }
      }
      /* Helper functions */
      /**
       * Builds the `DatabaseOperation[]` list which describes the DB operations to
       * write the heads, head header hash and the head header block to the DB
       * @hidden
       */
      _saveHeadOps() {
          return [
              helpers_1.DBOp.set(operation_1.DBTarget.Heads, this._heads),
              helpers_1.DBOp.set(operation_1.DBTarget.HeadHeader, this._headHeaderHash),
              helpers_1.DBOp.set(operation_1.DBTarget.HeadBlock, this._headBlockHash),
          ];
      }
      /**
       * Gets the `DatabaseOperation[]` list to save `_heads`, `_headHeaderHash` and
       * `_headBlockHash` and writes these to the DB
       * @hidden
       */
      async _saveHeads() {
          return this.dbManager.batch(this._saveHeadOps());
      }
      /**
       * Gets a header by hash and number. Header can exist outside the canonical
       * chain
       *
       * @hidden
       */
      async _getHeader(hash, number) {
          if ((0, util_1$6.isFalsy)(number)) {
              number = await this.dbManager.hashToNumber(hash);
          }
          return this.dbManager.getHeader(hash, number);
      }
      checkAndTransitionHardForkByNumber(number, td) {
          this._common.setHardforkByBlockNumber(number, td);
          // If custom consensus algorithm is used, skip merge hardfork consensus checks
          if (!Object.values(common_1$5.ConsensusAlgorithm).includes(this.consensus.algorithm))
              return;
          switch (this._common.consensusAlgorithm()) {
              case common_1$5.ConsensusAlgorithm.Casper:
                  if (!(this.consensus instanceof consensus_1.CasperConsensus)) {
                      this.consensus = new consensus_1.CasperConsensus();
                  }
                  break;
              case common_1$5.ConsensusAlgorithm.Clique:
                  if (!(this.consensus instanceof consensus_1.CliqueConsensus)) {
                      this.consensus = new consensus_1.CliqueConsensus();
                  }
                  break;
              case common_1$5.ConsensusAlgorithm.Ethash:
                  if (!(this.consensus instanceof consensus_1.EthashConsensus)) {
                      this.consensus = new consensus_1.EthashConsensus();
                  }
                  break;
              default:
                  throw new Error(`consensus algorithm ${this._common.consensusAlgorithm()} not supported`);
          }
      }
      /**
       * Gets a header by number. Header must be in the canonical chain
       */
      async getCanonicalHeader(number) {
          const hash = await this.dbManager.numberToHash(number);
          return this._getHeader(hash, number);
      }
      /**
       * This method either returns a Buffer if there exists one in the DB or if it
       * does not exist (DB throws a `NotFoundError`) then return false If DB throws
       * any other error, this function throws.
       * @param number
       */
      async safeNumberToHash(number) {
          try {
              const hash = await this.dbManager.numberToHash(number);
              return hash;
          }
          catch (error) {
              if (error.code !== 'LEVEL_NOT_FOUND') {
                  throw error;
              }
              return false;
          }
      }
      /**
       * The genesis {@link Block} for the blockchain.
       */
      get genesisBlock() {
          if (!this._genesisBlock)
              throw new Error('genesis block not set (init may not be finished)');
          return this._genesisBlock;
      }
      /**
       * Creates a genesis {@link Block} for the blockchain with params from {@link Common.genesis}
       * @param stateRoot The genesis stateRoot
       */
      createGenesisBlock(stateRoot) {
          const common = this._common.copy();
          common.setHardforkByBlockNumber(0);
          const header = {
              ...common.genesis(),
              number: 0,
              stateRoot,
          };
          if (common.consensusType() === 'poa') {
              if (common.genesis().extraData && common.chainName() !== 'kovan') {
                  // Ensure exta data is populated from genesis data if provided
                  header.extraData = common.genesis().extraData;
              }
              else {
                  // Add required extraData (32 bytes vanity + 65 bytes filled with zeroes (or if chain is Kovan)
                  header.extraData = Buffer$8.concat([Buffer$8.alloc(32), Buffer$8.alloc(65).fill(0)]);
              }
          }
          return block_1$3.Block.fromBlockData({ header }, { common });
      }
      /**
       * Returns the genesis state of the blockchain.
       * All values are provided as hex-prefixed strings.
       */
      genesisState() {
          if (this._customGenesisState) {
              return this._customGenesisState;
          }
          // Use require statements here in favor of import statements
          // to load json files on demand
          // (high memory usage by large mainnet.json genesis state file)
          switch (this._common.chainName()) {
              case 'mainnet':
                  return require$$10;
              case 'ropsten':
                  return require$$11;
              case 'rinkeby':
                  return require$$12;
              case 'kovan':
                  return require$$13;
              case 'goerli':
                  return require$$14;
              case 'sepolia':
                  return require$$15;
          }
          return {};
      }
  }
  blockchain.Blockchain = Blockchain;

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EthashConsensus = exports.CliqueConsensus = exports.CasperConsensus = exports.Blockchain = void 0;
  var blockchain_1 = blockchain;
  Object.defineProperty(exports, "Blockchain", { enumerable: true, get: function () { return blockchain_1.Blockchain; } });
  var consensus_1 = consensus;
  Object.defineProperty(exports, "CasperConsensus", { enumerable: true, get: function () { return consensus_1.CasperConsensus; } });
  Object.defineProperty(exports, "CliqueConsensus", { enumerable: true, get: function () { return consensus_1.CliqueConsensus; } });
  Object.defineProperty(exports, "EthashConsensus", { enumerable: true, get: function () { return consensus_1.EthashConsensus; } });

  }(dist$7));

  var dist$1 = {};

  var baseStateManager = {};

  Object.defineProperty(baseStateManager, "__esModule", { value: true });
  baseStateManager.BaseStateManager = void 0;
  const common_1$4 = dist$8;
  const debug_1$2 = src$1.exports;
  /**
   * Abstract BaseStateManager class for the non-storage-backend
   * related functionality parts of a StateManager like keeping
   * track of accessed storage (`EIP-2929`) or touched accounts
   * (`EIP-158`).
   *
   * This is not a full StateManager implementation in itself but
   * can be used to ease implementing an own StateManager.
   *
   * Note that the implementation is pretty new (October 2021)
   * and we cannot guarantee a stable interface yet.
   */
  class BaseStateManager {
      /**
       * Needs to be called from the subclass constructor
       */
      constructor(opts) {
          /**
           * StateManager is run in DEBUG mode (default: false)
           * Taken from DEBUG environment variable
           *
           * Safeguards on debug() calls are added for
           * performance reasons to avoid string literal evaluation
           * @hidden
           */
          this.DEBUG = false;
          let common = opts.common;
          if (!common) {
              common = new common_1$4.Common({ chain: common_1$4.Chain.Mainnet, hardfork: common_1$4.Hardfork.Petersburg });
          }
          this._common = common;
          // Safeguard if "process" is not available (browser)
          if (typeof browser$1$1?.env.DEBUG !== 'undefined') {
              this.DEBUG = true;
          }
          this._debug = (0, debug_1$2.debug)('statemanager:statemanager');
      }
      /**
       * Gets the account associated with `address`. Returns an empty account if the account does not exist.
       * @param address - Address of the `account` to get
       */
      async getAccount(address) {
          const account = await this._cache.getOrLoad(address);
          return account;
      }
      /**
       * Saves an account into state under the provided `address`.
       * @param address - Address under which to store `account`
       * @param account - The account to store
       */
      async putAccount(address, account) {
          if (this.DEBUG) {
              this._debug(`Save account address=${address} nonce=${account.nonce} balance=${account.balance} contract=${account.isContract() ? 'yes' : 'no'} empty=${account.isEmpty() ? 'yes' : 'no'}`);
          }
          this._cache.put(address, account);
      }
      /**
       * Gets the account associated with `address`, modifies the given account
       * fields, then saves the account into state. Account fields can include
       * `nonce`, `balance`, `stateRoot`, and `codeHash`.
       * @param address - Address of the account to modify
       * @param accountFields - Object containing account fields and values to modify
       */
      async modifyAccountFields(address, accountFields) {
          const account = await this.getAccount(address);
          account.nonce = accountFields.nonce ?? account.nonce;
          account.balance = accountFields.balance ?? account.balance;
          account.stateRoot = accountFields.stateRoot ?? account.stateRoot;
          account.codeHash = accountFields.codeHash ?? account.codeHash;
          await this.putAccount(address, account);
      }
      /**
       * Deletes an account from state under the provided `address`. The account will also be removed from the state trie.
       * @param address - Address of the account which should be deleted
       */
      async deleteAccount(address) {
          if (this.DEBUG) {
              this._debug(`Delete account ${address}`);
          }
          this._cache.del(address);
      }
      async accountIsEmpty(address) {
          const account = await this.getAccount(address);
          return account.isEmpty();
      }
      /**
       * Checkpoints the current state of the StateManager instance.
       * State changes that follow can then be committed by calling
       * `commit` or `reverted` by calling rollback.
       *
       * Partial implementation, called from the subclass.
       */
      async checkpoint() {
          this._cache.checkpoint();
      }
      /**
       * Commits the current change-set to the instance since the
       * last call to checkpoint.
       *
       * Partial implementation, called from the subclass.
       */
      async commit() {
          // setup cache checkpointing
          this._cache.commit();
      }
      /**
       * Reverts the current change-set to the instance since the
       * last call to checkpoint.
       *
       * Partial implementation , called from the subclass.
       */
      async revert() {
          // setup cache checkpointing
          this._cache.revert();
      }
      async flush() {
          await this._cache.flush();
      }
  }
  baseStateManager.BaseStateManager = BaseStateManager;

  var stateManager = {};

  var cache = {};

  Object.defineProperty(cache, "__esModule", { value: true });
  cache.Cache = void 0;
  const util_1$5 = dist$a;
  const Tree = rbtree;
  /**
   * @ignore
   */
  class Cache {
      constructor(opts) {
          this._cache = Tree();
          this._getCb = opts.getCb;
          this._putCb = opts.putCb;
          this._deleteCb = opts.deleteCb;
          this._checkpoints = [];
      }
      /**
       * Puts account to cache under its address.
       * @param key - Address of account
       * @param val - Account
       */
      put(key, val, fromTrie = false) {
          const modified = !fromTrie;
          this._update(key, val, modified, false);
      }
      /**
       * Returns the queried account or an empty account.
       * @param key - Address of account
       */
      get(key) {
          const account = this.lookup(key);
          return account ?? new util_1$5.Account();
      }
      /**
       * Returns the queried account or undefined.
       * @param key - Address of account
       */
      lookup(key) {
          const keyStr = key.buf.toString('hex');
          const it = this._cache.find(keyStr);
          if ((0, util_1$5.isTruthy)(it.node)) {
              const rlp = it.value.val;
              const account = util_1$5.Account.fromRlpSerializedAccount(rlp);
              account.virtual = it.value.virtual;
              return account;
          }
      }
      /**
       * Returns true if the key was deleted and thus existed in the cache earlier
       * @param key - trie key to lookup
       */
      keyIsDeleted(key) {
          const keyStr = key.buf.toString('hex');
          const it = this._cache.find(keyStr);
          if ((0, util_1$5.isTruthy)(it.node)) {
              return it.value.deleted;
          }
          return false;
      }
      /**
       * Looks up address in cache, if not found, looks it up
       * in the underlying trie.
       * @param key - Address of account
       */
      async getOrLoad(address) {
          let account = this.lookup(address);
          if (!account) {
              account = await this._getCb(address);
              if (account) {
                  this._update(address, account, false, false, false);
              }
              else {
                  account = new util_1$5.Account();
                  account.virtual = true;
                  this._update(address, account, false, false, true);
              }
          }
          return account;
      }
      /**
       * Flushes cache by updating accounts that have been modified
       * and removing accounts that have been deleted.
       */
      async flush() {
          const it = this._cache.begin;
          let next = true;
          while (next) {
              if ((0, util_1$5.isTruthy)(it.value) && (0, util_1$5.isTruthy)(it.value.modified) && (0, util_1$5.isFalsy)(it.value.deleted)) {
                  it.value.modified = false;
                  const accountRlp = it.value.val;
                  const keyBuf = Buffer$8.from(it.key, 'hex');
                  await this._putCb(keyBuf, accountRlp);
                  next = it.hasNext;
                  it.next();
              }
              else if ((0, util_1$5.isTruthy)(it.value) && (0, util_1$5.isTruthy)(it.value.modified) && (0, util_1$5.isTruthy)(it.value.deleted)) {
                  it.value.modified = false;
                  it.value.deleted = true;
                  it.value.virtual = true;
                  it.value.val = new util_1$5.Account().serialize();
                  const keyBuf = Buffer$8.from(it.key, 'hex');
                  await this._deleteCb(keyBuf);
                  next = it.hasNext;
                  it.next();
              }
              else {
                  next = it.hasNext;
                  it.next();
              }
          }
      }
      /**
       * Marks current state of cache as checkpoint, which can
       * later on be reverted or commited.
       */
      checkpoint() {
          this._checkpoints.push(this._cache);
      }
      /**
       * Revert changes to cache last checkpoint (no effect on trie).
       */
      revert() {
          this._cache = this._checkpoints.pop();
      }
      /**
       * Commits to current state of cache (no effect on trie).
       */
      commit() {
          this._checkpoints.pop();
      }
      /**
       * Clears cache.
       */
      clear() {
          this._cache = Tree();
      }
      /**
       * Marks address as deleted in cache.
       * @param key - Address
       */
      del(key) {
          this._update(key, new util_1$5.Account(), true, true, true);
      }
      /**
       * Generic cache update helper function
       *
       * @param key
       * @param value
       * @param modified - Has the value been modfied or is it coming unchanged from the trie (also used for deleted accounts)
       * @param deleted - Delete operation on an account
       * @param virtual - Account doesn't exist in the underlying trie
       */
      _update(key, value, modified, deleted, virtual = false) {
          const keyHex = key.buf.toString('hex');
          const it = this._cache.find(keyHex);
          const val = value.serialize();
          if ((0, util_1$5.isTruthy)(it.node)) {
              this._cache = it.update({ val, modified, deleted, virtual });
          }
          else {
              this._cache = this._cache.insert(keyHex, { val, modified, deleted, virtual });
          }
      }
  }
  cache.Cache = Cache;

  Object.defineProperty(stateManager, "__esModule", { value: true });
  stateManager.DefaultStateManager = void 0;
  const rlp_1$2 = dist$9;
  const trie_1$2 = dist$5;
  const util_1$4 = dist$a;
  const keccak_1 = keccak;
  const baseStateManager_1 = baseStateManager;
  const cache_1 = cache;
  /**
   * Prefix to distinguish between a contract deployed with code `0x80`
   * and `RLP([])` (also having the value `0x80`).
   *
   * Otherwise the creation of the code hash for the `0x80` contract
   * will be the same as the hash of the empty trie which leads to
   * misbehaviour in the underyling trie library.
   */
  const CODEHASH_PREFIX = Buffer$8.from('c');
  /**
   * Default StateManager implementation for the VM.
   *
   * The state manager abstracts from the underlying data store
   * by providing higher level access to accounts, contract code
   * and storage slots.
   *
   * The default state manager implementation uses a
   * `@ethereumjs/trie` trie as a data backend.
   */
  class DefaultStateManager extends baseStateManager_1.BaseStateManager {
      /**
       * Instantiate the StateManager interface.
       */
      constructor(opts = {}) {
          super(opts);
          this._trie = opts.trie ?? new trie_1$2.SecureTrie();
          this._storageTries = {};
          /*
           * For a custom StateManager implementation adopt these
           * callbacks passed to the `Cache` instantiated to perform
           * the `get`, `put` and `delete` operations with the
           * desired backend.
           */
          const getCb = async (address) => {
              const rlp = await this._trie.get(address.buf);
              return rlp ? util_1$4.Account.fromRlpSerializedAccount(rlp) : undefined;
          };
          const putCb = async (keyBuf, accountRlp) => {
              const trie = this._trie;
              await trie.put(keyBuf, accountRlp);
          };
          const deleteCb = async (keyBuf) => {
              const trie = this._trie;
              await trie.del(keyBuf);
          };
          this._cache = new cache_1.Cache({ getCb, putCb, deleteCb });
      }
      /**
       * Copies the current instance of the `StateManager`
       * at the last fully committed point, i.e. as if all current
       * checkpoints were reverted.
       */
      copy() {
          return new DefaultStateManager({
              trie: this._trie.copy(false),
              common: this._common,
          });
      }
      /**
       * Adds `value` to the state trie as code, and sets `codeHash` on the account
       * corresponding to `address` to reference this.
       * @param address - Address of the `account` to add the `code` for
       * @param value - The value of the `code`
       */
      async putContractCode(address, value) {
          const codeHash = Buffer$8.from((0, keccak_1.keccak256)(value));
          if (codeHash.equals(util_1$4.KECCAK256_NULL)) {
              return;
          }
          const key = Buffer$8.concat([CODEHASH_PREFIX, codeHash]);
          await this._trie.db.put(key, value);
          if (this.DEBUG) {
              this._debug(`Update codeHash (-> ${(0, util_1$4.short)(codeHash)}) for account ${address}`);
          }
          await this.modifyAccountFields(address, { codeHash });
      }
      /**
       * Gets the code corresponding to the provided `address`.
       * @param address - Address to get the `code` for
       * @returns {Promise<Buffer>} -  Resolves with the code corresponding to the provided address.
       * Returns an empty `Buffer` if the account has no associated code.
       */
      async getContractCode(address) {
          const account = await this.getAccount(address);
          if (!account.isContract()) {
              return Buffer$8.alloc(0);
          }
          const key = Buffer$8.concat([CODEHASH_PREFIX, account.codeHash]);
          const code = await this._trie.db.get(key);
          return code ?? Buffer$8.alloc(0);
      }
      /**
       * Creates a storage trie from the primary storage trie
       * for an account and saves this in the storage cache.
       * @private
       */
      async _lookupStorageTrie(address) {
          // from state trie
          const account = await this.getAccount(address);
          const storageTrie = this._trie.copy(false);
          storageTrie.root = account.stateRoot;
          storageTrie.db.checkpoints = [];
          return storageTrie;
      }
      /**
       * Gets the storage trie for an account from the storage
       * cache or does a lookup.
       * @private
       */
      async _getStorageTrie(address) {
          // from storage cache
          const addressHex = address.buf.toString('hex');
          let storageTrie = this._storageTries[addressHex];
          if ((0, util_1$4.isFalsy)(storageTrie)) {
              // lookup from state
              storageTrie = await this._lookupStorageTrie(address);
          }
          return storageTrie;
      }
      /**
       * Gets the storage value associated with the provided `address` and `key`. This method returns
       * the shortest representation of the stored value.
       * @param address -  Address of the account to get the storage for
       * @param key - Key in the account's storage to get the value for. Must be 32 bytes long.
       * @returns {Promise<Buffer>} - The storage value for the account
       * corresponding to the provided address at the provided key.
       * If this does not exist an empty `Buffer` is returned.
       */
      async getContractStorage(address, key) {
          if (key.length !== 32) {
              throw new Error('Storage key must be 32 bytes long');
          }
          const trie = await this._getStorageTrie(address);
          const value = await trie.get(key);
          const decoded = Buffer$8.from(rlp_1$2.RLP.decode(Uint8Array.from(value ?? [])));
          return decoded;
      }
      /**
       * Modifies the storage trie of an account.
       * @private
       * @param address -  Address of the account whose storage is to be modified
       * @param modifyTrie - Function to modify the storage trie of the account
       */
      async _modifyContractStorage(address, modifyTrie) {
          // eslint-disable-next-line no-async-promise-executor
          return new Promise(async (resolve) => {
              const storageTrie = await this._getStorageTrie(address);
              modifyTrie(storageTrie, async () => {
                  // update storage cache
                  const addressHex = address.buf.toString('hex');
                  this._storageTries[addressHex] = storageTrie;
                  // update contract stateRoot
                  const contract = this._cache.get(address);
                  contract.stateRoot = storageTrie.root;
                  await this.putAccount(address, contract);
                  resolve();
              });
          });
      }
      /**
       * Adds value to the state trie for the `account`
       * corresponding to `address` at the provided `key`.
       * @param address -  Address to set a storage value for
       * @param key - Key to set the value at. Must be 32 bytes long.
       * @param value - Value to set at `key` for account corresponding to `address`. Cannot be more than 32 bytes. Leading zeros are stripped. If it is a empty or filled with zeros, deletes the value.
       */
      async putContractStorage(address, key, value) {
          if (key.length !== 32) {
              throw new Error('Storage key must be 32 bytes long');
          }
          if (value.length > 32) {
              throw new Error('Storage value cannot be longer than 32 bytes');
          }
          value = (0, util_1$4.unpadBuffer)(value);
          await this._modifyContractStorage(address, async (storageTrie, done) => {
              if ((0, util_1$4.isTruthy)(value) && value.length) {
                  // format input
                  const encodedValue = Buffer$8.from(rlp_1$2.RLP.encode(Uint8Array.from(value)));
                  if (this.DEBUG) {
                      this._debug(`Update contract storage for account ${address} to ${(0, util_1$4.short)(value)}`);
                  }
                  await storageTrie.put(key, encodedValue);
              }
              else {
                  // deleting a value
                  if (this.DEBUG) {
                      this._debug(`Delete contract storage for account`);
                  }
                  await storageTrie.del(key);
              }
              done();
          });
      }
      /**
       * Clears all storage entries for the account corresponding to `address`.
       * @param address -  Address to clear the storage of
       */
      async clearContractStorage(address) {
          await this._modifyContractStorage(address, (storageTrie, done) => {
              storageTrie.root = storageTrie.EMPTY_TRIE_ROOT;
              done();
          });
      }
      /**
       * Checkpoints the current state of the StateManager instance.
       * State changes that follow can then be committed by calling
       * `commit` or `reverted` by calling rollback.
       */
      async checkpoint() {
          this._trie.checkpoint();
          await super.checkpoint();
      }
      /**
       * Commits the current change-set to the instance since the
       * last call to checkpoint.
       */
      async commit() {
          // setup trie checkpointing
          await this._trie.commit();
          await super.commit();
      }
      /**
       * Reverts the current change-set to the instance since the
       * last call to checkpoint.
       */
      async revert() {
          // setup trie checkpointing
          await this._trie.revert();
          this._storageTries = {};
          await super.revert();
      }
      /**
       * Get an EIP-1186 proof
       * @param address address to get proof of
       * @param storageSlots storage slots to get proof of
       */
      async getProof(address, storageSlots = []) {
          const account = await this.getAccount(address);
          const accountProof = (await this._trie.createProof(address.buf)).map((p) => (0, util_1$4.bufferToHex)(p));
          const storageProof = [];
          const storageTrie = await this._getStorageTrie(address);
          for (const storageKey of storageSlots) {
              const proof = (await storageTrie.createProof(storageKey)).map((p) => (0, util_1$4.bufferToHex)(p));
              let value = (0, util_1$4.bufferToHex)(await this.getContractStorage(address, storageKey));
              if (value === '0x') {
                  value = '0x0';
              }
              const proofItem = {
                  key: (0, util_1$4.bufferToHex)(storageKey),
                  value,
                  proof,
              };
              storageProof.push(proofItem);
          }
          const returnValue = {
              address: address.toString(),
              balance: (0, util_1$4.bigIntToHex)(account.balance),
              codeHash: (0, util_1$4.bufferToHex)(account.codeHash),
              nonce: (0, util_1$4.bigIntToHex)(account.nonce),
              storageHash: (0, util_1$4.bufferToHex)(account.stateRoot),
              accountProof,
              storageProof,
          };
          return returnValue;
      }
      /**
       * Verify an EIP-1186 proof. Throws if proof is invalid, otherwise returns true.
       * @param proof the proof to prove
       */
      async verifyProof(proof) {
          const rootHash = Buffer$8.from((0, keccak_1.keccak256)((0, util_1$4.toBuffer)(proof.accountProof[0])));
          const key = (0, util_1$4.toBuffer)(proof.address);
          const accountProof = proof.accountProof.map((rlpString) => (0, util_1$4.toBuffer)(rlpString));
          // This returns the account if the proof is valid.
          // Verify that it matches the reported account.
          const value = await new trie_1$2.SecureTrie().verifyProof(rootHash, key, accountProof);
          if (value === null) {
              // Verify that the account is empty in the proof.
              const emptyBuffer = Buffer$8.from('');
              const notEmptyErrorMsg = 'Invalid proof provided: account is not empty';
              const nonce = (0, util_1$4.unpadBuffer)((0, util_1$4.toBuffer)(proof.nonce));
              if (!nonce.equals(emptyBuffer)) {
                  throw new Error(`${notEmptyErrorMsg} (nonce is not zero)`);
              }
              const balance = (0, util_1$4.unpadBuffer)((0, util_1$4.toBuffer)(proof.balance));
              if (!balance.equals(emptyBuffer)) {
                  throw new Error(`${notEmptyErrorMsg} (balance is not zero)`);
              }
              const storageHash = (0, util_1$4.toBuffer)(proof.storageHash);
              if (!storageHash.equals(util_1$4.KECCAK256_RLP)) {
                  throw new Error(`${notEmptyErrorMsg} (storageHash does not equal KECCAK256_RLP)`);
              }
              const codeHash = (0, util_1$4.toBuffer)(proof.codeHash);
              if (!codeHash.equals(util_1$4.KECCAK256_NULL)) {
                  throw new Error(`${notEmptyErrorMsg} (codeHash does not equal KECCAK256_NULL)`);
              }
          }
          else {
              const account = util_1$4.Account.fromRlpSerializedAccount(value);
              const { nonce, balance, stateRoot, codeHash } = account;
              const invalidErrorMsg = 'Invalid proof provided:';
              if (nonce !== BigInt(proof.nonce)) {
                  throw new Error(`${invalidErrorMsg} nonce does not match`);
              }
              if (balance !== BigInt(proof.balance)) {
                  throw new Error(`${invalidErrorMsg} balance does not match`);
              }
              if (!stateRoot.equals((0, util_1$4.toBuffer)(proof.storageHash))) {
                  throw new Error(`${invalidErrorMsg} storageHash does not match`);
              }
              if (!codeHash.equals((0, util_1$4.toBuffer)(proof.codeHash))) {
                  throw new Error(`${invalidErrorMsg} codeHash does not match`);
              }
          }
          const storageRoot = (0, util_1$4.toBuffer)(proof.storageHash);
          for (const stProof of proof.storageProof) {
              const storageProof = stProof.proof.map((value) => (0, util_1$4.toBuffer)(value));
              const storageValue = (0, util_1$4.setLengthLeft)((0, util_1$4.toBuffer)(stProof.value), 32);
              const storageKey = (0, util_1$4.toBuffer)(stProof.key);
              const proofValue = await new trie_1$2.SecureTrie().verifyProof(storageRoot, storageKey, storageProof);
              const reportedValue = (0, util_1$4.setLengthLeft)(Buffer$8.from(rlp_1$2.RLP.decode(Uint8Array.from(proofValue ?? []))), 32);
              if (!reportedValue.equals(storageValue)) {
                  throw new Error('Reported trie value does not match storage');
              }
          }
          return true;
      }
      /**
       * Gets the state-root of the Merkle-Patricia trie representation
       * of the state of this StateManager. Will error if there are uncommitted
       * checkpoints on the instance.
       * @returns {Promise<Buffer>} - Returns the state-root of the `StateManager`
       */
      async getStateRoot() {
          await this._cache.flush();
          const stateRoot = this._trie.root;
          return stateRoot;
      }
      /**
       * Sets the state of the instance to that represented
       * by the provided `stateRoot`. Will error if there are uncommitted
       * checkpoints on the instance or if the state root does not exist in
       * the state trie.
       * @param stateRoot - The state-root to reset the instance to
       */
      async setStateRoot(stateRoot) {
          await this._cache.flush();
          if (!stateRoot.equals(this._trie.EMPTY_TRIE_ROOT)) {
              const hasRoot = await this._trie.checkRoot(stateRoot);
              if (!hasRoot) {
                  throw new Error('State trie does not contain state root');
              }
          }
          this._trie.root = stateRoot;
          this._cache.clear();
          this._storageTries = {};
      }
      /**
       * Dumps the RLP-encoded storage values for an `account` specified by `address`.
       * @param address - The address of the `account` to return storage for
       * @returns {Promise<StorageDump>} - The state of the account as an `Object` map.
       * Keys are are the storage keys, values are the storage values as strings.
       * Both are represented as hex strings without the `0x` prefix.
       */
      async dumpStorage(address) {
          return new Promise((resolve, reject) => {
              this._getStorageTrie(address)
                  .then((trie) => {
                  const storage = {};
                  const stream = trie.createReadStream();
                  stream.on('data', (val) => {
                      storage[val.key.toString('hex')] = val.value.toString('hex');
                  });
                  stream.on('end', () => {
                      resolve(storage);
                  });
              })
                  .catch((e) => {
                  reject(e);
              });
          });
      }
      /**
       * Checks whether there is a state corresponding to a stateRoot
       */
      async hasStateRoot(root) {
          return await this._trie.checkRoot(root);
      }
      /**
       * Checks if the `account` corresponding to `address`
       * exists
       * @param address - Address of the `account` to check
       */
      async accountExists(address) {
          const account = this._cache.lookup(address);
          if (account && (0, util_1$4.isFalsy)(account.virtual) && !this._cache.keyIsDeleted(address)) {
              return true;
          }
          if (await this._trie.get(address.buf)) {
              return true;
          }
          return false;
      }
  }
  stateManager.DefaultStateManager = DefaultStateManager;

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultStateManager = exports.BaseStateManager = void 0;
  var baseStateManager_1 = baseStateManager;
  Object.defineProperty(exports, "BaseStateManager", { enumerable: true, get: function () { return baseStateManager_1.BaseStateManager; } });
  var stateManager_1 = stateManager;
  Object.defineProperty(exports, "DefaultStateManager", { enumerable: true, get: function () { return stateManager_1.DefaultStateManager; } });

  }(dist$1));

  var dist = {};

  (function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Message = exports.getActivePrecompiles = exports.EvmErrorMessage = exports.EvmError = exports.EVM = void 0;
  const evm_1 = evm$1;
  Object.defineProperty(exports, "EVM", { enumerable: true, get: function () { return evm_1.EVM; } });
  const exceptions_1 = exceptions;
  Object.defineProperty(exports, "EvmErrorMessage", { enumerable: true, get: function () { return exceptions_1.ERROR; } });
  Object.defineProperty(exports, "EvmError", { enumerable: true, get: function () { return exceptions_1.EvmError; } });
  const message_1 = message;
  Object.defineProperty(exports, "Message", { enumerable: true, get: function () { return message_1.Message; } });
  const precompiles_1 = precompiles$1;
  Object.defineProperty(exports, "getActivePrecompiles", { enumerable: true, get: function () { return precompiles_1.getActivePrecompiles; } });

  }(dist));

  var buildBlock$1 = {};

  var runBlock$1 = {};

  var DAOAccounts = [
  	"d4fe7bc31cedb7bfb8a345f31e668033056b2728",
  	"b3fb0e5aba0e20e5c49d252dfd30e102b171a425",
  	"2c19c7f9ae8b751e37aeb2d93a699722395ae18f",
  	"ecd135fa4f61a655311e86238c92adcd779555d2",
  	"1975bd06d486162d5dc297798dfc41edd5d160a7",
  	"a3acf3a1e16b1d7c315e23510fdd7847b48234f6",
  	"319f70bab6845585f412ec7724b744fec6095c85",
  	"06706dd3f2c9abf0a21ddcc6941d9b86f0596936",
  	"5c8536898fbb74fc7445814902fd08422eac56d0",
  	"6966ab0d485353095148a2155858910e0965b6f9",
  	"779543a0491a837ca36ce8c635d6154e3c4911a6",
  	"2a5ed960395e2a49b1c758cef4aa15213cfd874c",
  	"5c6e67ccd5849c0d29219c4f95f1a7a93b3f5dc5",
  	"9c50426be05db97f5d64fc54bf89eff947f0a321",
  	"200450f06520bdd6c527622a273333384d870efb",
  	"be8539bfe837b67d1282b2b1d61c3f723966f049",
  	"6b0c4d41ba9ab8d8cfb5d379c69a612f2ced8ecb",
  	"f1385fb24aad0cd7432824085e42aff90886fef5",
  	"d1ac8b1ef1b69ff51d1d401a476e7e612414f091",
  	"8163e7fb499e90f8544ea62bbf80d21cd26d9efd",
  	"51e0ddd9998364a2eb38588679f0d2c42653e4a6",
  	"627a0a960c079c21c34f7612d5d230e01b4ad4c7",
  	"f0b1aa0eb660754448a7937c022e30aa692fe0c5",
  	"24c4d950dfd4dd1902bbed3508144a54542bba94",
  	"9f27daea7aca0aa0446220b98d028715e3bc803d",
  	"a5dc5acd6a7968a4554d89d65e59b7fd3bff0f90",
  	"d9aef3a1e38a39c16b31d1ace71bca8ef58d315b",
  	"63ed5a272de2f6d968408b4acb9024f4cc208ebf",
  	"6f6704e5a10332af6672e50b3d9754dc460dfa4d",
  	"77ca7b50b6cd7e2f3fa008e24ab793fd56cb15f6",
  	"492ea3bb0f3315521c31f273e565b868fc090f17",
  	"0ff30d6de14a8224aa97b78aea5388d1c51c1f00",
  	"9ea779f907f0b315b364b0cfc39a0fde5b02a416",
  	"ceaeb481747ca6c540a000c1f3641f8cef161fa7",
  	"cc34673c6c40e791051898567a1222daf90be287",
  	"579a80d909f346fbfb1189493f521d7f48d52238",
  	"e308bd1ac5fda103967359b2712dd89deffb7973",
  	"4cb31628079fb14e4bc3cd5e30c2f7489b00960c",
  	"ac1ecab32727358dba8962a0f3b261731aad9723",
  	"4fd6ace747f06ece9c49699c7cabc62d02211f75",
  	"440c59b325d2997a134c2c7c60a8c61611212bad",
  	"4486a3d68fac6967006d7a517b889fd3f98c102b",
  	"9c15b54878ba618f494b38f0ae7443db6af648ba",
  	"27b137a85656544b1ccb5a0f2e561a5703c6a68f",
  	"21c7fdb9ed8d291d79ffd82eb2c4356ec0d81241",
  	"23b75c2f6791eef49c69684db4c6c1f93bf49a50",
  	"1ca6abd14d30affe533b24d7a21bff4c2d5e1f3b",
  	"b9637156d330c0d605a791f1c31ba5890582fe1c",
  	"6131c42fa982e56929107413a9d526fd99405560",
  	"1591fc0f688c81fbeb17f5426a162a7024d430c2",
  	"542a9515200d14b68e934e9830d91645a980dd7a",
  	"c4bbd073882dd2add2424cf47d35213405b01324",
  	"782495b7b3355efb2833d56ecb34dc22ad7dfcc4",
  	"58b95c9a9d5d26825e70a82b6adb139d3fd829eb",
  	"3ba4d81db016dc2890c81f3acec2454bff5aada5",
  	"b52042c8ca3f8aa246fa79c3feaa3d959347c0ab",
  	"e4ae1efdfc53b73893af49113d8694a057b9c0d1",
  	"3c02a7bc0391e86d91b7d144e61c2c01a25a79c5",
  	"0737a6b837f97f46ebade41b9bc3e1c509c85c53",
  	"97f43a37f595ab5dd318fb46e7a155eae057317a",
  	"52c5317c848ba20c7504cb2c8052abd1fde29d03",
  	"4863226780fe7c0356454236d3b1c8792785748d",
  	"5d2b2e6fcbe3b11d26b525e085ff818dae332479",
  	"5f9f3392e9f62f63b8eac0beb55541fc8627f42c",
  	"057b56736d32b86616a10f619859c6cd6f59092a",
  	"9aa008f65de0b923a2a4f02012ad034a5e2e2192",
  	"304a554a310c7e546dfe434669c62820b7d83490",
  	"914d1b8b43e92723e64fd0a06f5bdb8dd9b10c79",
  	"4deb0033bb26bc534b197e61d19e0733e5679784",
  	"07f5c1e1bc2c93e0402f23341973a0e043f7bf8a",
  	"35a051a0010aba705c9008d7a7eff6fb88f6ea7b",
  	"4fa802324e929786dbda3b8820dc7834e9134a2a",
  	"9da397b9e80755301a3b32173283a91c0ef6c87e",
  	"8d9edb3054ce5c5774a420ac37ebae0ac02343c6",
  	"0101f3be8ebb4bbd39a2e3b9a3639d4259832fd9",
  	"5dc28b15dffed94048d73806ce4b7a4612a1d48f",
  	"bcf899e6c7d9d5a215ab1e3444c86806fa854c76",
  	"12e626b0eebfe86a56d633b9864e389b45dcb260",
  	"a2f1ccba9395d7fcb155bba8bc92db9bafaeade7",
  	"ec8e57756626fdc07c63ad2eafbd28d08e7b0ca5",
  	"d164b088bd9108b60d0ca3751da4bceb207b0782",
  	"6231b6d0d5e77fe001c2a460bd9584fee60d409b",
  	"1cba23d343a983e9b5cfd19496b9a9701ada385f",
  	"a82f360a8d3455c5c41366975bde739c37bfeb8a",
  	"9fcd2deaff372a39cc679d5c5e4de7bafb0b1339",
  	"005f5cee7a43331d5a3d3eec71305925a62f34b6",
  	"0e0da70933f4c7849fc0d203f5d1d43b9ae4532d",
  	"d131637d5275fd1a68a3200f4ad25c71a2a9522e",
  	"bc07118b9ac290e4622f5e77a0853539789effbe",
  	"47e7aa56d6bdf3f36be34619660de61275420af8",
  	"acd87e28b0c9d1254e868b81cba4cc20d9a32225",
  	"adf80daec7ba8dcf15392f1ac611fff65d94f880",
  	"5524c55fb03cf21f549444ccbecb664d0acad706",
  	"40b803a9abce16f50f36a77ba41180eb90023925",
  	"fe24cdd8648121a43a7c86d289be4dd2951ed49f",
  	"17802f43a0137c506ba92291391a8a8f207f487d",
  	"253488078a4edf4d6f42f113d1e62836a942cf1a",
  	"86af3e9626fce1957c82e88cbf04ddf3a2ed7915",
  	"b136707642a4ea12fb4bae820f03d2562ebff487",
  	"dbe9b615a3ae8709af8b93336ce9b477e4ac0940",
  	"f14c14075d6c4ed84b86798af0956deef67365b5",
  	"ca544e5c4687d109611d0f8f928b53a25af72448",
  	"aeeb8ff27288bdabc0fa5ebb731b6f409507516c",
  	"cbb9d3703e651b0d496cdefb8b92c25aeb2171f7",
  	"6d87578288b6cb5549d5076a207456a1f6a63dc0",
  	"b2c6f0dfbb716ac562e2d85d6cb2f8d5ee87603e",
  	"accc230e8a6e5be9160b8cdf2864dd2a001c28b6",
  	"2b3455ec7fedf16e646268bf88846bd7a2319bb2",
  	"4613f3bca5c44ea06337a9e439fbc6d42e501d0a",
  	"d343b217de44030afaa275f54d31a9317c7f441e",
  	"84ef4b2357079cd7a7c69fd7a37cd0609a679106",
  	"da2fef9e4a3230988ff17df2165440f37e8b1708",
  	"f4c64518ea10f995918a454158c6b61407ea345c",
  	"7602b46df5390e432ef1c307d4f2c9ff6d65cc97",
  	"bb9bc244d798123fde783fcc1c72d3bb8c189413",
  	"807640a13483f8ac783c557fcdf27be11ea4ac7a"
  ];
  var DAORefundContract$1 = "bf4ed7b27f1d666546e30d74d50d173d20bca754";
  var require$$7 = {
  	DAOAccounts: DAOAccounts,
  	DAORefundContract: DAORefundContract$1
  };

  Object.defineProperty(runBlock$1, "__esModule", { value: true });
  runBlock$1.encodeReceipt = runBlock$1.rewardAccount = runBlock$1.calculateMinerReward = runBlock$1.runBlock = void 0;
  const block_1$2 = dist$6;
  const common_1$3 = dist$8;
  const rlp_1$1 = dist$9;
  const trie_1$1 = dist$5;
  const util_1$3 = dist$a;
  const debug_1$1 = src$1.exports;
  const bloom_1$2 = bloom;
  const DAOConfig = require$$7;
  const debug$1 = (0, debug_1$1.debug)('vm:block');
  /* DAO account list */
  const DAOAccountList = DAOConfig.DAOAccounts;
  const DAORefundContract = DAOConfig.DAORefundContract;
  /**
   * @ignore
   */
  async function runBlock(opts) {
      const state = this.eei;
      const { root } = opts;
      let { block } = opts;
      const generateFields = opts.generate === true;
      /**
       * The `beforeBlock` event.
       *
       * @event Event: beforeBlock
       * @type {Object}
       * @property {Block} block emits the block that is about to be processed
       */
      await this._emit('beforeBlock', block);
      if (this._hardforkByBlockNumber ||
          (0, util_1$3.isTruthy)(this._hardforkByTTD) ||
          (0, util_1$3.isTruthy)(opts.hardforkByTTD)) {
          this._common.setHardforkByBlockNumber(block.header.number, opts.hardforkByTTD ?? this._hardforkByTTD);
      }
      if (this.DEBUG) {
          debug$1('-'.repeat(100));
          debug$1(`Running block hash=${block.hash().toString('hex')} number=${block.header.number} hardfork=${this._common.hardfork()}`);
      }
      // Set state root if provided
      if (root) {
          if (this.DEBUG) {
              debug$1(`Set provided state root ${root.toString('hex')}`);
          }
          await state.setStateRoot(root);
      }
      // check for DAO support and if we should apply the DAO fork
      if (this._common.hardforkIsActiveOnBlock(common_1$3.Hardfork.Dao, block.header.number) === true &&
          block.header.number === this._common.hardforkBlock(common_1$3.Hardfork.Dao)) {
          if (this.DEBUG) {
              debug$1(`Apply DAO hardfork`);
          }
          await _applyDAOHardfork(state);
      }
      // Checkpoint state
      await state.checkpoint();
      if (this.DEBUG) {
          debug$1(`block checkpoint`);
      }
      let result;
      try {
          result = await applyBlock.bind(this)(block, opts);
          if (this.DEBUG) {
              debug$1(`Received block results gasUsed=${result.gasUsed} bloom=${(0, util_1$3.short)(result.bloom.bitvector)} (${result.bloom.bitvector.length} bytes) receiptRoot=${result.receiptRoot.toString('hex')} receipts=${result.receipts.length} txResults=${result.results.length}`);
          }
      }
      catch (err) {
          await state.revert();
          if (this.DEBUG) {
              debug$1(`block checkpoint reverted`);
          }
          throw err;
      }
      // Persist state
      await state.commit();
      if (this.DEBUG) {
          debug$1(`block checkpoint committed`);
      }
      const stateRoot = await state.getStateRoot();
      // Given the generate option, either set resulting header
      // values to the current block, or validate the resulting
      // header values against the current block.
      if (generateFields) {
          const bloom = result.bloom.bitvector;
          const gasUsed = result.gasUsed;
          const receiptTrie = result.receiptRoot;
          const transactionsTrie = await _genTxTrie(block);
          const generatedFields = { stateRoot, bloom, gasUsed, receiptTrie, transactionsTrie };
          const blockData = {
              ...block,
              header: { ...block.header, ...generatedFields },
          };
          block = block_1$2.Block.fromBlockData(blockData, { common: this._common });
      }
      else {
          if (result.receiptRoot.equals(block.header.receiptTrie) === false) {
              if (this.DEBUG) {
                  debug$1(`Invalid receiptTrie received=${result.receiptRoot.toString('hex')} expected=${block.header.receiptTrie.toString('hex')}`);
              }
              const msg = _errorMsg$1('invalid receiptTrie', this, block);
              throw new Error(msg);
          }
          if (!result.bloom.bitvector.equals(block.header.logsBloom)) {
              if (this.DEBUG) {
                  debug$1(`Invalid bloom received=${result.bloom.bitvector.toString('hex')} expected=${block.header.logsBloom.toString('hex')}`);
              }
              const msg = _errorMsg$1('invalid bloom', this, block);
              throw new Error(msg);
          }
          if (result.gasUsed !== block.header.gasUsed) {
              if (this.DEBUG) {
                  debug$1(`Invalid gasUsed received=${result.gasUsed} expected=${block.header.gasUsed}`);
              }
              const msg = _errorMsg$1('invalid gasUsed', this, block);
              throw new Error(msg);
          }
          if (!stateRoot.equals(block.header.stateRoot)) {
              if (this.DEBUG) {
                  debug$1(`Invalid stateRoot received=${stateRoot.toString('hex')} expected=${block.header.stateRoot.toString('hex')}`);
              }
              const msg = _errorMsg$1('invalid block stateRoot', this, block);
              throw new Error(msg);
          }
      }
      const results = {
          receipts: result.receipts,
          results: result.results,
          stateRoot,
          gasUsed: result.gasUsed,
          logsBloom: result.bloom.bitvector,
          receiptRoot: result.receiptRoot,
      };
      const afterBlockEvent = { ...results, block };
      /**
       * The `afterBlock` event
       *
       * @event Event: afterBlock
       * @type {AfterBlockEvent}
       * @property {AfterBlockEvent} result emits the results of processing a block
       */
      await this._emit('afterBlock', afterBlockEvent);
      if (this.DEBUG) {
          debug$1(`Running block finished hash=${block.hash().toString('hex')} number=${block.header.number} hardfork=${this._common.hardfork()}`);
      }
      return results;
  }
  runBlock$1.runBlock = runBlock;
  /**
   * Validates and applies a block, computing the results of
   * applying its transactions. This method doesn't modify the
   * block itself. It computes the block rewards and puts
   * them on state (but doesn't persist the changes).
   * @param {Block} block
   * @param {RunBlockOpts} opts
   */
  async function applyBlock(block, opts) {
      // Validate block
      if (opts.skipBlockValidation !== true) {
          if (block.header.gasLimit >= BigInt('0x8000000000000000')) {
              const msg = _errorMsg$1('Invalid block with gas limit greater than (2^63 - 1)', this, block);
              throw new Error(msg);
          }
          else {
              if (this.DEBUG) {
                  debug$1(`Validate block`);
              }
              // TODO: decide what block validation method is appropriate here
              if (opts.skipHeaderValidation !== true) {
                  if (typeof this.blockchain.validateHeader === 'function') {
                      await this.blockchain.validateHeader(block.header);
                  }
                  else {
                      throw new Error('cannot validate header: blockchain has no `validateHeader` method');
                  }
              }
              await block.validateData();
          }
      }
      // Apply transactions
      if (this.DEBUG) {
          debug$1(`Apply transactions`);
      }
      const blockResults = await applyTransactions.bind(this)(block, opts);
      // Pay ommers and miners
      if (block._common.consensusType() === common_1$3.ConsensusType.ProofOfWork) {
          await assignBlockRewards.bind(this)(block);
      }
      return blockResults;
  }
  /**
   * Applies the transactions in a block, computing the receipts
   * as well as gas usage and some relevant data. This method is
   * side-effect free (it doesn't modify the block nor the state).
   * @param {Block} block
   * @param {RunBlockOpts} opts
   */
  async function applyTransactions(block, opts) {
      const bloom = new bloom_1$2.Bloom();
      // the total amount of gas used processing these transactions
      let gasUsed = BigInt(0);
      const receiptTrie = new trie_1$1.Trie();
      const receipts = [];
      const txResults = [];
      /*
       * Process transactions
       */
      for (let txIdx = 0; txIdx < block.transactions.length; txIdx++) {
          const tx = block.transactions[txIdx];
          let maxGasLimit;
          if (this._common.isActivatedEIP(1559) === true) {
              maxGasLimit = block.header.gasLimit * this._common.param('gasConfig', 'elasticityMultiplier');
          }
          else {
              maxGasLimit = block.header.gasLimit;
          }
          const gasLimitIsHigherThanBlock = maxGasLimit < tx.gasLimit + gasUsed;
          if (gasLimitIsHigherThanBlock) {
              const msg = _errorMsg$1('tx has a higher gas limit than the block', this, block);
              throw new Error(msg);
          }
          // Run the tx through the VM
          const { skipBalance, skipNonce } = opts;
          const txRes = await this.runTx({
              tx,
              block,
              skipBalance,
              skipNonce,
              blockGasUsed: gasUsed,
          });
          txResults.push(txRes);
          if (this.DEBUG) {
              debug$1('-'.repeat(100));
          }
          // Add to total block gas usage
          gasUsed += txRes.totalGasSpent;
          if (this.DEBUG) {
              debug$1(`Add tx gas used (${txRes.totalGasSpent}) to total block gas usage (-> ${gasUsed})`);
          }
          // Combine blooms via bitwise OR
          bloom.or(txRes.bloom);
          // Add receipt to trie to later calculate receipt root
          receipts.push(txRes.receipt);
          const encodedReceipt = encodeReceipt(txRes.receipt, tx.type);
          await receiptTrie.put(Buffer$8.from(rlp_1$1.RLP.encode(txIdx)), encodedReceipt);
      }
      return {
          bloom,
          gasUsed,
          receiptRoot: receiptTrie.root,
          receipts,
          results: txResults,
      };
  }
  /**
   * Calculates block rewards for miner and ommers and puts
   * the updated balances of their accounts to state.
   */
  async function assignBlockRewards(block) {
      if (this.DEBUG) {
          debug$1(`Assign block rewards`);
      }
      const state = this.eei;
      const minerReward = this._common.param('pow', 'minerReward');
      const ommers = block.uncleHeaders;
      // Reward ommers
      for (const ommer of ommers) {
          const reward = calculateOmmerReward(ommer.number, block.header.number, minerReward);
          const account = await rewardAccount(state, ommer.coinbase, reward);
          if (this.DEBUG) {
              debug$1(`Add uncle reward ${reward} to account ${ommer.coinbase} (-> ${account.balance})`);
          }
      }
      // Reward miner
      const reward = calculateMinerReward(minerReward, ommers.length);
      const account = await rewardAccount(state, block.header.coinbase, reward);
      if (this.DEBUG) {
          debug$1(`Add miner reward ${reward} to account ${block.header.coinbase} (-> ${account.balance})`);
      }
  }
  function calculateOmmerReward(ommerBlockNumber, blockNumber, minerReward) {
      const heightDiff = blockNumber - ommerBlockNumber;
      let reward = ((BigInt(8) - heightDiff) * minerReward) / BigInt(8);
      if (reward < BigInt(0)) {
          reward = BigInt(0);
      }
      return reward;
  }
  function calculateMinerReward(minerReward, ommersNum) {
      // calculate nibling reward
      const niblingReward = minerReward / BigInt(32);
      const totalNiblingReward = niblingReward * BigInt(ommersNum);
      const reward = minerReward + totalNiblingReward;
      return reward;
  }
  runBlock$1.calculateMinerReward = calculateMinerReward;
  async function rewardAccount(state, address, reward) {
      const account = await state.getAccount(address);
      account.balance += reward;
      await state.putAccount(address, account);
      return account;
  }
  runBlock$1.rewardAccount = rewardAccount;
  /**
   * Returns the encoded tx receipt.
   */
  function encodeReceipt(receipt, txType) {
      const encoded = Buffer$8.from(rlp_1$1.RLP.encode((0, util_1$3.bufArrToArr)([
          receipt.stateRoot ??
              (receipt.status === 0
                  ? Buffer$8.from([])
                  : Buffer$8.from('01', 'hex')),
          (0, util_1$3.bigIntToBuffer)(receipt.cumulativeBlockGasUsed),
          receipt.bitvector,
          receipt.logs,
      ])));
      if (txType === 0) {
          return encoded;
      }
      // Serialize receipt according to EIP-2718:
      // `typed-receipt = tx-type || receipt-data`
      return Buffer$8.concat([(0, util_1$3.intToBuffer)(txType), encoded]);
  }
  runBlock$1.encodeReceipt = encodeReceipt;
  /**
   * Apply the DAO fork changes to the VM
   */
  async function _applyDAOHardfork(state) {
      const DAORefundContractAddress = new util_1$3.Address(Buffer$8.from(DAORefundContract, 'hex'));
      if ((await state.accountExists(DAORefundContractAddress)) === false) {
          await state.putAccount(DAORefundContractAddress, new util_1$3.Account());
      }
      const DAORefundAccount = await state.getAccount(DAORefundContractAddress);
      for (const addr of DAOAccountList) {
          // retrieve the account and add it to the DAO's Refund accounts' balance.
          const address = new util_1$3.Address(Buffer$8.from(addr, 'hex'));
          const account = await state.getAccount(address);
          DAORefundAccount.balance += account.balance;
          // clear the accounts' balance
          account.balance = BigInt(0);
          await state.putAccount(address, account);
      }
      // finally, put the Refund Account
      await state.putAccount(DAORefundContractAddress, DAORefundAccount);
  }
  async function _genTxTrie(block) {
      const trie = new trie_1$1.Trie();
      for (const [i, tx] of block.transactions.entries()) {
          await trie.put(Buffer$8.from(rlp_1$1.RLP.encode(i)), tx.serialize());
      }
      return trie.root;
  }
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  function _errorMsg$1(msg, vm, block) {
      const blockErrorStr = 'errorStr' in block ? block.errorStr() : 'block';
      const errorMsg = `${msg} (${vm.errorStr()} -> ${blockErrorStr})`;
      return errorMsg;
  }

  Object.defineProperty(buildBlock$1, "__esModule", { value: true });
  buildBlock$1.buildBlock = buildBlock$1.BlockBuilder = void 0;
  const block_1$1 = dist$6;
  const common_1$2 = dist$8;
  const rlp_1 = dist$9;
  const trie_1 = dist$5;
  const util_1$2 = dist$a;
  const bloom_1$1 = bloom;
  const runBlock_1$1 = runBlock$1;
  class BlockBuilder {
      constructor(vm, opts) {
          /**
           * The cumulative gas used by the transactions added to the block.
           */
          this.gasUsed = BigInt(0);
          this.transactions = [];
          this.transactionResults = [];
          this.checkpointed = false;
          this.reverted = false;
          this.built = false;
          this.vm = vm;
          this.blockOpts = { putBlockIntoBlockchain: true, ...opts.blockOpts, common: this.vm._common };
          this.headerData = {
              ...opts.headerData,
              parentHash: opts.headerData?.parentHash ?? opts.parentBlock.hash(),
              number: opts.headerData?.number ?? opts.parentBlock.header.number + BigInt(1),
              gasLimit: opts.headerData?.gasLimit ?? opts.parentBlock.header.gasLimit,
          };
          if (this.vm._common.isActivatedEIP(1559) === true &&
              typeof this.headerData.baseFeePerGas === 'undefined') {
              this.headerData.baseFeePerGas = opts.parentBlock.header.calcNextBaseFee();
          }
      }
      get transactionReceipts() {
          return this.transactionResults.map((result) => result.receipt);
      }
      /**
       * Throws if the block has already been built or reverted.
       */
      checkStatus() {
          if (this.built) {
              throw new Error('Block has already been built');
          }
          if (this.reverted) {
              throw new Error('State has already been reverted');
          }
      }
      /**
       * Calculates and returns the transactionsTrie for the block.
       */
      async transactionsTrie() {
          const trie = new trie_1.Trie();
          for (const [i, tx] of this.transactions.entries()) {
              await trie.put(Buffer$8.from(rlp_1.RLP.encode(i)), tx.serialize());
          }
          return trie.root;
      }
      /**
       * Calculates and returns the logs bloom for the block.
       */
      logsBloom() {
          const bloom = new bloom_1$1.Bloom();
          for (const txResult of this.transactionResults) {
              // Combine blooms via bitwise OR
              bloom.or(txResult.bloom);
          }
          return bloom.bitvector;
      }
      /**
       * Calculates and returns the receiptTrie for the block.
       */
      async receiptTrie() {
          const receiptTrie = new trie_1.Trie();
          for (const [i, txResult] of this.transactionResults.entries()) {
              const tx = this.transactions[i];
              const encodedReceipt = (0, runBlock_1$1.encodeReceipt)(txResult.receipt, tx.type);
              await receiptTrie.put(Buffer$8.from(rlp_1.RLP.encode(i)), encodedReceipt);
          }
          return receiptTrie.root;
      }
      /**
       * Adds the block miner reward to the coinbase account.
       */
      async rewardMiner() {
          const minerReward = this.vm._common.param('pow', 'minerReward');
          const reward = (0, runBlock_1$1.calculateMinerReward)(minerReward, 0);
          const coinbase = (0, util_1$2.isTruthy)(this.headerData.coinbase)
              ? new util_1$2.Address((0, util_1$2.toBuffer)(this.headerData.coinbase))
              : util_1$2.Address.zero();
          await (0, runBlock_1$1.rewardAccount)(this.vm.eei, coinbase, reward);
      }
      /**
       * Run and add a transaction to the block being built.
       * Please note that this modifies the state of the VM.
       * Throws if the transaction's gasLimit is greater than
       * the remaining gas in the block.
       */
      async addTransaction(tx) {
          this.checkStatus();
          if (!this.checkpointed) {
              await this.vm.stateManager.checkpoint();
              this.checkpointed = true;
          }
          // According to the Yellow Paper, a transaction's gas limit
          // cannot be greater than the remaining gas in the block
          const blockGasLimit = (0, util_1$2.toType)(this.headerData.gasLimit, util_1$2.TypeOutput.BigInt);
          const blockGasRemaining = blockGasLimit - this.gasUsed;
          if (tx.gasLimit > blockGasRemaining) {
              throw new Error('tx has a higher gas limit than the remaining gas in the block');
          }
          const header = {
              ...this.headerData,
              gasUsed: this.gasUsed,
          };
          const blockData = { header, transactions: this.transactions };
          const block = block_1$1.Block.fromBlockData(blockData, this.blockOpts);
          const result = await this.vm.runTx({ tx, block });
          this.transactions.push(tx);
          this.transactionResults.push(result);
          this.gasUsed += result.totalGasSpent;
          return result;
      }
      /**
       * Reverts the checkpoint on the StateManager to reset the state from any transactions that have been run.
       */
      async revert() {
          this.checkStatus();
          if (this.checkpointed) {
              await this.vm.stateManager.revert();
              this.reverted = true;
          }
      }
      /**
       * This method returns the finalized block.
       * It also:
       *  - Assigns the reward for miner (PoW)
       *  - Commits the checkpoint on the StateManager
       *  - Sets the tip of the VM's blockchain to this block
       * For PoW, optionally seals the block with params `nonce` and `mixHash`,
       * which is validated along with the block number and difficulty by ethash.
       * For PoA, please pass `blockOption.cliqueSigner` into the buildBlock constructor,
       * as the signer will be awarded the txs amount spent on gas as they are added.
       */
      async build(sealOpts) {
          this.checkStatus();
          const blockOpts = this.blockOpts;
          const consensusType = this.vm._common.consensusType();
          if (consensusType === common_1$2.ConsensusType.ProofOfWork) {
              await this.rewardMiner();
          }
          const stateRoot = await this.vm.stateManager.getStateRoot();
          const transactionsTrie = await this.transactionsTrie();
          const receiptTrie = await this.receiptTrie();
          const logsBloom = this.logsBloom();
          const gasUsed = this.gasUsed;
          const timestamp = this.headerData.timestamp ?? Math.round(Date.now() / 1000);
          const headerData = {
              ...this.headerData,
              stateRoot,
              transactionsTrie,
              receiptTrie,
              logsBloom,
              gasUsed,
              timestamp,
          };
          if (consensusType === common_1$2.ConsensusType.ProofOfWork) {
              headerData.nonce = sealOpts?.nonce ?? headerData.nonce;
              headerData.mixHash = sealOpts?.mixHash ?? headerData.mixHash;
          }
          const blockData = { header: headerData, transactions: this.transactions };
          const block = block_1$1.Block.fromBlockData(blockData, blockOpts);
          if (this.blockOpts.putBlockIntoBlockchain === true) {
              await this.vm.blockchain.putBlock(block);
          }
          this.built = true;
          if (this.checkpointed) {
              await this.vm.stateManager.commit();
              this.checkpointed = false;
          }
          return block;
      }
  }
  buildBlock$1.BlockBuilder = BlockBuilder;
  async function buildBlock(opts) {
      return new BlockBuilder(this, opts);
  }
  buildBlock$1.buildBlock = buildBlock;

  var runTx$1 = {};

  Object.defineProperty(runTx$1, "__esModule", { value: true });
  runTx$1.generateTxReceipt = runTx$1.runTx = void 0;
  const block_1 = dist$6;
  const common_1$1 = dist$8;
  const tx_1 = dist$3;
  const util_1$1 = dist$a;
  const debug_1 = src$1.exports;
  const bloom_1 = bloom;
  const debug = (0, debug_1.debug)('vm:tx');
  const debugGas = (0, debug_1.debug)('vm:tx:gas');
  /**
   * @ignore
   */
  async function runTx(opts) {
      // tx is required
      if ((0, util_1$1.isFalsy)(opts.tx)) {
          throw new Error('invalid input, tx is required');
      }
      // create a reasonable default if no block is given
      opts.block = opts.block ?? block_1.Block.fromBlockData({}, { common: opts.tx.common });
      if (opts.skipBlockGasLimitValidation !== true && opts.block.header.gasLimit < opts.tx.gasLimit) {
          const msg = _errorMsg('tx has a higher gas limit than the block', this, opts.block, opts.tx);
          throw new Error(msg);
      }
      const state = this.eei;
      if (opts.reportAccessList === true && !('generateAccessList' in state)) {
          const msg = _errorMsg('reportAccessList needs a StateManager implementing the generateAccessList() method', this, opts.block, opts.tx);
          throw new Error(msg);
      }
      // Ensure we start with a clear warmed accounts Map
      if (this._common.isActivatedEIP(2929) === true) {
          state.clearWarmedAccounts();
      }
      await state.checkpoint();
      if (this.DEBUG) {
          debug('-'.repeat(100));
          debug(`tx checkpoint`);
      }
      // Typed transaction specific setup tasks
      if (opts.tx.supports(tx_1.Capability.EIP2718TypedTransaction) &&
          this._common.isActivatedEIP(2718) === true) {
          // Is it an Access List transaction?
          if (this._common.isActivatedEIP(2930) === false) {
              await state.revert();
              const msg = _errorMsg('Cannot run transaction: EIP 2930 is not activated.', this, opts.block, opts.tx);
              throw new Error(msg);
          }
          if (opts.reportAccessList === true && !('generateAccessList' in state)) {
              await state.revert();
              const msg = _errorMsg('StateManager needs to implement generateAccessList() when running with reportAccessList option', this, opts.block, opts.tx);
              throw new Error(msg);
          }
          if (opts.tx.supports(tx_1.Capability.EIP1559FeeMarket) &&
              this._common.isActivatedEIP(1559) === false) {
              await state.revert();
              const msg = _errorMsg('Cannot run transaction: EIP 1559 is not activated.', this, opts.block, opts.tx);
              throw new Error(msg);
          }
          const castedTx = opts.tx;
          castedTx.AccessListJSON.forEach((accessListItem) => {
              const address = (0, util_1$1.toBuffer)(accessListItem.address);
              state.addWarmedAddress(address);
              accessListItem.storageKeys.forEach((storageKey) => {
                  state.addWarmedStorage(address, (0, util_1$1.toBuffer)(storageKey));
              });
          });
      }
      try {
          const result = await _runTx.bind(this)(opts);
          await state.commit();
          if (this.DEBUG) {
              debug(`tx checkpoint committed`);
          }
          if (this._common.isActivatedEIP(2929) === true && opts.reportAccessList === true) {
              const { tx } = opts;
              // Do not include sender address in access list
              const removed = [tx.getSenderAddress()];
              // Add the active precompiles as well
              // Note: `precompiles` is always updated if the hardfork of `common` changes
              const activePrecompiles = this.evm.precompiles;
              for (const [key] of activePrecompiles.entries()) {
                  removed.push(util_1$1.Address.fromString('0x' + key));
              }
              // Only include to address on present storage slot accesses
              const onlyStorage = tx.to ? [tx.to] : [];
              result.accessList = state.generateAccessList(removed, onlyStorage);
          }
          return result;
      }
      catch (e) {
          await state.revert();
          if (this.DEBUG) {
              debug(`tx checkpoint reverted`);
          }
          throw e;
      }
      finally {
          if (this._common.isActivatedEIP(2929) === true) {
              state.clearWarmedAccounts();
          }
      }
  }
  runTx$1.runTx = runTx;
  async function _runTx(opts) {
      const state = this.eei;
      const { tx, block } = opts;
      if (!block) {
          throw new Error('block required');
      }
      /**
       * The `beforeTx` event
       *
       * @event Event: beforeTx
       * @type {Object}
       * @property {Transaction} tx emits the Transaction that is about to be processed
       */
      await this._emit('beforeTx', tx);
      const caller = tx.getSenderAddress();
      if (this.DEBUG) {
          debug(`New tx run hash=${opts.tx.isSigned() ? opts.tx.hash().toString('hex') : 'unsigned'} sender=${caller}`);
      }
      if (this._common.isActivatedEIP(2929) === true) {
          // Add origin and precompiles to warm addresses
          const activePrecompiles = this.evm.precompiles;
          for (const [addressStr] of activePrecompiles.entries()) {
              state.addWarmedAddress(Buffer$8.from(addressStr, 'hex'));
          }
          state.addWarmedAddress(caller.buf);
          if (tx.to) {
              // Note: in case we create a contract, we do this in EVMs `_executeCreate` (this is also correct in inner calls, per the EIP)
              state.addWarmedAddress(tx.to.buf);
          }
          if (this._common.isActivatedEIP(3651) === true) {
              state.addWarmedAddress(block.header.coinbase.buf);
          }
      }
      // Validate gas limit against tx base fee (DataFee + TxFee + Creation Fee)
      const txBaseFee = tx.getBaseFee();
      let gasLimit = tx.gasLimit;
      if (gasLimit < txBaseFee) {
          const msg = _errorMsg('base fee exceeds gas limit', this, block, tx);
          throw new Error(msg);
      }
      gasLimit -= txBaseFee;
      if (this.DEBUG) {
          debugGas(`Subtracting base fee (${txBaseFee}) from gasLimit (-> ${gasLimit})`);
      }
      if (this._common.isActivatedEIP(1559) === true) {
          // EIP-1559 spec:
          // Ensure that the user was willing to at least pay the base fee
          // assert transaction.max_fee_per_gas >= block.base_fee_per_gas
          const maxFeePerGas = 'maxFeePerGas' in tx ? tx.maxFeePerGas : tx.gasPrice;
          const baseFeePerGas = block.header.baseFeePerGas;
          if (maxFeePerGas < baseFeePerGas) {
              const msg = _errorMsg(`Transaction's maxFeePerGas (${maxFeePerGas}) is less than the block's baseFeePerGas (${baseFeePerGas})`, this, block, tx);
              throw new Error(msg);
          }
      }
      // Check from account's balance and nonce
      let fromAccount = await state.getAccount(caller);
      const { nonce, balance } = fromAccount;
      // EIP-3607: Reject transactions from senders with deployed code
      if (this._common.isActivatedEIP(3607) === true && !fromAccount.codeHash.equals(util_1$1.KECCAK256_NULL)) {
          const msg = _errorMsg('invalid sender address, address is not EOA (EIP-3607)', this, block, tx);
          throw new Error(msg);
      }
      const cost = tx.getUpfrontCost(block.header.baseFeePerGas);
      if (opts.skipBalance === true) {
          // if skipBalance, add tx cost to sender balance to ensure sufficient funds
          fromAccount.balance += cost;
          await this.stateManager.putAccount(caller, fromAccount);
      }
      else {
          if (balance < cost) {
              const msg = _errorMsg(`sender doesn't have enough funds to send tx. The upfront cost is: ${cost} and the sender's account (${caller}) only has: ${balance}`, this, block, tx);
              throw new Error(msg);
          }
          if (tx.supports(tx_1.Capability.EIP1559FeeMarket)) {
              // EIP-1559 spec:
              // The signer must be able to afford the transaction
              // `assert balance >= gas_limit * max_fee_per_gas`
              const cost = tx.gasLimit * tx.maxFeePerGas + tx.value;
              if (balance < cost) {
                  const msg = _errorMsg(`sender doesn't have enough funds to send tx. The max cost is: ${cost} and the sender's account (${caller}) only has: ${balance}`, this, block, tx);
                  throw new Error(msg);
              }
          }
      }
      if (opts.skipNonce !== true) {
          if (nonce !== tx.nonce) {
              const msg = _errorMsg(`the tx doesn't have the correct nonce. account has nonce of: ${nonce} tx has nonce of: ${tx.nonce}`, this, block, tx);
              throw new Error(msg);
          }
      }
      let gasPrice;
      let inclusionFeePerGas;
      // EIP-1559 tx
      if (tx.supports(tx_1.Capability.EIP1559FeeMarket)) {
          const baseFee = block.header.baseFeePerGas;
          inclusionFeePerGas =
              tx.maxPriorityFeePerGas <
                  tx.maxFeePerGas - baseFee
                  ? tx.maxPriorityFeePerGas
                  : tx.maxFeePerGas - baseFee;
          gasPrice = inclusionFeePerGas + baseFee;
      }
      else {
          // Have to cast as legacy tx since EIP1559 tx does not have gas price
          gasPrice = tx.gasPrice;
          if (this._common.isActivatedEIP(1559) === true) {
              const baseFee = block.header.baseFeePerGas;
              inclusionFeePerGas = tx.gasPrice - baseFee;
          }
      }
      // Update from account's balance
      const txCost = tx.gasLimit * gasPrice;
      fromAccount.balance -= txCost;
      if (opts.skipBalance === true && fromAccount.balance < BigInt(0)) {
          fromAccount.balance = BigInt(0);
      }
      await state.putAccount(caller, fromAccount);
      if (this.DEBUG) {
          debug(`Update fromAccount (caller) balance(-> ${fromAccount.balance})`);
      }
      /*
       * Execute message
       */
      const { value, data, to } = tx;
      if (this.DEBUG) {
          debug(`Running tx=0x${tx.isSigned() ? tx.hash().toString('hex') : 'unsigned'} with caller=${caller} gasLimit=${gasLimit} to=${to?.toString() ?? 'none'} value=${value} data=0x${(0, util_1$1.short)(data)}`);
      }
      const results = (await this.evm.runCall({
          block,
          gasPrice,
          caller,
          gasLimit,
          to,
          value,
          data,
      }));
      // After running the call, increment the nonce
      const acc = await state.getAccount(caller);
      acc.nonce++;
      await state.putAccount(caller, acc);
      if (this.DEBUG) {
          debug(`Update fromAccount (caller) nonce (-> ${fromAccount.nonce})`);
      }
      if (this.DEBUG) {
          const { executionGasUsed, exceptionError, returnValue } = results.execResult;
          debug('-'.repeat(100));
          debug(`Received tx execResult: [ executionGasUsed=${executionGasUsed} exceptionError=${exceptionError ? `'${exceptionError.error}'` : 'none'} returnValue=0x${(0, util_1$1.short)(returnValue)} gasRefund=${results.gasRefund ?? 0} ]`);
      }
      /*
       * Parse results
       */
      // Generate the bloom for the tx
      results.bloom = txLogsBloom(results.execResult.logs);
      if (this.DEBUG) {
          debug(`Generated tx bloom with logs=${results.execResult.logs?.length}`);
      }
      // Calculate the total gas used
      results.totalGasSpent = results.execResult.executionGasUsed + txBaseFee;
      if (this.DEBUG) {
          debugGas(`tx add baseFee ${txBaseFee} to totalGasSpent (-> ${results.totalGasSpent})`);
      }
      // Process any gas refund
      let gasRefund = results.execResult.gasRefund ?? BigInt(0);
      results.gasRefund = gasRefund;
      const maxRefundQuotient = this._common.param('gasConfig', 'maxRefundQuotient');
      if (gasRefund !== BigInt(0)) {
          const maxRefund = results.totalGasSpent / maxRefundQuotient;
          gasRefund = gasRefund < maxRefund ? gasRefund : maxRefund;
          results.totalGasSpent -= gasRefund;
          if (this.DEBUG) {
              debug(`Subtract tx gasRefund (${gasRefund}) from totalGasSpent (-> ${results.totalGasSpent})`);
          }
      }
      else {
          if (this.DEBUG) {
              debug(`No tx gasRefund`);
          }
      }
      results.amountSpent = results.totalGasSpent * gasPrice;
      // Update sender's balance
      fromAccount = await state.getAccount(caller);
      const actualTxCost = results.totalGasSpent * gasPrice;
      const txCostDiff = txCost - actualTxCost;
      fromAccount.balance += txCostDiff;
      await state.putAccount(caller, fromAccount);
      if (this.DEBUG) {
          debug(`Refunded txCostDiff (${txCostDiff}) to fromAccount (caller) balance (-> ${fromAccount.balance})`);
      }
      // Update miner's balance
      let miner;
      if (this._common.consensusType() === common_1$1.ConsensusType.ProofOfAuthority) {
          miner = block.header.cliqueSigner();
      }
      else {
          miner = block.header.coinbase;
      }
      const minerAccount = await state.getAccount(miner);
      // add the amount spent on gas to the miner's account
      if (this._common.isActivatedEIP(1559) === true) {
          minerAccount.balance += results.totalGasSpent * inclusionFeePerGas;
      }
      else {
          minerAccount.balance += results.amountSpent;
      }
      // Put the miner account into the state. If the balance of the miner account remains zero, note that
      // the state.putAccount function puts this into the "touched" accounts. This will thus be removed when
      // we clean the touched accounts below in case we are in a fork >= SpuriousDragon
      await state.putAccount(miner, minerAccount);
      if (this.DEBUG) {
          debug(`tx update miner account (${miner}) balance (-> ${minerAccount.balance})`);
      }
      /*
       * Cleanup accounts
       */
      if (results.execResult.selfdestruct) {
          const keys = Object.keys(results.execResult.selfdestruct);
          for (const k of keys) {
              const address = new util_1$1.Address(Buffer$8.from(k, 'hex'));
              await state.deleteAccount(address);
              if (this.DEBUG) {
                  debug(`tx selfdestruct on address=${address}`);
              }
          }
      }
      await state.cleanupTouchedAccounts();
      state.clearOriginalStorageCache();
      // Generate the tx receipt
      const gasUsed = opts.blockGasUsed !== undefined ? opts.blockGasUsed : block.header.gasUsed;
      const cumulativeGasUsed = gasUsed + results.totalGasSpent;
      results.receipt = await generateTxReceipt.bind(this)(tx, results, cumulativeGasUsed);
      /**
       * The `afterTx` event
       *
       * @event Event: afterTx
       * @type {Object}
       * @property {Object} result result of the transaction
       */
      const event = { transaction: tx, ...results };
      await this._emit('afterTx', event);
      if (this.DEBUG) {
          debug(`tx run finished hash=${opts.tx.isSigned() ? opts.tx.hash().toString('hex') : 'unsigned'} sender=${caller}`);
      }
      return results;
  }
  /**
   * @method txLogsBloom
   * @private
   */
  function txLogsBloom(logs) {
      const bloom = new bloom_1.Bloom();
      if (logs) {
          for (let i = 0; i < logs.length; i++) {
              const log = logs[i];
              // add the address
              bloom.add(log[0]);
              // add the topics
              const topics = log[1];
              for (let q = 0; q < topics.length; q++) {
                  bloom.add(topics[q]);
              }
          }
      }
      return bloom;
  }
  /**
   * Returns the tx receipt.
   * @param this The vm instance
   * @param tx The transaction
   * @param txResult The tx result
   * @param cumulativeGasUsed The gas used in the block including this tx
   */
  async function generateTxReceipt(tx, txResult, cumulativeGasUsed) {
      const baseReceipt = {
          cumulativeBlockGasUsed: cumulativeGasUsed,
          bitvector: txResult.bloom.bitvector,
          logs: txResult.execResult.logs ?? [],
      };
      let receipt;
      if (this.DEBUG) {
          debug(`Generate tx receipt transactionType=${tx.type} cumulativeBlockGasUsed=${cumulativeGasUsed} bitvector=${(0, util_1$1.short)(baseReceipt.bitvector)} (${baseReceipt.bitvector.length} bytes) logs=${baseReceipt.logs.length}`);
      }
      if (!tx.supports(tx_1.Capability.EIP2718TypedTransaction)) {
          // Legacy transaction
          if (this._common.gteHardfork(common_1$1.Hardfork.Byzantium) === true) {
              // Post-Byzantium
              receipt = {
                  status: txResult.execResult.exceptionError ? 0 : 1,
                  ...baseReceipt,
              };
          }
          else {
              // Pre-Byzantium
              const stateRoot = await this.stateManager.getStateRoot();
              receipt = {
                  stateRoot: stateRoot,
                  ...baseReceipt,
              };
          }
      }
      else {
          // Typed EIP-2718 Transaction
          receipt = {
              status: txResult.execResult.exceptionError ? 0 : 1,
              ...baseReceipt,
          };
      }
      return receipt;
  }
  runTx$1.generateTxReceipt = generateTxReceipt;
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  function _errorMsg(msg, vm, block, tx) {
      const blockErrorStr = 'errorStr' in block ? block.errorStr() : 'block';
      const txErrorStr = 'errorStr' in tx ? tx.errorStr() : 'tx';
      const errorMsg = `${msg} (${vm.errorStr()} -> ${blockErrorStr} -> ${txErrorStr})`;
      return errorMsg;
  }

  Object.defineProperty(vm, "__esModule", { value: true });
  vm.VM = void 0;
  const util_1 = util$6;
  const blockchain_1 = dist$7;
  const common_1 = dist$8;
  const statemanager_1 = dist$1;
  const util_2 = dist$a;
  const AsyncEventEmitter = asyncEventemitter;
  const evm_1 = dist;
  const buildBlock_1 = buildBlock$1;
  const eei_1 = eei;
  const runBlock_1 = runBlock$1;
  const runTx_1 = runTx$1;
  /**
   * Execution engine which can be used to run a blockchain, individual
   * blocks, individual transactions, or snippets of EVM bytecode.
   *
   * This class is an AsyncEventEmitter, please consult the README to learn how to use it.
   */
  class VM extends AsyncEventEmitter {
      /**
       * Instantiates a new {@link VM} Object.
       *
       * @deprecated The direct usage of this constructor is discouraged since
       * non-finalized async initialization might lead to side effects. Please
       * use the async {@link VM.create} constructor instead (same API).
       * @param opts
       */
      constructor(opts = {}) {
          super();
          this._isInitialized = false;
          /**
           * VM is run in DEBUG mode (default: false)
           * Taken from DEBUG environment variable
           *
           * Safeguards on debug() calls are added for
           * performance reasons to avoid string literal evaluation
           * @hidden
           */
          this.DEBUG = false;
          this._opts = opts;
          if (opts.common) {
              this._common = opts.common;
          }
          else {
              const DEFAULT_CHAIN = common_1.Chain.Mainnet;
              this._common = new common_1.Common({ chain: DEFAULT_CHAIN });
          }
          if (opts.stateManager) {
              this.stateManager = opts.stateManager;
          }
          else {
              this.stateManager = new statemanager_1.DefaultStateManager({
                  common: this._common,
              });
          }
          this.blockchain = opts.blockchain ?? new blockchain_1.Blockchain({ common: this._common });
          // TODO tests
          if (opts.eei) {
              if (opts.evm) {
                  throw new Error('cannot specify EEI if EVM opt provided');
              }
              this.eei = opts.eei;
          }
          else {
              if (opts.evm) {
                  this.eei = opts.evm.eei;
              }
              else {
                  this.eei = new eei_1.EEI(this.stateManager, this._common, this.blockchain);
              }
          }
          // TODO tests
          if (opts.evm) {
              this.evm = opts.evm;
          }
          else {
              this.evm = new evm_1.EVM({
                  common: this._common,
                  eei: this.eei,
              });
          }
          if (opts.hardforkByBlockNumber !== undefined && opts.hardforkByTTD !== undefined) {
              throw new Error(`The hardforkByBlockNumber and hardforkByTTD options can't be used in conjunction`);
          }
          this._hardforkByBlockNumber = opts.hardforkByBlockNumber ?? false;
          this._hardforkByTTD = (0, util_2.toType)(opts.hardforkByTTD, util_2.TypeOutput.BigInt);
          // Safeguard if "process" is not available (browser)
          if (browser$1$1 !== undefined && typeof browser$1$1.env.DEBUG !== 'undefined') {
              this.DEBUG = true;
          }
          // We cache this promisified function as it's called from the main execution loop, and
          // promisifying each time has a huge performance impact.
          this._emit = (0, util_1.promisify)(this.emit.bind(this));
      }
      /**
       * VM async constructor. Creates engine instance and initializes it.
       *
       * @param opts VM engine constructor options
       */
      static async create(opts = {}) {
          const vm = new this(opts);
          await vm.init();
          return vm;
      }
      async init() {
          if (this._isInitialized)
              return;
          if (typeof this.blockchain._init === 'function') {
              await this.blockchain._init();
          }
          if (!this._opts.stateManager) {
              if (this._opts.activateGenesisState === true) {
                  if (typeof this.blockchain.genesisState === 'function') {
                      await this.eei.generateCanonicalGenesis(this.blockchain.genesisState());
                  }
                  else {
                      throw new Error('cannot activate genesis state: blockchain object has no `genesisState` method');
                  }
              }
          }
          if (this._opts.activatePrecompiles === true && typeof this._opts.stateManager === 'undefined') {
              await this.eei.checkpoint();
              // put 1 wei in each of the precompiles in order to make the accounts non-empty and thus not have them deduct `callNewAccount` gas.
              for (const [addressStr] of (0, evm_1.getActivePrecompiles)(this._common)) {
                  const address = new util_2.Address(Buffer$8.from(addressStr, 'hex'));
                  const account = await this.eei.getAccount(address);
                  // Only do this if it is not overridden in genesis
                  // Note: in the case that custom genesis has storage fields, this is preserved
                  if (account.isEmpty()) {
                      const newAccount = util_2.Account.fromAccountData({ balance: 1, stateRoot: account.stateRoot });
                      await this.eei.putAccount(address, newAccount);
                  }
              }
              await this.eei.commit();
          }
          this._isInitialized = true;
      }
      /**
       * Processes the `block` running all of the transactions it contains and updating the miner's account
       *
       * This method modifies the state. If `generate` is `true`, the state modifications will be
       * reverted if an exception is raised. If it's `false`, it won't revert if the block's header is
       * invalid. If an error is thrown from an event handler, the state may or may not be reverted.
       *
       * @param {RunBlockOpts} opts - Default values for options:
       *  - `generate`: false
       */
      async runBlock(opts) {
          return runBlock_1.runBlock.bind(this)(opts);
      }
      /**
       * Process a transaction. Run the vm. Transfers eth. Checks balances.
       *
       * This method modifies the state. If an error is thrown, the modifications are reverted, except
       * when the error is thrown from an event handler. In the latter case the state may or may not be
       * reverted.
       *
       * @param {RunTxOpts} opts
       */
      async runTx(opts) {
          return runTx_1.runTx.bind(this)(opts);
      }
      /**
       * Build a block on top of the current state
       * by adding one transaction at a time.
       *
       * Creates a checkpoint on the StateManager and modifies the state
       * as transactions are run. The checkpoint is committed on {@link BlockBuilder.build}
       * or discarded with {@link BlockBuilder.revert}.
       *
       * @param {BuildBlockOpts} opts
       * @returns An instance of {@link BlockBuilder} with methods:
       * - {@link BlockBuilder.addTransaction}
       * - {@link BlockBuilder.build}
       * - {@link BlockBuilder.revert}
       */
      async buildBlock(opts) {
          return buildBlock_1.buildBlock.bind(this)(opts);
      }
      /**
       * Returns a copy of the {@link VM} instance.
       */
      async copy() {
          const evmCopy = this.evm.copy();
          const eeiCopy = evmCopy.eei;
          return VM.create({
              stateManager: eeiCopy._stateManager,
              blockchain: eeiCopy._blockchain,
              common: eeiCopy._common,
              evm: evmCopy,
              hardforkByBlockNumber: this._hardforkByBlockNumber ? true : undefined,
              hardforkByTTD: (0, util_2.isTruthy)(this._hardforkByTTD) ? this._hardforkByTTD : undefined,
          });
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
          let hf = '';
          try {
              hf = this._common.hardfork();
          }
          catch (e) {
              hf = 'error';
          }
          const errorStr = `vm hf=${hf}`;
          return errorStr;
      }
  }
  vm.VM = VM;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VM = exports.Bloom = void 0;
  var index_1 = bloom;
  Object.defineProperty(exports, "Bloom", { enumerable: true, get: function () { return index_1.Bloom; } });
  __exportStar(eei, exports);
  __exportStar(types$3, exports);
  var vm_1 = vm;
  Object.defineProperty(exports, "VM", { enumerable: true, get: function () { return vm_1.VM; } });

  }(dist$b));

  const init = async (opts = {}) => {
    const common = new dist$8.Common({ chain: dist$8.Chain.Goerli });
    const hardforkByBlockNumber = true;
    const vm = new dist$b.VM({ common, hardforkByBlockNumber });

    const accountPk = Buffer$8.from('e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109', 'hex');
    const account = dist$a.Account.fromAccountData({ nonce: 0, balance: window.BigInt(100) ** window.BigInt(18) });
    const accountAddress = dist$a.Address.fromPrivateKey(accountPk);
    await vm.stateManager.putAccount(accountAddress, account);
    return { vm, accountPk, account, accountAddress, common }
  };

  const deploy = async ({ vm, common, account, accountPk }, object) => {
    const txData = {
      value: 0,
      gasLimit: 200_000_000_000,
      gasPrice: 10,
      data: '0x' + object,
      nounce: account.nonce
    };
    const tx = dist$3.Transaction.fromTxData(txData, { common }).sign(accountPk);
    const deployment = await vm.runTx({ tx });
    console.log(deployment);
    return deployment
  };

  const call = async ({ vm, accountAddress }, contractAddress, sighash) => {
    const result = await vm.evm.runCall({
      to: contractAddress,
      caller: accountAddress,
      origin: accountAddress,
      data: Buffer$8.from(sighash.slice(2), 'hex')
    });
    console.log(result);
    return result
  };

  const evm = { init, deploy, call };

  return evm;

}));
//# sourceMappingURL=bundle.js.map
